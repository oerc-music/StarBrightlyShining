"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuadDestinationPatchSparqlUpdate = void 0;
const stream_1 = require("stream");
const bus_http_1 = require("@comunica/bus-http");
const cross_fetch_1 = require("cross-fetch");
/**
 * A quad destination that represents an LDP resource.
 */
class QuadDestinationPatchSparqlUpdate {
    constructor(url, context, mediatorHttp, mediatorRdfSerialize) {
        this.url = url;
        this.context = context;
        this.mediatorHttp = mediatorHttp;
        this.mediatorRdfSerialize = mediatorRdfSerialize;
    }
    insert(quads) {
        return this.wrapSparqlUpdateRequest('INSERT', quads);
    }
    async delete(quads) {
        return this.wrapSparqlUpdateRequest('DELETE', quads);
    }
    async wrapSparqlUpdateRequest(type, quads) {
        var _a;
        // Serialize quads
        const { handle: { data } } = await this.mediatorRdfSerialize.mediate({
            handle: { quadStream: quads },
            handleMediaType: 'text/turtle',
        });
        // Wrap triples in INSERT DATA block
        const dataWrapped = new stream_1.PassThrough();
        dataWrapped.push(`${type} DATA {`);
        data.pipe(dataWrapped, { end: false });
        data.on('end', () => {
            dataWrapped.push('}');
            dataWrapped.push(null);
        });
        // Send data in PUT request
        const headers = new cross_fetch_1.Headers({ 'content-type': 'application/sparql-update' });
        const httpResponse = await this.mediatorHttp.mediate({
            context: this.context,
            init: {
                headers,
                method: 'PATCH',
                body: bus_http_1.ActorHttp.toWebReadableStream(dataWrapped),
            },
            input: this.url,
        });
        // Check if update was successful
        if (httpResponse.status >= 400) {
            throw new Error(`Could not retrieve ${this.url} (${httpResponse.status}: ${httpResponse.statusText || 'unknown error'})`);
        }
        // Close response body, as we don't need it
        await ((_a = httpResponse.body) === null || _a === void 0 ? void 0 : _a.cancel());
    }
    async deleteGraphs(graphs, requireExistence, dropGraphs) {
        throw new Error(`Patch-based SPARQL Update destinations don't support named graphs`);
    }
    async createGraphs(graphs, requireNonExistence) {
        throw new Error(`Patch-based SPARQL Update destinations don't support named graphs`);
    }
}
exports.QuadDestinationPatchSparqlUpdate = QuadDestinationPatchSparqlUpdate;
//# sourceMappingURL=QuadDestinationPatchSparqlUpdate.js.map