import { KeysInitSparql, KeysQueryOperation } from '@comunica/context-entries';
import type { ActionContext, IActorArgs, IActorTest, Mediator } from '@comunica/core';
import { Actor } from '@comunica/core';
import type { IActionQueryOperation, IActorQueryOperationOutput, IActorQueryOperationOutputBindings, IActorQueryOperationOutputBoolean, IActorQueryOperationOutputQuads, IActorQueryOperationOutputUpdate, IActorQueryOperationOutputStream, Bindings, PatternBindings } from '@comunica/types';
import type * as RDF from 'rdf-js';
import type { Algebra } from 'sparqlalgebrajs';
/**
 * @deprecated Use the type in @comunica/types
 */
export type { IActionQueryOperation };
/**
 * @deprecated Use the type in @comunica/types
 */
export type { IActorQueryOperationOutput };
/**
 * @deprecated Use the type in @comunica/types
 */
export type { IActorQueryOperationOutputBindings };
/**
 * @deprecated Use the type in @comunica/types
 */
export type { IActorQueryOperationOutputBoolean };
/**
 * @deprecated Use the type in @comunica/types
 */
export type { IActorQueryOperationOutputQuads };
/**
 * @deprecated Use the type in @comunica/types
 */
export type { IActorQueryOperationOutputUpdate };
/**
 * @deprecated Use the type in @comunica/types
 */
export type { IActorQueryOperationOutputStream };
/**
 * @deprecated Use the type in @comunica/types
 */
export type { PatternBindings as IPatternBindings };
/**
 * @type {string} Context entry for current metadata.
 *                I.e., the metadata that was used to determine the next BGP operation.
 * @value {any} A metadata hash.
 * @deprecated Import this constant from @comunica/context-entries.
 */
export declare const KEY_CONTEXT_BGP_CURRENTMETADATA = KeysQueryOperation.bgpCurrentMetadata;
/**
 * @type {string} Context entry for an array of parent metadata.
 *                I.e., an array of the metadata that was present before materializing the current BGP operations.
 *                This can be passed in 'bgp' actions.
 *                The array entries should correspond to the pattern entries in the BGP.
 * @value {any} An array of metadata hashes.
 * @deprecated Import this constant from @comunica/context-entries.
 */
export declare const KEY_CONTEXT_BGP_PARENTMETADATA = KeysQueryOperation.bgpParentMetadata;
/**
 * @type {string} Context entry for indicating which patterns were bound from variables.
 *                I.e., an array of the same length as the value of KeysQueryOperation.patternParentMetadata,
 *                where each array value corresponds to the pattern bindings for the corresponding pattern.
 * @value {any} An array of {@link PatternBindings}.
 * @deprecated Import this constant from @comunica/context-entries.
 */
export declare const KEY_CONTEXT_BGP_PATTERNBINDINGS = KeysQueryOperation.bgpPatternBindings;
/**
 * @type {string} Context entry for parent metadata.
 *                I.e., the metadata that was present before materializing the current operation.
 *                This can be passed in 'pattern' actions.
 * @value {any} A metadata hash.
 * @deprecated Import this constant from @comunica/context-entries.
 */
export declare const KEY_CONTEXT_PATTERN_PARENTMETADATA = KeysQueryOperation.patternParentMetadata;
/**
 * @type {string} Context entry for query's base IRI.
 * @value {any} A string.
 * @deprecated Import this constant from @comunica/context-entries.
 */
export declare const KEY_CONTEXT_BASEIRI = KeysInitSparql.baseIRI;
/**
 * @type {string} A timestamp representing the current time.
 *                This is required for certain SPARQL operations such as NOW().
 * @value {any} a date.
 * @deprecated Import this constant from @comunica/context-entries.
 */
export declare const KEY_CONTEXT_QUERY_TIMESTAMP = KeysInitSparql.queryTimestamp;
/**
 * @type {string} Context entry for indicating that only read operations are allowed, defaults to false.
 * @value {any} A boolean.
 * @deprecated Import this constant from @comunica/context-entries.
 */
export declare const KEY_CONTEXT_READONLY = KeysQueryOperation.readOnly;
/**
 * A comunica actor for query-operation events.
 *
 * Actor types:
 * * Input:  IActionQueryOperation:      A SPARQL Algebra operation.
 * * Test:   <none>
 * * Output: IActorQueryOperationOutput: A bindings stream.
 *
 * @see IActionQueryOperation
 * @see IActorQueryOperationOutput
 */
export declare abstract class ActorQueryOperation extends Actor<IActionQueryOperation, IActorTest, IActorQueryOperationOutput> {
    protected constructor(args: IActorArgs<IActionQueryOperation, IActorTest, IActorQueryOperationOutput>);
    /**
     * Safely cast a query operation output to a bindings output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IActorQueryOperationOutput} output A query operation output.
     * @return {IActorQueryOperationOutputBindings} A bindings query operation output.
     */
    static getSafeBindings(output: IActorQueryOperationOutput): IActorQueryOperationOutputBindings;
    /**
     * Safely cast a query operation output to a quads output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IActorQueryOperationOutput} output A query operation output.
     * @return {IActorQueryOperationOutputQuads} A quads query operation output.
     */
    static getSafeQuads(output: IActorQueryOperationOutput): IActorQueryOperationOutputQuads;
    /**
     * Safely cast a query operation output to a boolean output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IActorQueryOperationOutput} output A query operation output.
     * @return {IActorQueryOperationOutputBoolean} A boolean query operation output.
     */
    static getSafeBoolean(output: IActorQueryOperationOutput): IActorQueryOperationOutputBoolean;
    /**
     * Safely cast a query operation output to an update output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IActorQueryOperationOutput} output A query operation output.
     * @return {IActorQueryOperationOutputUpdate} An update query operation output.
     */
    static getSafeUpdate(output: IActorQueryOperationOutput): IActorQueryOperationOutputUpdate;
    /**
     * Convert a metadata callback to a lazy callback where the response value is cached.
     * @param {() => Promise<{[p: string]: any}>} metadata A metadata callback
     * @return {() => Promise<{[p: string]: any}>} The callback where the response will be cached.
     */
    static cachifyMetadata<T extends (() => Promise<Record<string, any>>) | (undefined | (() => Promise<Record<string, any>>))>(metadata: T): T;
    /**
     * Throw an error if the output type does not match the expected type.
     * @param {IActorQueryOperationOutput} output A query operation output.
     * @param {string} expectedType The expected output type.
     */
    static validateQueryOutput(output: IActorQueryOperationOutput, expectedType: string): void;
    protected static getBaseExpressionContext(context: ActionContext): IBaseExpressionContext;
    /**
     * Create an options object that can be used to construct a sparqlee synchronous evaluator.
     * @param context An action context.
     * @param mediatorQueryOperation An optional query query operation mediator.
     *                               If defined, the existence resolver will be defined as `exists`.
     */
    static getExpressionContext(context: ActionContext, mediatorQueryOperation?: Mediator<Actor<IActionQueryOperation, IActorTest, IActorQueryOperationOutput>, IActionQueryOperation, IActorTest, IActorQueryOperationOutput>): IExpressionContext;
    /**
     * Create an options object that can be used to construct a sparqlee asynchronous evaluator.
     * @param context An action context.
     * @param mediatorQueryOperation An optional query query operation mediator.
     *                               If defined, the existence resolver will be defined as `exists`.
     */
    static getAsyncExpressionContext(context: ActionContext, mediatorQueryOperation?: Mediator<Actor<IActionQueryOperation, IActorTest, IActorQueryOperationOutput>, IActionQueryOperation, IActorTest, IActorQueryOperationOutput>): IAsyncExpressionContext;
    /**
     * Create an existence resolver for usage within an expression context.
     * @param context An action context.
     * @param mediatorQueryOperation A query operation mediator.
     */
    static createExistenceResolver(context: ActionContext, mediatorQueryOperation: Mediator<Actor<IActionQueryOperation, IActorTest, IActorQueryOperationOutput>, IActionQueryOperation, IActorTest, IActorQueryOperationOutput>): (expr: Algebra.ExistenceExpression, bindings: Bindings) => Promise<boolean>;
    /**
     * Throw an error if the context contains the readOnly flag.
     * @param context An action context.
     */
    static throwOnReadOnly(context?: ActionContext): void;
}
/**
 * Helper function to get the metadata of an action output.
 * @param actionOutput An action output, with an optional metadata function.
 * @return The metadata.
 */
export declare function getMetadata(actionOutput: IActorQueryOperationOutputStream): Promise<Record<string, any>>;
interface IBaseExpressionContext {
    now?: Date;
    baseIRI?: string;
}
export interface IExpressionContext extends IBaseExpressionContext {
    bnode: (input?: string | undefined) => RDF.BlankNode;
}
export interface IAsyncExpressionContext extends IBaseExpressionContext {
    bnode: (input?: string | undefined) => Promise<RDF.BlankNode>;
    exists?: (expr: Algebra.ExistenceExpression, bindings: Bindings) => Promise<boolean>;
}
