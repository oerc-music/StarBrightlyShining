"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMetadata = exports.ActorQueryOperation = exports.KEY_CONTEXT_READONLY = exports.KEY_CONTEXT_QUERY_TIMESTAMP = exports.KEY_CONTEXT_BASEIRI = exports.KEY_CONTEXT_PATTERN_PARENTMETADATA = exports.KEY_CONTEXT_BGP_PATTERNBINDINGS = exports.KEY_CONTEXT_BGP_PARENTMETADATA = exports.KEY_CONTEXT_BGP_CURRENTMETADATA = void 0;
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const data_factory_1 = require("@comunica/data-factory");
const Bindings_1 = require("./Bindings");
/**
 * @type {string} Context entry for current metadata.
 *                I.e., the metadata that was used to determine the next BGP operation.
 * @value {any} A metadata hash.
 * @deprecated Import this constant from @comunica/context-entries.
 */
exports.KEY_CONTEXT_BGP_CURRENTMETADATA = context_entries_1.KeysQueryOperation.bgpCurrentMetadata;
/**
 * @type {string} Context entry for an array of parent metadata.
 *                I.e., an array of the metadata that was present before materializing the current BGP operations.
 *                This can be passed in 'bgp' actions.
 *                The array entries should correspond to the pattern entries in the BGP.
 * @value {any} An array of metadata hashes.
 * @deprecated Import this constant from @comunica/context-entries.
 */
exports.KEY_CONTEXT_BGP_PARENTMETADATA = context_entries_1.KeysQueryOperation.bgpParentMetadata;
/**
 * @type {string} Context entry for indicating which patterns were bound from variables.
 *                I.e., an array of the same length as the value of KeysQueryOperation.patternParentMetadata,
 *                where each array value corresponds to the pattern bindings for the corresponding pattern.
 * @value {any} An array of {@link PatternBindings}.
 * @deprecated Import this constant from @comunica/context-entries.
 */
exports.KEY_CONTEXT_BGP_PATTERNBINDINGS = context_entries_1.KeysQueryOperation.bgpPatternBindings;
/**
 * @type {string} Context entry for parent metadata.
 *                I.e., the metadata that was present before materializing the current operation.
 *                This can be passed in 'pattern' actions.
 * @value {any} A metadata hash.
 * @deprecated Import this constant from @comunica/context-entries.
 */
exports.KEY_CONTEXT_PATTERN_PARENTMETADATA = context_entries_1.KeysQueryOperation.patternParentMetadata;
/**
 * @type {string} Context entry for query's base IRI.
 * @value {any} A string.
 * @deprecated Import this constant from @comunica/context-entries.
 */
exports.KEY_CONTEXT_BASEIRI = context_entries_1.KeysInitSparql.baseIRI;
/**
 * @type {string} A timestamp representing the current time.
 *                This is required for certain SPARQL operations such as NOW().
 * @value {any} a date.
 * @deprecated Import this constant from @comunica/context-entries.
 */
exports.KEY_CONTEXT_QUERY_TIMESTAMP = context_entries_1.KeysInitSparql.queryTimestamp;
/**
 * @type {string} Context entry for indicating that only read operations are allowed, defaults to false.
 * @value {any} A boolean.
 * @deprecated Import this constant from @comunica/context-entries.
 */
exports.KEY_CONTEXT_READONLY = context_entries_1.KeysQueryOperation.readOnly;
/**
 * A counter that keeps track blank node generated through BNODE() SPARQL
 * expressions.
 *
 * @type {number}
 */
let bnodeCounter = 0;
/**
 * A comunica actor for query-operation events.
 *
 * Actor types:
 * * Input:  IActionQueryOperation:      A SPARQL Algebra operation.
 * * Test:   <none>
 * * Output: IActorQueryOperationOutput: A bindings stream.
 *
 * @see IActionQueryOperation
 * @see IActorQueryOperationOutput
 */
class ActorQueryOperation extends core_1.Actor {
    constructor(args) {
        super(args);
    }
    /**
     * Safely cast a query operation output to a bindings output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IActorQueryOperationOutput} output A query operation output.
     * @return {IActorQueryOperationOutputBindings} A bindings query operation output.
     */
    static getSafeBindings(output) {
        ActorQueryOperation.validateQueryOutput(output, 'bindings');
        return output;
    }
    /**
     * Safely cast a query operation output to a quads output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IActorQueryOperationOutput} output A query operation output.
     * @return {IActorQueryOperationOutputQuads} A quads query operation output.
     */
    static getSafeQuads(output) {
        ActorQueryOperation.validateQueryOutput(output, 'quads');
        return output;
    }
    /**
     * Safely cast a query operation output to a boolean output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IActorQueryOperationOutput} output A query operation output.
     * @return {IActorQueryOperationOutputBoolean} A boolean query operation output.
     */
    static getSafeBoolean(output) {
        ActorQueryOperation.validateQueryOutput(output, 'boolean');
        return output;
    }
    /**
     * Safely cast a query operation output to an update output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IActorQueryOperationOutput} output A query operation output.
     * @return {IActorQueryOperationOutputUpdate} An update query operation output.
     */
    static getSafeUpdate(output) {
        ActorQueryOperation.validateQueryOutput(output, 'update');
        return output;
    }
    /**
     * Convert a metadata callback to a lazy callback where the response value is cached.
     * @param {() => Promise<{[p: string]: any}>} metadata A metadata callback
     * @return {() => Promise<{[p: string]: any}>} The callback where the response will be cached.
     */
    static cachifyMetadata(metadata) {
        let lastReturn;
        // eslint-disable-next-line no-return-assign,@typescript-eslint/no-misused-promises
        return (metadata && (() => (lastReturn || (lastReturn = metadata()))));
    }
    /**
     * Throw an error if the output type does not match the expected type.
     * @param {IActorQueryOperationOutput} output A query operation output.
     * @param {string} expectedType The expected output type.
     */
    static validateQueryOutput(output, expectedType) {
        if (output.type !== expectedType) {
            throw new Error(`Invalid query output type: Expected '${expectedType}' but got '${output.type}'`);
        }
    }
    static getBaseExpressionContext(context) {
        if (context) {
            const now = context.get(context_entries_1.KeysInitSparql.queryTimestamp);
            const baseIRI = context.get(context_entries_1.KeysInitSparql.baseIRI);
            return { now, baseIRI };
        }
        return {};
    }
    /**
     * Create an options object that can be used to construct a sparqlee synchronous evaluator.
     * @param context An action context.
     * @param mediatorQueryOperation An optional query query operation mediator.
     *                               If defined, the existence resolver will be defined as `exists`.
     */
    static getExpressionContext(context, mediatorQueryOperation) {
        return Object.assign(Object.assign({}, this.getBaseExpressionContext(context)), { bnode: (input) => new data_factory_1.BlankNodeBindingsScoped(input || `BNODE_${bnodeCounter++}`) });
    }
    /**
     * Create an options object that can be used to construct a sparqlee asynchronous evaluator.
     * @param context An action context.
     * @param mediatorQueryOperation An optional query query operation mediator.
     *                               If defined, the existence resolver will be defined as `exists`.
     */
    static getAsyncExpressionContext(context, mediatorQueryOperation) {
        const expressionContext = Object.assign(Object.assign({}, this.getBaseExpressionContext(context)), { bnode: (input) => Promise.resolve(new data_factory_1.BlankNodeBindingsScoped(input || `BNODE_${bnodeCounter++}`)) });
        if (context && mediatorQueryOperation) {
            expressionContext.exists = ActorQueryOperation.createExistenceResolver(context, mediatorQueryOperation);
        }
        return expressionContext;
    }
    /**
     * Create an existence resolver for usage within an expression context.
     * @param context An action context.
     * @param mediatorQueryOperation A query operation mediator.
     */
    static createExistenceResolver(context, mediatorQueryOperation) {
        return async (expr, bindings) => {
            const operation = Bindings_1.materializeOperation(expr.input, bindings);
            const outputRaw = await mediatorQueryOperation.mediate({ operation, context });
            const output = ActorQueryOperation.getSafeBindings(outputRaw);
            return new Promise((resolve, reject) => {
                output.bindingsStream.on('end', () => {
                    resolve(false);
                });
                output.bindingsStream.on('error', reject);
                output.bindingsStream.on('data', () => {
                    output.bindingsStream.close();
                    resolve(true);
                });
            })
                .then((exists) => expr.not ? !exists : exists);
        };
    }
    /**
     * Throw an error if the context contains the readOnly flag.
     * @param context An action context.
     */
    static throwOnReadOnly(context) {
        if (context && context.get(exports.KEY_CONTEXT_READONLY)) {
            throw new Error(`Attempted a write operation in read-only mode`);
        }
    }
}
exports.ActorQueryOperation = ActorQueryOperation;
/**
 * Helper function to get the metadata of an action output.
 * @param actionOutput An action output, with an optional metadata function.
 * @return The metadata.
 */
function getMetadata(actionOutput) {
    if (!actionOutput.metadata) {
        return Promise.resolve({});
    }
    return actionOutput.metadata();
}
exports.getMetadata = getMetadata;
//# sourceMappingURL=ActorQueryOperation.js.map