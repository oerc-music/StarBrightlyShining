{"version":3,"sources":["webpack://JOSE/./node_modules/base64url/dist/base64url.js","webpack://JOSE/./node_modules/base64url/dist/pad-string.js","webpack://JOSE/./node_modules/base64url/index.js","webpack://JOSE/./src/algorithms/HMAC.js","webpack://JOSE/./src/algorithms/NONE.js","webpack://JOSE/./src/algorithms/RSASSA-PKCS1-v1_5.js","webpack://JOSE/./src/algorithms/SupportedAlgorithms.js","webpack://JOSE/./src/algorithms/index.js","webpack://JOSE/./src/crypto.js","webpack://JOSE/./src/errors/DataError.js","webpack://JOSE/./src/errors/NotSupportedError.js","webpack://JOSE/./src/errors/index.js","webpack://JOSE/./src/index.js","webpack://JOSE/./src/jose/JOSEHeader.js","webpack://JOSE/./src/jose/JWA.js","webpack://JOSE/./src/jose/JWK.js","webpack://JOSE/./src/jose/JWKSet.js","webpack://JOSE/./src/jose/JWS.js","webpack://JOSE/./src/jose/JWT.js","webpack://JOSE/./src/text-encoder/index.js","webpack://JOSE/external \"TextEncoder\"","webpack://JOSE/external \"crypto\"","webpack://JOSE/webpack/bootstrap","webpack://JOSE/webpack/runtime/global","webpack://JOSE/webpack/startup"],"names":["pad_string_1","encode","input","encoding","Buffer","isBuffer","fromBase64","toString","from","toBase64","base64url","default","replace","base64","decode","toBuffer","exports","Object","defineProperty","value","stringLength","length","diff","position","padLength","paddedStringLength","buffer","alloc","write","module","crypto","TextEncoder","params","this","key","data","algorithm","subtle","sign","then","signature","Uint8Array","verify","bitlength","Error","Promise","resolve","jwk","assign","usages","use","push","key_ops","importKey","cryptoKey","enumerable","NotSupportedError","operations","forEach","op","alg","argument","registeredAlgorithms","SyntaxError","None","HMAC","RSASSA_PKCS1_v1_5","supportedAlgorithms","define","name","hash","imported","DataError","message","super","JWA","JWK","JWKSet","JWT","JWS","typ","cty","jku","kid","x5u","x5c","x5t","crit","enc","zip","normalizedAlgorithm","normalize","reject","kty","keys","jwks","importing","map","err","all","JOSEHeader","header","payload","protected","signatures","verified","token","JSON","stringify","serialization","jwt","segments","type","unprotected","iv","aad","ciphertext","tag","recipients","ExtendedJWT","startsWith","parse","error","filter","split","match","Array","isArray","find","isJWE","JWE","encrypt","g","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","globalThis","Function","e","window","__webpack_exports__"],"mappings":"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","file":"jose.min.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pad_string_1 = require(\"./pad-string\");\nfunction encode(input, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    return Buffer.from(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url)\n        .replace(/\\-/g, \"+\")\n        .replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return Buffer.from(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nexports.default = base64url;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = Buffer.alloc(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nexports.default = padString;\n","module.exports = require('./dist/base64url').default;\nmodule.exports.default = module.exports;\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst base64url = require('base64url')\nconst crypto = require('isomorphic-webcrypto')\nconst TextEncoder = require('../text-encoder')\n\n/**\n * HMAC with SHA-2 Functions\n */\nclass HMAC {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  constructor (params) {\n    this.params = params\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n  sign (key, data) {\n    let algorithm = this.params\n\n    // TODO: validate key length\n\n    data = new TextEncoder().encode(data)\n\n    return crypto.subtle\n      .sign(algorithm, key, data)\n      .then(signature => base64url(Buffer.from(signature)))\n  }\n\n  /**\n   * Verify\n   *\n   * @description\n   * Verify a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {string} signature\n   * @param {string} data\n   *\n   * @returns {Boolean}\n   */\n  verify (key, signature, data) {\n    let algorithm = this.params\n\n    if (typeof signature === 'string') {\n      signature = Uint8Array.from(base64url.toBuffer(signature))\n    }\n\n    if (typeof data === 'string') {\n      data = new TextEncoder().encode(data)\n    }\n\n    return crypto.subtle.verify(algorithm, key, signature, data)\n  }\n\n  /**\n   * Assert Sufficient Key Length\n   *\n   * @description Assert that the key length is sufficient\n   * @param {string} key\n   */\n  assertSufficientKeyLength (key) {\n    if (key.length < this.bitlength) {\n      throw new Error('The key is too short.')\n    }\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = HMAC\n","/**\n * None\n */\nclass None {\n  /**\n   * sign\n   */\n  sign () {\n    return Promise.resolve('')\n  }\n\n  /**\n   * verify\n   */\n  verify () {\n    // this will never get called. but you looked.\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = None\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst base64url = require('base64url')\nlet crypto = require('../crypto')\nconst TextEncoder = require('../text-encoder')\n\n/**\n * RSASSA-PKCS1-v1_5\n */\nclass RSASSA_PKCS1_v1_5 {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  constructor (params) {\n    this.params = params\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n  sign (key, data) {\n    let algorithm = this.params\n\n    // TODO\n    //if (!this.sufficientKeySize()) {\n    //  return Promise.reject(\n    //    new Error(\n    //      'A key size of 2048 bits or larger must be used with RSASSA-PKCS1-v1_5'\n    //    )\n    //  )\n    //}\n\n    data = new TextEncoder().encode(data)\n\n    return crypto.subtle\n      .sign(algorithm, key, data)\n      .then(signature => base64url(Buffer.from(signature)))\n  }\n\n  /**\n   * verify\n   *\n   * @description\n   * Verify a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} signature\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n  verify (key, signature, data) {\n    let algorithm = this.params\n\n    if (typeof signature === 'string') {\n      signature = Uint8Array.from(base64url.toBuffer(signature))\n    }\n\n    if (typeof data === 'string') {\n      data = new TextEncoder().encode(data)\n    }\n    // ...\n\n    return crypto.subtle.verify(algorithm, key, signature, data)\n  }\n\n  /**\n   * importKey\n   *\n   * @param {JWK} key\n   * @returns {Promise}\n   */\n  async importKey (key) {\n    let jwk = Object.assign({}, key)\n    let algorithm = this.params\n    let usages = key['key_ops'] || []\n\n    if (key.use === 'sig') {\n      usages.push('verify')\n    }\n\n    if (key.use === 'enc') {\n      // TODO: handle encryption keys\n      return Promise.resolve(key)\n    }\n\n    if (key.key_ops) {\n      usages = key.key_ops\n    }\n\n    return crypto.subtle\n      .importKey('jwk', jwk, algorithm, true, usages)\n      .then(cryptoKey => {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        })\n\n        return jwk\n      })\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = RSASSA_PKCS1_v1_5\n","/**\n * Dependencies\n */\nconst NotSupportedError = require('../errors/NotSupportedError')\n\n/**\n * Operations\n */\nconst operations = [\n  'sign',\n  'verify',\n  'encrypt',\n  'decrypt',\n  'importKey'\n]\n\n/**\n * SupportedAlgorithms\n */\nclass SupportedAlgorithms {\n\n  /**\n   * constructor\n   */\n  constructor () {\n    operations.forEach(op => {\n      this[op] = {}\n    })\n  }\n\n  /**\n   * Supported Operations\n   */\n  static get operations () {\n    return operations\n  }\n\n  /**\n   * define\n   *\n   * @description\n   * Register Web Crypto API algorithm parameter for an algorithm\n   * and operation.\n   *\n   * @param {string} alg\n   * @param {string} op\n   * @param {Object} argument\n   */\n  define (alg, op, argument) {\n    let registeredAlgorithms = this[op]\n    registeredAlgorithms[alg] = argument\n  }\n\n  /**\n   * normalize\n   *\n   * @description\n   * Map JWA alg name to Web Crypto API algorithm parameter\n   *\n   * @param {string} op\n   * @param {Object} alg\n   *\n   * @returns {Object}\n   */\n  normalize (op, alg) {\n    let registeredAlgorithms = this[op]\n\n    if (!registeredAlgorithms) {\n      return new SyntaxError() // what kind of error should this be?\n    }\n\n    let argument = registeredAlgorithms[alg]\n\n    if (!argument) {\n      return new NotSupportedError(alg)\n    }\n\n    return argument\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = SupportedAlgorithms\n","/**\n * Local dependencies\n */\nconst None = require('./NONE')\nconst HMAC = require('./HMAC')\nconst RSASSA_PKCS1_v1_5 = require('./RSASSA-PKCS1-v1_5')\nconst SupportedAlgorithms = require('./SupportedAlgorithms')\n\n/**\n * Register Supported Algorithms\n */\nconst supportedAlgorithms = new SupportedAlgorithms\n\n/**\n * Sign\n */\nsupportedAlgorithms.define('HS256', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('HS384', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('HS512', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('RS256', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('RS384', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('RS512', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n//supportedAlgorithms.define('ES256', 'sign', {})\n//supportedAlgorithms.define('ES384', 'sign', {})\n//supportedAlgorithms.define('ES512', 'sign', {})\n//supportedAlgorithms.define('PS256', 'sign', {})\n//supportedAlgorithms.define('PS384', 'sign', {})\n//supportedAlgorithms.define('PS512', 'sign', {})\n\nsupportedAlgorithms.define('none', 'sign', new None({\n  // nothing goes here\n}))\n\n/**\n * Verify\n */\nsupportedAlgorithms.define('HS256', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('HS384', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('HS512', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('RS256', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('RS384', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('RS512', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n//supportedAlgorithms.define('ES256', 'verify', {})\n//supportedAlgorithms.define('ES384', 'verify', {})\n//supportedAlgorithms.define('ES512', 'verify', {})\n//supportedAlgorithms.define('PS256', 'verify', {})\n//supportedAlgorithms.define('PS384', 'verify', {})\n//supportedAlgorithms.define('PS512', 'verify', {})\n\nsupportedAlgorithms.define('none', 'verify', new None({\n  // nothing goes here\n}))\n\nsupportedAlgorithms.define('RS256', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('RS384', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('RS512', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\n/**\n * Export\n */\nmodule.exports = supportedAlgorithms\n\n\n","const imported = require('isomorphic-webcrypto')\n\nmodule.exports = (imported.default ? imported.default : imported)\n","/**\n * DataError\n */\nclass DataError extends Error {\n  constructor (message) {\n    super(message)\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = DataError\n","/**\n * NotSupportedError\n */\nclass NotSupportedError extends Error {\n  constructor (alg) {\n    super()\n    this.message = `${alg} is not a supported algorithm`\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = NotSupportedError\n","module.exports = {\n  DataError: require('./DataError'),\n  NotSupportedError: require('./NotSupportedError')\n}\n","/**\n * @module JSON Object Signing and Encryption (JOSE)\n */\nconst crypto = require('./crypto')\nconst JWA = require('./jose/JWA')\nconst JWK = require('./jose/JWK')\nconst JWKSet = require('./jose/JWKSet')\nconst JWT = require('./jose/JWT')\nconst JWS = require('./jose/JWS')\n\n/**\n * Export\n */\nmodule.exports = {\n  crypto,\n  JWA,\n  JWK,\n  JWKSet,\n  JWT,\n  JWS\n}\n","/**\n * Header\n */\nclass JOSEHeader {\n  constructor ({ typ, cty, alg, jku, kid, x5u, x5c, x5t, crit, enc, zip } = {}) {\n    this.typ = typ\n    this.cty = cty\n    this.alg = alg\n    this.jku = jku\n    this.kid = kid\n    this.x5u = x5u\n    this.x5c = x5c\n    this.x5t = x5t\n    this.crit = crit\n    this.enc = enc\n    this.zip = zip\n  }\n\n  /**\n   * isJWS\n   */\n  isJWS () {}\n\n  /**\n   * isJWE\n   */\n  isJWE () {}\n}\n\n/**\n * Export\n */\nmodule.exports = JOSEHeader\n","/**\n * Dependencies\n *\n * TODO\n * - switch between Node.js webcrypto package and browser implementation\n */\n// const base64url = require('base64url')\nconst supportedAlgorithms = require('../algorithms')\nconst {NotSupportedError} = require('../errors')\n\n/**\n * JWA\n * https://tools.ietf.org/html/rfc7518\n */\nclass JWA {\n\n  /**\n   * Sign\n   *\n   * @description\n   * Create a digital signature.\n   *\n   * @param {string} alg\n   * @param {CryptoKey} key\n   * @param {string|Buffer} data\n   *\n   * @return {Promise}\n   */\n  static async sign (alg, key, data) {\n    // normalize the algorithm\n    let normalizedAlgorithm = supportedAlgorithms.normalize('sign', alg)\n\n    // validate algorithm is supported\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(new NotSupportedError(alg))\n    }\n\n    // validate type of key\n    // TODO\n    //  - is the key suitable for the algorithm?\n    //  - does that get validated in webcrypto?\n    //if (key instanceof CryptoKey) {\n    //  return Promise.reject(new InvalidKeyError())\n    //}\n\n    // sign the data\n    return normalizedAlgorithm.sign(key, data)\n  }\n\n  /**\n   * Verify\n   *\n   * @description\n   * Verify a digital signature.\n   *\n   * @param {string} alg\n   * @param {CryptoKey} privateKey\n   * @param {string|Buffer} signature\n   * @param {string|Buffer} data\n   *\n   * @return {Promise}\n   */\n  static async verify (alg, key, signature, data) {\n    let normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg)\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(new NotSupportedError(alg))\n    }\n\n    // TODO\n    // validate publicKey\n\n    // verify the signature\n    return normalizedAlgorithm.verify(key, signature, data)\n  }\n\n  /**\n   * Encrypt\n   */\n\n  /**\n   * Decrypt\n   */\n\n  /**\n   * Import\n   */\n  static async importKey (key) {\n    let normalizedAlgorithm = supportedAlgorithms.normalize('importKey', key.alg)\n    return normalizedAlgorithm.importKey(key)\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWA\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst JWA = require('./JWA')\n\n/**\n * JWK Class\n */\nclass JWK {\n  constructor ({ kty, use, key_ops, alg, kid, x5u, x5c, x5t } = {}) {\n    this.kty = kty\n    this.use = use\n    this.key_ops = key_ops\n    this.alg = alg\n    this.kid = kid\n    this.x5u = x5u\n    this.x5c = x5c\n    this.x5t = x5t\n  }\n\n  /**\n   * importKey\n   *\n   * TODO:\n   * - should this be on JWA?\n   */\n  static async importKey (jwk) {\n    return JWA.importKey(jwk)\n  }\n\n\n}\n\n/**\n * Export\n */\nmodule.exports = JWK\n","'use strict'\n\n/**\n * Dependencies\n */\nconst JWK = require('./JWK')\n\n/**\n * JWKSet\n *\n * @class\n * JWKSet represents a JSON Web Key Set as described in Section 5 of RFC 7517:\n * https://tools.ietf.org/html/rfc7517#section-5\n */\nclass JWKSet {\n  constructor ({ keys } = {}) {\n    this.keys = keys\n  }\n\n  /**\n   * importKeys\n   */\n  static async importKeys (jwks) {\n    if (!jwks.keys) {\n      return Promise.reject(new Error('Cannot import JWKSet: keys property is empty'))\n    }\n\n    let imported, importing\n\n    try {\n      imported = new JWKSet(jwks)\n      importing = jwks.keys.map(key => JWK.importKey(key))\n    } catch (err) {\n      return Promise.reject(err)\n    }\n\n    return Promise.all(importing)\n      .then(keys => {\n        imported.keys = keys\n        return imported\n      })\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWKSet\n","/**\n * Dependencies\n */\nconst base64url = require('base64url')\nconst JWA = require('./JWA')\nconst { DataError } = require('../errors')\nconst JOSEHeader = require('./JOSEHeader')\n\n/**\n * JWS\n */\nclass JWS {\n  constructor (data = {}) {\n    // compact\n    this.header = new JOSEHeader(data.header)\n    this.payload = data.payload || {}\n    this.signature = data.signature\n\n    // flattened\n    this.protected = data.protected\n\n    // JSON serialization\n    this.signatures = data.signatures\n\n    this.verified = false\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Encode a JWT instance\n   *\n   * @param {Object} token\n   * @returns {Promise}\n   */\n  static async sign (token) {\n    let payload = base64url(JSON.stringify(token.payload))\n\n    // compact serialization\n    if (token.serialization === 'compact') {\n      let {key, header: {alg}} = token\n      let header = base64url(JSON.stringify(token.header))\n      let data = `${header}.${payload}`\n\n      return JWA.sign(alg, key, data).then(signature => `${data}.${signature}`)\n    }\n\n    // JSON serialization\n    if (token.serialization === 'json') {\n\n    }\n\n    // Flattened serialization\n    if (token.serialization === 'flattened') {\n\n    }\n\n    return Promise.reject(new DataError('Unsupported serialization'))\n  }\n\n  /**\n   * verify\n   */\n  static async verify (jwt) {\n    // multiple signatures\n    if (jwt.signatures) {\n      // ...\n    }\n\n    let {key, signature, header: {alg}} = jwt\n\n    // one signature\n    if (jwt.signature) {\n      let [header, payload] = jwt.segments\n      let data = `${header}.${payload}`\n\n      if (alg === 'none') {\n        return Promise.reject(new DataError('Signature provided to verify with alg: none'))\n      }\n\n      return JWA.verify(alg, key, signature, data).then(verified => {\n        jwt.verified = verified\n        return verified\n      })\n    }\n\n    if (alg === 'none') {\n      if (!key && !signature) {\n        jwt.verified = true\n\n        return Promise.resolve(true)\n      }\n\n      if (key) {\n        return Promise.reject(new DataError('Key provided to verify signature with alg: none'))\n      }\n    }\n\n    // no signatures to verify\n    return Promise.reject(new DataError('Missing signature(s)'))\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWS\n","/**\n * Dependencies\n */\nconst base64url = require('base64url')\nconst JWS = require('./JWS')\nconst DataError = require('../errors/DataError')\nconst JOSEHeader = require('./JOSEHeader')\n\n/**\n * JWT\n */\nclass JWT {\n  constructor (data = {}) {\n    this.type = data.type\n    this.segments = data.segments\n    this.header = new JOSEHeader(data.header)\n    this.protected = data.protected\n    this.unprotected = data.unprotected\n    this.iv = data.iv\n    this.aad = data.aad\n    this.ciphertext = data.ciphertext\n    this.tag = data.tag\n    this.recipients = data.recipients\n    this.payload = data.payload\n    this.signatures = data.signatures\n    this.signature = data.signature\n    this.key = data.key\n    this.serialization = data.serialization || 'compact' // default\n  }\n\n  /**\n   * decode\n   *\n   * @description\n   * Decode a JSON Web Token\n   *\n   * @param {string} data\n   * @returns {JWT}\n   */\n  static decode (data) {\n    let ExtendedJWT = this\n    let jwt\n\n    if (typeof data !== 'string') {\n      throw new DataError('JWT must be a string')\n    }\n\n    // JSON of Flattened JSON Serialization\n    if (data.startsWith('{')) {\n      try {\n        data = JSON.parse(data, () => {})\n      } catch (error) {\n        throw new DataError('Invalid JWT serialization')\n      }\n\n      if (data.signatures || data.recipients) {\n        data.serialization = 'json'\n      } else {\n        data.serialization = 'flattened'\n      }\n\n      jwt = new ExtendedJWT(data, { filter: false })\n\n    // Compact Serialization\n    } else {\n      try {\n        let serialization = 'compact'\n        let segments = data.split('.')\n        let length = segments.length\n\n        if (length !== 3 && length !== 5) {\n          throw new Error('Malformed JWT')\n        }\n\n        let header = JSON.parse(base64url.decode(segments[0]))\n\n        // JSON Web Signature\n        if (length === 3) {\n          let type = 'JWS'\n          let payload = JSON.parse(base64url.decode(segments[1]))\n          let signature = segments[2]\n\n          jwt = new ExtendedJWT(\n              { type, segments, header, payload, signature, serialization },\n              { filter: false }\n            )\n        }\n\n        // JSON Web Encryption\n        if (length === 5) {\n          //let type = 'JWE'\n          //let [protected, encryption_key, iv, ciphertext, tag] = segments\n\n          //jwt = new ExtendedJWT({\n          //  type,\n          //  protected: base64url.decode(JSON.parse(protected)),\n          //  encryption_key,\n          //  iv,\n          //  ciphertext,\n          //  tag,\n          //  serialization\n          //})\n        }\n      } catch (error) {\n        throw new DataError('Invalid JWT compact serialization')\n      }\n    }\n\n    return jwt\n  }\n\n  /**\n   * encode\n   *\n   * @description\n   * Encode a JSON Web Token\n   *\n   * @param {Object} header\n   * @param {Object} payload\n   * @param {CryptoKey} key\n   *\n   * @returns {Promise}\n   */\n  static encode (header, payload, key) {\n    let jwt = new JWT(header, payload)\n    return jwt.encode(key)\n  }\n\n\n  /**\n   * verify\n   *\n   * @description\n   *\n   * @param {CryptoKey} key\n   * @param {string} token\n   *\n   * @returns {Promise}\n   */\n  static async verify (key, token) {\n    let jwt = JWT.decode(token)\n    jwt.key = key\n    return jwt.verify().then(verified => jwt)\n  }\n\n  /**\n   * isJWE\n   */\n  isJWE () {\n    return !!this.header.enc\n  }\n\n  /**\n   * resolveKeys\n   */\n  resolveKeys (jwks) {\n    let kid = this.header.kid\n    let keys, match\n\n    // treat an array as the \"keys\" property of a JWK Set\n    if (Array.isArray(jwks)) {\n      keys = jwks\n    }\n\n    // presence of keys indicates object is a JWK Set\n    if (jwks.keys) {\n      keys = jwks.keys\n    }\n\n    // wrap a plain object they is not a JWK Set in Array\n    if (!jwks.keys && typeof jwks === 'object') {\n      keys = [jwks]\n    }\n\n    // ensure there are keys to search\n    if (!keys) {\n      throw new DataError('Invalid JWK argument')\n    }\n\n    // match by \"kid\" or \"use\" header\n    if (kid) {\n      match = keys.find(jwk => jwk.kid === kid)\n    } else {\n      match = keys.find(jwk => jwk.use === 'sig')\n    }\n\n    // assign matching key to JWT and return a boolean\n    if (match) {\n      this.key = match.cryptoKey\n      return true\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * encode\n   *\n   * @description\n   * Encode a JWT instance\n   *\n   * @returns {Promise}\n   */\n  async encode () {\n    let token = this\n\n    if (this.isJWE()) {\n      return JWE.encrypt(token)\n    } else {\n      return JWS.sign(token)\n    }\n  }\n\n  /**\n   * verify\n   *\n   * @description\n   * Verify a decoded JWT instance\n   *\n   * @returns {Promise}\n   */\n  async verify () {\n    return JWS.verify(this)\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWT\n","const TextEncoder = global.TextEncoder\n  ? global.TextEncoder  // browser\n  : require('@sinonjs/text-encoding').TextEncoder  // node shim\nmodule.exports = TextEncoder\n","module.exports = TextEncoder;","module.exports = crypto;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(138);\n"],"sourceRoot":""}