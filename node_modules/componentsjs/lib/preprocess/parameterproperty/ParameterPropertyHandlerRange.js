"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterPropertyHandlerRange = void 0;
const Iris_1 = require("../../rdf/Iris");
const ErrorResourcesContext_1 = require("../../util/ErrorResourcesContext");
/**
 * If a param range is defined, apply the type and validate the range.
 */
class ParameterPropertyHandlerRange {
    constructor(objectLoader) {
        this.objectLoader = objectLoader;
    }
    canHandle(value, configRoot, parameter, configElement) {
        return Boolean(parameter.property.range);
    }
    handle(value, configRoot, parameter, configElement) {
        for (const subValue of value) {
            this.captureType(subValue, parameter);
        }
        return value;
    }
    /**
     * Apply the given datatype to the given literal.
     * Checks if the datatype is correct and casts to the correct js type.
     * Will throw an error if the type has an invalid value.
     * Will be ignored if the value is not a literal or the type is not recognized.
     * @param value The value.
     * @param param The parameter.
     */
    captureType(value, param) {
        if (value.type === 'Literal') {
            let parsed;
            switch (param.property.range.value) {
                case Iris_1.IRIS_XSD.boolean:
                    if (value.value === 'true') {
                        value.term.valueRaw = true;
                    }
                    else if (value.value === 'false') {
                        value.term.valueRaw = false;
                    }
                    else {
                        this.throwIncorrectTypeError(value, param);
                    }
                    break;
                case Iris_1.IRIS_XSD.integer:
                case Iris_1.IRIS_XSD.number:
                case Iris_1.IRIS_XSD.int:
                case Iris_1.IRIS_XSD.byte:
                case Iris_1.IRIS_XSD.long:
                    parsed = Number.parseInt(value.value, 10);
                    if (Number.isNaN(parsed)) {
                        this.throwIncorrectTypeError(value, param);
                    }
                    else {
                        // ParseInt also parses floats to ints!
                        if (String(parsed) !== value.value) {
                            this.throwIncorrectTypeError(value, param);
                        }
                        value.term.valueRaw = parsed;
                    }
                    break;
                case Iris_1.IRIS_XSD.float:
                case Iris_1.IRIS_XSD.decimal:
                case Iris_1.IRIS_XSD.double:
                    parsed = Number.parseFloat(value.value);
                    if (Number.isNaN(parsed)) {
                        this.throwIncorrectTypeError(value, param);
                    }
                    else {
                        value.term.valueRaw = parsed;
                    }
                    break;
                case Iris_1.IRIS_RDF.JSON:
                    try {
                        parsed = JSON.parse(value.value);
                        value.term.valueRaw = parsed;
                    }
                    catch (_a) {
                        this.throwIncorrectTypeError(value, param);
                    }
                    break;
            }
        }
        return value;
    }
    throwIncorrectTypeError(value, parameter) {
        throw new ErrorResourcesContext_1.ErrorResourcesContext(`Parameter value "${value.value}" is not of required range type "${parameter.property.range.value}"`, {
            parameter,
        });
    }
}
exports.ParameterPropertyHandlerRange = ParameterPropertyHandlerRange;
//# sourceMappingURL=ParameterPropertyHandlerRange.js.map