{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeHandlerSelectionAdapter = void 0;\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n\nconst IConvertContext_1 = require(\"../IConvertContext\");\n\nconst NodeHandlerAdapter_1 = require(\"./NodeHandlerAdapter\");\n/**\n * A handler for converting GraphQL selection nodes to operations.\n */\n\n\nclass NodeHandlerSelectionAdapter extends NodeHandlerAdapter_1.NodeHandlerAdapter {\n  constructor(targetKind, util, settings) {\n    super(targetKind, util, settings);\n  }\n  /**\n   * Get the quad context of a field node that should be used for the whole definition node.\n   * @param {FieldNode} field A field node.\n   * @param {string} fieldLabel A field label.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {INodeQuadContext | null} The subject and optional auxiliary patterns.\n   */\n\n\n  getNodeQuadContextFieldNode(field, fieldLabel, convertContext) {\n    return this.getNodeQuadContextSelectionSet(field.selectionSet, fieldLabel, Object.assign(Object.assign({}, convertContext), {\n      path: this.util.appendFieldToPath(convertContext.path, fieldLabel)\n    }));\n  }\n  /**\n   * Convert a field node to an operation.\n   * @param {IConvertContext} convertContext A convert context.\n   * @param {FieldNode} fieldNode The field node to convert.\n   * @param {boolean} pushTerminalVariables If terminal variables should be created.\n   * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.\n   * @return {Operation} The reslting operation.\n   */\n\n\n  fieldToOperation(convertContext, fieldNode, pushTerminalVariables, auxiliaryPatterns) {\n    // If a deeper node is being selected, and if the current object should become the next subject\n    const nesting = pushTerminalVariables; // Offset and limit can be changed using the magic arguments 'first' and 'offset'.\n\n    let offset = 0;\n    let limit; // Ignore 'id' and 'graph' fields, because we have processed them earlier in getNodeQuadContextSelectionSet.\n\n    if (fieldNode.name.value === 'id' || fieldNode.name.value === 'graph') {\n      pushTerminalVariables = false; // Validate all _-arguments, because even though they were handled before,\n      // the validity of variables could not be checked,\n      // as variablesMetaDict wasn't populated at that time yet.\n\n      if (fieldNode.arguments) {\n        for (const argument of fieldNode.arguments) {\n          if (argument.name.value === '_') {\n            this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n          }\n        }\n      }\n    } // Determine the field label for variable naming, taking into account aliases\n\n\n    const fieldLabel = this.util.getFieldLabel(fieldNode); // Handle the singular/plural scope\n\n    if (convertContext.singularizeState === IConvertContext_1.SingularizeState.SINGLE) {\n      convertContext.singularizeVariables[this.util.nameToVariable(fieldLabel, convertContext).value] = true;\n    } // Handle meta fields\n\n\n    if (pushTerminalVariables) {\n      const operationOverride = this.handleMetaField(convertContext, fieldLabel, auxiliaryPatterns);\n\n      if (operationOverride) {\n        return operationOverride;\n      }\n    }\n\n    const operations = auxiliaryPatterns ? [this.util.operationFactory.createBgp(auxiliaryPatterns)] : []; // Define subject and object\n\n    const subjectOutput = this.getNodeQuadContextFieldNode(fieldNode, fieldLabel, convertContext);\n    let object = subjectOutput.subject || this.util.nameToVariable(fieldLabel, convertContext);\n    let graph = subjectOutput.graph || convertContext.graph;\n\n    if (subjectOutput.auxiliaryPatterns) {\n      operations.push(this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns));\n    } // Check if there is a '_' argument\n    // We do this before handling all other arguments so that the order of final triple patterns is sane.\n\n\n    let createQuadPattern = true;\n    let overrideObjectTerms = null;\n\n    if (pushTerminalVariables && fieldNode.arguments && fieldNode.arguments.length) {\n      for (const argument of fieldNode.arguments) {\n        if (argument.name.value === '_') {\n          // '_'-arguments do not create an additional predicate link, but set the value directly.\n          const valueOutput = this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n          overrideObjectTerms = valueOutput.terms;\n          operations.push(this.util.operationFactory.createBgp(valueOutput.terms.map(term => this.util.createQuadPattern(convertContext.subject, fieldNode.name, term, convertContext.graph, convertContext.context))));\n\n          if (valueOutput.auxiliaryPatterns) {\n            operations.push(this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns));\n          }\n\n          pushTerminalVariables = false;\n          break;\n        } else if (argument.name.value === 'graph') {\n          // 'graph'-arguments do not create an additional predicate link, but set the graph.\n          const valueOutput = this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n\n          if (valueOutput.terms.length !== 1) {\n            throw new Error(`Only single values can be set as graph, but got ${valueOutput.terms.length} at ${fieldNode.name.value}`);\n          }\n\n          graph = valueOutput.terms[0];\n          convertContext = Object.assign(Object.assign({}, convertContext), {\n            graph\n          });\n\n          if (valueOutput.auxiliaryPatterns) {\n            operations.push(this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns));\n          }\n\n          break;\n        } else if (argument.name.value === 'alt') {\n          // 'alt'-arguments do not create an additional predicate link, but create alt-property paths.\n          let pathValue = argument.value;\n\n          if (pathValue.kind !== 'ListValue') {\n            pathValue = {\n              kind: 'ListValue',\n              values: [pathValue]\n            };\n          }\n\n          operations.push(this.util.createQuadPath(convertContext.subject, fieldNode.name, pathValue, object, convertContext.graph, convertContext.context));\n          createQuadPattern = false;\n          break;\n        }\n      }\n    } // Create at least a pattern for the parent node and the current path.\n\n\n    if (pushTerminalVariables && createQuadPattern) {\n      operations.push(this.util.operationFactory.createBgp([this.util.createQuadPattern(convertContext.subject, fieldNode.name, object, convertContext.graph, convertContext.context)]));\n    } // Create patterns for the node's arguments\n\n\n    if (fieldNode.arguments && fieldNode.arguments.length) {\n      for (const argument of fieldNode.arguments) {\n        if (argument.name.value === '_' || argument.name.value === 'graph' || argument.name.value === 'alt') {// no-op\n        } else if (argument.name.value === 'first') {\n          if (argument.value.kind !== 'IntValue') {\n            throw new Error('Invalid value type for \\'first\\' argument: ' + argument.value.kind);\n          }\n\n          limit = parseInt(argument.value.value, 10);\n        } else if (argument.name.value === 'offset') {\n          if (argument.value.kind !== 'IntValue') {\n            throw new Error('Invalid value type for \\'offset\\' argument: ' + argument.value.kind);\n          }\n\n          offset = parseInt(argument.value.value, 10);\n        } else {\n          const valueOutput = this.util.handleNodeValue(argument.value, argument.name.value, convertContext);\n          operations.push(this.util.operationFactory.createBgp(valueOutput.terms.map(term => this.util.createQuadPattern(object, argument.name, term, convertContext.graph, convertContext.context))));\n\n          if (valueOutput.auxiliaryPatterns) {\n            operations.push(this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns));\n          }\n        }\n      }\n    } // Directives\n\n\n    const directiveOutputs = this.getDirectiveOutputs(fieldNode.directives, fieldLabel, convertContext);\n\n    if (!directiveOutputs) {\n      return this.util.operationFactory.createBgp([]);\n    } // Recursive call for nested selection sets\n\n\n    let operation = this.util.joinOperations(operations);\n\n    if (fieldNode.selectionSet && fieldNode.selectionSet.selections.length) {\n      // Override the object if needed\n      if (overrideObjectTerms) {\n        if (overrideObjectTerms.length !== 1) {\n          throw new Error(`Only single values can be set as id, but got ${overrideObjectTerms.length} at ${fieldNode.name.value}`);\n        }\n\n        object = overrideObjectTerms[0];\n      } // Change path value when there was an alias on this node.\n\n\n      const subConvertContext = Object.assign(Object.assign(Object.assign({}, convertContext), nesting ? {\n        path: this.util.appendFieldToPath(convertContext.path, fieldLabel)\n      } : {}), {\n        graph,\n        subject: nesting ? object : convertContext.subject\n      }); // If the magic keyword 'totalCount' is present, include a count aggregator.\n\n      let totalCount = false;\n      const selections = fieldNode.selectionSet.selections.filter(selection => {\n        if (selection.kind === 'Field' && selection.name.value === 'totalCount') {\n          totalCount = true;\n          return false;\n        }\n\n        return true;\n      });\n      let joinedOperation = this.util.joinOperations(operations.concat(selections.map(selectionNode => this.util.handleNode(selectionNode, subConvertContext)))); // Modify the operation if there was a count selection\n\n      if (totalCount) {\n        // Create to a count aggregation\n        const expressionVariable = this.util.dataFactory.variable('var' + this.settings.expressionVariableCounter++);\n        const countOverVariable = this.util.dataFactory.variable(object.value + this.settings.variableDelimiter + 'totalCount');\n        const aggregator = this.util.operationFactory.createBoundAggregate(expressionVariable, 'count', this.util.operationFactory.createTermExpression(object), false);\n        const countProject = this.util.operationFactory.createProject(this.util.operationFactory.createExtend(this.util.operationFactory.createGroup(operation, [], [aggregator]), countOverVariable, this.util.operationFactory.createTermExpression(expressionVariable)), [countOverVariable]);\n        convertContext.terminalVariables.push(countOverVariable); // If no other selections exist (next to totalCount),\n        // then we just return the count operations as-is,\n        // otherwise, we join the count operation with all other selections\n\n        if (!selections.length) {\n          joinedOperation = countProject;\n        } else {\n          joinedOperation = this.util.operationFactory.createJoin(this.util.operationFactory.createProject(joinedOperation, []), countProject);\n        }\n      }\n\n      operation = joinedOperation;\n    } else if (pushTerminalVariables && object.termType === 'Variable') {\n      // If no nested selection sets exist,\n      // consider the object variable as a terminal variable that should be selected.\n      convertContext.terminalVariables.push(object);\n    } // Wrap the operation in a slice if a 'first' or 'offset' argument was provided.\n\n\n    if (offset || limit) {\n      operation = this.util.operationFactory.createSlice(this.util.operationFactory.createProject(operation, sparqlalgebrajs_1.Util.inScopeVariables(operation)), offset, limit);\n    } // Override operation if needed\n\n\n    return this.handleDirectiveOutputs(directiveOutputs, operation);\n  }\n  /**\n   * Check if the given node is a meta field, for things like introspection.\n   * If so, return a new operation for this, otherwise, null is returned.\n   * @param {IConvertContext} convertContext A convert context.\n   * @param {Term} subject The subject.\n   * @param {string} fieldLabel The field label to convert.\n   * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.\n   * @return {Operation} An operation or null.\n   */\n\n\n  handleMetaField(convertContext, fieldLabel, auxiliaryPatterns) {\n    // TODO: in the future, we should add support for GraphQL wide range of introspection features:\n    // http://graphql.org/learn/introspection/\n    if (fieldLabel === '__typename') {\n      const object = this.util.nameToVariable(fieldLabel, convertContext);\n      convertContext.terminalVariables.push(object);\n      return this.util.operationFactory.createBgp([this.util.operationFactory.createPattern(convertContext.subject, this.util.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), this.util.nameToVariable(fieldLabel, convertContext), convertContext.graph)].concat(auxiliaryPatterns || []));\n    }\n\n    return null;\n  }\n\n}\n\nexports.NodeHandlerSelectionAdapter = NodeHandlerSelectionAdapter;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/graphql-to-sparql/lib/handler/NodeHandlerSelectionAdapter.js"],"names":["Object","defineProperty","exports","value","NodeHandlerSelectionAdapter","sparqlalgebrajs_1","require","IConvertContext_1","NodeHandlerAdapter_1","NodeHandlerAdapter","constructor","targetKind","util","settings","getNodeQuadContextFieldNode","field","fieldLabel","convertContext","getNodeQuadContextSelectionSet","selectionSet","assign","path","appendFieldToPath","fieldToOperation","fieldNode","pushTerminalVariables","auxiliaryPatterns","nesting","offset","limit","name","arguments","argument","handleNodeValue","getFieldLabel","singularizeState","SingularizeState","SINGLE","singularizeVariables","nameToVariable","operationOverride","handleMetaField","operations","operationFactory","createBgp","subjectOutput","object","subject","graph","push","createQuadPattern","overrideObjectTerms","length","valueOutput","terms","map","term","context","Error","pathValue","kind","values","createQuadPath","parseInt","directiveOutputs","getDirectiveOutputs","directives","operation","joinOperations","selections","subConvertContext","totalCount","filter","selection","joinedOperation","concat","selectionNode","handleNode","expressionVariable","dataFactory","variable","expressionVariableCounter","countOverVariable","variableDelimiter","aggregator","createBoundAggregate","createTermExpression","countProject","createProject","createExtend","createGroup","terminalVariables","createJoin","termType","createSlice","Util","inScopeVariables","handleDirectiveOutputs","createPattern","namedNode"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NodeHandlerSelectionAdapter = void 0;\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\nconst IConvertContext_1 = require(\"../IConvertContext\");\nconst NodeHandlerAdapter_1 = require(\"./NodeHandlerAdapter\");\n/**\n * A handler for converting GraphQL selection nodes to operations.\n */\nclass NodeHandlerSelectionAdapter extends NodeHandlerAdapter_1.NodeHandlerAdapter {\n    constructor(targetKind, util, settings) {\n        super(targetKind, util, settings);\n    }\n    /**\n     * Get the quad context of a field node that should be used for the whole definition node.\n     * @param {FieldNode} field A field node.\n     * @param {string} fieldLabel A field label.\n     * @param {IConvertContext} convertContext A convert context.\n     * @return {INodeQuadContext | null} The subject and optional auxiliary patterns.\n     */\n    getNodeQuadContextFieldNode(field, fieldLabel, convertContext) {\n        return this.getNodeQuadContextSelectionSet(field.selectionSet, fieldLabel, Object.assign(Object.assign({}, convertContext), { path: this.util.appendFieldToPath(convertContext.path, fieldLabel) }));\n    }\n    /**\n     * Convert a field node to an operation.\n     * @param {IConvertContext} convertContext A convert context.\n     * @param {FieldNode} fieldNode The field node to convert.\n     * @param {boolean} pushTerminalVariables If terminal variables should be created.\n     * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.\n     * @return {Operation} The reslting operation.\n     */\n    fieldToOperation(convertContext, fieldNode, pushTerminalVariables, auxiliaryPatterns) {\n        // If a deeper node is being selected, and if the current object should become the next subject\n        const nesting = pushTerminalVariables;\n        // Offset and limit can be changed using the magic arguments 'first' and 'offset'.\n        let offset = 0;\n        let limit;\n        // Ignore 'id' and 'graph' fields, because we have processed them earlier in getNodeQuadContextSelectionSet.\n        if (fieldNode.name.value === 'id' || fieldNode.name.value === 'graph') {\n            pushTerminalVariables = false;\n            // Validate all _-arguments, because even though they were handled before,\n            // the validity of variables could not be checked,\n            // as variablesMetaDict wasn't populated at that time yet.\n            if (fieldNode.arguments) {\n                for (const argument of fieldNode.arguments) {\n                    if (argument.name.value === '_') {\n                        this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n                    }\n                }\n            }\n        }\n        // Determine the field label for variable naming, taking into account aliases\n        const fieldLabel = this.util.getFieldLabel(fieldNode);\n        // Handle the singular/plural scope\n        if (convertContext.singularizeState === IConvertContext_1.SingularizeState.SINGLE) {\n            convertContext.singularizeVariables[this.util.nameToVariable(fieldLabel, convertContext).value] = true;\n        }\n        // Handle meta fields\n        if (pushTerminalVariables) {\n            const operationOverride = this.handleMetaField(convertContext, fieldLabel, auxiliaryPatterns);\n            if (operationOverride) {\n                return operationOverride;\n            }\n        }\n        const operations = auxiliaryPatterns\n            ? [this.util.operationFactory.createBgp(auxiliaryPatterns)] : [];\n        // Define subject and object\n        const subjectOutput = this.getNodeQuadContextFieldNode(fieldNode, fieldLabel, convertContext);\n        let object = subjectOutput.subject || this.util.nameToVariable(fieldLabel, convertContext);\n        let graph = subjectOutput.graph || convertContext.graph;\n        if (subjectOutput.auxiliaryPatterns) {\n            operations.push(this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns));\n        }\n        // Check if there is a '_' argument\n        // We do this before handling all other arguments so that the order of final triple patterns is sane.\n        let createQuadPattern = true;\n        let overrideObjectTerms = null;\n        if (pushTerminalVariables && fieldNode.arguments && fieldNode.arguments.length) {\n            for (const argument of fieldNode.arguments) {\n                if (argument.name.value === '_') {\n                    // '_'-arguments do not create an additional predicate link, but set the value directly.\n                    const valueOutput = this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n                    overrideObjectTerms = valueOutput.terms;\n                    operations.push(this.util.operationFactory.createBgp(valueOutput.terms.map((term) => this.util.createQuadPattern(convertContext.subject, fieldNode.name, term, convertContext.graph, convertContext.context))));\n                    if (valueOutput.auxiliaryPatterns) {\n                        operations.push(this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns));\n                    }\n                    pushTerminalVariables = false;\n                    break;\n                }\n                else if (argument.name.value === 'graph') {\n                    // 'graph'-arguments do not create an additional predicate link, but set the graph.\n                    const valueOutput = this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n                    if (valueOutput.terms.length !== 1) {\n                        throw new Error(`Only single values can be set as graph, but got ${valueOutput.terms\n                            .length} at ${fieldNode.name.value}`);\n                    }\n                    graph = valueOutput.terms[0];\n                    convertContext = Object.assign(Object.assign({}, convertContext), { graph });\n                    if (valueOutput.auxiliaryPatterns) {\n                        operations.push(this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns));\n                    }\n                    break;\n                }\n                else if (argument.name.value === 'alt') {\n                    // 'alt'-arguments do not create an additional predicate link, but create alt-property paths.\n                    let pathValue = argument.value;\n                    if (pathValue.kind !== 'ListValue') {\n                        pathValue = { kind: 'ListValue', values: [pathValue] };\n                    }\n                    operations.push(this.util.createQuadPath(convertContext.subject, fieldNode.name, pathValue, object, convertContext.graph, convertContext.context));\n                    createQuadPattern = false;\n                    break;\n                }\n            }\n        }\n        // Create at least a pattern for the parent node and the current path.\n        if (pushTerminalVariables && createQuadPattern) {\n            operations.push(this.util.operationFactory.createBgp([\n                this.util.createQuadPattern(convertContext.subject, fieldNode.name, object, convertContext.graph, convertContext.context),\n            ]));\n        }\n        // Create patterns for the node's arguments\n        if (fieldNode.arguments && fieldNode.arguments.length) {\n            for (const argument of fieldNode.arguments) {\n                if (argument.name.value === '_' || argument.name.value === 'graph' || argument.name.value === 'alt') {\n                    // no-op\n                }\n                else if (argument.name.value === 'first') {\n                    if (argument.value.kind !== 'IntValue') {\n                        throw new Error('Invalid value type for \\'first\\' argument: ' + argument.value.kind);\n                    }\n                    limit = parseInt(argument.value.value, 10);\n                }\n                else if (argument.name.value === 'offset') {\n                    if (argument.value.kind !== 'IntValue') {\n                        throw new Error('Invalid value type for \\'offset\\' argument: ' + argument.value.kind);\n                    }\n                    offset = parseInt(argument.value.value, 10);\n                }\n                else {\n                    const valueOutput = this.util.handleNodeValue(argument.value, argument.name.value, convertContext);\n                    operations.push(this.util.operationFactory.createBgp(valueOutput.terms.map((term) => this.util.createQuadPattern(object, argument.name, term, convertContext.graph, convertContext.context))));\n                    if (valueOutput.auxiliaryPatterns) {\n                        operations.push(this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns));\n                    }\n                }\n            }\n        }\n        // Directives\n        const directiveOutputs = this.getDirectiveOutputs(fieldNode.directives, fieldLabel, convertContext);\n        if (!directiveOutputs) {\n            return this.util.operationFactory.createBgp([]);\n        }\n        // Recursive call for nested selection sets\n        let operation = this.util.joinOperations(operations);\n        if (fieldNode.selectionSet && fieldNode.selectionSet.selections.length) {\n            // Override the object if needed\n            if (overrideObjectTerms) {\n                if (overrideObjectTerms.length !== 1) {\n                    throw new Error(`Only single values can be set as id, but got ${overrideObjectTerms\n                        .length} at ${fieldNode.name.value}`);\n                }\n                object = overrideObjectTerms[0];\n            }\n            // Change path value when there was an alias on this node.\n            const subConvertContext = Object.assign(Object.assign(Object.assign({}, convertContext), nesting ? { path: this.util.appendFieldToPath(convertContext.path, fieldLabel) } : {}), { graph, subject: nesting ? object : convertContext.subject });\n            // If the magic keyword 'totalCount' is present, include a count aggregator.\n            let totalCount = false;\n            const selections = fieldNode.selectionSet.selections\n                .filter((selection) => {\n                if (selection.kind === 'Field' && selection.name.value === 'totalCount') {\n                    totalCount = true;\n                    return false;\n                }\n                return true;\n            });\n            let joinedOperation = this.util.joinOperations(operations\n                .concat(selections.map((selectionNode) => this.util.handleNode(selectionNode, subConvertContext))));\n            // Modify the operation if there was a count selection\n            if (totalCount) {\n                // Create to a count aggregation\n                const expressionVariable = this.util.dataFactory.variable('var' + this.settings.expressionVariableCounter++);\n                const countOverVariable = this.util.dataFactory\n                    .variable(object.value + this.settings.variableDelimiter + 'totalCount');\n                const aggregator = this.util.operationFactory.createBoundAggregate(expressionVariable, 'count', this.util.operationFactory.createTermExpression(object), false);\n                const countProject = this.util.operationFactory.createProject(this.util.operationFactory.createExtend(this.util.operationFactory.createGroup(operation, [], [aggregator]), countOverVariable, this.util.operationFactory.createTermExpression(expressionVariable)), [countOverVariable]);\n                convertContext.terminalVariables.push(countOverVariable);\n                // If no other selections exist (next to totalCount),\n                // then we just return the count operations as-is,\n                // otherwise, we join the count operation with all other selections\n                if (!selections.length) {\n                    joinedOperation = countProject;\n                }\n                else {\n                    joinedOperation = this.util.operationFactory.createJoin(this.util.operationFactory.createProject(joinedOperation, []), countProject);\n                }\n            }\n            operation = joinedOperation;\n        }\n        else if (pushTerminalVariables && object.termType === 'Variable') {\n            // If no nested selection sets exist,\n            // consider the object variable as a terminal variable that should be selected.\n            convertContext.terminalVariables.push(object);\n        }\n        // Wrap the operation in a slice if a 'first' or 'offset' argument was provided.\n        if (offset || limit) {\n            operation = this.util.operationFactory.createSlice(this.util.operationFactory.createProject(operation, sparqlalgebrajs_1.Util.inScopeVariables(operation)), offset, limit);\n        }\n        // Override operation if needed\n        return this.handleDirectiveOutputs(directiveOutputs, operation);\n    }\n    /**\n     * Check if the given node is a meta field, for things like introspection.\n     * If so, return a new operation for this, otherwise, null is returned.\n     * @param {IConvertContext} convertContext A convert context.\n     * @param {Term} subject The subject.\n     * @param {string} fieldLabel The field label to convert.\n     * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.\n     * @return {Operation} An operation or null.\n     */\n    handleMetaField(convertContext, fieldLabel, auxiliaryPatterns) {\n        // TODO: in the future, we should add support for GraphQL wide range of introspection features:\n        // http://graphql.org/learn/introspection/\n        if (fieldLabel === '__typename') {\n            const object = this.util.nameToVariable(fieldLabel, convertContext);\n            convertContext.terminalVariables.push(object);\n            return this.util.operationFactory.createBgp([\n                this.util.operationFactory.createPattern(convertContext.subject, this.util.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), this.util.nameToVariable(fieldLabel, convertContext), convertContext.graph),\n            ].concat(auxiliaryPatterns || []));\n        }\n        return null;\n    }\n}\nexports.NodeHandlerSelectionAdapter = NodeHandlerSelectionAdapter;\n//# sourceMappingURL=NodeHandlerSelectionAdapter.js.map"]},"metadata":{},"sourceType":"script"}