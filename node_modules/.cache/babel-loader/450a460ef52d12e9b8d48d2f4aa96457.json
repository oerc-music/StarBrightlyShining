{"ast":null,"code":"// **N3Parser** parses N3 documents.\nimport N3Lexer from './N3Lexer';\nimport N3DataFactory from './N3DataFactory';\nimport namespaces from './IRIs';\nlet blankNodePrefix = 0; // ## Constructor\n\nexport default class N3Parser {\n  constructor(options) {\n    this._contextStack = [];\n    this._graph = null; // Set the document IRI\n\n    options = options || {};\n\n    this._setBase(options.baseIRI);\n\n    options.factory && initDataFactory(this, options.factory); // Set supported features depending on the format\n\n    const format = typeof options.format === 'string' ? options.format.match(/\\w*$/)[0].toLowerCase() : '',\n          isTurtle = /turtle/.test(format),\n          isTriG = /trig/.test(format),\n          isNTriples = /triple/.test(format),\n          isNQuads = /quad/.test(format),\n          isN3 = this._n3Mode = /n3/.test(format),\n          isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3))) this._readPredicateOrNamedGraph = this._readPredicate; // Support triples in other graphs\n\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3); // Support nesting of triples\n\n    this._supportsRDFStar = format === '' || /star|\\*$/.test(format); // Disable relative IRIs in N-Triples or N-Quads mode\n\n    if (isLineMode) this._resolveRelativeIRI = iri => {\n      return null;\n    };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' : options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer({\n      lineMode: isLineMode,\n      n3: isN3\n    }); // Disable explicit quantifiers by default\n\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  } // ## Static class methods\n  // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n\n\n  static _resetBlankNodePrefix() {\n    blankNodePrefix = 0;\n  } // ## Private methods\n  // ### `_setBase` sets the base IRI to resolve relative IRIs\n\n\n  _setBase(baseIRI) {\n    if (!baseIRI) {\n      this._base = '';\n      this._basePath = '';\n    } else {\n      // Remove fragment if present\n      const fragmentPos = baseIRI.indexOf('#');\n      if (fragmentPos >= 0) baseIRI = baseIRI.substr(0, fragmentPos); // Set base IRI and its components\n\n      this._base = baseIRI;\n      this._basePath = baseIRI.indexOf('/') < 0 ? baseIRI : baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n      baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n      this._baseRoot = baseIRI[0];\n      this._baseScheme = baseIRI[1];\n    }\n  } // ### `_saveContext` stores the current parsing context\n  // when entering a new scope (list, blank node, formula)\n\n\n  _saveContext(type, graph, subject, predicate, object) {\n    const n3Mode = this._n3Mode;\n\n    this._contextStack.push({\n      subject: subject,\n      predicate: predicate,\n      object: object,\n      graph: graph,\n      type: type,\n      inverse: n3Mode ? this._inversePredicate : false,\n      blankPrefix: n3Mode ? this._prefixes._ : '',\n      quantified: n3Mode ? this._quantified : null\n    }); // The settings below only apply to N3 streams\n\n\n    if (n3Mode) {\n      // Every new scope resets the predicate direction\n      this._inversePredicate = false; // In N3, blank nodes are scoped to a formula\n      // (using a dot as separator, as a blank node label cannot start with it)\n\n      this._prefixes._ = this._graph ? `${this._graph.id.substr(2)}.` : '.'; // Quantifiers are scoped to a formula\n\n      this._quantified = Object.create(this._quantified);\n    }\n  } // ### `_restoreContext` restores the parent context\n  // when leaving a scope (list, blank node, formula)\n\n\n  _restoreContext() {\n    const context = this._contextStack.pop(),\n          n3Mode = this._n3Mode;\n\n    this._subject = context.subject;\n    this._predicate = context.predicate;\n    this._object = context.object;\n    this._graph = context.graph; // The settings below only apply to N3 streams\n\n    if (n3Mode) {\n      this._inversePredicate = context.inverse;\n      this._prefixes._ = context.blankPrefix;\n      this._quantified = context.quantified;\n    }\n  } // ### `_readInTopContext` reads a token when in the top context\n\n\n  _readInTopContext(token) {\n    switch (token.type) {\n      // If an EOF token arrives in the top context, signal that we're done\n      case 'eof':\n        if (this._graph !== null) return this._error('Unclosed graph', token);\n        delete this._prefixes._;\n        return this._callback(null, null, this._prefixes);\n      // It could be a prefix declaration\n\n      case 'PREFIX':\n        this._sparqlStyle = true;\n\n      case '@prefix':\n        return this._readPrefix;\n      // It could be a base declaration\n\n      case 'BASE':\n        this._sparqlStyle = true;\n\n      case '@base':\n        return this._readBaseIRI;\n      // It could be a graph\n\n      case '{':\n        if (this._supportsNamedGraphs) {\n          this._graph = '';\n          this._subject = null;\n          return this._readSubject;\n        }\n\n      case 'GRAPH':\n        if (this._supportsNamedGraphs) return this._readNamedGraphLabel;\n      // Otherwise, the next token must be a subject\n\n      default:\n        return this._readSubject(token);\n    }\n  } // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n\n\n  _readEntity(token, quantifier) {\n    let value;\n\n    switch (token.type) {\n      // Read a relative or absolute IRI\n      case 'IRI':\n      case 'typeIRI':\n        const iri = this._resolveIRI(token.value);\n\n        if (iri === null) return this._error('Invalid IRI', token);\n        value = this._namedNode(iri);\n        break;\n      // Read a prefixed name\n\n      case 'type':\n      case 'prefixed':\n        const prefix = this._prefixes[token.prefix];\n        if (prefix === undefined) return this._error(`Undefined prefix \"${token.prefix}:\"`, token);\n        value = this._namedNode(prefix + token.value);\n        break;\n      // Read a blank node\n\n      case 'blank':\n        value = this._blankNode(this._prefixes[token.prefix] + token.value);\n        break;\n      // Read a variable\n\n      case 'var':\n        value = this._variable(token.value.substr(1));\n        break;\n      // Everything else is not an entity\n\n      default:\n        return this._error(`Expected entity but got ${token.type}`, token);\n    } // In N3 mode, replace the entity if it is quantified\n\n\n    if (!quantifier && this._n3Mode && value.id in this._quantified) value = this._quantified[value.id];\n    return value;\n  } // ### `_readSubject` reads a quad's subject\n\n\n  _readSubject(token) {\n    this._predicate = null;\n\n    switch (token.type) {\n      case '[':\n        // Start a new quad with a new blank node as subject\n        this._saveContext('blank', this._graph, this._subject = this._blankNode(), null, null);\n\n        return this._readBlankNodeHead;\n\n      case '(':\n        // Start a new list\n        this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n\n        this._subject = null;\n        return this._readListItem;\n\n      case '{':\n        // Start a new formula\n        if (!this._n3Mode) return this._error('Unexpected graph', token);\n\n        this._saveContext('formula', this._graph, this._graph = this._blankNode(), null, null);\n\n        return this._readSubject;\n\n      case '}':\n        // No subject; the graph in which we are reading is closed instead\n        return this._readPunctuation(token);\n\n      case '@forSome':\n        if (!this._n3Mode) return this._error('Unexpected \"@forSome\"', token);\n        this._subject = null;\n        this._predicate = this.N3_FORSOME;\n        this._quantifier = this._blankNode;\n        return this._readQuantifierList;\n\n      case '@forAll':\n        if (!this._n3Mode) return this._error('Unexpected \"@forAll\"', token);\n        this._subject = null;\n        this._predicate = this.N3_FORALL;\n        this._quantifier = this._variable;\n        return this._readQuantifierList;\n\n      case 'literal':\n        if (!this._n3Mode) return this._error('Unexpected literal', token);\n\n        if (token.prefix.length === 0) {\n          this._literalValue = token.value;\n          return this._completeSubjectLiteral;\n        } else this._subject = this._literal(token.value, this._namedNode(token.prefix));\n\n        break;\n\n      case '<<':\n        if (!this._supportsRDFStar) return this._error('Unexpected RDF* syntax', token);\n\n        this._saveContext('<<', this._graph, null, null, null);\n\n        this._graph = null;\n        return this._readSubject;\n\n      default:\n        // Read the subject entity\n        if ((this._subject = this._readEntity(token)) === undefined) return; // In N3 mode, the subject might be a path\n\n        if (this._n3Mode) return this._getPathReader(this._readPredicateOrNamedGraph);\n    } // The next token must be a predicate,\n    // or, if the subject was actually a graph IRI, a named graph\n\n\n    return this._readPredicateOrNamedGraph;\n  } // ### `_readPredicate` reads a quad's predicate\n\n\n  _readPredicate(token) {\n    const type = token.type;\n\n    switch (type) {\n      case 'inverse':\n        this._inversePredicate = true;\n\n      case 'abbreviation':\n        this._predicate = this.ABBREVIATIONS[token.value];\n        break;\n\n      case '.':\n      case ']':\n      case '}':\n        // Expected predicate didn't come, must have been trailing semicolon\n        if (this._predicate === null) return this._error(`Unexpected ${type}`, token);\n        this._subject = null;\n        return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n\n      case ';':\n        // Additional semicolons can be safely ignored\n        return this._predicate !== null ? this._readPredicate : this._error('Expected predicate but got ;', token);\n\n      case 'blank':\n        if (!this._n3Mode) return this._error('Disallowed blank node as predicate', token);\n\n      default:\n        if ((this._predicate = this._readEntity(token)) === undefined) return;\n    } // The next token must be an object\n\n\n    return this._readObject;\n  } // ### `_readObject` reads a quad's object\n\n\n  _readObject(token) {\n    switch (token.type) {\n      case 'literal':\n        // Regular literal, can still get a datatype or language\n        if (token.prefix.length === 0) {\n          this._literalValue = token.value;\n          return this._readDataTypeOrLang;\n        } // Pre-datatyped string literal (prefix stores the datatype)\n        else this._object = this._literal(token.value, this._namedNode(token.prefix));\n\n        break;\n\n      case '[':\n        // Start a new quad with a new blank node as subject\n        this._saveContext('blank', this._graph, this._subject, this._predicate, this._subject = this._blankNode());\n\n        return this._readBlankNodeHead;\n\n      case '(':\n        // Start a new list\n        this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n\n        this._subject = null;\n        return this._readListItem;\n\n      case '{':\n        // Start a new formula\n        if (!this._n3Mode) return this._error('Unexpected graph', token);\n\n        this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());\n\n        return this._readSubject;\n\n      case '<<':\n        if (!this._supportsRDFStar) return this._error('Unexpected RDF* syntax', token);\n\n        this._saveContext('<<', this._graph, this._subject, this._predicate, null);\n\n        this._graph = null;\n        return this._readSubject;\n\n      default:\n        // Read the object entity\n        if ((this._object = this._readEntity(token)) === undefined) return; // In N3 mode, the object might be a path\n\n        if (this._n3Mode) return this._getPathReader(this._getContextEndReader());\n    }\n\n    return this._getContextEndReader();\n  } // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n\n\n  _readPredicateOrNamedGraph(token) {\n    return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n  } // ### `_readGraph` reads a graph\n\n\n  _readGraph(token) {\n    if (token.type !== '{') return this._error(`Expected graph but got ${token.type}`, token); // The \"subject\" we read is actually the GRAPH's label\n\n    this._graph = this._subject, this._subject = null;\n    return this._readSubject;\n  } // ### `_readBlankNodeHead` reads the head of a blank node\n\n\n  _readBlankNodeHead(token) {\n    if (token.type === ']') {\n      this._subject = null;\n      return this._readBlankNodeTail(token);\n    } else {\n      this._predicate = null;\n      return this._readPredicate(token);\n    }\n  } // ### `_readBlankNodeTail` reads the end of a blank node\n\n\n  _readBlankNodeTail(token) {\n    if (token.type !== ']') return this._readBlankNodePunctuation(token); // Store blank node quad\n\n    if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph); // Restore the parent context containing this blank node\n\n    const empty = this._predicate === null;\n\n    this._restoreContext(); // If the blank node was the subject, continue reading the predicate\n\n\n    if (this._object === null) // If the blank node was empty, it could be a named graph label\n      return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank; // If the blank node was the object, restore previous context and read punctuation\n    else return this._getContextEndReader();\n  } // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n\n\n  _readPredicateAfterBlank(token) {\n    switch (token.type) {\n      case '.':\n      case '}':\n        // No predicate is coming if the triple is terminated here\n        this._subject = null;\n        return this._readPunctuation(token);\n\n      default:\n        return this._readPredicate(token);\n    }\n  } // ### `_readListItem` reads items from a list\n\n\n  _readListItem(token) {\n    let item = null,\n        // The item of the list\n    list = null,\n        // The list itself\n    next = this._readListItem; // The next function to execute\n\n    const previousList = this._subject,\n          // The previous list that contains this list\n    stack = this._contextStack,\n          // The stack of parent contexts\n    parent = stack[stack.length - 1]; // The parent containing the current list\n\n    switch (token.type) {\n      case '[':\n        // Stack the current list quad and start a new quad with a blank node as subject\n        this._saveContext('blank', this._graph, list = this._blankNode(), this.RDF_FIRST, this._subject = item = this._blankNode());\n\n        next = this._readBlankNodeHead;\n        break;\n\n      case '(':\n        // Stack the current list quad and start a new list\n        this._saveContext('list', this._graph, list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);\n\n        this._subject = null;\n        break;\n\n      case ')':\n        // Closing the list; restore the parent context\n        this._restoreContext(); // If this list is contained within a parent list, return the membership quad here.\n        // This will be `<parent list element> rdf:first <this list>.`.\n\n\n        if (stack.length !== 0 && stack[stack.length - 1].type === 'list') this._emit(this._subject, this._predicate, this._object, this._graph); // Was this list the parent's subject?\n\n        if (this._predicate === null) {\n          // The next token is the predicate\n          next = this._readPredicate; // No list tail if this was an empty list\n\n          if (this._subject === this.RDF_NIL) return next;\n        } // The list was in the parent context's object\n        else {\n          next = this._getContextEndReader(); // No list tail if this was an empty list\n\n          if (this._object === this.RDF_NIL) return next;\n        } // Close the list by making the head nil\n\n\n        list = this.RDF_NIL;\n        break;\n\n      case 'literal':\n        // Regular literal, can still get a datatype or language\n        if (token.prefix.length === 0) {\n          this._literalValue = token.value;\n          next = this._readListItemDataTypeOrLang;\n        } // Pre-datatyped string literal (prefix stores the datatype)\n        else {\n          item = this._literal(token.value, this._namedNode(token.prefix));\n          next = this._getContextEndReader();\n        }\n\n        break;\n\n      case '{':\n        // Start a new formula\n        if (!this._n3Mode) return this._error('Unexpected graph', token);\n\n        this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());\n\n        return this._readSubject;\n\n      default:\n        if ((item = this._readEntity(token)) === undefined) return;\n    } // Create a new blank node if no item head was assigned yet\n\n\n    if (list === null) this._subject = list = this._blankNode(); // Is this the first element of the list?\n\n    if (previousList === null) {\n      // This list is either the subject or the object of its parent\n      if (parent.predicate === null) parent.subject = list;else parent.object = list;\n    } else {\n      // Continue the previous list with the current list\n      this._emit(previousList, this.RDF_REST, list, this._graph);\n    } // If an item was read, add it to the list\n\n\n    if (item !== null) {\n      // In N3 mode, the item might be a path\n      if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n        // Create a new context to add the item's path\n        this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n\n        this._subject = item, this._predicate = null; // _readPath will restore the context and output the item\n\n        return this._getPathReader(this._readListItem);\n      } // Output the item\n\n\n      this._emit(list, this.RDF_FIRST, item, this._graph);\n    }\n\n    return next;\n  } // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n\n\n  _readDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, false);\n  } // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n\n\n  _readListItemDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, true);\n  } // ### `_completeLiteral` completes a literal with an optional datatype or language\n\n\n  _completeLiteral(token) {\n    // Create a simple string literal by default\n    let literal = this._literal(this._literalValue);\n\n    switch (token.type) {\n      // Create a datatyped literal\n      case 'type':\n      case 'typeIRI':\n        const datatype = this._readEntity(token);\n\n        if (datatype === undefined) return; // No datatype means an error occurred\n\n        literal = this._literal(this._literalValue, datatype);\n        token = null;\n        break;\n      // Create a language-tagged string\n\n      case 'langcode':\n        literal = this._literal(this._literalValue, token.value);\n        token = null;\n        break;\n    }\n\n    return {\n      token,\n      literal\n    };\n  } // Completes a literal in subject position\n\n\n  _completeSubjectLiteral(token) {\n    this._subject = this._completeLiteral(token).literal;\n    return this._readPredicateOrNamedGraph;\n  } // Completes a literal in object position\n\n\n  _completeObjectLiteral(token, listItem) {\n    const completed = this._completeLiteral(token);\n\n    if (!completed) return;\n    this._object = completed.literal; // If this literal was part of a list, write the item\n    // (we could also check the context stack, but passing in a flag is faster)\n\n    if (listItem) this._emit(this._subject, this.RDF_FIRST, this._object, this._graph); // If the token was consumed, continue with the rest of the input\n\n    if (completed.token === null) return this._getContextEndReader(); // Otherwise, consume the token now\n    else {\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(completed.token);\n    }\n  } // ### `_readFormulaTail` reads the end of a formula\n\n\n  _readFormulaTail(token) {\n    if (token.type !== '}') return this._readPunctuation(token); // Store the last quad of the formula\n\n    if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph); // Restore the parent context containing this formula\n\n    this._restoreContext(); // If the formula was the subject, continue reading the predicate.\n    // If the formula was the object, read punctuation.\n\n\n    return this._object === null ? this._readPredicate : this._getContextEndReader();\n  } // ### `_readPunctuation` reads punctuation between quads or quad parts\n\n\n  _readPunctuation(token) {\n    let next,\n        graph = this._graph;\n    const subject = this._subject,\n          inversePredicate = this._inversePredicate;\n\n    switch (token.type) {\n      // A closing brace ends a graph\n      case '}':\n        if (this._graph === null) return this._error('Unexpected graph closing', token);\n        if (this._n3Mode) return this._readFormulaTail(token);\n        this._graph = null;\n      // A dot just ends the statement, without sharing anything with the next\n\n      case '.':\n        this._subject = null;\n        next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n        if (inversePredicate) this._inversePredicate = false;\n        break;\n      // Semicolon means the subject is shared; predicate and object are different\n\n      case ';':\n        next = this._readPredicate;\n        break;\n      // Comma means both the subject and predicate are shared; the object is different\n\n      case ',':\n        next = this._readObject;\n        break;\n\n      default:\n        // An entity means this is a quad (only allowed if not already inside a graph)\n        if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n          next = this._readQuadPunctuation;\n          break;\n        }\n\n        return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    } // A quad has been completed now, so return it\n\n\n    if (subject !== null) {\n      const predicate = this._predicate,\n            object = this._object;\n      if (!inversePredicate) this._emit(subject, predicate, object, graph);else this._emit(object, predicate, subject, graph);\n    }\n\n    return next;\n  } // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n\n\n  _readBlankNodePunctuation(token) {\n    let next;\n\n    switch (token.type) {\n      // Semicolon means the subject is shared; predicate and object are different\n      case ';':\n        next = this._readPredicate;\n        break;\n      // Comma means both the subject and predicate are shared; the object is different\n\n      case ',':\n        next = this._readObject;\n        break;\n\n      default:\n        return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    } // A quad has been completed now, so return it\n\n\n    this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    return next;\n  } // ### `_readQuadPunctuation` reads punctuation after a quad\n\n\n  _readQuadPunctuation(token) {\n    if (token.type !== '.') return this._error('Expected dot to follow quad', token);\n    return this._readInTopContext;\n  } // ### `_readPrefix` reads the prefix of a prefix declaration\n\n\n  _readPrefix(token) {\n    if (token.type !== 'prefix') return this._error('Expected prefix to follow @prefix', token);\n    this._prefix = token.value;\n    return this._readPrefixIRI;\n  } // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n\n\n  _readPrefixIRI(token) {\n    if (token.type !== 'IRI') return this._error(`Expected IRI to follow prefix \"${this._prefix}:\"`, token);\n\n    const prefixNode = this._readEntity(token);\n\n    this._prefixes[this._prefix] = prefixNode.value;\n\n    this._prefixCallback(this._prefix, prefixNode);\n\n    return this._readDeclarationPunctuation;\n  } // ### `_readBaseIRI` reads the IRI of a base declaration\n\n\n  _readBaseIRI(token) {\n    const iri = token.type === 'IRI' && this._resolveIRI(token.value);\n\n    if (!iri) return this._error('Expected valid IRI to follow base declaration', token);\n\n    this._setBase(iri);\n\n    return this._readDeclarationPunctuation;\n  } // ### `_readNamedGraphLabel` reads the label of a named graph\n\n\n  _readNamedGraphLabel(token) {\n    switch (token.type) {\n      case 'IRI':\n      case 'blank':\n      case 'prefixed':\n        return this._readSubject(token), this._readGraph;\n\n      case '[':\n        return this._readNamedGraphBlankLabel;\n\n      default:\n        return this._error('Invalid graph label', token);\n    }\n  } // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n\n\n  _readNamedGraphBlankLabel(token) {\n    if (token.type !== ']') return this._error('Invalid graph label', token);\n    this._subject = this._blankNode();\n    return this._readGraph;\n  } // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n\n\n  _readDeclarationPunctuation(token) {\n    // SPARQL-style declarations don't have punctuation\n    if (this._sparqlStyle) {\n      this._sparqlStyle = false;\n      return this._readInTopContext(token);\n    }\n\n    if (token.type !== '.') return this._error('Expected declaration to end with a dot', token);\n    return this._readInTopContext;\n  } // Reads a list of quantified symbols from a @forSome or @forAll statement\n\n\n  _readQuantifierList(token) {\n    let entity;\n\n    switch (token.type) {\n      case 'IRI':\n      case 'prefixed':\n        if ((entity = this._readEntity(token, true)) !== undefined) break;\n\n      default:\n        return this._error(`Unexpected ${token.type}`, token);\n    } // Without explicit quantifiers, map entities to a quantified entity\n\n\n    if (!this._explicitQuantifiers) this._quantified[entity.id] = this._quantifier(this._blankNode().value); // With explicit quantifiers, output the reified quantifier\n    else {\n      // If this is the first item, start a new quantifier list\n      if (this._subject === null) this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH); // Otherwise, continue the previous list\n      else this._emit(this._subject, this.RDF_REST, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH); // Output the list item\n\n      this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n    }\n    return this._readQuantifierPunctuation;\n  } // Reads punctuation from a @forSome or @forAll statement\n\n\n  _readQuantifierPunctuation(token) {\n    // Read more quantifiers\n    if (token.type === ',') return this._readQuantifierList; // End of the quantifier list\n    else {\n      // With explicit quantifiers, close the quantifier list\n      if (this._explicitQuantifiers) {\n        this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n\n        this._subject = null;\n      } // Read a dot\n\n\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(token);\n    }\n  } // ### `_getPathReader` reads a potential path and then resumes with the given function\n\n\n  _getPathReader(afterPath) {\n    this._afterPath = afterPath;\n    return this._readPath;\n  } // ### `_readPath` reads a potential path\n\n\n  _readPath(token) {\n    switch (token.type) {\n      // Forward path\n      case '!':\n        return this._readForwardPath;\n      // Backward path\n\n      case '^':\n        return this._readBackwardPath;\n      // Not a path; resume reading where we left off\n\n      default:\n        const stack = this._contextStack,\n              parent = stack.length && stack[stack.length - 1]; // If we were reading a list item, we still need to output it\n\n        if (parent && parent.type === 'item') {\n          // The list item is the remaining subejct after reading the path\n          const item = this._subject; // Switch back to the context of the list\n\n          this._restoreContext(); // Output the list item\n\n\n          this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n        }\n\n        return this._afterPath(token);\n    }\n  } // ### `_readForwardPath` reads a '!' path\n\n\n  _readForwardPath(token) {\n    let subject, predicate;\n\n    const object = this._blankNode(); // The next token is the predicate\n\n\n    if ((predicate = this._readEntity(token)) === undefined) return; // If we were reading a subject, replace the subject by the path's object\n\n    if (this._predicate === null) subject = this._subject, this._subject = object; // If we were reading an object, replace the subject by the path's object\n    else subject = this._object, this._object = object; // Emit the path's current quad and read its next section\n\n    this._emit(subject, predicate, object, this._graph);\n\n    return this._readPath;\n  } // ### `_readBackwardPath` reads a '^' path\n\n\n  _readBackwardPath(token) {\n    const subject = this._blankNode();\n\n    let predicate, object; // The next token is the predicate\n\n    if ((predicate = this._readEntity(token)) === undefined) return; // If we were reading a subject, replace the subject by the path's subject\n\n    if (this._predicate === null) object = this._subject, this._subject = subject; // If we were reading an object, replace the subject by the path's subject\n    else object = this._object, this._object = subject; // Emit the path's current quad and read its next section\n\n    this._emit(subject, predicate, object, this._graph);\n\n    return this._readPath;\n  } // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple\n\n\n  _readRDFStarTailOrGraph(token) {\n    if (token.type !== '>>') {\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined) return this._readRDFStarTail;\n      return this._error(`Expected >> to follow \"${this._object.id}\"`, token);\n    }\n\n    return this._readRDFStarTail(token);\n  } // ### `_readRDFStarTail` reads the end of a nested RDF* triple\n\n\n  _readRDFStarTail(token) {\n    if (token.type !== '>>') return this._error(`Expected >> but got ${token.type}`, token); // Read the quad and restore the previous context\n\n    const quad = this._quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);\n\n    this._restoreContext(); // If the triple was the subject, continue by reading the predicate.\n\n\n    if (this._subject === null) {\n      this._subject = quad;\n      return this._readPredicate;\n    } // If the triple was the object, read context end.\n    else {\n      this._object = quad;\n      return this._getContextEndReader();\n    }\n  } // ### `_getContextEndReader` gets the next reader function at the end of a context\n\n\n  _getContextEndReader() {\n    const contextStack = this._contextStack;\n    if (!contextStack.length) return this._readPunctuation;\n\n    switch (contextStack[contextStack.length - 1].type) {\n      case 'blank':\n        return this._readBlankNodeTail;\n\n      case 'list':\n        return this._readListItem;\n\n      case 'formula':\n        return this._readFormulaTail;\n\n      case '<<':\n        return this._readRDFStarTailOrGraph;\n    }\n  } // ### `_emit` sends a quad through the callback\n\n\n  _emit(subject, predicate, object, graph) {\n    this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n  } // ### `_error` emits an error message through the callback\n\n\n  _error(message, token) {\n    const err = new Error(`${message} on line ${token.line}.`);\n    err.context = {\n      token: token,\n      line: token.line,\n      previousToken: this._lexer.previousToken\n    };\n\n    this._callback(err);\n\n    this._callback = noop;\n  } // ### `_resolveIRI` resolves an IRI against the base path\n\n\n  _resolveIRI(iri) {\n    return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n  } // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative\n\n\n  _resolveRelativeIRI(iri) {\n    // An empty relative IRI indicates the base IRI\n    if (!iri.length) return this._base; // Decide resolving strategy based in the first character\n\n    switch (iri[0]) {\n      // Resolve relative fragment IRIs against the base IRI\n      case '#':\n        return this._base + iri;\n      // Resolve relative query string IRIs by replacing the query string\n\n      case '?':\n        return this._base.replace(/(?:\\?.*)?$/, iri);\n      // Resolve root-relative IRIs at the root of the base IRI\n\n      case '/':\n        // Resolve scheme-relative IRIs to the scheme\n        return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n      // Resolve all other IRIs at the base IRI's path\n\n      default:\n        // Relative IRIs cannot contain a colon in the first path segment\n        return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);\n    }\n  } // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n\n\n  _removeDotSegments(iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri)) return iri; // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n\n    const length = iri.length;\n    let result = '',\n        i = -1,\n        pathStart = -1,\n        segmentStart = 0,\n        next = '/';\n\n    while (i < length) {\n      switch (next) {\n        // The path starts with the first slash after the authority\n        case ':':\n          if (pathStart < 0) {\n            // Skip two slashes before the authority\n            if (iri[++i] === '/' && iri[++i] === '/') // Skip to slash after the authority\n              while ((pathStart = i + 1) < length && iri[pathStart] !== '/') i = pathStart;\n          }\n\n          break;\n        // Don't modify a query string or fragment\n\n        case '?':\n        case '#':\n          i = length;\n          break;\n        // Handle '/.' or '/..' path segments\n\n        case '/':\n          if (iri[i + 1] === '.') {\n            next = iri[++i + 1];\n\n            switch (next) {\n              // Remove a '/.' segment\n              case '/':\n                result += iri.substring(segmentStart, i - 1);\n                segmentStart = i + 1;\n                break;\n              // Remove a trailing '/.' segment\n\n              case undefined:\n              case '?':\n              case '#':\n                return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n              // Remove a '/..' segment\n\n              case '.':\n                next = iri[++i + 1];\n\n                if (next === undefined || next === '/' || next === '?' || next === '#') {\n                  result += iri.substring(segmentStart, i - 2); // Try to remove the parent path from result\n\n                  if ((segmentStart = result.lastIndexOf('/')) >= pathStart) result = result.substr(0, segmentStart); // Remove a trailing '/..' segment\n\n                  if (next !== '/') return `${result}/${iri.substr(i + 1)}`;\n                  segmentStart = i + 1;\n                }\n\n            }\n          }\n\n      }\n\n      next = iri[++i];\n    }\n\n    return result + iri.substring(segmentStart);\n  } // ## Public methods\n  // ### `parse` parses the N3 input and emits each parsed quad through the callback\n\n\n  parse(input, quadCallback, prefixCallback) {\n    // The read callback is the next function to be executed when a token arrives.\n    // We start reading in the top context.\n    this._readCallback = this._readInTopContext;\n    this._sparqlStyle = false;\n    this._prefixes = Object.create(null);\n    this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${blankNodePrefix++}_`;\n    this._prefixCallback = prefixCallback || noop;\n    this._inversePredicate = false;\n    this._quantified = Object.create(null); // Parse synchronously if no quad callback is given\n\n    if (!quadCallback) {\n      const quads = [];\n      let error;\n\n      this._callback = (e, t) => {\n        e ? error = e : t && quads.push(t);\n      };\n\n      this._lexer.tokenize(input).every(token => {\n        return this._readCallback = this._readCallback(token);\n      });\n\n      if (error) throw error;\n      return quads;\n    } // Parse asynchronously otherwise, executing the read callback when a token arrives\n\n\n    this._callback = quadCallback;\n\n    this._lexer.tokenize(input, (error, token) => {\n      if (error !== null) this._callback(error), this._callback = noop;else if (this._readCallback) this._readCallback = this._readCallback(token);\n    });\n  }\n\n} // The empty function\n\nfunction noop() {} // Initializes the parser with the given data factory\n\n\nfunction initDataFactory(parser, factory) {\n  // Set factory methods\n  const namedNode = factory.namedNode;\n  parser._namedNode = namedNode;\n  parser._blankNode = factory.blankNode;\n  parser._literal = factory.literal;\n  parser._variable = factory.variable;\n  parser._quad = factory.quad;\n  parser.DEFAULTGRAPH = factory.defaultGraph(); // Set common named nodes\n\n  parser.RDF_FIRST = namedNode(namespaces.rdf.first);\n  parser.RDF_REST = namedNode(namespaces.rdf.rest);\n  parser.RDF_NIL = namedNode(namespaces.rdf.nil);\n  parser.N3_FORALL = namedNode(namespaces.r.forAll);\n  parser.N3_FORSOME = namedNode(namespaces.r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': namedNode(namespaces.rdf.type),\n    '=': namedNode(namespaces.owl.sameAs),\n    '>': namedNode(namespaces.log.implies)\n  };\n  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');\n}\n\ninitDataFactory(N3Parser.prototype, N3DataFactory);","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/n3/src/N3Parser.js"],"names":["N3Lexer","N3DataFactory","namespaces","blankNodePrefix","N3Parser","constructor","options","_contextStack","_graph","_setBase","baseIRI","factory","initDataFactory","format","match","toLowerCase","isTurtle","test","isTriG","isNTriples","isNQuads","isN3","_n3Mode","isLineMode","_supportsNamedGraphs","_readPredicateOrNamedGraph","_readPredicate","_supportsQuads","_supportsRDFStar","_resolveRelativeIRI","iri","_blankNodePrefix","replace","_lexer","lexer","lineMode","n3","_explicitQuantifiers","explicitQuantifiers","_resetBlankNodePrefix","_base","_basePath","fragmentPos","indexOf","substr","_baseRoot","_baseScheme","_saveContext","type","graph","subject","predicate","object","n3Mode","push","inverse","_inversePredicate","blankPrefix","_prefixes","_","quantified","_quantified","id","Object","create","_restoreContext","context","pop","_subject","_predicate","_object","_readInTopContext","token","_error","_callback","_sparqlStyle","_readPrefix","_readBaseIRI","_readSubject","_readNamedGraphLabel","_readEntity","quantifier","value","_resolveIRI","_namedNode","prefix","undefined","_blankNode","_variable","_readBlankNodeHead","RDF_NIL","_readListItem","_readPunctuation","N3_FORSOME","_quantifier","_readQuantifierList","N3_FORALL","length","_literalValue","_completeSubjectLiteral","_literal","_getPathReader","ABBREVIATIONS","_readBlankNodeTail","_readObject","_readDataTypeOrLang","_getContextEndReader","_readGraph","_readBlankNodePunctuation","_emit","empty","_readPredicateAfterBlank","item","list","next","previousList","stack","parent","RDF_FIRST","_readListItemDataTypeOrLang","RDF_REST","_completeObjectLiteral","_completeLiteral","literal","datatype","listItem","completed","_readCallback","_readFormulaTail","inversePredicate","_readQuadPunctuation","_prefix","_readPrefixIRI","prefixNode","_prefixCallback","_readDeclarationPunctuation","_readNamedGraphBlankLabel","entity","DEFAULTGRAPH","QUANTIFIERS_GRAPH","_readQuantifierPunctuation","afterPath","_afterPath","_readPath","_readForwardPath","_readBackwardPath","_readRDFStarTailOrGraph","_readRDFStarTail","quad","_quad","contextStack","message","err","Error","line","previousToken","noop","_removeDotSegments","result","i","pathStart","segmentStart","substring","lastIndexOf","parse","input","quadCallback","prefixCallback","quads","error","e","t","tokenize","every","parser","namedNode","blankNode","variable","defaultGraph","rdf","first","rest","nil","r","forAll","forSome","owl","sameAs","log","implies","prototype"],"mappings":"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","sourcesContent":["// **N3Parser** parses N3 documents.\nimport N3Lexer from './N3Lexer';\nimport N3DataFactory from './N3DataFactory';\nimport namespaces from './IRIs';\n\nlet blankNodePrefix = 0;\n\n// ## Constructor\nexport default class N3Parser {\n  constructor(options) {\n    this._contextStack = [];\n    this._graph = null;\n\n    // Set the document IRI\n    options = options || {};\n    this._setBase(options.baseIRI);\n    options.factory && initDataFactory(this, options.factory);\n\n    // Set supported features depending on the format\n    const format = (typeof options.format === 'string') ?\n                 options.format.match(/\\w*$/)[0].toLowerCase() : '',\n        isTurtle = /turtle/.test(format), isTriG = /trig/.test(format),\n        isNTriples = /triple/.test(format), isNQuads = /quad/.test(format),\n        isN3 = this._n3Mode = /n3/.test(format),\n        isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))\n      this._readPredicateOrNamedGraph = this._readPredicate;\n    // Support triples in other graphs\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);\n    // Support nesting of triples\n    this._supportsRDFStar = format === '' || /star|\\*$/.test(format);\n    // Disable relative IRIs in N-Triples or N-Quads mode\n    if (isLineMode)\n      this._resolveRelativeIRI = iri => { return null; };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' :\n                              options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode, n3: isN3 });\n    // Disable explicit quantifiers by default\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  }\n\n  // ## Static class methods\n\n  // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n  static _resetBlankNodePrefix() {\n    blankNodePrefix = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_setBase` sets the base IRI to resolve relative IRIs\n  _setBase(baseIRI) {\n    if (!baseIRI) {\n      this._base = '';\n      this._basePath = '';\n    }\n    else {\n      // Remove fragment if present\n      const fragmentPos = baseIRI.indexOf('#');\n      if (fragmentPos >= 0)\n        baseIRI = baseIRI.substr(0, fragmentPos);\n      // Set base IRI and its components\n      this._base = baseIRI;\n      this._basePath   = baseIRI.indexOf('/') < 0 ? baseIRI :\n                         baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n      baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n      this._baseRoot   = baseIRI[0];\n      this._baseScheme = baseIRI[1];\n    }\n  }\n\n  // ### `_saveContext` stores the current parsing context\n  // when entering a new scope (list, blank node, formula)\n  _saveContext(type, graph, subject, predicate, object) {\n    const n3Mode = this._n3Mode;\n    this._contextStack.push({\n      subject: subject, predicate: predicate, object: object,\n      graph: graph, type: type,\n      inverse: n3Mode ? this._inversePredicate : false,\n      blankPrefix: n3Mode ? this._prefixes._ : '',\n      quantified: n3Mode ? this._quantified : null,\n    });\n    // The settings below only apply to N3 streams\n    if (n3Mode) {\n      // Every new scope resets the predicate direction\n      this._inversePredicate = false;\n      // In N3, blank nodes are scoped to a formula\n      // (using a dot as separator, as a blank node label cannot start with it)\n      this._prefixes._ = (this._graph ? `${this._graph.id.substr(2)}.` : '.');\n      // Quantifiers are scoped to a formula\n      this._quantified = Object.create(this._quantified);\n    }\n  }\n\n  // ### `_restoreContext` restores the parent context\n  // when leaving a scope (list, blank node, formula)\n  _restoreContext() {\n    const context = this._contextStack.pop(), n3Mode = this._n3Mode;\n    this._subject   = context.subject;\n    this._predicate = context.predicate;\n    this._object    = context.object;\n    this._graph     = context.graph;\n    // The settings below only apply to N3 streams\n    if (n3Mode) {\n      this._inversePredicate = context.inverse;\n      this._prefixes._ = context.blankPrefix;\n      this._quantified = context.quantified;\n    }\n  }\n\n  // ### `_readInTopContext` reads a token when in the top context\n  _readInTopContext(token) {\n    switch (token.type) {\n    // If an EOF token arrives in the top context, signal that we're done\n    case 'eof':\n      if (this._graph !== null)\n        return this._error('Unclosed graph', token);\n      delete this._prefixes._;\n      return this._callback(null, null, this._prefixes);\n    // It could be a prefix declaration\n    case 'PREFIX':\n      this._sparqlStyle = true;\n    case '@prefix':\n      return this._readPrefix;\n    // It could be a base declaration\n    case 'BASE':\n      this._sparqlStyle = true;\n    case '@base':\n      return this._readBaseIRI;\n    // It could be a graph\n    case '{':\n      if (this._supportsNamedGraphs) {\n        this._graph = '';\n        this._subject = null;\n        return this._readSubject;\n      }\n    case 'GRAPH':\n      if (this._supportsNamedGraphs)\n        return this._readNamedGraphLabel;\n    // Otherwise, the next token must be a subject\n    default:\n      return this._readSubject(token);\n    }\n  }\n\n  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n  _readEntity(token, quantifier) {\n    let value;\n    switch (token.type) {\n    // Read a relative or absolute IRI\n    case 'IRI':\n    case 'typeIRI':\n      const iri = this._resolveIRI(token.value);\n      if (iri === null)\n        return this._error('Invalid IRI', token);\n      value = this._namedNode(iri);\n      break;\n    // Read a prefixed name\n    case 'type':\n    case 'prefixed':\n      const prefix = this._prefixes[token.prefix];\n      if (prefix === undefined)\n        return this._error(`Undefined prefix \"${token.prefix}:\"`, token);\n      value = this._namedNode(prefix + token.value);\n      break;\n    // Read a blank node\n    case 'blank':\n      value = this._blankNode(this._prefixes[token.prefix] + token.value);\n      break;\n    // Read a variable\n    case 'var':\n      value = this._variable(token.value.substr(1));\n      break;\n    // Everything else is not an entity\n    default:\n      return this._error(`Expected entity but got ${token.type}`, token);\n    }\n    // In N3 mode, replace the entity if it is quantified\n    if (!quantifier && this._n3Mode && (value.id in this._quantified))\n      value = this._quantified[value.id];\n    return value;\n  }\n\n  // ### `_readSubject` reads a quad's subject\n  _readSubject(token) {\n    this._predicate = null;\n    switch (token.type) {\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph,\n                        this._subject = this._blankNode(), null, null);\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph,\n                        this._graph = this._blankNode(), null, null);\n      return this._readSubject;\n    case '}':\n       // No subject; the graph in which we are reading is closed instead\n      return this._readPunctuation(token);\n    case '@forSome':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forSome\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORSOME;\n      this._quantifier = this._blankNode;\n      return this._readQuantifierList;\n    case '@forAll':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forAll\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORALL;\n      this._quantifier = this._variable;\n      return this._readQuantifierList;\n    case 'literal':\n      if (!this._n3Mode)\n        return this._error('Unexpected literal', token);\n\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._completeSubjectLiteral;\n      }\n      else\n        this._subject = this._literal(token.value, this._namedNode(token.prefix));\n\n      break;\n    case '<<':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF* syntax', token);\n      this._saveContext('<<', this._graph, null, null, null);\n      this._graph = null;\n      return this._readSubject;\n    default:\n      // Read the subject entity\n      if ((this._subject = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the subject might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._readPredicateOrNamedGraph);\n    }\n\n    // The next token must be a predicate,\n    // or, if the subject was actually a graph IRI, a named graph\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // ### `_readPredicate` reads a quad's predicate\n  _readPredicate(token) {\n    const type = token.type;\n    switch (type) {\n    case 'inverse':\n      this._inversePredicate = true;\n    case 'abbreviation':\n      this._predicate = this.ABBREVIATIONS[token.value];\n      break;\n    case '.':\n    case ']':\n    case '}':\n      // Expected predicate didn't come, must have been trailing semicolon\n      if (this._predicate === null)\n        return this._error(`Unexpected ${type}`, token);\n      this._subject = null;\n      return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n    case ';':\n      // Additional semicolons can be safely ignored\n      return this._predicate !== null ? this._readPredicate :\n             this._error('Expected predicate but got ;', token);\n    case 'blank':\n      if (!this._n3Mode)\n        return this._error('Disallowed blank node as predicate', token);\n    default:\n      if ((this._predicate = this._readEntity(token)) === undefined)\n        return;\n    }\n    // The next token must be an object\n    return this._readObject;\n  }\n\n  // ### `_readObject` reads a quad's object\n  _readObject(token) {\n    switch (token.type) {\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._readDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else\n        this._object = this._literal(token.value, this._namedNode(token.prefix));\n      break;\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph, this._subject, this._predicate,\n                        this._subject = this._blankNode());\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._blankNode());\n      return this._readSubject;\n    case '<<':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF* syntax', token);\n      this._saveContext('<<', this._graph, this._subject, this._predicate, null);\n      this._graph = null;\n      return this._readSubject;\n    default:\n      // Read the object entity\n      if ((this._object = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the object might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._getContextEndReader());\n    }\n    return this._getContextEndReader();\n  }\n\n  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n  _readPredicateOrNamedGraph(token) {\n    return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n  }\n\n  // ### `_readGraph` reads a graph\n  _readGraph(token) {\n    if (token.type !== '{')\n      return this._error(`Expected graph but got ${token.type}`, token);\n    // The \"subject\" we read is actually the GRAPH's label\n    this._graph = this._subject, this._subject = null;\n    return this._readSubject;\n  }\n\n  // ### `_readBlankNodeHead` reads the head of a blank node\n  _readBlankNodeHead(token) {\n    if (token.type === ']') {\n      this._subject = null;\n      return this._readBlankNodeTail(token);\n    }\n    else {\n      this._predicate = null;\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readBlankNodeTail` reads the end of a blank node\n  _readBlankNodeTail(token) {\n    if (token.type !== ']')\n      return this._readBlankNodePunctuation(token);\n\n    // Store blank node quad\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this blank node\n    const empty = this._predicate === null;\n    this._restoreContext();\n    // If the blank node was the subject, continue reading the predicate\n    if (this._object === null)\n      // If the blank node was empty, it could be a named graph label\n      return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;\n    // If the blank node was the object, restore previous context and read punctuation\n    else\n      return this._getContextEndReader();\n  }\n\n  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n  _readPredicateAfterBlank(token) {\n    switch (token.type) {\n    case '.':\n    case '}':\n      // No predicate is coming if the triple is terminated here\n      this._subject = null;\n      return this._readPunctuation(token);\n    default:\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readListItem` reads items from a list\n  _readListItem(token) {\n    let item = null,                      // The item of the list\n        list = null,                      // The list itself\n        next = this._readListItem;        // The next function to execute\n    const previousList = this._subject,   // The previous list that contains this list\n        stack = this._contextStack,       // The stack of parent contexts\n        parent = stack[stack.length - 1]; // The parent containing the current list\n\n    switch (token.type) {\n    case '[':\n      // Stack the current list quad and start a new quad with a blank node as subject\n      this._saveContext('blank', this._graph,\n                        list = this._blankNode(), this.RDF_FIRST,\n                        this._subject = item = this._blankNode());\n      next = this._readBlankNodeHead;\n      break;\n    case '(':\n      // Stack the current list quad and start a new list\n      this._saveContext('list', this._graph,\n                        list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);\n      this._subject = null;\n      break;\n    case ')':\n      // Closing the list; restore the parent context\n      this._restoreContext();\n      // If this list is contained within a parent list, return the membership quad here.\n      // This will be `<parent list element> rdf:first <this list>.`.\n      if (stack.length !== 0 && stack[stack.length - 1].type === 'list')\n        this._emit(this._subject, this._predicate, this._object, this._graph);\n      // Was this list the parent's subject?\n      if (this._predicate === null) {\n        // The next token is the predicate\n        next = this._readPredicate;\n        // No list tail if this was an empty list\n        if (this._subject === this.RDF_NIL)\n          return next;\n      }\n      // The list was in the parent context's object\n      else {\n        next = this._getContextEndReader();\n        // No list tail if this was an empty list\n        if (this._object === this.RDF_NIL)\n          return next;\n      }\n      // Close the list by making the head nil\n      list = this.RDF_NIL;\n      break;\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        next = this._readListItemDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else {\n        item = this._literal(token.value, this._namedNode(token.prefix));\n        next = this._getContextEndReader();\n      }\n      break;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._blankNode());\n      return this._readSubject;\n    default:\n      if ((item = this._readEntity(token)) === undefined)\n        return;\n    }\n\n     // Create a new blank node if no item head was assigned yet\n    if (list === null)\n      this._subject = list = this._blankNode();\n\n    // Is this the first element of the list?\n    if (previousList === null) {\n      // This list is either the subject or the object of its parent\n      if (parent.predicate === null)\n        parent.subject = list;\n      else\n        parent.object = list;\n    }\n    else {\n      // Continue the previous list with the current list\n      this._emit(previousList, this.RDF_REST, list, this._graph);\n    }\n    // If an item was read, add it to the list\n    if (item !== null) {\n      // In N3 mode, the item might be a path\n      if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n        // Create a new context to add the item's path\n        this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n        this._subject = item, this._predicate = null;\n        // _readPath will restore the context and output the item\n        return this._getPathReader(this._readListItem);\n      }\n      // Output the item\n      this._emit(list, this.RDF_FIRST, item, this._graph);\n    }\n    return next;\n  }\n\n  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n  _readDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, false);\n  }\n\n\n  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n  _readListItemDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, true);\n  }\n\n  // ### `_completeLiteral` completes a literal with an optional datatype or language\n  _completeLiteral(token) {\n    // Create a simple string literal by default\n    let literal = this._literal(this._literalValue);\n\n    switch (token.type) {\n    // Create a datatyped literal\n    case 'type':\n    case 'typeIRI':\n      const datatype = this._readEntity(token);\n      if (datatype === undefined) return; // No datatype means an error occurred\n      literal = this._literal(this._literalValue, datatype);\n      token = null;\n      break;\n    // Create a language-tagged string\n    case 'langcode':\n      literal = this._literal(this._literalValue, token.value);\n      token = null;\n      break;\n    }\n\n    return { token, literal };\n  }\n\n  // Completes a literal in subject position\n  _completeSubjectLiteral(token) {\n    this._subject = this._completeLiteral(token).literal;\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // Completes a literal in object position\n  _completeObjectLiteral(token, listItem) {\n    const completed = this._completeLiteral(token);\n    if (!completed)\n      return;\n    this._object = completed.literal;\n\n    // If this literal was part of a list, write the item\n    // (we could also check the context stack, but passing in a flag is faster)\n    if (listItem)\n      this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);\n    // If the token was consumed, continue with the rest of the input\n    if (completed.token === null)\n      return this._getContextEndReader();\n    // Otherwise, consume the token now\n    else {\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(completed.token);\n    }\n  }\n\n  // ### `_readFormulaTail` reads the end of a formula\n  _readFormulaTail(token) {\n    if (token.type !== '}')\n      return this._readPunctuation(token);\n\n    // Store the last quad of the formula\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this formula\n    this._restoreContext();\n    // If the formula was the subject, continue reading the predicate.\n    // If the formula was the object, read punctuation.\n    return this._object === null ? this._readPredicate : this._getContextEndReader();\n  }\n\n  // ### `_readPunctuation` reads punctuation between quads or quad parts\n  _readPunctuation(token) {\n    let next, graph = this._graph;\n    const subject = this._subject, inversePredicate = this._inversePredicate;\n    switch (token.type) {\n    // A closing brace ends a graph\n    case '}':\n      if (this._graph === null)\n        return this._error('Unexpected graph closing', token);\n      if (this._n3Mode)\n        return this._readFormulaTail(token);\n      this._graph = null;\n    // A dot just ends the statement, without sharing anything with the next\n    case '.':\n      this._subject = null;\n      next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n      if (inversePredicate) this._inversePredicate = false;\n      break;\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n        next = this._readQuadPunctuation;\n        break;\n      }\n      return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    }\n    // A quad has been completed now, so return it\n    if (subject !== null) {\n      const predicate = this._predicate, object = this._object;\n      if (!inversePredicate)\n        this._emit(subject, predicate, object,  graph);\n      else\n        this._emit(object,  predicate, subject, graph);\n    }\n    return next;\n  }\n\n    // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n  _readBlankNodePunctuation(token) {\n    let next;\n    switch (token.type) {\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    }\n    // A quad has been completed now, so return it\n    this._emit(this._subject, this._predicate, this._object, this._graph);\n    return next;\n  }\n\n  // ### `_readQuadPunctuation` reads punctuation after a quad\n  _readQuadPunctuation(token) {\n    if (token.type !== '.')\n      return this._error('Expected dot to follow quad', token);\n    return this._readInTopContext;\n  }\n\n  // ### `_readPrefix` reads the prefix of a prefix declaration\n  _readPrefix(token) {\n    if (token.type !== 'prefix')\n      return this._error('Expected prefix to follow @prefix', token);\n    this._prefix = token.value;\n    return this._readPrefixIRI;\n  }\n\n  // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n  _readPrefixIRI(token) {\n    if (token.type !== 'IRI')\n      return this._error(`Expected IRI to follow prefix \"${this._prefix}:\"`, token);\n    const prefixNode = this._readEntity(token);\n    this._prefixes[this._prefix] = prefixNode.value;\n    this._prefixCallback(this._prefix, prefixNode);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readBaseIRI` reads the IRI of a base declaration\n  _readBaseIRI(token) {\n    const iri = token.type === 'IRI' && this._resolveIRI(token.value);\n    if (!iri)\n      return this._error('Expected valid IRI to follow base declaration', token);\n    this._setBase(iri);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readNamedGraphLabel` reads the label of a named graph\n  _readNamedGraphLabel(token) {\n    switch (token.type) {\n    case 'IRI':\n    case 'blank':\n    case 'prefixed':\n      return this._readSubject(token), this._readGraph;\n    case '[':\n      return this._readNamedGraphBlankLabel;\n    default:\n      return this._error('Invalid graph label', token);\n    }\n  }\n\n  // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n  _readNamedGraphBlankLabel(token) {\n    if (token.type !== ']')\n      return this._error('Invalid graph label', token);\n    this._subject = this._blankNode();\n    return this._readGraph;\n  }\n\n  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n  _readDeclarationPunctuation(token) {\n    // SPARQL-style declarations don't have punctuation\n    if (this._sparqlStyle) {\n      this._sparqlStyle = false;\n      return this._readInTopContext(token);\n    }\n\n    if (token.type !== '.')\n      return this._error('Expected declaration to end with a dot', token);\n    return this._readInTopContext;\n  }\n\n  // Reads a list of quantified symbols from a @forSome or @forAll statement\n  _readQuantifierList(token) {\n    let entity;\n    switch (token.type) {\n    case 'IRI':\n    case 'prefixed':\n      if ((entity = this._readEntity(token, true)) !== undefined)\n        break;\n    default:\n      return this._error(`Unexpected ${token.type}`, token);\n    }\n    // Without explicit quantifiers, map entities to a quantified entity\n    if (!this._explicitQuantifiers)\n      this._quantified[entity.id] = this._quantifier(this._blankNode().value);\n    // With explicit quantifiers, output the reified quantifier\n    else {\n      // If this is the first item, start a new quantifier list\n      if (this._subject === null)\n        this._emit(this._graph || this.DEFAULTGRAPH, this._predicate,\n                   this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Otherwise, continue the previous list\n      else\n        this._emit(this._subject, this.RDF_REST,\n                   this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Output the list item\n      this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n    }\n    return this._readQuantifierPunctuation;\n  }\n\n  // Reads punctuation from a @forSome or @forAll statement\n  _readQuantifierPunctuation(token) {\n    // Read more quantifiers\n    if (token.type === ',')\n      return this._readQuantifierList;\n    // End of the quantifier list\n    else {\n      // With explicit quantifiers, close the quantifier list\n      if (this._explicitQuantifiers) {\n        this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n        this._subject = null;\n      }\n      // Read a dot\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(token);\n    }\n  }\n\n  // ### `_getPathReader` reads a potential path and then resumes with the given function\n  _getPathReader(afterPath) {\n    this._afterPath = afterPath;\n    return this._readPath;\n  }\n\n  // ### `_readPath` reads a potential path\n  _readPath(token) {\n    switch (token.type) {\n    // Forward path\n    case '!': return this._readForwardPath;\n    // Backward path\n    case '^': return this._readBackwardPath;\n    // Not a path; resume reading where we left off\n    default:\n      const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];\n      // If we were reading a list item, we still need to output it\n      if (parent && parent.type === 'item') {\n        // The list item is the remaining subejct after reading the path\n        const item = this._subject;\n        // Switch back to the context of the list\n        this._restoreContext();\n        // Output the list item\n        this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n      }\n      return this._afterPath(token);\n    }\n  }\n\n  // ### `_readForwardPath` reads a '!' path\n  _readForwardPath(token) {\n    let subject, predicate;\n    const object = this._blankNode();\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's object\n    if (this._predicate === null)\n      subject = this._subject, this._subject = object;\n    // If we were reading an object, replace the subject by the path's object\n    else\n      subject = this._object,  this._object  = object;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readBackwardPath` reads a '^' path\n  _readBackwardPath(token) {\n    const subject = this._blankNode();\n    let predicate, object;\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's subject\n    if (this._predicate === null)\n      object = this._subject, this._subject = subject;\n    // If we were reading an object, replace the subject by the path's subject\n    else\n      object = this._object,  this._object  = subject;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple\n  _readRDFStarTailOrGraph(token) {\n    if (token.type !== '>>') {\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined)\n        return this._readRDFStarTail;\n      return this._error(`Expected >> to follow \"${this._object.id}\"`, token);\n    }\n    return this._readRDFStarTail(token);\n  }\n\n  // ### `_readRDFStarTail` reads the end of a nested RDF* triple\n  _readRDFStarTail(token) {\n    if (token.type !== '>>')\n      return this._error(`Expected >> but got ${token.type}`, token);\n    // Read the quad and restore the previous context\n    const quad = this._quad(this._subject, this._predicate, this._object,\n      this._graph || this.DEFAULTGRAPH);\n    this._restoreContext();\n    // If the triple was the subject, continue by reading the predicate.\n    if (this._subject === null) {\n      this._subject = quad;\n      return this._readPredicate;\n    }\n    // If the triple was the object, read context end.\n    else {\n      this._object = quad;\n      return this._getContextEndReader();\n    }\n  }\n\n  // ### `_getContextEndReader` gets the next reader function at the end of a context\n  _getContextEndReader() {\n    const contextStack = this._contextStack;\n    if (!contextStack.length)\n      return this._readPunctuation;\n\n    switch (contextStack[contextStack.length - 1].type) {\n    case 'blank':\n      return this._readBlankNodeTail;\n    case 'list':\n      return this._readListItem;\n    case 'formula':\n      return this._readFormulaTail;\n    case '<<':\n      return this._readRDFStarTailOrGraph;\n    }\n  }\n\n  // ### `_emit` sends a quad through the callback\n  _emit(subject, predicate, object, graph) {\n    this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n  }\n\n  // ### `_error` emits an error message through the callback\n  _error(message, token) {\n    const err = new Error(`${message} on line ${token.line}.`);\n    err.context = {\n      token: token,\n      line: token.line,\n      previousToken: this._lexer.previousToken,\n    };\n    this._callback(err);\n    this._callback = noop;\n  }\n\n  // ### `_resolveIRI` resolves an IRI against the base path\n  _resolveIRI(iri) {\n    return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n  }\n\n  // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative\n  _resolveRelativeIRI(iri) {\n    // An empty relative IRI indicates the base IRI\n    if (!iri.length)\n      return this._base;\n    // Decide resolving strategy based in the first character\n    switch (iri[0]) {\n    // Resolve relative fragment IRIs against the base IRI\n    case '#': return this._base + iri;\n    // Resolve relative query string IRIs by replacing the query string\n    case '?': return this._base.replace(/(?:\\?.*)?$/, iri);\n    // Resolve root-relative IRIs at the root of the base IRI\n    case '/':\n      // Resolve scheme-relative IRIs to the scheme\n      return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n    // Resolve all other IRIs at the base IRI's path\n    default:\n      // Relative IRIs cannot contain a colon in the first path segment\n      return (/^[^/:]*:/.test(iri)) ? null : this._removeDotSegments(this._basePath + iri);\n    }\n  }\n\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n  _removeDotSegments(iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri))\n      return iri;\n\n    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n    const length = iri.length;\n    let result = '', i = -1, pathStart = -1, segmentStart = 0, next = '/';\n\n    while (i < length) {\n      switch (next) {\n      // The path starts with the first slash after the authority\n      case ':':\n        if (pathStart < 0) {\n          // Skip two slashes before the authority\n          if (iri[++i] === '/' && iri[++i] === '/')\n            // Skip to slash after the authority\n            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')\n              i = pathStart;\n        }\n        break;\n      // Don't modify a query string or fragment\n      case '?':\n      case '#':\n        i = length;\n        break;\n      // Handle '/.' or '/..' path segments\n      case '/':\n        if (iri[i + 1] === '.') {\n          next = iri[++i + 1];\n          switch (next) {\n          // Remove a '/.' segment\n          case '/':\n            result += iri.substring(segmentStart, i - 1);\n            segmentStart = i + 1;\n            break;\n          // Remove a trailing '/.' segment\n          case undefined:\n          case '?':\n          case '#':\n            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n          // Remove a '/..' segment\n          case '.':\n            next = iri[++i + 1];\n            if (next === undefined || next === '/' || next === '?' || next === '#') {\n              result += iri.substring(segmentStart, i - 2);\n              // Try to remove the parent path from result\n              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)\n                result = result.substr(0, segmentStart);\n              // Remove a trailing '/..' segment\n              if (next !== '/')\n                return `${result}/${iri.substr(i + 1)}`;\n              segmentStart = i + 1;\n            }\n          }\n        }\n      }\n      next = iri[++i];\n    }\n    return result + iri.substring(segmentStart);\n  }\n\n  // ## Public methods\n\n  // ### `parse` parses the N3 input and emits each parsed quad through the callback\n  parse(input, quadCallback, prefixCallback) {\n    // The read callback is the next function to be executed when a token arrives.\n    // We start reading in the top context.\n    this._readCallback = this._readInTopContext;\n    this._sparqlStyle = false;\n    this._prefixes = Object.create(null);\n    this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2)\n                                             : `b${blankNodePrefix++}_`;\n    this._prefixCallback = prefixCallback || noop;\n    this._inversePredicate = false;\n    this._quantified = Object.create(null);\n\n    // Parse synchronously if no quad callback is given\n    if (!quadCallback) {\n      const quads = [];\n      let error;\n      this._callback = (e, t) => { e ? (error = e) : t && quads.push(t); };\n      this._lexer.tokenize(input).every(token => {\n        return this._readCallback = this._readCallback(token);\n      });\n      if (error) throw error;\n      return quads;\n    }\n\n    // Parse asynchronously otherwise, executing the read callback when a token arrives\n    this._callback = quadCallback;\n    this._lexer.tokenize(input, (error, token) => {\n      if (error !== null)\n        this._callback(error), this._callback = noop;\n      else if (this._readCallback)\n        this._readCallback = this._readCallback(token);\n    });\n  }\n}\n\n// The empty function\nfunction noop() {}\n\n// Initializes the parser with the given data factory\nfunction initDataFactory(parser, factory) {\n  // Set factory methods\n  const namedNode = factory.namedNode;\n  parser._namedNode   = namedNode;\n  parser._blankNode   = factory.blankNode;\n  parser._literal     = factory.literal;\n  parser._variable    = factory.variable;\n  parser._quad        = factory.quad;\n  parser.DEFAULTGRAPH = factory.defaultGraph();\n\n  // Set common named nodes\n  parser.RDF_FIRST  = namedNode(namespaces.rdf.first);\n  parser.RDF_REST   = namedNode(namespaces.rdf.rest);\n  parser.RDF_NIL    = namedNode(namespaces.rdf.nil);\n  parser.N3_FORALL  = namedNode(namespaces.r.forAll);\n  parser.N3_FORSOME = namedNode(namespaces.r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': namedNode(namespaces.rdf.type),\n    '=': namedNode(namespaces.owl.sameAs),\n    '>': namedNode(namespaces.log.implies),\n  };\n  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');\n}\ninitDataFactory(N3Parser.prototype, N3DataFactory);\n"]},"metadata":{},"sourceType":"module"}