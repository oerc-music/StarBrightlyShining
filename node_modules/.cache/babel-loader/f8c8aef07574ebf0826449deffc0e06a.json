{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.promote = exports.SpecialFunction = exports.NamedFunction = exports.RegularFunction = exports.BaseFunction = void 0;\n\nconst immutable_1 = require(\"immutable\");\n\nconst Err = require(\"../util/Errors\");\n\nclass BaseFunction {\n  constructor(operator, definition) {\n    this.operator = operator;\n    /**\n     * A function application works by monomorphing the function to a specific\n     * instance depending on the runtime types. We then just apply this function\n     * to the args.\n     */\n\n    this.apply = args => {\n      const concreteFunction = this.monomorph(args) || this.handleInvalidTypes(args);\n      return concreteFunction(args);\n    };\n\n    this.arity = definition.arity;\n    this.overloads = definition.overloads;\n  }\n  /**\n   * We monomorph by checking the map of overloads for keys corresponding\n   * to the runtime types. We start by checking for an implementation for the\n   * most concrete types (integer, string, date, IRI), if we find none,\n   * we consider their term types (literal, blank, IRI), and lastly we consider\n   * all arguments as generic terms.\n   *\n   * Another option would be to populate the overloads with an implementation\n   * for every concrete type when the function is generic over termtypes or\n   * terms.\n   */\n\n\n  monomorph(args) {\n    return false // TODO: Maybe use non primitive types first?\n    || this.overloads.get(Typer.asConcreteTypes(args)) || this.overloads.get(Typer.asTermTypes(args)) || this.overloads.get(Typer.asGenericTerms(args));\n  }\n\n}\n\nexports.BaseFunction = BaseFunction;\n\nclass Typer {\n  static asConcreteTypes(args) {\n    // tslint:disable-next-line:no-any\n    return immutable_1.List(args.map(a => a.type || a.termType));\n  }\n\n  static asTermTypes(args) {\n    return immutable_1.List(args.map(a => a.termType));\n  }\n\n  static asGenericTerms(args) {\n    return immutable_1.List(Array(args.length).fill('term'));\n  }\n\n} // Regular Functions ----------------------------------------------------------\n\n/**\n * Varying kinds of functions take arguments of different types on which the\n * specific behaviour is dependant. Although their behaviour is often varying,\n * it is always relatively simple, and better suited for synced behaviour.\n * The types of their arguments are always terms, but might differ in\n * their term-type (eg: iri, literal),\n * their specific literal type (eg: string, integer),\n * their arity (see BNODE),\n * or even their specific numeric type (eg: integer, float).\n *\n * Examples include:\n *  - Arithmetic operations such as: *, -, /, +\n *  - Bool operators such as: =, !=, <=, <, ...\n *  - Functions such as: str, IRI\n *\n * See also: https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n * and https://www.w3.org/TR/sparql11-query/#OperatorMapping\n */\n\n\nclass RegularFunction extends BaseFunction {\n  constructor(op, definition) {\n    super(op, definition);\n    this.functionClass = 'regular';\n  }\n\n  handleInvalidTypes(args) {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n\n}\n\nexports.RegularFunction = RegularFunction; // Named Functions ------------------------------------------------------------\n\nclass NamedFunction extends BaseFunction {\n  constructor(op, definition) {\n    super(op, definition);\n    this.functionClass = 'named';\n  }\n\n  handleInvalidTypes(args) {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n\n}\n\nexports.NamedFunction = NamedFunction; // Special Functions ----------------------------------------------------------\n\n/*\n * Special Functions are those that don't really fit in sensible categories and\n * have extremely heterogeneous signatures that make them impossible to abstract\n * over. They are small in number, and their behaviour is often complex and open\n * for multiple correct implementations with different trade-offs.\n *\n * Due to their varying nature, they need all available information present\n * during evaluation. This reflects in the signature of the apply() method.\n *\n * They need access to an evaluator to be able to even implement their logic.\n * Especially relevant for IF, and the logical connectives.\n *\n * They can have both sync and async implementations, and both would make sense\n * in some contexts.\n */\n\nclass SpecialFunction {\n  constructor(operator, definition) {\n    this.operator = operator;\n    this.functionClass = 'special';\n    this.arity = definition.arity;\n    this.applySync = definition.applySync;\n    this.applyAsync = definition.applyAsync;\n    this.checkArity = definition.checkArity || defaultArityCheck(this.arity);\n  }\n\n}\n\nexports.SpecialFunction = SpecialFunction;\n\nfunction defaultArityCheck(arity) {\n  return args => {\n    // Infinity is used to represent var-args, so it's always correct.\n    if (arity === Infinity) {\n      return true;\n    } // If the function has overloaded arity, the actual arity needs to be present.\n\n\n    if (Array.isArray(arity)) {\n      return arity.indexOf(args.length) >= 0;\n    }\n\n    return args.length === arity;\n  };\n} // Type Promotion -------------------------------------------------------------\n\n\nconst _promote = {\n  integer: {\n    integer: 'integer',\n    decimal: 'decimal',\n    float: 'float',\n    double: 'double'\n  },\n  decimal: {\n    integer: 'decimal',\n    decimal: 'decimal',\n    float: 'float',\n    double: 'double'\n  },\n  float: {\n    integer: 'float',\n    decimal: 'float',\n    float: 'float',\n    double: 'double'\n  },\n  double: {\n    integer: 'double',\n    decimal: 'double',\n    float: 'double',\n    double: 'double'\n  }\n};\n\nfunction promote(left, right) {\n  return _promote[left][right];\n}\n\nexports.promote = promote;","map":{"version":3,"sources":["../../../lib/functions/Core.ts"],"names":[],"mappings":"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","sourcesContent":["import { List, Map } from 'immutable';\n\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\ntype Term = E.TermExpression;\n\n// ----------------------------------------------------------------------------\n// Overloaded Functions\n// ----------------------------------------------------------------------------\n\n// Maps argument types on their specific implementation.\nexport type OverloadMap = Map<List<ArgumentType>, E.SimpleApplication>;\n\n// Function and operator arguments are 'flattened' in the SPARQL spec.\n// If the argument is a literal, the datatype often also matters.\nexport type ArgumentType = 'term' | E.TermType | C.Type;\n\nexport type OverloadedDefinition = {\n  arity: number | number[]\n  overloads: OverloadMap,\n};\n\nexport abstract class BaseFunction<Operator> {\n\n  arity: number | number[];\n  private overloads: OverloadMap;\n\n  constructor(public operator: Operator, definition: OverloadedDefinition) {\n    this.arity = definition.arity;\n    this.overloads = definition.overloads;\n  }\n\n  /**\n   * A function application works by monomorphing the function to a specific\n   * instance depending on the runtime types. We then just apply this function\n   * to the args.\n   */\n  apply = (args: Term[]): Term => {\n    const concreteFunction = this.monomorph(args) || this.handleInvalidTypes(args);\n    return concreteFunction(args);\n  }\n\n  protected abstract handleInvalidTypes(args: Term[]): never;\n\n  /**\n   * We monomorph by checking the map of overloads for keys corresponding\n   * to the runtime types. We start by checking for an implementation for the\n   * most concrete types (integer, string, date, IRI), if we find none,\n   * we consider their term types (literal, blank, IRI), and lastly we consider\n   * all arguments as generic terms.\n   *\n   * Another option would be to populate the overloads with an implementation\n   * for every concrete type when the function is generic over termtypes or\n   * terms.\n   */\n  private monomorph(args: Term[]) {\n    return (false\n      // TODO: Maybe use non primitive types first?\n      || this.overloads.get(Typer.asConcreteTypes(args))\n      || this.overloads.get(Typer.asTermTypes(args))\n      || this.overloads.get(Typer.asGenericTerms(args))\n    );\n  }\n}\n\nclass Typer {\n  static asConcreteTypes(args: Term[]): List<ArgumentType> {\n    // tslint:disable-next-line:no-any\n    return List(args.map((a: any) => a.type || a.termType));\n  }\n\n  static asTermTypes(args: Term[]): List<E.TermType> {\n    return List(args.map((a: E.TermExpression) => a.termType));\n  }\n\n  static asGenericTerms(args: Term[]): List<'term'> {\n    return List(Array(args.length).fill('term'));\n  }\n}\n\n// Regular Functions ----------------------------------------------------------\n\n/**\n * Varying kinds of functions take arguments of different types on which the\n * specific behaviour is dependant. Although their behaviour is often varying,\n * it is always relatively simple, and better suited for synced behaviour.\n * The types of their arguments are always terms, but might differ in\n * their term-type (eg: iri, literal),\n * their specific literal type (eg: string, integer),\n * their arity (see BNODE),\n * or even their specific numeric type (eg: integer, float).\n *\n * Examples include:\n *  - Arithmetic operations such as: *, -, /, +\n *  - Bool operators such as: =, !=, <=, <, ...\n *  - Functions such as: str, IRI\n *\n * See also: https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n * and https://www.w3.org/TR/sparql11-query/#OperatorMapping\n */\nexport class RegularFunction extends BaseFunction<C.RegularOperator> {\n  functionClass: 'regular' = 'regular';\n\n  constructor(op: C.RegularOperator, definition: OverloadedDefinition) {\n    super(op, definition);\n  }\n\n  handleInvalidTypes(args: Term[]): never {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n}\n\n// Named Functions ------------------------------------------------------------\nexport class NamedFunction extends BaseFunction<C.NamedOperator> {\n  functionClass: 'named' = 'named';\n\n  constructor(op: C.NamedOperator, definition: OverloadedDefinition) {\n    super(op, definition);\n  }\n\n  handleInvalidTypes(args: Term[]): never {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n}\n\n// Special Functions ----------------------------------------------------------\n/*\n * Special Functions are those that don't really fit in sensible categories and\n * have extremely heterogeneous signatures that make them impossible to abstract\n * over. They are small in number, and their behaviour is often complex and open\n * for multiple correct implementations with different trade-offs.\n *\n * Due to their varying nature, they need all available information present\n * during evaluation. This reflects in the signature of the apply() method.\n *\n * They need access to an evaluator to be able to even implement their logic.\n * Especially relevant for IF, and the logical connectives.\n *\n * They can have both sync and async implementations, and both would make sense\n * in some contexts.\n */\nexport class SpecialFunction {\n  functionClass: 'special' = 'special';\n  arity: number;\n  applySync: E.SpecialApplicationSync;\n  applyAsync: E.SpecialApplicationAsync;\n  checkArity: (args: E.Expression[]) => boolean;\n\n  constructor(public operator: C.SpecialOperator, definition: SpecialDefinition) {\n    this.arity = definition.arity;\n    this.applySync = definition.applySync;\n    this.applyAsync = definition.applyAsync;\n    this.checkArity = definition.checkArity || defaultArityCheck(this.arity);\n  }\n}\n\nfunction defaultArityCheck(arity: number): (args: E.Expression[]) => boolean {\n  return (args: E.Expression[]): boolean => {\n    // Infinity is used to represent var-args, so it's always correct.\n    if (arity === Infinity) { return true; }\n\n    // If the function has overloaded arity, the actual arity needs to be present.\n    if (Array.isArray(arity)) {\n      return arity.indexOf(args.length) >= 0;\n    }\n\n    return args.length === arity;\n  };\n}\n\nexport type SpecialDefinition = {\n  arity: number;\n  applyAsync: E.SpecialApplicationAsync;\n  applySync: E.SpecialApplicationSync;\n  checkArity?: (args: E.Expression[]) => boolean;\n};\n\n// Type Promotion -------------------------------------------------------------\n\nconst _promote: { [t in C.PrimitiveNumericType]: { [tt in C.PrimitiveNumericType]: C.PrimitiveNumericType } } = {\n  integer: {\n    integer: 'integer',\n    decimal: 'decimal',\n    float: 'float',\n    double: 'double',\n  },\n  decimal: {\n    integer: 'decimal',\n    decimal: 'decimal',\n    float: 'float',\n    double: 'double',\n  },\n  float: {\n    integer: 'float',\n    decimal: 'float',\n    float: 'float',\n    double: 'double',\n  },\n  double: {\n    integer: 'double',\n    decimal: 'double',\n    float: 'double',\n    double: 'double',\n  },\n};\n\nexport function promote(left: C.PrimitiveNumericType, right: C.PrimitiveNumericType): C.PrimitiveNumericType {\n  return _promote[left][right];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}