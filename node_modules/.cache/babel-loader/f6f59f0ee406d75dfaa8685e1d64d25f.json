{"ast":null,"code":"'use strict';\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i;\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/;\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g;\nvar DELIMITER_PATTERN = /[;,\"]/;\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/;\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\n\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/;\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2\n};\n\nfunction trim(value) {\n  return value.replace(WS_TRIM_PATTERN, '');\n}\n\nfunction hasWhitespace(value) {\n  return WS_CHAR_PATTERN.test(value);\n}\n\nfunction skipWhitespace(value, offset) {\n  while (hasWhitespace(value[offset])) {\n    offset++;\n  }\n\n  return offset;\n}\n\nfunction needsQuotes(value) {\n  return WS_DELIMITER_PATTERN.test(value) || !TOKEN_PATTERN.test(value);\n}\n\nclass Link {\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor(value) {\n    /** @type {Array} URI references */\n    this.refs = [];\n\n    if (value) {\n      this.parse(value);\n    }\n  }\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n\n\n  rel(value) {\n    var links = [];\n    var type = value.toLowerCase();\n\n    for (var i = 0; i < this.refs.length; i++) {\n      if (this.refs[i].rel.toLowerCase() === type) {\n        links.push(this.refs[i]);\n      }\n    }\n\n    return links;\n  }\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n\n\n  get(attr, value) {\n    attr = attr.toLowerCase();\n    var links = [];\n\n    for (var i = 0; i < this.refs.length; i++) {\n      if (this.refs[i][attr] === value) {\n        links.push(this.refs[i]);\n      }\n    }\n\n    return links;\n  }\n\n  set(link) {\n    this.refs.push(link);\n    return this;\n  }\n\n  has(attr, value) {\n    attr = attr.toLowerCase();\n\n    for (var i = 0; i < this.refs.length; i++) {\n      if (this.refs[i][attr] === value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  parse(value, offset) {\n    offset = offset || 0;\n    value = offset ? value.slice(offset) : value; // Trim & unfold folded lines\n\n    value = trim(value).replace(WS_FOLD_PATTERN, '');\n    var state = STATE.IDLE;\n    var length = value.length;\n    var offset = 0;\n    var ref = null;\n\n    while (offset < length) {\n      if (state === STATE.IDLE) {\n        if (hasWhitespace(value[offset])) {\n          offset++;\n          continue;\n        } else if (value[offset] === '<') {\n          if (ref != null) {\n            ref.rel != null ? this.refs.push(...Link.expandRelations(ref)) : this.refs.push(ref);\n          }\n\n          var end = value.indexOf('>', offset);\n          if (end === -1) throw new Error('Expected end of URI delimiter at offset ' + offset);\n          ref = {\n            uri: value.slice(offset + 1, end)\n          }; // this.refs.push( ref )\n\n          offset = end;\n          state = STATE.URI;\n        } else {\n          throw new Error('Unexpected character \"' + value[offset] + '\" at offset ' + offset);\n        }\n\n        offset++;\n      } else if (state === STATE.URI) {\n        if (hasWhitespace(value[offset])) {\n          offset++;\n          continue;\n        } else if (value[offset] === ';') {\n          state = STATE.ATTR;\n          offset++;\n        } else if (value[offset] === ',') {\n          state = STATE.IDLE;\n          offset++;\n        } else {\n          throw new Error('Unexpected character \"' + value[offset] + '\" at offset ' + offset);\n        }\n      } else if (state === STATE.ATTR) {\n        if (value[offset] === ';' || hasWhitespace(value[offset])) {\n          offset++;\n          continue;\n        }\n\n        var end = value.indexOf('=', offset);\n        if (end === -1) throw new Error('Expected attribute delimiter at offset ' + offset);\n        var attr = trim(value.slice(offset, end)).toLowerCase();\n        var attrValue = '';\n        offset = end + 1;\n        offset = skipWhitespace(value, offset);\n\n        if (value[offset] === '\"') {\n          offset++;\n\n          while (offset < length) {\n            if (value[offset] === '\"') {\n              offset++;\n              break;\n            }\n\n            if (value[offset] === '\\\\') {\n              offset++;\n            }\n\n            attrValue += value[offset];\n            offset++;\n          }\n        } else {\n          var end = offset + 1;\n\n          while (!DELIMITER_PATTERN.test(value[end]) && end < length) {\n            end++;\n          }\n\n          attrValue = value.slice(offset, end);\n          offset = end;\n        }\n\n        if (ref[attr] && Link.isSingleOccurenceAttr(attr)) {// Ignore multiples of attributes which may only appear once\n        } else if (attr[attr.length - 1] === '*') {\n          ref[attr] = Link.parseExtendedValue(attrValue);\n        } else {\n          attrValue = attr === 'type' ? attrValue.toLowerCase() : attrValue;\n\n          if (ref[attr] != null) {\n            if (Array.isArray(ref[attr])) {\n              ref[attr].push(attrValue);\n            } else {\n              ref[attr] = [ref[attr], attrValue];\n            }\n          } else {\n            ref[attr] = attrValue;\n          }\n        }\n\n        switch (value[offset]) {\n          case ',':\n            state = STATE.IDLE;\n            break;\n\n          case ';':\n            state = STATE.ATTR;\n            break;\n        }\n\n        offset++;\n      } else {\n        throw new Error('Unknown parser state \"' + state + '\"');\n      }\n    }\n\n    if (ref != null) {\n      ref.rel != null ? this.refs.push(...Link.expandRelations(ref)) : this.refs.push(ref);\n    }\n\n    ref = null;\n    return this;\n  }\n\n  toString() {\n    var refs = [];\n    var link = '';\n    var ref = null;\n\n    for (var i = 0; i < this.refs.length; i++) {\n      ref = this.refs[i];\n      link = Object.keys(this.refs[i]).reduce(function (link, attr) {\n        if (attr === 'uri') return link;\n        return link + '; ' + Link.formatAttribute(attr, ref[attr]);\n      }, '<' + ref.uri + '>');\n      refs.push(link);\n    }\n\n    return refs.join(', ');\n  }\n\n}\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\n\n\nLink.isCompatibleEncoding = function (value) {\n  return COMPATIBLE_ENCODING_PATTERN.test(value);\n};\n\nLink.parse = function (value, offset) {\n  return new Link().parse(value, offset);\n};\n\nLink.isSingleOccurenceAttr = function (attr) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' || attr === 'title' || attr === 'title*';\n};\n\nLink.isTokenAttr = function (attr) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor';\n};\n\nLink.escapeQuotes = function (value) {\n  return value.replace(/\"/g, '\\\\\"');\n};\n\nLink.expandRelations = function (ref) {\n  var rels = ref.rel.split(' ');\n  return rels.map(function (rel) {\n    var value = Object.assign({}, ref);\n    value.rel = rel;\n    return value;\n  });\n};\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\n\n\nLink.parseExtendedValue = function (value) {\n  var parts = /([^']+)?(?:'([^']+)')?(.+)/.exec(value);\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding(parts[1]) ? null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding(parts[1]) ? decodeURIComponent(parts[3]) : parts[3]\n  };\n};\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\n\n\nLink.formatExtendedAttribute = function (attr, data) {\n  var encoding = (data.encoding || 'utf-8').toUpperCase();\n  var language = data.language || 'en';\n  var encodedValue = '';\n\n  if (Buffer.isBuffer(data.value) && Link.isCompatibleEncoding(encoding)) {\n    encodedValue = data.value.toString(encoding);\n  } else if (Buffer.isBuffer(data.value)) {\n    encodedValue = data.value.toString('hex').replace(/[0-9a-f]{2}/gi, '%$1');\n  } else {\n    encodedValue = encodeURIComponent(data.value);\n  }\n\n  return attr + '=' + encoding + '\\'' + language + '\\'' + encodedValue;\n};\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\n\n\nLink.formatAttribute = function (attr, value) {\n  if (Array.isArray(value)) {\n    return value.map(item => {\n      return Link.formatAttribute(attr, item);\n    }).join('; ');\n  }\n\n  if (attr[attr.length - 1] === '*' || typeof value !== 'string') {\n    return Link.formatExtendedAttribute(attr, value);\n  }\n\n  if (Link.isTokenAttr(attr)) {\n    value = needsQuotes(value) ? '\"' + Link.escapeQuotes(value) + '\"' : Link.escapeQuotes(value);\n  } else if (needsQuotes(value)) {\n    value = encodeURIComponent(value); // We don't need to escape <SP> <,> <;> within quotes\n\n    value = value.replace(/%20/g, ' ').replace(/%2C/g, ',').replace(/%3B/g, ';');\n    value = '\"' + value + '\"';\n  }\n\n  return attr + '=' + value;\n};\n\nmodule.exports = Link;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/http-link-header/lib/link.js"],"names":["COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","TOKEN_PATTERN","STATE","IDLE","URI","ATTR","trim","value","replace","hasWhitespace","test","skipWhitespace","offset","needsQuotes","Link","constructor","refs","parse","rel","links","type","toLowerCase","i","length","push","get","attr","set","link","has","slice","state","ref","expandRelations","end","indexOf","Error","uri","attrValue","isSingleOccurenceAttr","parseExtendedValue","Array","isArray","toString","Object","keys","reduce","formatAttribute","join","isCompatibleEncoding","isTokenAttr","escapeQuotes","rels","split","map","assign","parts","exec","language","encoding","decodeURIComponent","formatExtendedAttribute","data","toUpperCase","encodedValue","Buffer","isBuffer","encodeURIComponent","item","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) throw new Error( 'Expected attribute delimiter at offset ' + offset )\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']+)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n"]},"metadata":{},"sourceType":"script"}