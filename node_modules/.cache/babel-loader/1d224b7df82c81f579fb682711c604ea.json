{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SortIterator = void 0;\n\nconst asynciterator_1 = require(\"asynciterator\"); // Based on https://github.com/LinkedDataFragments/Client.js/blob/master/lib/sparql/SortIterator.js\n\n\nclass SortIterator extends asynciterator_1.TransformIterator {\n  constructor(source, sort, options) {\n    super(source, options); // The `window` parameter indicates the length of the sliding window to apply sorting\n\n    const window = options && options.window;\n    this.windowLength = Number.isFinite(window) && window > 0 ? window : Number.POSITIVE_INFINITY;\n    this.sort = sort;\n    this.sorted = [];\n  } // Reads the smallest item in the current sorting window\n\n\n  _read(count, done) {\n    let item;\n    let {\n      length\n    } = this.sorted; // Try to read items until we reach the desired window length\n\n    while (length !== this.windowLength) {\n      item = this.source.read();\n\n      if (item === null) {\n        break;\n      } // Insert the item in the sorted window (smallest last)\n\n\n      let left = 0;\n      let right = length - 1;\n      let mid;\n      let order;\n\n      while (left <= right) {\n        mid = Math.trunc((left + right) / 2);\n        order = this.sort(item, this.sorted[mid]);\n\n        if (order < 0) {\n          left = mid + 1;\n        } else if (order > 0) {\n          right = mid - 1;\n        } else {\n          left = mid;\n          right = -1;\n        }\n      }\n\n      this.sorted.splice(left, 0, item);\n      length++;\n    } // Push the smallest item in the window\n\n\n    if (length === this.windowLength) {\n      this._push(this.sorted.pop());\n    }\n\n    done();\n  } // Flushes remaining data after the source has ended\n\n\n  _flush(done) {\n    let {\n      length\n    } = this.sorted;\n\n    while (length--) {\n      this._push(this.sorted.pop());\n    }\n\n    done();\n  }\n\n}\n\nexports.SortIterator = SortIterator;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-orderby-sparqlee/lib/SortIterator.js"],"names":["Object","defineProperty","exports","value","SortIterator","asynciterator_1","require","TransformIterator","constructor","source","sort","options","window","windowLength","Number","isFinite","POSITIVE_INFINITY","sorted","_read","count","done","item","length","read","left","right","mid","order","Math","trunc","splice","_push","pop","_flush"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,YAAR,GAAuB,KAAK,CAA5B;;AACA,MAAMC,eAAe,GAAGC,OAAO,CAAC,eAAD,CAA/B,C,CACA;;;AACA,MAAMF,YAAN,SAA2BC,eAAe,CAACE,iBAA3C,CAA6D;AACzDC,EAAAA,WAAW,CAACC,MAAD,EAASC,IAAT,EAAeC,OAAf,EAAwB;AAC/B,UAAMF,MAAN,EAAcE,OAAd,EAD+B,CAE/B;;AACA,UAAMC,MAAM,GAAGD,OAAO,IAAIA,OAAO,CAACC,MAAlC;AACA,SAAKC,YAAL,GAAoBC,MAAM,CAACC,QAAP,CAAgBH,MAAhB,KAA2BA,MAAM,GAAG,CAApC,GAAwCA,MAAxC,GAAiDE,MAAM,CAACE,iBAA5E;AACA,SAAKN,IAAL,GAAYA,IAAZ;AACA,SAAKO,MAAL,GAAc,EAAd;AACH,GARwD,CASzD;;;AACAC,EAAAA,KAAK,CAACC,KAAD,EAAQC,IAAR,EAAc;AACf,QAAIC,IAAJ;AACA,QAAI;AAAEC,MAAAA;AAAF,QAAa,KAAKL,MAAtB,CAFe,CAGf;;AACA,WAAOK,MAAM,KAAK,KAAKT,YAAvB,EAAqC;AACjCQ,MAAAA,IAAI,GAAG,KAAKZ,MAAL,CAAYc,IAAZ,EAAP;;AACA,UAAIF,IAAI,KAAK,IAAb,EAAmB;AACf;AACH,OAJgC,CAKjC;;;AACA,UAAIG,IAAI,GAAG,CAAX;AACA,UAAIC,KAAK,GAAGH,MAAM,GAAG,CAArB;AACA,UAAII,GAAJ;AACA,UAAIC,KAAJ;;AACA,aAAOH,IAAI,IAAIC,KAAf,EAAsB;AAClBC,QAAAA,GAAG,GAAGE,IAAI,CAACC,KAAL,CAAW,CAACL,IAAI,GAAGC,KAAR,IAAiB,CAA5B,CAAN;AACAE,QAAAA,KAAK,GAAG,KAAKjB,IAAL,CAAUW,IAAV,EAAgB,KAAKJ,MAAL,CAAYS,GAAZ,CAAhB,CAAR;;AACA,YAAIC,KAAK,GAAG,CAAZ,EAAe;AACXH,UAAAA,IAAI,GAAGE,GAAG,GAAG,CAAb;AACH,SAFD,MAGK,IAAIC,KAAK,GAAG,CAAZ,EAAe;AAChBF,UAAAA,KAAK,GAAGC,GAAG,GAAG,CAAd;AACH,SAFI,MAGA;AACDF,UAAAA,IAAI,GAAGE,GAAP;AACAD,UAAAA,KAAK,GAAG,CAAC,CAAT;AACH;AACJ;;AACD,WAAKR,MAAL,CAAYa,MAAZ,CAAmBN,IAAnB,EAAyB,CAAzB,EAA4BH,IAA5B;AACAC,MAAAA,MAAM;AACT,KA9Bc,CA+Bf;;;AACA,QAAIA,MAAM,KAAK,KAAKT,YAApB,EAAkC;AAC9B,WAAKkB,KAAL,CAAW,KAAKd,MAAL,CAAYe,GAAZ,EAAX;AACH;;AACDZ,IAAAA,IAAI;AACP,GA9CwD,CA+CzD;;;AACAa,EAAAA,MAAM,CAACb,IAAD,EAAO;AACT,QAAI;AAAEE,MAAAA;AAAF,QAAa,KAAKL,MAAtB;;AACA,WAAOK,MAAM,EAAb,EAAiB;AACb,WAAKS,KAAL,CAAW,KAAKd,MAAL,CAAYe,GAAZ,EAAX;AACH;;AACDZ,IAAAA,IAAI;AACP;;AAtDwD;;AAwD7DlB,OAAO,CAACE,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SortIterator = void 0;\nconst asynciterator_1 = require(\"asynciterator\");\n// Based on https://github.com/LinkedDataFragments/Client.js/blob/master/lib/sparql/SortIterator.js\nclass SortIterator extends asynciterator_1.TransformIterator {\n    constructor(source, sort, options) {\n        super(source, options);\n        // The `window` parameter indicates the length of the sliding window to apply sorting\n        const window = options && options.window;\n        this.windowLength = Number.isFinite(window) && window > 0 ? window : Number.POSITIVE_INFINITY;\n        this.sort = sort;\n        this.sorted = [];\n    }\n    // Reads the smallest item in the current sorting window\n    _read(count, done) {\n        let item;\n        let { length } = this.sorted;\n        // Try to read items until we reach the desired window length\n        while (length !== this.windowLength) {\n            item = this.source.read();\n            if (item === null) {\n                break;\n            }\n            // Insert the item in the sorted window (smallest last)\n            let left = 0;\n            let right = length - 1;\n            let mid;\n            let order;\n            while (left <= right) {\n                mid = Math.trunc((left + right) / 2);\n                order = this.sort(item, this.sorted[mid]);\n                if (order < 0) {\n                    left = mid + 1;\n                }\n                else if (order > 0) {\n                    right = mid - 1;\n                }\n                else {\n                    left = mid;\n                    right = -1;\n                }\n            }\n            this.sorted.splice(left, 0, item);\n            length++;\n        }\n        // Push the smallest item in the window\n        if (length === this.windowLength) {\n            this._push(this.sorted.pop());\n        }\n        done();\n    }\n    // Flushes remaining data after the source has ended\n    _flush(done) {\n        let { length } = this.sorted;\n        while (length--) {\n            this._push(this.sorted.pop());\n        }\n        done();\n    }\n}\nexports.SortIterator = SortIterator;\n//# sourceMappingURL=SortIterator.js.map"]},"metadata":{},"sourceType":"script"}