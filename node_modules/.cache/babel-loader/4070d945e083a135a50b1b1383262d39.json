{"ast":null,"code":"// **N3Writer** writes N3 documents.\nimport namespaces from './IRIs';\nimport { default as N3DataFactory, Term } from './N3DataFactory';\nimport { isDefaultGraph } from './N3Util';\nconst DEFAULTGRAPH = N3DataFactory.defaultGraph();\nconst {\n  rdf,\n  xsd\n} = namespaces; // Characters in literals that require escaping\n\nconst escape = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n      escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n      escapedCharacters = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n}; // ## Placeholder class to represent already pretty-printed terms\n\nclass SerializedTerm extends Term {\n  // Pretty-printed nodes are not equal to any other node\n  // (e.g., [] does not equal [])\n  equals() {\n    return false;\n  }\n\n} // ## Constructor\n\n\nexport default class N3Writer {\n  constructor(outputStream, options) {\n    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n    this._prefixRegex = /$0^/; // Shift arguments if the first argument is not a stream\n\n    if (outputStream && typeof outputStream.write !== 'function') options = outputStream, outputStream = null;\n    options = options || {};\n    this._lists = options.lists; // If no output stream given, send the output as string through the end callback\n\n    if (!outputStream) {\n      let output = '';\n      this._outputStream = {\n        write(chunk, encoding, done) {\n          output += chunk;\n          done && done();\n        },\n\n        end: done => {\n          done && done(null, output);\n        }\n      };\n      this._endStream = true;\n    } else {\n      this._outputStream = outputStream;\n      this._endStream = options.end === undefined ? true : !!options.end;\n    } // Initialize writer, depending on the format\n\n\n    this._subject = null;\n\n    if (!/triple|quad/i.test(options.format)) {\n      this._lineMode = false;\n      this._graph = DEFAULTGRAPH;\n      this._baseIRI = options.baseIRI;\n      this._prefixIRIs = Object.create(null);\n      options.prefixes && this.addPrefixes(options.prefixes);\n    } else {\n      this._lineMode = true;\n      this._writeQuad = this._writeQuadLine;\n    }\n  } // ## Private methods\n  // ### Whether the current graph is the default graph\n\n\n  get _inDefaultGraph() {\n    return DEFAULTGRAPH.equals(this._graph);\n  } // ### `_write` writes the argument to the output stream\n\n\n  _write(string, callback) {\n    this._outputStream.write(string, 'utf8', callback);\n  } // ### `_writeQuad` writes the quad to the output stream\n\n\n  _writeQuad(subject, predicate, object, graph, done) {\n    try {\n      // Write the graph's label if it has changed\n      if (!graph.equals(this._graph)) {\n        // Close the previous graph and start the new one\n        this._write((this._subject === null ? '' : this._inDefaultGraph ? '.\\n' : '\\n}\\n') + (DEFAULTGRAPH.equals(graph) ? '' : `${this._encodeIriOrBlank(graph)} {\\n`));\n\n        this._graph = graph;\n        this._subject = null;\n      } // Don't repeat the subject if it's the same\n\n\n      if (subject.equals(this._subject)) {\n        // Don't repeat the predicate if it's the same\n        if (predicate.equals(this._predicate)) this._write(`, ${this._encodeObject(object)}`, done); // Same subject, different predicate\n        else this._write(`;\\n    ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);\n      } // Different subject; write the whole quad\n      else this._write(`${(this._subject === null ? '' : '.\\n') + this._encodeSubject(this._subject = subject)} ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);\n    } catch (error) {\n      done && done(error);\n    }\n  } // ### `_writeQuadLine` writes the quad to the output stream as a single line\n\n\n  _writeQuadLine(subject, predicate, object, graph, done) {\n    // Write the quad without prefixes\n    delete this._prefixMatch;\n\n    this._write(this.quadToString(subject, predicate, object, graph), done);\n  } // ### `quadToString` serializes a quad as a string\n\n\n  quadToString(subject, predicate, object, graph) {\n    return `${this._encodeSubject(subject)} ${this._encodeIriOrBlank(predicate)} ${this._encodeObject(object)}${graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .\\n` : ' .\\n'}`;\n  } // ### `quadsToString` serializes an array of quads as a string\n\n\n  quadsToString(quads) {\n    return quads.map(t => {\n      return this.quadToString(t.subject, t.predicate, t.object, t.graph);\n    }).join('');\n  } // ### `_encodeSubject` represents a subject\n\n\n  _encodeSubject(entity) {\n    return entity.termType === 'Quad' ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);\n  } // ### `_encodeIriOrBlank` represents an IRI or blank node\n\n\n  _encodeIriOrBlank(entity) {\n    // A blank node or list is represented as-is\n    if (entity.termType !== 'NamedNode') {\n      // If it is a list head, pretty-print it\n      if (this._lists && entity.value in this._lists) entity = this.list(this._lists[entity.value]);\n      return 'id' in entity ? entity.id : `_:${entity.value}`;\n    }\n\n    let iri = entity.value; // Use relative IRIs if requested and possible\n\n    if (this._baseIRI && iri.startsWith(this._baseIRI)) iri = iri.substr(this._baseIRI.length); // Escape special characters\n\n    if (escape.test(iri)) iri = iri.replace(escapeAll, characterReplacer); // Try to represent the IRI as prefixed name\n\n    const prefixMatch = this._prefixRegex.exec(iri);\n\n    return !prefixMatch ? `<${iri}>` : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];\n  } // ### `_encodeLiteral` represents a literal\n\n\n  _encodeLiteral(literal) {\n    // Escape special characters\n    let value = literal.value;\n    if (escape.test(value)) value = value.replace(escapeAll, characterReplacer); // Write a language-tagged literal\n\n    if (literal.language) return `\"${value}\"@${literal.language}`; // Write dedicated literals per data type\n\n    if (this._lineMode) {\n      // Only abbreviate strings in N-Triples or N-Quads\n      if (literal.datatype.value === xsd.string) return `\"${value}\"`;\n    } else {\n      // Use common datatype abbreviations in Turtle or TriG\n      switch (literal.datatype.value) {\n        case xsd.string:\n          return `\"${value}\"`;\n\n        case xsd.boolean:\n          if (value === 'true' || value === 'false') return value;\n          break;\n\n        case xsd.integer:\n          if (/^[+-]?\\d+$/.test(value)) return value;\n          break;\n\n        case xsd.decimal:\n          if (/^[+-]?\\d*\\.\\d+$/.test(value)) return value;\n          break;\n\n        case xsd.double:\n          if (/^[+-]?(?:\\d+\\.\\d*|\\.?\\d+)[eE][+-]?\\d+$/.test(value)) return value;\n          break;\n      }\n    } // Write a regular datatyped literal\n\n\n    return `\"${value}\"^^${this._encodeIriOrBlank(literal.datatype)}`;\n  } // ### `_encodePredicate` represents a predicate\n\n\n  _encodePredicate(predicate) {\n    return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);\n  } // ### `_encodeObject` represents an object\n\n\n  _encodeObject(object) {\n    switch (object.termType) {\n      case 'Quad':\n        return this._encodeQuad(object);\n\n      case 'Literal':\n        return this._encodeLiteral(object);\n\n      default:\n        return this._encodeIriOrBlank(object);\n    }\n  } // ### `_encodeQuad` encodes an RDF* quad\n\n\n  _encodeQuad({\n    subject,\n    predicate,\n    object,\n    graph\n  }) {\n    return `<<${this._encodeSubject(subject)} ${this._encodePredicate(predicate)} ${this._encodeObject(object)}${isDefaultGraph(graph) ? '' : ` ${this._encodeIriOrBlank(graph)}`}>>`;\n  } // ### `_blockedWrite` replaces `_write` after the writer has been closed\n\n\n  _blockedWrite() {\n    throw new Error('Cannot write because the writer has been closed.');\n  } // ### `addQuad` adds the quad to the output stream\n\n\n  addQuad(subject, predicate, object, graph, done) {\n    // The quad was given as an object, so shift parameters\n    if (object === undefined) this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate); // The optional `graph` parameter was not provided\n    else if (typeof graph === 'function') this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph); // The `graph` parameter was provided\n    else this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);\n  } // ### `addQuads` adds the quads to the output stream\n\n\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++) this.addQuad(quads[i]);\n  } // ### `addPrefix` adds the prefix to the output stream\n\n\n  addPrefix(prefix, iri, done) {\n    const prefixes = {};\n    prefixes[prefix] = iri;\n    this.addPrefixes(prefixes, done);\n  } // ### `addPrefixes` adds the prefixes to the output stream\n\n\n  addPrefixes(prefixes, done) {\n    // Ignore prefixes if not supported by the serialization\n    if (!this._prefixIRIs) return done && done(); // Write all new prefixes\n\n    let hasPrefixes = false;\n\n    for (let prefix in prefixes) {\n      let iri = prefixes[prefix];\n      if (typeof iri !== 'string') iri = iri.value;\n      hasPrefixes = true; // Finish a possible pending quad\n\n      if (this._subject !== null) {\n        this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n\n        this._subject = null, this._graph = '';\n      } // Store and write the prefix\n\n\n      this._prefixIRIs[iri] = prefix += ':';\n\n      this._write(`@prefix ${prefix} <${iri}>.\\n`);\n    } // Recreate the prefix matcher\n\n\n    if (hasPrefixes) {\n      let IRIlist = '',\n          prefixList = '';\n\n      for (const prefixIRI in this._prefixIRIs) {\n        IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;\n        prefixList += (prefixList ? '|' : '') + this._prefixIRIs[prefixIRI];\n      }\n\n      IRIlist = IRIlist.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n      this._prefixRegex = new RegExp(`^(?:${prefixList})[^\\/]*$|` + `^(${IRIlist})([a-zA-Z][\\\\-_a-zA-Z0-9]*)$`);\n    } // End a prefix block with a newline\n\n\n    this._write(hasPrefixes ? '\\n' : '', done);\n  } // ### `blank` creates a blank node with the given content\n\n\n  blank(predicate, object) {\n    let children = predicate,\n        child,\n        length; // Empty blank node\n\n    if (predicate === undefined) children = []; // Blank node passed as blank(Term(\"predicate\"), Term(\"object\"))\n    else if (predicate.termType) children = [{\n      predicate: predicate,\n      object: object\n    }]; // Blank node passed as blank({ predicate: predicate, object: object })\n    else if (!('length' in predicate)) children = [predicate];\n\n    switch (length = children.length) {\n      // Generate an empty blank node\n      case 0:\n        return new SerializedTerm('[]');\n      // Generate a non-nested one-triple blank node\n\n      case 1:\n        child = children[0];\n        if (!(child.object instanceof SerializedTerm)) return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)} ]`);\n      // Generate a multi-triple or nested blank node\n\n      default:\n        let contents = '['; // Write all triples in order\n\n        for (let i = 0; i < length; i++) {\n          child = children[i]; // Write only the object is the predicate is the same as the previous\n\n          if (child.predicate.equals(predicate)) contents += `, ${this._encodeObject(child.object)}`; // Otherwise, write the predicate and the object\n          else {\n            contents += `${(i ? ';\\n  ' : '\\n  ') + this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)}`;\n            predicate = child.predicate;\n          }\n        }\n\n        return new SerializedTerm(`${contents}\\n]`);\n    }\n  } // ### `list` creates a list node with the given content\n\n\n  list(elements) {\n    const length = elements && elements.length || 0,\n          contents = new Array(length);\n\n    for (let i = 0; i < length; i++) contents[i] = this._encodeObject(elements[i]);\n\n    return new SerializedTerm(`(${contents.join(' ')})`);\n  } // ### `end` signals the end of the output stream\n\n\n  end(done) {\n    // Finish a possible pending quad\n    if (this._subject !== null) {\n      this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n\n      this._subject = null;\n    } // Disallow further writing\n\n\n    this._write = this._blockedWrite; // Try to end the underlying stream, ensuring done is called exactly one time\n\n    let singleDone = done && ((error, result) => {\n      singleDone = null, done(error, result);\n    });\n\n    if (this._endStream) {\n      try {\n        return this._outputStream.end(singleDone);\n      } catch (error) {\n        /* error closing stream */\n      }\n    }\n\n    singleDone && singleDone();\n  }\n\n} // Replaces a character by its escaped version\n\nfunction characterReplacer(character) {\n  // Replace a single character by its escaped version\n  let result = escapedCharacters[character];\n\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    } // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n      result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n      result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/n3/src/N3Writer.js"],"names":["namespaces","default","N3DataFactory","Term","isDefaultGraph","DEFAULTGRAPH","defaultGraph","rdf","xsd","escape","escapeAll","escapedCharacters","SerializedTerm","equals","N3Writer","constructor","outputStream","options","_prefixRegex","write","_lists","lists","output","_outputStream","chunk","encoding","done","end","_endStream","undefined","_subject","test","format","_lineMode","_graph","_baseIRI","baseIRI","_prefixIRIs","Object","create","prefixes","addPrefixes","_writeQuad","_writeQuadLine","_inDefaultGraph","_write","string","callback","subject","predicate","object","graph","_encodeIriOrBlank","_predicate","_encodeObject","_encodePredicate","_encodeSubject","error","_prefixMatch","quadToString","value","quadsToString","quads","map","t","join","entity","termType","_encodeQuad","list","id","iri","startsWith","substr","length","replace","characterReplacer","prefixMatch","exec","_encodeLiteral","literal","language","datatype","boolean","integer","decimal","double","type","_blockedWrite","Error","addQuad","addQuads","i","addPrefix","prefix","hasPrefixes","IRIlist","prefixList","prefixIRI","RegExp","blank","children","child","contents","elements","Array","singleDone","result","character","charCodeAt","toString"],"mappings":"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","sourcesContent":["// **N3Writer** writes N3 documents.\nimport namespaces from './IRIs';\nimport { default as N3DataFactory, Term } from './N3DataFactory';\nimport { isDefaultGraph } from './N3Util';\n\nconst DEFAULTGRAPH = N3DataFactory.defaultGraph();\n\nconst { rdf, xsd } = namespaces;\n\n// Characters in literals that require escaping\nconst escape    = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n    escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n    escapedCharacters = {\n      '\\\\': '\\\\\\\\', '\"': '\\\\\"', '\\t': '\\\\t',\n      '\\n': '\\\\n', '\\r': '\\\\r', '\\b': '\\\\b', '\\f': '\\\\f',\n    };\n\n// ## Placeholder class to represent already pretty-printed terms\nclass SerializedTerm extends Term {\n  // Pretty-printed nodes are not equal to any other node\n  // (e.g., [] does not equal [])\n  equals() {\n    return false;\n  }\n}\n\n// ## Constructor\nexport default class N3Writer {\n  constructor(outputStream, options) {\n    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n    this._prefixRegex = /$0^/;\n\n    // Shift arguments if the first argument is not a stream\n    if (outputStream && typeof outputStream.write !== 'function')\n      options = outputStream, outputStream = null;\n    options = options || {};\n    this._lists = options.lists;\n\n    // If no output stream given, send the output as string through the end callback\n    if (!outputStream) {\n      let output = '';\n      this._outputStream = {\n        write(chunk, encoding, done) { output += chunk; done && done(); },\n        end: done => { done && done(null, output); },\n      };\n      this._endStream = true;\n    }\n    else {\n      this._outputStream = outputStream;\n      this._endStream = options.end === undefined ? true : !!options.end;\n    }\n\n    // Initialize writer, depending on the format\n    this._subject = null;\n    if (!(/triple|quad/i).test(options.format)) {\n      this._lineMode = false;\n      this._graph = DEFAULTGRAPH;\n      this._baseIRI = options.baseIRI;\n      this._prefixIRIs = Object.create(null);\n      options.prefixes && this.addPrefixes(options.prefixes);\n    }\n    else {\n      this._lineMode = true;\n      this._writeQuad = this._writeQuadLine;\n    }\n  }\n\n  // ## Private methods\n\n  // ### Whether the current graph is the default graph\n  get _inDefaultGraph() {\n    return DEFAULTGRAPH.equals(this._graph);\n  }\n\n  // ### `_write` writes the argument to the output stream\n  _write(string, callback) {\n    this._outputStream.write(string, 'utf8', callback);\n  }\n\n  // ### `_writeQuad` writes the quad to the output stream\n  _writeQuad(subject, predicate, object, graph, done) {\n    try {\n      // Write the graph's label if it has changed\n      if (!graph.equals(this._graph)) {\n        // Close the previous graph and start the new one\n        this._write((this._subject === null ? '' : (this._inDefaultGraph ? '.\\n' : '\\n}\\n')) +\n                    (DEFAULTGRAPH.equals(graph) ? '' : `${this._encodeIriOrBlank(graph)} {\\n`));\n        this._graph = graph;\n        this._subject = null;\n      }\n      // Don't repeat the subject if it's the same\n      if (subject.equals(this._subject)) {\n        // Don't repeat the predicate if it's the same\n        if (predicate.equals(this._predicate))\n          this._write(`, ${this._encodeObject(object)}`, done);\n        // Same subject, different predicate\n        else\n          this._write(`;\\n    ${\n                      this._encodePredicate(this._predicate = predicate)} ${\n                      this._encodeObject(object)}`, done);\n      }\n      // Different subject; write the whole quad\n      else\n        this._write(`${(this._subject === null ? '' : '.\\n') +\n                    this._encodeSubject(this._subject = subject)} ${\n                    this._encodePredicate(this._predicate = predicate)} ${\n                    this._encodeObject(object)}`, done);\n    }\n    catch (error) { done && done(error); }\n  }\n\n  // ### `_writeQuadLine` writes the quad to the output stream as a single line\n  _writeQuadLine(subject, predicate, object, graph, done) {\n    // Write the quad without prefixes\n    delete this._prefixMatch;\n    this._write(this.quadToString(subject, predicate, object, graph), done);\n  }\n\n  // ### `quadToString` serializes a quad as a string\n  quadToString(subject, predicate, object, graph) {\n    return  `${this._encodeSubject(subject)} ${\n            this._encodeIriOrBlank(predicate)} ${\n            this._encodeObject(object)\n            }${graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .\\n` : ' .\\n'}`;\n  }\n\n  // ### `quadsToString` serializes an array of quads as a string\n  quadsToString(quads) {\n    return quads.map(t => {\n      return this.quadToString(t.subject, t.predicate, t.object, t.graph);\n    }).join('');\n  }\n\n  // ### `_encodeSubject` represents a subject\n  _encodeSubject(entity) {\n    return entity.termType === 'Quad' ?\n      this._encodeQuad(entity) : this._encodeIriOrBlank(entity);\n  }\n\n  // ### `_encodeIriOrBlank` represents an IRI or blank node\n  _encodeIriOrBlank(entity) {\n    // A blank node or list is represented as-is\n    if (entity.termType !== 'NamedNode') {\n      // If it is a list head, pretty-print it\n      if (this._lists && (entity.value in this._lists))\n        entity = this.list(this._lists[entity.value]);\n      return 'id' in entity ? entity.id : `_:${entity.value}`;\n    }\n    let iri = entity.value;\n    // Use relative IRIs if requested and possible\n    if (this._baseIRI && iri.startsWith(this._baseIRI))\n      iri = iri.substr(this._baseIRI.length);\n    // Escape special characters\n    if (escape.test(iri))\n      iri = iri.replace(escapeAll, characterReplacer);\n    // Try to represent the IRI as prefixed name\n    const prefixMatch = this._prefixRegex.exec(iri);\n    return !prefixMatch ? `<${iri}>` :\n           (!prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2]);\n  }\n\n  // ### `_encodeLiteral` represents a literal\n  _encodeLiteral(literal) {\n    // Escape special characters\n    let value = literal.value;\n    if (escape.test(value))\n      value = value.replace(escapeAll, characterReplacer);\n\n    // Write a language-tagged literal\n    if (literal.language)\n      return `\"${value}\"@${literal.language}`;\n\n    // Write dedicated literals per data type\n    if (this._lineMode) {\n      // Only abbreviate strings in N-Triples or N-Quads\n      if (literal.datatype.value === xsd.string)\n        return `\"${value}\"`;\n    }\n    else {\n      // Use common datatype abbreviations in Turtle or TriG\n      switch (literal.datatype.value) {\n      case xsd.string:\n        return `\"${value}\"`;\n      case xsd.boolean:\n        if (value === 'true' || value === 'false')\n          return value;\n        break;\n      case xsd.integer:\n        if (/^[+-]?\\d+$/.test(value))\n          return value;\n        break;\n      case xsd.decimal:\n        if (/^[+-]?\\d*\\.\\d+$/.test(value))\n          return value;\n        break;\n      case xsd.double:\n        if (/^[+-]?(?:\\d+\\.\\d*|\\.?\\d+)[eE][+-]?\\d+$/.test(value))\n          return value;\n        break;\n      }\n    }\n\n    // Write a regular datatyped literal\n    return `\"${value}\"^^${this._encodeIriOrBlank(literal.datatype)}`;\n  }\n\n  // ### `_encodePredicate` represents a predicate\n  _encodePredicate(predicate) {\n    return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);\n  }\n\n  // ### `_encodeObject` represents an object\n  _encodeObject(object) {\n    switch (object.termType) {\n    case 'Quad':\n      return this._encodeQuad(object);\n    case 'Literal':\n      return this._encodeLiteral(object);\n    default:\n      return this._encodeIriOrBlank(object);\n    }\n  }\n\n  // ### `_encodeQuad` encodes an RDF* quad\n  _encodeQuad({ subject, predicate, object, graph }) {\n    return `<<${\n      this._encodeSubject(subject)} ${\n      this._encodePredicate(predicate)} ${\n      this._encodeObject(object)}${\n      isDefaultGraph(graph) ? '' : ` ${this._encodeIriOrBlank(graph)}`}>>`;\n  }\n\n  // ### `_blockedWrite` replaces `_write` after the writer has been closed\n  _blockedWrite() {\n    throw new Error('Cannot write because the writer has been closed.');\n  }\n\n  // ### `addQuad` adds the quad to the output stream\n  addQuad(subject, predicate, object, graph, done) {\n    // The quad was given as an object, so shift parameters\n    if (object === undefined)\n      this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);\n    // The optional `graph` parameter was not provided\n    else if (typeof graph === 'function')\n      this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph);\n    // The `graph` parameter was provided\n    else\n      this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);\n  }\n\n  // ### `addQuads` adds the quads to the output stream\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.addQuad(quads[i]);\n  }\n\n  // ### `addPrefix` adds the prefix to the output stream\n  addPrefix(prefix, iri, done) {\n    const prefixes = {};\n    prefixes[prefix] = iri;\n    this.addPrefixes(prefixes, done);\n  }\n\n  // ### `addPrefixes` adds the prefixes to the output stream\n  addPrefixes(prefixes, done) {\n    // Ignore prefixes if not supported by the serialization\n    if (!this._prefixIRIs)\n      return done && done();\n\n    // Write all new prefixes\n    let hasPrefixes = false;\n    for (let prefix in prefixes) {\n      let iri = prefixes[prefix];\n      if (typeof iri !== 'string')\n        iri = iri.value;\n      hasPrefixes = true;\n      // Finish a possible pending quad\n      if (this._subject !== null) {\n        this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n        this._subject = null, this._graph = '';\n      }\n      // Store and write the prefix\n      this._prefixIRIs[iri] = (prefix += ':');\n      this._write(`@prefix ${prefix} <${iri}>.\\n`);\n    }\n    // Recreate the prefix matcher\n    if (hasPrefixes) {\n      let IRIlist = '', prefixList = '';\n      for (const prefixIRI in this._prefixIRIs) {\n        IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;\n        prefixList += (prefixList ? '|' : '') + this._prefixIRIs[prefixIRI];\n      }\n      IRIlist = IRIlist.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n      this._prefixRegex = new RegExp(`^(?:${prefixList})[^\\/]*$|` +\n                                     `^(${IRIlist})([a-zA-Z][\\\\-_a-zA-Z0-9]*)$`);\n    }\n    // End a prefix block with a newline\n    this._write(hasPrefixes ? '\\n' : '', done);\n  }\n\n  // ### `blank` creates a blank node with the given content\n  blank(predicate, object) {\n    let children = predicate, child, length;\n    // Empty blank node\n    if (predicate === undefined)\n      children = [];\n    // Blank node passed as blank(Term(\"predicate\"), Term(\"object\"))\n    else if (predicate.termType)\n      children = [{ predicate: predicate, object: object }];\n    // Blank node passed as blank({ predicate: predicate, object: object })\n    else if (!('length' in predicate))\n      children = [predicate];\n\n    switch (length = children.length) {\n    // Generate an empty blank node\n    case 0:\n      return new SerializedTerm('[]');\n    // Generate a non-nested one-triple blank node\n    case 1:\n      child = children[0];\n      if (!(child.object instanceof SerializedTerm))\n        return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${\n                                  this._encodeObject(child.object)} ]`);\n    // Generate a multi-triple or nested blank node\n    default:\n      let contents = '[';\n      // Write all triples in order\n      for (let i = 0; i < length; i++) {\n        child = children[i];\n        // Write only the object is the predicate is the same as the previous\n        if (child.predicate.equals(predicate))\n          contents += `, ${this._encodeObject(child.object)}`;\n        // Otherwise, write the predicate and the object\n        else {\n          contents += `${(i ? ';\\n  ' : '\\n  ') +\n                      this._encodePredicate(child.predicate)} ${\n                      this._encodeObject(child.object)}`;\n          predicate = child.predicate;\n        }\n      }\n      return new SerializedTerm(`${contents}\\n]`);\n    }\n  }\n\n  // ### `list` creates a list node with the given content\n  list(elements) {\n    const length = elements && elements.length || 0, contents = new Array(length);\n    for (let i = 0; i < length; i++)\n      contents[i] = this._encodeObject(elements[i]);\n    return new SerializedTerm(`(${contents.join(' ')})`);\n  }\n\n  // ### `end` signals the end of the output stream\n  end(done) {\n    // Finish a possible pending quad\n    if (this._subject !== null) {\n      this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n      this._subject = null;\n    }\n    // Disallow further writing\n    this._write = this._blockedWrite;\n\n    // Try to end the underlying stream, ensuring done is called exactly one time\n    let singleDone = done && ((error, result) => { singleDone = null, done(error, result); });\n    if (this._endStream) {\n      try { return this._outputStream.end(singleDone); }\n      catch (error) { /* error closing stream */ }\n    }\n    singleDone && singleDone();\n  }\n}\n\n// Replaces a character by its escaped version\nfunction characterReplacer(character) {\n  // Replace a single character by its escaped version\n  let result = escapedCharacters[character];\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    }\n    // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n      result = ((character.charCodeAt(0) - 0xD800) * 0x400 +\n                 character.charCodeAt(1) + 0x2400).toString(16);\n      result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n    }\n  }\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}