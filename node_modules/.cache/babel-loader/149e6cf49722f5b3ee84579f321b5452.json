{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorRdfMetadataExtractHydraControls = void 0;\n\nconst bus_rdf_metadata_extract_1 = require(\"@comunica/bus-rdf-metadata-extract\");\n\nconst uritemplate_1 = require(\"uritemplate\");\n/**\n * An RDF Metadata Extract Actor that extracts all Hydra controls from the metadata stream.\n */\n\n\nclass ActorRdfMetadataExtractHydraControls extends bus_rdf_metadata_extract_1.ActorRdfMetadataExtract {\n  constructor(args) {\n    super(args);\n    this.parsedUriTemplateCache = {};\n  }\n\n  async test(action) {\n    return true;\n  }\n  /**\n   * Collect all Hydra page links from the given Hydra properties object.\n   * @param pageUrl The page URL in which the Hydra properties are defined.\n   * @param hydraProperties The collected Hydra properties.\n   * @return The Hydra links\n   */\n\n\n  getLinks(pageUrl, hydraProperties) {\n    return ActorRdfMetadataExtractHydraControls.LINK_TYPES.reduce((metadata, link) => {\n      // First check the correct hydra:next, then the deprecated hydra:nextPage\n      const links = hydraProperties[link] || hydraProperties[`${link}Page`];\n      const linkTargets = links && links[pageUrl];\n      metadata[link] = linkTargets && linkTargets.length > 0 ? linkTargets[0] : null;\n      return metadata;\n    }, {});\n  }\n  /**\n   * Parse a URI template, or retrieve it from a cache.\n   * @param {string} template A URI template string.\n   * @return {} A parsed URI template object.\n   */\n\n\n  parseUriTemplateCached(template) {\n    const cachedUriTemplate = this.parsedUriTemplateCache[template];\n\n    if (cachedUriTemplate) {\n      return cachedUriTemplate;\n    } // eslint-disable-next-line no-return-assign\n\n\n    return this.parsedUriTemplateCache[template] = uritemplate_1.parse(template);\n  }\n  /**\n   * Collect all search forms from the given Hydra properties object.\n   * @param hydraProperties The collected Hydra properties.\n   * @return The search forms.\n   */\n\n\n  getSearchForms(hydraProperties) {\n    const searchFormData = hydraProperties.search;\n    const searchForms = [];\n\n    if (searchFormData) {\n      for (const dataset in searchFormData) {\n        for (const searchFormId of searchFormData[dataset]) {\n          const searchTemplates = (hydraProperties.template || {})[searchFormId] || []; // Parse the template\n\n          if (searchTemplates.length !== 1) {\n            throw new Error(`Expected 1 hydra:template for ${searchFormId}`);\n          }\n\n          const template = searchTemplates[0];\n          const searchTemplate = this.parseUriTemplateCached(template); // Parse the template mappings\n\n          const mappings = ((hydraProperties.mapping || {})[searchFormId] || []).reduce((acc, mapping) => {\n            const variable = ((hydraProperties.variable || {})[mapping] || [])[0];\n            const property = ((hydraProperties.property || {})[mapping] || [])[0];\n\n            if (!variable) {\n              throw new Error(`Expected a hydra:variable for ${mapping}`);\n            }\n\n            if (!property) {\n              throw new Error(`Expected a hydra:property for ${mapping}`);\n            }\n\n            acc[property] = variable;\n            return acc;\n          }, {}); // Gets the URL of the Triple Pattern Fragment with the given triple pattern\n\n          const getUri = entries => searchTemplate.expand(Object.keys(entries).reduce((variables, key) => {\n            variables[mappings[key]] = entries[key];\n            return variables;\n          }, {}));\n\n          searchForms.push({\n            dataset,\n            template,\n            mappings,\n            getUri\n          });\n        }\n      }\n    }\n\n    return {\n      values: searchForms\n    };\n  }\n  /**\n   * Collect all hydra properties from a given metadata stream\n   * in a nice convenient nested hash (property / subject / objects).\n   * @param {RDF.Stream} metadata\n   * @return The collected Hydra properties.\n   */\n\n\n  getHydraProperties(metadata) {\n    return new Promise((resolve, reject) => {\n      metadata.on('error', reject); // Collect all hydra properties in a nice convenient nested hash (property / subject / objects).\n\n      const hydraProperties = {};\n      metadata.on('data', quad => {\n        if (quad.predicate.value.startsWith(ActorRdfMetadataExtractHydraControls.HYDRA)) {\n          const property = quad.predicate.value.slice(ActorRdfMetadataExtractHydraControls.HYDRA.length);\n          const subjectProperties = hydraProperties[property] || (hydraProperties[property] = {});\n          const objects = subjectProperties[quad.subject.value] || (subjectProperties[quad.subject.value] = []);\n          objects.push(quad.object.value);\n        }\n      });\n      metadata.on('end', () => resolve(hydraProperties));\n    });\n  }\n\n  async run(action) {\n    const metadata = {};\n    const hydraProperties = await this.getHydraProperties(action.metadata);\n    Object.assign(metadata, this.getLinks(action.url, hydraProperties));\n    metadata.searchForms = this.getSearchForms(hydraProperties);\n    return {\n      metadata\n    };\n  }\n\n}\n\nexports.ActorRdfMetadataExtractHydraControls = ActorRdfMetadataExtractHydraControls;\nActorRdfMetadataExtractHydraControls.HYDRA = 'http://www.w3.org/ns/hydra/core#';\nActorRdfMetadataExtractHydraControls.LINK_TYPES = ['first', 'next', 'previous', 'last'];","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-rdf-metadata-extract-hydra-controls/lib/ActorRdfMetadataExtractHydraControls.js"],"names":["Object","defineProperty","exports","value","ActorRdfMetadataExtractHydraControls","bus_rdf_metadata_extract_1","require","uritemplate_1","ActorRdfMetadataExtract","constructor","args","parsedUriTemplateCache","test","action","getLinks","pageUrl","hydraProperties","LINK_TYPES","reduce","metadata","link","links","linkTargets","length","parseUriTemplateCached","template","cachedUriTemplate","parse","getSearchForms","searchFormData","search","searchForms","dataset","searchFormId","searchTemplates","Error","searchTemplate","mappings","mapping","acc","variable","property","getUri","entries","expand","keys","variables","key","push","values","getHydraProperties","Promise","resolve","reject","on","quad","predicate","startsWith","HYDRA","slice","subjectProperties","objects","subject","object","run","assign","url"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorRdfMetadataExtractHydraControls = void 0;\nconst bus_rdf_metadata_extract_1 = require(\"@comunica/bus-rdf-metadata-extract\");\nconst uritemplate_1 = require(\"uritemplate\");\n/**\n * An RDF Metadata Extract Actor that extracts all Hydra controls from the metadata stream.\n */\nclass ActorRdfMetadataExtractHydraControls extends bus_rdf_metadata_extract_1.ActorRdfMetadataExtract {\n    constructor(args) {\n        super(args);\n        this.parsedUriTemplateCache = {};\n    }\n    async test(action) {\n        return true;\n    }\n    /**\n     * Collect all Hydra page links from the given Hydra properties object.\n     * @param pageUrl The page URL in which the Hydra properties are defined.\n     * @param hydraProperties The collected Hydra properties.\n     * @return The Hydra links\n     */\n    getLinks(pageUrl, hydraProperties) {\n        return ActorRdfMetadataExtractHydraControls.LINK_TYPES.reduce((metadata, link) => {\n            // First check the correct hydra:next, then the deprecated hydra:nextPage\n            const links = hydraProperties[link] || hydraProperties[`${link}Page`];\n            const linkTargets = links && links[pageUrl];\n            metadata[link] = linkTargets && linkTargets.length > 0 ? linkTargets[0] : null;\n            return metadata;\n        }, {});\n    }\n    /**\n     * Parse a URI template, or retrieve it from a cache.\n     * @param {string} template A URI template string.\n     * @return {} A parsed URI template object.\n     */\n    parseUriTemplateCached(template) {\n        const cachedUriTemplate = this.parsedUriTemplateCache[template];\n        if (cachedUriTemplate) {\n            return cachedUriTemplate;\n        }\n        // eslint-disable-next-line no-return-assign\n        return this.parsedUriTemplateCache[template] = uritemplate_1.parse(template);\n    }\n    /**\n     * Collect all search forms from the given Hydra properties object.\n     * @param hydraProperties The collected Hydra properties.\n     * @return The search forms.\n     */\n    getSearchForms(hydraProperties) {\n        const searchFormData = hydraProperties.search;\n        const searchForms = [];\n        if (searchFormData) {\n            for (const dataset in searchFormData) {\n                for (const searchFormId of searchFormData[dataset]) {\n                    const searchTemplates = (hydraProperties.template || {})[searchFormId] || [];\n                    // Parse the template\n                    if (searchTemplates.length !== 1) {\n                        throw new Error(`Expected 1 hydra:template for ${searchFormId}`);\n                    }\n                    const template = searchTemplates[0];\n                    const searchTemplate = this.parseUriTemplateCached(template);\n                    // Parse the template mappings\n                    const mappings = ((hydraProperties.mapping || {})[searchFormId] || [])\n                        .reduce((acc, mapping) => {\n                        const variable = ((hydraProperties.variable || {})[mapping] || [])[0];\n                        const property = ((hydraProperties.property || {})[mapping] || [])[0];\n                        if (!variable) {\n                            throw new Error(`Expected a hydra:variable for ${mapping}`);\n                        }\n                        if (!property) {\n                            throw new Error(`Expected a hydra:property for ${mapping}`);\n                        }\n                        acc[property] = variable;\n                        return acc;\n                    }, {});\n                    // Gets the URL of the Triple Pattern Fragment with the given triple pattern\n                    const getUri = (entries) => searchTemplate\n                        .expand(Object.keys(entries).reduce((variables, key) => {\n                        variables[mappings[key]] = entries[key];\n                        return variables;\n                    }, {}));\n                    searchForms.push({ dataset, template, mappings, getUri });\n                }\n            }\n        }\n        return { values: searchForms };\n    }\n    /**\n     * Collect all hydra properties from a given metadata stream\n     * in a nice convenient nested hash (property / subject / objects).\n     * @param {RDF.Stream} metadata\n     * @return The collected Hydra properties.\n     */\n    getHydraProperties(metadata) {\n        return new Promise((resolve, reject) => {\n            metadata.on('error', reject);\n            // Collect all hydra properties in a nice convenient nested hash (property / subject / objects).\n            const hydraProperties = {};\n            metadata.on('data', quad => {\n                if (quad.predicate.value.startsWith(ActorRdfMetadataExtractHydraControls.HYDRA)) {\n                    const property = quad.predicate.value.slice(ActorRdfMetadataExtractHydraControls.HYDRA.length);\n                    const subjectProperties = hydraProperties[property] || (hydraProperties[property] = {});\n                    const objects = subjectProperties[quad.subject.value] || (subjectProperties[quad.subject.value] = []);\n                    objects.push(quad.object.value);\n                }\n            });\n            metadata.on('end', () => resolve(hydraProperties));\n        });\n    }\n    async run(action) {\n        const metadata = {};\n        const hydraProperties = await this.getHydraProperties(action.metadata);\n        Object.assign(metadata, this.getLinks(action.url, hydraProperties));\n        metadata.searchForms = this.getSearchForms(hydraProperties);\n        return { metadata };\n    }\n}\nexports.ActorRdfMetadataExtractHydraControls = ActorRdfMetadataExtractHydraControls;\nActorRdfMetadataExtractHydraControls.HYDRA = 'http://www.w3.org/ns/hydra/core#';\nActorRdfMetadataExtractHydraControls.LINK_TYPES = ['first', 'next', 'previous', 'last'];\n//# sourceMappingURL=ActorRdfMetadataExtractHydraControls.js.map"]},"metadata":{},"sourceType":"script"}