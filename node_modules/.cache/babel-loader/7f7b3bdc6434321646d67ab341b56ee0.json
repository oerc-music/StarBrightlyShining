{"ast":null,"code":"import axios from 'axios';\nimport auth from 'solid-auth-client';\nimport jsonld from 'jsonld';\nimport querystring from 'querystring';\nimport { v4 as uuidv4 } from 'uuid';\nimport { prefix } from '../library/prefixes.js';\nimport { ANNOTATION_HANDLED, ANNOTATION_NOT_HANDLED, ANNOTATION_PATCHED, ANNOTATION_POSTED, ANNOTATION_SKIPPED } from './meldActions';\nexport const SET_TRAVERSAL_OBJECTIVES = \"SET_TRAVERSAL_OBJECTIVES\";\nexport const APPLY_TRAVERSAL_OBJECTIVE = \"APPLY_OBJECTIVE\";\nexport const HAS_BODY = \"oa:hasBody\";\nexport const FETCH_SCORE = 'FETCH_SCORE';\nexport const FETCH_RIBBON_CONTENT = 'FETCH_RIBBON_CONTENT';\nexport const FETCH_CONCEPTUAL_SCORE = 'FETCH_CONCEPTUAL_SCORE';\nexport const FETCH_TEI = 'FETCH_TEI';\nexport const FETCH_GRAPH = 'FETCH_GRAPH';\nexport const FETCH_GRAPH_DOCUMENT = 'FETCH_GRAPH_DOCUMENT';\nexport const FETCH_WORK = 'FETCH_WORK';\nexport const FETCH_TARGET_EXPRESSION = 'FETCH_TARGET_EXPRESSION';\nexport const FETCH_COMPONENT_TARGET = 'FETCH_COMPONENT_TARGET';\nexport const PROCESS_COMPONENT_TARGET = 'PROCESS_COMPONENT_TARGET';\nexport const FETCH_STRUCTURE = 'FETCH_STRUCTURE';\nexport const FETCH_MANIFESTATIONS = 'FETCH_MANIFESTATIONS';\nexport const SCORE_PREV_PAGE = 'SCORE_PREV_PAGE';\nexport const SCORE_NEXT_PAGE = 'SCORE_NEXT_PAGE';\nexport const SCORE_SET_OPTIONS = 'SCORE_SET_OPTIONS';\nexport const SCORE_PAGE_TO_TARGET = 'SCORE_PAGE_TO_TARGET';\nexport const PROCESS_ANNOTATION = 'PROCESS_ANNOTATION';\nexport const SESSION_GRAPH_ETAG = 'SESSION_GRAPH_ETAG';\nexport const RESET_NEXT_SESSION_TRIGGER = 'RESET_NEXT_SESSION_TRIGGER';\nexport const TRANSITION_TO_NEXT_SESSION = 'TRANSITION_TO_NEXT_SESSION';\nexport const REGISTER_PUBLISHED_PERFORMANCE_SCORE = 'REGISTER_PUBLISHED_PERFORMANCE_SCORE';\nexport const MUZICODES_UPDATED = 'MUZICODES_UPDATED';\nexport const REALIZATION_OF = 'frbr:realizationOf';\nexport const EXPRESSION = 'frbr:Expression';\nexport const PART_OF = 'frbr:partOf';\nexport const PART = 'frbr:part';\nexport const KEY = 'mo:key';\nexport const HARMONY = 'https://meld.linkedmusic.org/companion/vocab/harmony';\nexport const CADENCE = 'https://meld.linkedmusic.org/companion/vocab/cadentialGoal';\nexport const DEGREE = 'https://meld.linkedmusic.org/companion/vocab/hasDegree';\nexport const CHORD_TYPE = 'https://meld.linkedmusic.org/companion/vocab/chordType';\nexport const HAS_STRUCTURE = 'https://meld.linkedmusic.org/terms/hasStructure';\nexport const SEQ = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#Seq';\nexport const SEQPART = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#_';\nexport const SCORE = 'http://purl.org/ontology/mo/Score';\nexport const CONTAINS = 'http://www.w3.org/ns/ldp#contains';\nexport const MOTIVATED_BY = 'http://www.w3.org/ns/oa#motivatedBy';\nexport const SEGMENT = 'so:Segment';\nexport const MUZICODE = 'meld:Muzicode';\nexport const PUBLISHED_AS = 'http://purl.org/ontology/mo/published_as';\nexport const HAS_PERFORMANCE_MEDIUM = 'http://rdaregistry.info/Elements/e/p20215';\nexport const HAS_PIANO = \"http://id.loc.gov/authorities/performanceMediums/2013015550\";\nexport const CREATE_SESSION = \"CREATE_SESSION\";\nexport const SESSION_NOT_CREATED = \"SESSION_NOT_CREATED\";\nexport const TICK = \"TICK\";\nexport const TRAVERSAL_PREHOP = \"TRAVERSAL_PREHOP\";\nexport const TRAVERSAL_HOP = \"TRAVERSAL_HOP\";\nexport const TRAVERSAL_FAILED = \"TRAVERSAL_FAILED\";\nexport const TRAVERSAL_UNNECCESSARY = \"TRAVERSAL_UNNECCESSARY\";\nexport const TRAVERSAL_CONSTRAINED = \"TRAVERSAL_CONSTRAINED\";\nexport const IGNORE_TRAVERSAL_OBJECTIVE_CHECK_ON_EMPTY_GRAPH = \"IGNORE_TRAVERSAL_OBJECTIVE_CHECK_ON_EMPTY_GRAPH\";\nexport const RUN_TRAVERSAL = \"RUN_TRAVERSAL\";\nexport const REGISTER_TRAVERSAL = \"REGISTER_TRAVERSAL\";\nexport const UPDATE_LATEST_RENDERED_PAGENUM = \"UPDATE_LATEST_RENDERED_PAGENUM\";\nexport const muzicodesUri = \"http://127.0.0.1:5000/MUZICODES\";\nexport const MAX_RETRIES = 3;\nexport const MAX_TRAVERSAL_HOPS = 10;\nexport const RETRY_DELAY = 10; // TODO move context somewhere global -- most framing happens server side\n// anyway, but in cases where the framed URI contains a fragment (\"#\"), \n// we have to do it client-side\t\t\n\nconst context = {\n  \"popRoles\": \"http://pop.linkedmusic.org/roles/\",\n  \"mo\": \"http://purl.org/ontology/mo/\",\n  \"ldp\": \"http://www.w3.org/ns/ldp#\",\n  \"mp\": \"http://id.loc.gov/authorities/performanceMediums/\",\n  \"oa\": \"http://www.w3.org/ns/oa#\",\n  \"frbr\": \"http://purl.org/vocab/frbr/core#\",\n  \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n  \"meld\": \"https://meld.linkedmusic.org/terms/\",\n  \"motivation\": \"https://meld.linkedmusic.org/motivation/\",\n  \"so\": \"http://www.linkedmusic.org/ontologies/segment/\",\n  \"dct\": \"http://purl.org/dc/terms/\",\n  \"climb\": \"http://meld.linkedmusic.org/climb/terms/\",\n  \"mc\": \"http://meld.linkedmusic.org/climb/muzicodeTypes/\"\n};\nexport function fetchScore(url, options) {\n  console.log(\"FETCH_SCORE ACTION on URI: \", url);\n  return dispatch => {\n    auth.fetch(url, {\n      mode: 'cors'\n    }).then(response => {\n      return response.text();\n    }).then(data => {\n      dispatch({\n        type: FETCH_SCORE,\n        payload: {\n          data,\n          config: {\n            url,\n            options\n          }\n        }\n      });\n    });\n  };\n}\nexport function fetchRibbonContent(url) {\n  // console.log(\"FETCH_RIBBON_CONTENT ACTION on URI: \", uri);\n  const promise = auth.fetch(url);\n  return dispatch => {\n    auth.fetch(url, {\n      mode: 'cors'\n    }).then(response => {\n      return response.text();\n    }).then(data => {\n      dispatch({\n        type: FETCH_RIBBON_CONTENT,\n        payload: {\n          data,\n          config: {\n            url\n          }\n        }\n      });\n    });\n  };\n  /*\n  return {\n   type: FETCH_RIBBON_CONTENT,\n   payload: promise\n  }*/\n}\nexport function fetchTEI(uri) {\n  const promise = new CETEI().getHTML5(uri);\n  return dispatch => {\n    promise.then(data => {\n      dispatch({\n        type: FETCH_TEI,\n        payload: {\n          data: data,\n          uri: uri\n        }\n      });\n    });\n  };\n}\nexport function registerTraversal(docUri, suppliedParams = {}) {\n  // PURPOSE:\n  // *************************************************************************\n  // Traverse through a graph, looking for entities of interest\n  //   (keys of 'objectives') and undertaking actions in response\n  //   (values of 'objectives').\n  // For each subject, traverse along its predicates to its attached objects,\n  //   then recurse (each object becomes subject in next round).\n  // When recursing, check for instances of object-as-subject in the current\n  //   file (traverseInternal), AND do an HTTP GET to resolve the object URI\n  //   and recurse there (external traversal).\n  // If useEtag is specified, then worry about etags for external traversals\n  // \t (and re-request if the file has changed)\n  // \t n.b. this is only an issue for dynamic MELD deployments\n  // With each hop, decrement numHops.\n  // Stop when numHops reaches zero, or when there are no more objects\n  //   to traverse to.\n  // If an extendObjectPrefix is specified, only traverse to objects with\n  //  URIs that start with a prefix in the list.\n  // If an extendObjectUri is specified, only traverse to objects with\n  //  URIs in the list.\n  // If an extendObjectType is specified, only traverse to objects with\n  //  a type that's in the list.\n  // If an ignoreObjectPrefix is specified, only traverse to objects with\n  //  URIs that do NOT start with a prefix in the list.\n  // If an ignoreObjectUri is specified, only traverse to objects with\n  //  URIs that are NOT in the list.\n  // If an ignoreObjectType is specified, do NOT traverse to  objects with\n  //  types in the list.\n  // If a followPropertyPrefix is specified, only traverse to objects along\n  //  properties whose URIs start with a prefix in the list.\n  // If a followPropertyUri is specified, only traverse to objects along\n  //  properties with URIs in the list.\n  // If a ignorePpropertyPrefix is specified, only traverse to objects along\n  //  properties whose URIs do NOT start with a prefix in the list.\n  // If a followPropertyUri is specified, only traverse to objects along\n  //  properties with URIs that are NOT in the list.\n  // *************************************************************************\n  // create new params object to pass on in recursive calls\n  // n.b. must update here if function signature changes - the\n  // params object is also used to check supplied parameter names.\n  const defaultParams = {\n    extendObjectPrefix: [],\n    extendObjectUri: [],\n    extendObjectType: [],\n    ignoreObjectPrefix: [],\n    ignoreObjectUri: [],\n    ignoreObjectType: [],\n    followPropertyPrefix: [],\n    followPropertyUri: [],\n    ignorePpropertyPrefix: [],\n    ignorePropertyUri: [],\n    objectives: {},\n    numHops: MAX_TRAVERSAL_HOPS,\n    useEtag: false,\n    etag: \"\"\n  };\n  let params = { ...defaultParams\n  }; // Check for unknown parameter/option names, and issue warnings\n\n  var key;\n\n  for (key in suppliedParams) {\n    if (!(key in params)) {\n      console.log(\"registerTraversal: unrecognized option: \", key);\n    } else {\n      params[key] = suppliedParams[key];\n    }\n  } // For older app compatibility, map old parameter names to new\n\n\n  const oldParamsMap = [[\"objectPrefixWhitelist\", \"extendObjectPrefix\"], [\"objectUriWhitelist\", \"extendObjectUri\"], [\"objectTypeWhitelist\", \"extendObjectType\"], [\"objectPrefixBlacklist\", \"ignoreObjectPrefix\"], [\"objectUriBlacklist\", \"ignoreObjectUri\"], [\"objectTypeBlacklist\", \"ignoreObjectType\"], [\"propertyPrefixWhitelist\", \"followPropertyPrefix\"], [\"propertyUriWhitelist\", \"followPropertyUri\"], [\"propertyPrefixBlacklist\", \"ignorePropertyPrefix\"], [\"propertyUriBlacklist\", \"ignorePropertyUri\"]];\n\n  for (var i in oldParamsMap) {\n    var oldkey = oldParamsMap[i][0];\n    var newkey = oldParamsMap[i][1];\n\n    if (oldkey in suppliedParams && !(newkey in suppliedParams)) {\n      params[newkey] = suppliedParams[oldkey];\n    }\n  }\n\n  const unimplementedParams = (\"extendObjectType\", \"ignoreObjectType\", \"followPropertyPrefix\", \"followPropertyUri\", \"ignorePropertyPrefix\", \"ignorePropertyUri\");\n\n  for (key in unimplementedParams) {\n    if (key in params) {\n      console.log(\"registerTraversal: unimplemented option: \", key);\n    }\n  }\n\n  docUri = new URL(docUri, document.URL).toString();\n\n  if (passesTraversalConstraints({\n    \"@id\": docUri\n  }, params)) {\n    return {\n      type: REGISTER_TRAVERSAL,\n      payload: {\n        docUri,\n        params\n      }\n    };\n  } else {\n    return {\n      type: TRAVERSAL_CONSTRAINED\n    };\n  }\n}\nexport function traverse(docUri, params) {\n  // set up HTTP request\n  const headers = {\n    'Accept': 'application/ld+json'\n  };\n\n  if (params[\"useEtag\"]) {\n    headers['If-None-Match'] = params[\"etag\"];\n  }\n\n  console.log(\"FETCHING: \", docUri, params);\n  const promise = auth.fetch(docUri, {\n    headers: headers,\n    mode: 'cors'\n  });\n  return dispatch => {\n    dispatch({\n      type: RUN_TRAVERSAL,\n      payload: {\n        docUri\n      }\n    });\n    promise.then(response => {\n      if (response.status == 304) {\n        dispatch({\n          type: TRAVERSAL_UNNECCESSARY\n        });\n        return; // file not modified, i.e. etag matched, no updates required\n      }\n\n      console.log(response.headers.get(\"Content-Type\")); // attempt to decide content type (either explicitly provided or by file suffix)\n      // and proceed with traversal accordingly\n\n      if (docUri.endsWith(\".json\") || docUri.endsWith(\".jsonld\") || docUri.endsWith(\".json-ld\") || response.headers.get(\"Content-Type\").startsWith(\"application/ld+json\") || response.headers.get(\"Content-Type\").startsWith(\"application/json\")) {\n        // treat as JSON-LD document\n        dispatch(traverseJSONLD(dispatch, docUri, params, response.json()));\n      } else if (docUri.endsWith(\".ttl\") || docUri.endsWith(\".n3\") || docUri.endsWith(\".rdf\") || docUri.endsWith(\".nt\") || response.headers.get(\"Content-Type\").startsWith(\"application/rdf+xml\") || response.headers.get(\"Content-Type\").startsWith(\"application/x-turtle\") || response.headers.get(\"Content-Type\").startsWith(\"text/turtle\")) {\n        // treat as RDF document\n        // TODO: Translate RDF to JSON-LD, then proceed with traverseJSONLD as above\n        dispatch({\n          type: TRAVERSAL_FAILED\n        });\n        console.log(\"Can't handle this document: (We currently only support nq and JSON-LD)\", docUri, response); // dispatch(traverseRDF(dispatch, docUri, params, response.text()));\n      } else if (docUri.endsWith(\".nq\") || response.headers.get(\"Content-Type\").startsWith(\"application/nquads\")) {\n        dispatch(traverseRDF(dispatch, docUri, params, response.text()));\n      } else {\n        dispatch({\n          type: TRAVERSAL_FAILED\n        });\n        console.log(\"Don't know how to treat this document: \", docUri, response);\n      } // appropriately handle content types\n      //\t\t\tif(isRDF(response.headers.get(\"Content-Type\"))) {\n      //\t\t\t\ttoNQuads(\n      //\t\t\t\t\t\n      //\t\t\t}\n      //\t\t\tswitch(response.headers.get(\"Content-Type\")) {\n      //\t\t\t\t// If we are working with RDF, we need to convert it to JSON-LD.\n      //\t\t\t\t// Unfortunately jsonld.js only reads nquads.\n      //\t\t\t\t// Thus, convert non-nquad RDF formats to nquad first\n      //\t\t\t\tcase \"text/turtle\":\n      //\t\t\t\tcase \"application/trig\":\n      //\t\t\t\tcase \"application/n-triples\":\n      //\t\t\t\tcase \"text/n3\":\n      //\n\n    }).catch(err => {\n      dispatch({\n        type: TRAVERSAL_FAILED\n      });\n      console.log(\"Could not retrieve \", docUri, err);\n    });\n    return {\n      type: TRAVERSAL_PREHOP\n    };\n  };\n} //helper function: \n// skolemize blank nodes to prevent identifier clashes between documents\n// by detecting \"_:<blank-node-identifier>\"\n// and replacing with document uri appended with  /genid/<blank-node-identifier> \n// by virtue of traversal mechanism, we only ever visit each document once, \n// so clashes with the same document should not occur.\n\nfunction skolemize(obj, docUri) {\n  if (Array.isArray(obj)) {\n    // if fed an array, recur on each constitutent\n    obj = obj.map(o => skolemize(o, docUri));\n  } else if (obj === Object(obj)) {\n    // if fed an object, iterate over each key\n    Object.keys(obj).map(k => {\n      if (k === \"@id\") {\n        // found an @id, check for blank node and skolemize if necesssary\n        obj[\"@id\"] = obj[\"@id\"].replace(\"_:\", docUri + \"#genid-\");\n      } else {\n        // recur on value\n        obj[k] = skolemize(obj[k], docUri);\n      }\n    });\n  }\n\n  return obj;\n}\n\nfunction traverseRDF(dispatch, docUri, params, dataPromise) {\n  console.log(\"in traverseRDF for doc \", docUri, \"with exclude list \", params[\"ignoreObjectUri\"]); // expand the JSON-LD object so that we are working with full URIs, not compacted into prefixes\n\n  dataPromise.then(data => {\n    dispatch(traverseJSONLD(dispatch, docUri, params, jsonld.fromRDF(data)));\n  }).catch(err => console.error(err));\n  return {\n    type: TRAVERSAL_HOP\n  };\n}\n\nfunction traverseJSONLD(dispatch, docUri, params, dataPromise) {\n  console.log(\"in traverseJSONLD for doc \", docUri, \"with exclude list \", params[\"ignoreObjectUri\"]); // expand the JSON-LD object so that we are working with full URIs, not compacted into prefixes\n\n  dataPromise.then(data => {\n    console.log(\"attempting to expand: \", data);\n    jsonld.expand(data).then(expanded => {\n      console.log(\"Got expanded json: \", expanded); // flatten the expanded JSON-LD object so that each described entity has an ID at the top-level of the tree\n\n      jsonld.flatten(expanded).then(flattened => {\n        const skolemized = skolemize(flattened, docUri);\n        dispatch({\n          type: FETCH_GRAPH_DOCUMENT,\n          payload: {\n            data: skolemized,\n            uri: docUri\n          }\n        }); // convert the flattened array of JSON-LD structures into a lookup table using each entity's URI (\"@id\")\n\n        let idLookup = {};\n        Object.entries(skolemized).forEach(([key, value]) => {\n          idLookup[value[\"@id\"]] = value;\n        });\n        Object.entries(idLookup).forEach(([subjectUri, subjectDescription]) => {\n          // iterating through each entity within the document as the subject,\n          // look at its description (set of predicate-object tuples).\n          Object.entries(subjectDescription).forEach(([pred, objs]) => {\n            // because JSON-LD, objs could be a single object or an array of objects\n            // therefore, ensure consistency:\n            objs = Array.isArray(objs) ? objs : [objs];\n            objs.map(obj => {\n              if (obj === Object(obj)) {\n                // our *RDF* object is a *JAVASCRIPT* object\n                // but because we've flattened our document, we know that it will contain only an @id\n                // and that all of its other descriptors will be associated with that @id at the top-level\n                // (which we will handle in another iteration)\n                // CHECK FOR OBJECTIVES HERE\n                //console.log(\"<>\", subjectUri, pred, obj[\"@id\"], docUri);\n                // Now recurse (if exclusion/inclusion conditions and hop counter allow)\n                if (passesTraversalConstraints(obj, params)) {\n                  //                  console.log(\"registering next traversal!\", obj[\"@id\"])\n                  dispatch(registerTraversal(obj[\"@id\"], { ...params,\n                    // Remember that we've already visited the current document to avoid loops\n                    \"ignoreObjectUri\": params[\"ignoreObjectUri\"].concat(docUri.split(\"#\")[0]),\n                    \"numHops\": params[\"numHops\"] - 1\n                  }));\n                }\n              } else {// our *RDF* object is a literal\n                // n.b. exceptions where pred is @type, @id, etc. There, the obj is still a URI, not a literal\n                // Could test for those explicitly here.\n                // CHECK FOR OBJECTIVES HERE\n                //\tconsole.log(\"||\", subjectUri, pred, obj, docUri)\n              }\n            });\n          });\n        });\n      });\n    }).catch(error => console.log(\"EXPANSION ERROR: \", docUri, err));\n  });\n  return {\n    type: TRAVERSAL_HOP\n  };\n}\n\nfunction passesTraversalConstraints(obj, params) {\n  // filter function that returns TRUE if uri should be traversed to\n  // (with a given set of constraints in the params)\n  //\n  // test: ensure we haven't run out of hops\n  if (params[\"numHops\"] === 0) {\n    //console.log(\"Test 1: Out of hops\", obj, params)\n    return false;\n  } // test: ensure obj is not a literal\n\n\n  if (!(\"@id\" in obj)) {\n    // ////console.log(\"Test 2: Found a literal\", obj, params)\n    return false;\n  }\n\n  const resourceUri = obj[\"@id\"].split(\"#\")[0]; // don't traverse fragments of an excluded resource...\n  // test: object URI doesn't violate constraints\n\n  if (params[\"extendObjectUri\"].length) {\n    // URI inclusion list specified:\n    // only pass if included in URI inclusion list AND not in URI exclusion list\n    if (!params[\"extendObjectUri\"].includes(resourceUri) || params[\"ignoreObjectUri\"].includes(resourceUri)) {\n      //console.log(\"Test 3: object excluded (and not in inclusion list)\", obj, params)\n      return false;\n    }\n  } else {\n    // no URI inclusion list\n    // only pass if not in URI exclusion list\n    if (params[\"ignoreObjectUri\"].includes(resourceUri)) {\n      //console.log(\"Test 4: object excluded (without inclusion list)\", obj, params)\n      return false;\n    }\n  } // test: object URI doesn't violate PREFIX constraints\n\n\n  const prefixExcluded = params[\"ignoreObjectPrefix\"].filter(pre => {\n    return resourceUri.startsWith(pre.split(\"#\")[0]);\n  }); // only pass if prefix not excluded\n\n  if (prefixExcluded.length) {\n    //console.log(\"Test 5: prefix excluded\", obj, params)\n    return false;\n  }\n\n  if (params[\"extendObjectPrefix\"].length) {\n    // Prefix inclusion list specified:\n    const prefixIncluded = params[\"extendObjectPrefix\"].filter(pre => {\n      return resourceUri.startsWith(pre);\n    }); // only pass if included in prefix inclusion list\n\n    if (prefixIncluded.length === 0) {\n      //console.log(\"Test 6: prefix not in specified inclusion list\", obj, params)\n      return false;\n    }\n  } //console.log(\"Object passes all traversal constraint tests\", obj, params, params[\"extendObjectPrefix\"], params[\"ignoreObjectPrefix\"], params[\"ignoreObjectUri\"]);\n\n\n  return true;\n}\n\nexport function checkTraversalObjectives(graph, objectives) {\n  // check a given json-ld structure against a set of objectives (json-ld frames)\n  if (graph.length) {\n    return dispatch => {\n      let framingPromises = [];\n      objectives.forEach(obj => {\n        framingPromises.push(jsonld.frame(graph, obj));\n      });\n      Promise.allSettled(framingPromises).then(framedResolved => {\n        framedResolved.forEach((resolvedFrame, ix) => {\n          const framed = resolvedFrame[\"value\"];\n          dispatch({\n            type: APPLY_TRAVERSAL_OBJECTIVE,\n            payload: {\n              ix,\n              framed\n            }\n          });\n        });\n      });\n    };\n  } else {\n    return {\n      type: IGNORE_TRAVERSAL_OBJECTIVE_CHECK_ON_EMPTY_GRAPH\n    };\n  }\n}\nexport function setTraversalObjectives(objectives) {\n  return {\n    type: SET_TRAVERSAL_OBJECTIVES,\n    payload: objectives\n  };\n}\nexport function fetchSessionGraph(uri, etag = \"\") {\n  console.warn(\"DEPRECATION WARNING: The function fetchSessionGraph is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\"); // console.log(\"FETCH_SESSION_GRAPH ACTION ON URI: \", uri, \" with etag: \", etag);\n  // TODO add etag to header as If-None-Match and enable corresponding support on server\n  // so that it can respond with 304 instead of 200 (i.e. so it can ommit file body)\n\n  const promise = auth.fetch(uri, {\n    headers: {\n      'Accept': 'application/ld+json',\n      'If-None-Match': etag\n    },\n    mode: 'cors'\n  });\n  return dispatch => {\n    promise.then(response => {\n      if (response.status == 304) {\n        return; // don't need to do any new work\n      }\n\n      const framed = response.data;\n      const session = framed[\"@graph\"][0];\n\n      if (!etag) {\n        // first time through: follow your nose along the conceptual score\n        // to retrieve the published score (MEI file)\n        if (\"mo:performance_of\" in session) {\n          dispatch(fetchConceptualScore(session[\"@id\"], session[\"mo:performance_of\"][\"@id\"]));\n        } else {\n          console.log(\"SESSION IS NOT A PERFORMANCE OF A SCORE: \", session);\n        }\n      }\n\n      if (response.headers.etag !== etag) {\n        // we need to grab the graph data, either because this is the first time,\n        // or because session etag has changed (i.e. annotation has been posted/patched)\n        dispatch({\n          type: FETCH_GRAPH,\n          payload: framed\n        }); // take note of the new etag\n\n        dispatch({\n          type: SESSION_GRAPH_ETAG,\n          payload: {\n            uri: uri,\n            etag: response.headers.etag\n          }\n        });\n\n        if (\"ldp:contains\" in framed[\"@graph\"][0]) {\n          // there are one or more annotations to process\n          framed[\"@graph\"][0] = ensureArray(framed[\"@graph\"][0], \"ldp:contains\"); // process each annotation\n\n          framed[\"@graph\"][0][\"ldp:contains\"].map(annotation => {\n            dispatch(processComponentAnnotation(annotation, session[\"mo:performance_of\"][\"@id\"]));\n          });\n        }\n      }\n    });\n  };\n}\nexport function fetchGraph(uri) {\n  // console.log(\"FETCH_GRAPH ACTION ON URI: \", uri);\n  const promise = auth.fetch(uri);\n  return dispatch => {\n    promise.then(({\n      data\n    }) => {\n      // dispatch the graph data\n      dispatch({\n        type: FETCH_GRAPH,\n        payload: data\n      }); // walk through component annotations\n\n      data[\"@graph\"][0][\"ldp:contains\"].map(topLevel => {\n        topLevel[\"oa:hasBody\"].map(annotation => {\n          dispatch(processComponentAnnotation(annotation));\n        });\n      });\n    });\n  };\n}\n\nfunction processComponentAnnotation(annotation, conceptualScore = \"\") {\n  console.warn(\"DEPRECATION WARNING: The function processComponentAnnotation is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\");\n\n  if (\"meld:state\" in annotation && annotation[\"meld:state\"][\"@id\"] === \"meld:processed\") {\n    // We can skip this processed annotation\n    return {\n      type: ANNOTATION_SKIPPED,\n      payload: annotation\n    };\n  }\n\n  annotation = ensureArray(annotation, \"oa:hasTarget\"); // console.log(\"Processing component annotation: \", annotation, conceptualScore)\n\n  const targets = annotation[\"oa:hasTarget\"].map(target => {\n    return {\n      \"@id\": target[\"@id\"],\n      // DW TODO 20170830 may need to validate whether @type exists\n      \"@type\": target[\"@type\"]\n    };\n  });\n  return dispatch => {\n    targets.map(target => {\n      dispatch(fetchComponentTarget(target[\"@id\"], conceptualScore));\n    });\n    dispatch({\n      type: PROCESS_ANNOTATION,\n      payload: {\n        id: annotation[\"@id\"],\n        bodies: annotation[\"oa:hasBody\"],\n        targets: targets\n      }\n    });\n  };\n}\n\nexport function fetchComponentTarget(uri, conceptualScore = \"\") {\n  console.warn(\"DEPRECATION WARNING: The function fetchComponentTarget is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\"); // console.log(\"FETCH_COMPONENT_TARGET ACTION ON URI: \", uri);\n\n  const promise = auth.fetch(uri, {\n    headers: {\n      'Accept': 'application/ld+json'\n    },\n    mode: 'cors'\n  });\n  return dispatch => {\n    promise.then(data => {\n      // console.log(\"Attemping to frame data\", data);\n      if (!\"content-type\" in data.headers || data.headers.get(\"Content-Type\") !== \"application/json\" && data.headers.get(\"Content-Type\") !== \"application/ld+json\") {\n        // console.log(\"Converting to JSON...\");\n        // need to convert triples to json\n        // TODO handle arbitrary RDF format here (currently requires ntriples)\n        jsonld.fromRDF(data.data, {\n          format: 'application/n-quads'\n        }).then(doc => {\n          dispatch(processComponentTarget(doc, uri, conceptualScore));\n        }).catch(err => console.log(\"ERROR CONVERTING NQUADS TO JSON-LD: \", err));\n      } else {\n        // already in json format\n        dispatch(processComponentTarget(data.data, uri, conceptualScore));\n      }\n    });\n  };\n}\n\nfunction processComponentTarget(data, uri, conceptualScore) {\n  console.warn(\"DEPRECATION WARNING: The function processComponentTarget is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the checkTraversalObjectives function instead.\"); // console.log(\"PROCESS_COMPONENT_TARGET ACTION ON URI: \", uri);\n\n  return dispatch => {\n    jsonld.frame(data, {\n      \"@id\": uri\n    }).then(framed => {\n      jsonld.compact(framed, context).then(compacted => {\n        dispatch({\n          type: FETCH_COMPONENT_TARGET,\n          payload: {\n            conceptualScore: conceptualScore,\n            structureTarget: uri\n          }\n        }); // console.log(\"COMPACTED: \", compacted);\n\n        let typecheck = compacted;\n        typecheck = ensureArray(typecheck, \"@type\"); // have we found a segment?\n        // console.log(\"TYPECHECK: \", typecheck)\n\n        if (typecheck[\"@type\"].includes(SEGMENT) || typecheck[\"@type\"].includes(MUZICODE)) {\n          // TODO jsonldify context\n          // TODO refine muzicode semantics for this\n          // found a segment or muzicode!\n          // hand it off to the reducer to process the embodibag\n          // nb this is a different route to larrymeld (via expression)\n          // i.e. there is no partonomy here. So send the segment itself as the part.\n          dispatch({\n            type: FETCH_MANIFESTATIONS,\n            payload: {\n              target: compacted,\n              part: compacted\n            }\n          });\n        } else {\n          // if not, continue following links via the target's expression\n          dispatch(fetchTargetExpression(compacted));\n        }\n      }).catch(err => console.log(\"COMPACTING ERROR in processComponentTarget:\", err));\n    }).catch(err => {\n      type: ANNOTATION_NOT_HANDLED;\n    });\n  };\n}\n\nexport function fetchTargetExpression(compacted) {\n  console.warn(\"DEPRECATION WARNING: The function fetchTargetExpression is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\"); // traverse from the provided Expression, via a Segment, to Manifestation(s)\n  // console.log(\"In fetchTargetExpression: \", compacted);\n\n  return dispatch => {\n    dispatch({\n      type: FETCH_TARGET_EXPRESSION,\n      payload: compacted\n    });\n    let target = compacted;\n\n    if (target[\"@type\"].includes(EXPRESSION)) {\n      // found an expression\n      // Do we have a harmony declaration?\n      let chords = [];\n      let expressionObj = {};\n      expressionObj['@id'] = target['@id'];\n\n      if (PART_OF in target) {\n        expressionObj.motif = target[PART_OF]['@id'];\n        expressionObj.n = parseInt(/\\d*$/.exec(target['@id'])[0]); // FIXME: bad hack for not having seq available\n      }\n\n      if (REALIZATION_OF in target) {\n        expressionObj.segment = target[REALIZATION_OF]['@id'];\n      }\n\n      if (KEY in target) expressionObj.key = target[KEY]['@id'];\n\n      if (HARMONY in target) {\n        if (PART_OF in target) {\n          expressionObj.motif = target[PART_OF]['@id'];\n          expressionObj.chords = chords;\n        }\n\n        var counter = 1;\n        var urlBegins = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#_\";\n\n        while (urlBegins + counter in target[HARMONY]) {\n          chords.push(target[HARMONY][urlBegins + counter]);\n          counter++;\n        }\n      }\n\n      if (CADENCE in target) {\n        var cadenceData = target[CADENCE];\n        expressionObj.cadence = {};\n        if (DEGREE in cadenceData) expressionObj.cadence.degree = cadenceData[DEGREE]['@id'];\n        if (CHORD_TYPE in cadenceData) expressionObj.cadence.chordType = cadenceData[CHORD_TYPE]['@id'];\n      } // does it have any parts?\n\n\n      let parts = []; // console.log(\"part check: \", target)\n\n      if (PART in target) {\n        // sometimes we may have multiple parts or part sequences; sometimes only one\n        // so ensure we have an array to work with (even if it's length one)\n        // TODO refactor to use ensureArray helper function\n        if (!Array.isArray(target[PART])) {\n          target[PART] = [target[PART]];\n        } // now process each sequence\n\n\n        target[PART].map(p => {\n          if (\"@type\" in p && p[\"@type\"].includes(SEQ)) {\n            // it's an RDF sequence\n            Object.keys(p).map(part => {\n              if (part.startsWith(SEQPART)) {\n                parts.push(p[part][\"@id\"]);\n              }\n            });\n          } else {\n            parts.push(p[\"@id\"]);\n          }\n        }); // now fetch the work to continue on to the manifestations associated with these parts\n\n        if (REALIZATION_OF in target) {\n          dispatch(fetchWork(compacted, parts, target[REALIZATION_OF][\"@id\"], expressionObj));\n        } else {\n          console.log(\"Target is an unrealized expression: \", target);\n        }\n      } else {\n        console.log(\"Target expression without parts\", target);\n      }\n    } else {\n      console.log(\"fetchTargetExpression attempted on a non-Expression! \", target);\n    }\n  };\n}\nexport function fetchWork(target, parts, work, expressionObj) {\n  console.warn(\"DEPRECATION WARNING: The function fetchWork is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\"); // console.log(\"STARTING FETCHWORK WITH \", work, parts, expressionObj);\n\n  return dispatch => {\n    dispatch({\n      type: FETCH_WORK,\n      payload: {\n        target: target,\n        parts: parts,\n        works: work,\n        chords: expressionObj\n      }\n    });\n    auth.fetch(work).then(data => {\n      jsonld.fromRDF(data.data, (err, doc) => {\n        if (err) {\n          console.log(\"ERROR TRANSLATING NQUADS TO JSONLD: \", err, data.data);\n        } else {\n          jsonld.frame(doc, {\n            \"@id\": work\n          }, (err, framed) => {\n            if (err) {\n              console.log(\"FRAMING ERROR in fetchWork:\", err);\n            } else {\n              jsonld.compact(framed, context, (err, compacted) => {\n                if (err) {\n                  console.log(\"COMPACTING ERROR in fetchWork:\", err);\n                } else {\n                  work = compacted; // Check if there is a segment line, in which case fetch manifestations\n                  // else, check if this is part of another (\"parent\") work\n\n                  if (HAS_STRUCTURE in work) {\n                    dispatch(fetchStructure(target, parts, work[HAS_STRUCTURE][\"@id\"]));\n                  } else if (PART_OF in work) {\n                    // does our doc attach a Score which realizes the parent work?\n                    // FIXME HACKHACK:\n                    // framing expands the nice compacted URIs\n                    // so here we need to use full URIs instead of REALIZATION_OF as defined above\n                    jsonld.frame({\n                      \"@context\": context,\n                      \"@graph\": doc\n                    }, {\n                      \"http://purl.org/vocab/frbr/core#realizationOf\": work[PART_OF][\"@id\"]\n                    }, (err, framed) => {\n                      if (err) {\n                        console.log(\"FRAMING ERROR when fetching parent work\", err);\n                      } else {\n                        // console.log(\"Attached score:\", framed);\n                        const attachedScore = framed[\"@graph\"][0];\n\n                        if (attachedScore && \"@type\" in attachedScore && attachedScore[\"@type\"] === SCORE) {\n                          // FIXME breaks with multiple types\n                          // Found an attached Score!!!\n                          if (PUBLISHED_AS in attachedScore) {\n                            // for now: assume published scores\n                            // are attached in same file\n                            // FIXME enable external pub_scores\n                            attachedScore[PUBLISHED_AS].map(pubScore => {\n                              // console.log(\"FOUND PUB SCORE: \", pubScore);\n                              if (HAS_PERFORMANCE_MEDIUM in pubScore) {\n                                // console.log(\"FOUND PERF MEDIUM: \", pubScore[HAS_PERFORMANCE_MEDIUM]);\n                                dispatch({\n                                  type: REGISTER_PUBLISHED_PERFORMANCE_SCORE,\n                                  payload: {\n                                    work: work,\n                                    conceptualScore: attachedScore,\n                                    publishedScore: pubScore,\n                                    performanceMedium: pubScore[HAS_PERFORMANCE_MEDIUM]\n                                  }\n                                });\n\n                                if (pubScore[HAS_PERFORMANCE_MEDIUM]['@id'] == HAS_PIANO) {\n                                  dispatch(fetchScore(pubScore[\"@id\"]));\n                                } else {\n                                  dispatch(fetchRibbonContent(pubScore[\"@id\"]));\n                                }\n                              } else {// console.log(\"Published score without performance medium: \", pubScore[\"@id\"]);\n                              }\n                            });\n                          } else {// console.log(\"Unpublished score: \", attachedScore);\n                          }\n\n                          if (HAS_STRUCTURE in attachedScore) {\n                            dispatch(fetchStructure(target, parts, attachedScore[HAS_STRUCTURE][\"@id\"]));\n                          } else {// console.log(\"Score \", attachedScore[\"@id\"], \" attached to work \", work[\"@id\"], \" has no segment line!!\");\n                          }\n                        } else {\n                          // no attached Score, so we have to recurse on the parent work\n                          dispatch(fetchWork(target, parts, work[PART_OF][\"@id\"]));\n                        }\n                      }\n                    });\n                  } else {// console.log(\"Found work without segmentLine or partonomy! \", work);\n                  }\n                }\n              });\n            }\n          });\n        }\n      });\n    });\n  };\n}\nexport function fetchStructure(target, parts, segline) {\n  console.warn(\"DEPRECATION WARNING: The function fetchStructure is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\");\n  return dispatch => {\n    dispatch({\n      type: FETCH_STRUCTURE,\n      payload: {\n        target: target,\n        parts: parts,\n        structure: segline\n      }\n    });\n    auth.fetch(segline).then(data => {\n      jsonld.fromRDF(data.data, (err, doc) => {\n        if (err) {\n          console.log(\"ERROR TRANSLATING NQUADS TO JSONLD: \", err, data.data);\n        } else {\n          // frame the doc in terms of each part of the expression targetted by the annotation\n          parts.map(part => {\n            jsonld.frame(doc, {\n              \"@id\": part\n            }, (err, framed) => {\n              if (err) {\n                console.log(\"FRAMING ERROR in fetchStructure: \", err);\n              } else {\n                jsonld.compact(framed, context, (err, compacted) => {\n                  if (err) {\n                    console.log(\"COMPACTING ERROR in fetchStructure:\", err);\n                  } else {\n                    // and hand to reducers to process associated embodibags\n                    // (manifestations of the expression)\n                    // console.log(\"fetching manifestations\", doc, target, part, compacted);\n                    dispatch({\n                      type: FETCH_MANIFESTATIONS,\n                      payload: {\n                        target: target,\n                        part: compacted\n                      }\n                    });\n                  }\n                });\n              }\n            });\n          });\n        }\n      });\n    });\n  };\n}\nexport function fetchConceptualScore(session, uri) {\n  console.warn(\"DEPRECATION WARNING: The function fetchConceptualScore is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\");\n  return dispatch => {\n    // console.log(\"FETCH_CONCEPTUAL_SCORE ON URI: \", uri);\n    const promise = auth.fetch(uri, {\n      headers: {\n        'Accept': 'application/ld+json'\n      }\n    });\n    return dispatch => {\n      promise.then(response => {\n        const framed = response.data;\n        const conceptualScore = framed[\"@graph\"][0];\n\n        if (\"mo:published_as\" in conceptualScore) {\n          // dispatch the conceptual score (containing the mei URI) so that we can initialise a <Score> component\n          dispatch({\n            type: FETCH_CONCEPTUAL_SCORE,\n            payload: conceptualScore\n          });\n          dispatch(fetchScore(conceptualScore[\"mo:published_as\"][\"@id\"]));\n        } else {\n          console.log(\"Unpublished conceptual score: \", conceptualScore);\n        }\n        /*if(\"climb:next\" in conceptualScore) {\n            //TODO REVISIT FOR JAM -- NO LONGER RELEVANT FOR CLIMB, AS MUZICODES NEEDS TO MAKE A DECISION\n            // BEFORE THE 'DEFAULT' NEXT SCORE CAN BE DETERMINED\n          // for dynamic meld applications:\n          // create a new session for the default next score\n          // (which sessionControl will then queue up)\n          console.log(\"About to create next session for conceptual score: \", conceptualScore);\n          dispatch(\n            createSession(\n              session.substr(0,session.lastIndexOf(\"/\")),\n              conceptualScore[\"climb:next\"][\"@id\"]\n            )\n          )\n        }*/\n\n      });\n    };\n  };\n}\nexport function scoreSetOptions(pubScoreUri, options) {\n  return {\n    type: SCORE_SET_OPTIONS,\n    payload: {\n      options: options,\n      uri: pubScoreUri\n    }\n  };\n}\nexport function scorePageToComponentTarget(target, pubScoreUri, MEI) {\n  return {\n    type: SCORE_PAGE_TO_TARGET,\n    payload: {\n      data: MEI,\n      uri: pubScoreUri,\n      target: target\n    }\n  };\n}\nexport function scoreNextPageStatic(pubScoreUri, pageNum, MEI) {\n  return dispatch => {\n    dispatch({\n      type: SCORE_NEXT_PAGE,\n      payload: {\n        pageNum: pageNum,\n        data: MEI,\n        uri: pubScoreUri\n      }\n    });\n  };\n}\nexport function scoreNextPage(session, nextSession, etag, annotation, pubScoreUri, pageNum, MEI) {\n  return dispatch => {\n    if (MEI) {\n      // console.log(\"Attempting to action SCORE_NEXT_PAGE\");\n      const action = {\n        type: SCORE_NEXT_PAGE,\n        payload: {\n          pageNum: pageNum,\n          data: MEI,\n          uri: pubScoreUri,\n          nextSession: nextSession\n        }\n      };\n      dispatch(patchAndProcessAnnotation(action, session, etag, annotation));\n    } else {\n      dispatch({\n        type: ANNOTATION_NOT_HANDLED,\n        payload: \"Page flip attempted on non-existing MEI. Has it loaded yet?\"\n      });\n    }\n  };\n}\nexport function scorePrevPageStatic(pubScoreUri, pageNum, MEI) {\n  return dispatch => {\n    dispatch({\n      type: SCORE_PREV_PAGE,\n      payload: {\n        pageNum: pageNum,\n        data: MEI,\n        uri: pubScoreUri\n      }\n    });\n  };\n}\nexport function scorePrevPage(session, nextSession, etag, annotation, pubScoreUri, pageNum, MEI) {\n  return dispatch => {\n    if (MEI) {\n      const action = {\n        type: SCORE_PREV_PAGE,\n        payload: {\n          pageNum: pageNum,\n          data: MEI,\n          uri: pubScoreUri,\n          nextSession: nextSession\n        }\n      };\n      dispatch(patchAndProcessAnnotation(action, session, etag, annotation));\n    } else {\n      dispatch({\n        type: ANNOTATION_NOT_HANDLED,\n        payload: \"Page flip attempted on non-existing MEI. Has it loaded yet?\"\n      });\n    }\n  };\n}\nexport function transitionToSession(thisSession, nextSession) {\n  // TODO do this properly using react.router to avoid full reload\n  window.location.assign('?session=' + nextSession);\n  return {\n    type: ANNOTATION_HANDLED\n  };\n}\nexport function resetNextSessionTrigger() {\n  return {\n    type: RESET_NEXT_SESSION_TRIGGER\n  };\n}\nexport function postNextPageAnnotation(session, etag) {\n  return dispatch => {\n    dispatch(postAnnotation(session, etag, JSON.stringify({\n      \"oa:hasTarget\": {\n        \"@id\": session\n      },\n      \"oa:motivatedBy\": {\n        \"@id\": \"motivation:nextPageOrPiece\"\n      }\n    })));\n  };\n}\nexport function postPrevPageAnnotation(session, etag) {\n  return dispatch => {\n    dispatch(postAnnotation(session, etag, JSON.stringify({\n      \"oa:hasTarget\": {\n        \"@id\": session\n      },\n      \"oa:motivatedBy\": {\n        \"@id\": \"motivation:prevPageOrPiece\"\n      }\n    })));\n  };\n}\nexport function postAnnotation(session, etag, json, retries = MAX_RETRIES, callback = {}) {\n  let uuid = uuidv4();\n\n  if (retries === \"\") {\n    retries = MAX_RETRIES;\n  }\n\n  if (!(\"id\" in json) && !(\"@id\" in json)) {\n    // bootstrap a UUID for this annotation\n    json[\"@id\"] = session + uuid + \".jsonld\";\n  }\n\n  return dispatch => {\n    if (retries) {\n      console.log(\"Posting annotation: \", session, etag, json);\n      auth.fetch(session, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/ld+json',\n          'If-None-Match': etag,\n          'Slug': uuid + \".jsonld\"\n        },\n        body: JSON.stringify(json)\n      }).then(response => {\n        typeof callback === \"function\" && callback(response);\n      }).catch(function (error) {\n        if (!error.response) {\n          console.log(error, \"Annotation post failed. Giving up.\");\n          return {\n            type: ANNOTATION_NOT_HANDLED\n          };\n        }\n\n        if (error.response.status == 412) {\n          console.log(\"Mid-air collision while attempting to POST annotation. Retrying.\", session, etag, json); // GET the session resource to figure out new etag\n\n          auth.fetch(session).then(response => {\n            return dispatch => {\n              // and try again\n              setTimeout(() => {\n                dispatch(postAnnotation(session, response.headers.get('etag'), json, retries - 1));\n              }, RETRY_DELAY);\n            };\n          });\n        } else {\n          console.log(\"Retrying.\");\n          setTimeout(() => {\n            dispatch(postAnnotation(session, response.headers.get(etag), json, retries - 1));\n          }, RETRY_DELAY);\n        }\n      });\n      return {\n        type: ANNOTATION_POSTED\n      };\n    } else {\n      console.log(\"FAILED TO POST ANNOTATION (MAX RETRIES EXCEEDED): \", session, etag, json);\n      return {\n        type: ANNOTATION_NOT_HANDLED\n      };\n    }\n  };\n}\nexport function markAnnotationProcessed(session, etag, annotation, retries = MAX_RETRIES) {\n  if (retries) {\n    // console.log(\"PATCHING: \", session, etag, annotation);\n    const patchJson = JSON.stringify({\n      \"@id\": annotation[\"@id\"],\n      \"meld:state\": {\n        \"@id\": \"meld:processed\"\n      }\n    });\n    axios.patch(session, patchJson, {\n      headers: {\n        'Content-Type': 'application/ld+json',\n        'If-None-Match': etag\n      }\n    }).catch(function (error) {\n      if (error.response.status == 412) {\n        console.log(\"Mid-air collision while attempting to MARK annotation processed. Retrying.\", session, etag, annotation); // GET the session resource to figure out new etag\n\n        auth.fetch(session).then(response => {\n          // and try again\n          return dispatch => {\n            setTimeout(() => {\n              dispatch(markAnnotationProcessed(session, response.headers.etag, annotation, retries - 1));\n            }, RETRY_DELAY);\n          };\n        });\n      } else {\n        console.log(\"Error while patching annotation: \", error);\n        console.log(\"Retrying.\");\n        return dispatch => {\n          setTimeout(() => {\n            dispatch(markAnnotationProcessed(session, response.headers.etag, annotation, retries - 1));\n          }, RETRY_DELAY);\n        };\n      }\n    }).then(\"Done?\");\n    return {\n      type: ANNOTATION_PATCHED\n    };\n  } else {\n    console.log(\"FAILED TO PATCH ANNOTATION (MAX RETRIES EXCEEDED): \", session, etag, annotation);\n    return {\n      type: ANNOTATION_NOT_HANDLED\n    };\n  }\n}\nexport function patchAndProcessAnnotation(action, session, etag, annotation, success = {\n  type: ANNOTATION_PATCHED\n}, retries = MAX_RETRIES) {\n  if (retries) {\n    // console.log(\"PATCHING: \", session, etag, annotation);\n    const patchJson = JSON.stringify({\n      \"@id\": annotation[\"@id\"],\n      \"meld:state\": {\n        \"@id\": \"meld:processed\"\n      }\n    });\n    return dispatch => {\n      axios.patch(session, patchJson, {\n        headers: {\n          'Content-Type': 'application/ld+json',\n          'If-None-Match': etag\n        }\n      }).then(function (response) {\n        // console.log(\"Dispatching action: \", action);\n        dispatch(action); // console.log(\"Dispatching success callback: \", success)\n\n        dispatch(success);\n      }).catch(function (error) {\n        if (error.response.status == 412) {\n          console.log(\"Mid-air collision while attempting to PATCH annotation. Retrying.\", session, etag, annotation); // GET the session resource to figure out new etag\n\n          auth.fetch(session).then(response => {\n            // and try again\n            return dispatch => {\n              setTimeout(() => {\n                dispatch(patchAndProcessAnnotation(action, session, response.headers.etag, annotation, success, retries - 1));\n              }, RETRY_DELAY);\n            };\n          });\n        } else {\n          console.log(\"Error while patching annotation: \", error);\n          console.log(\"Retrying.\");\n          return dispatch => {\n            setTimeout(() => {\n              dispatch(patchAndProcessAnnotation(action, session, response.headers.etag, annotation, success, retries - 1));\n            }, RETRY_DELAY);\n          };\n        }\n      });\n    };\n  } else {\n    console.log(\"FAILED TO PATCH ANNOTATION (MAX RETRIES EXCEEDED): \", session, etag, annotation);\n    return {\n      type: ANNOTATION_NOT_HANDLED\n    };\n  }\n}\nexport function updateMuzicodes(muzicodesUri, session, mei = \"\") {\n  // inform the muzicodes service that our session has loaded\n  // console.log(\"Updating muzicodes:\", muzicodesUri, session);\n  const params = querystring.stringify({\n    \"name\": \"meld.load\",\n    \"meldcollection\": session,\n    \"meldmei\": mei\n  });\n  auth.fetch(muzicodesUri, params);\n  return {\n    type: MUZICODES_UPDATED\n  };\n} // helper function to ensure that a given key of a JSON obj\n// is an array, rather than a single value\n// this is so that we can use the same approach for one and for\n// many values\n\nexport function ensureArray(theObj, theKey) {\n  if (theObj !== null && typeof theObj === 'object') {\n    if (!theKey in theObj) {\n      console.log(\"ensureArray: KEY NOT IN OBJECT!\", theKey, theObj);\n    } else if (!Array.isArray(theObj[theKey])) {\n      theObj[theKey] = [theObj[theKey]];\n    }\n\n    return theObj;\n  } else {\n    console.log(\"ensureArray: Provided structure is NOT AN OBJECT!\");\n  }\n} // Function to set up the objectives (objects containing JSON-LD frames)\n// matched against the graph being built during a traversal.\n// Typically called once, on componentWillMount\n\nexport function configureTraversalObjectives(objectives) {\n  return {\n    type: SET_TRAVERSAL_OBJECTIVES,\n    payload: objectives\n  };\n}\nexport function createSession(sessionsUri, scoreUri, {\n  session = \"\",\n  etag = \"\",\n  retries = MAX_RETRIES,\n  performerUri = \"\",\n  slug = \"\"\n} = {}) {\n  return dispatch => {\n    if (retries) {\n      // console.log(\"Trying to create session: \", sessionsUri, scoreUri, etag, retries, performerUri);\n      auth.fetch(sessionsUri).then(getResponse => {\n        axios.post(sessionsUri, JSON.stringify({\n          \"@type\": [\"mo:Performance\", \"ldp:BasicContainer\"],\n          \"mo:performance_of\": {\n            \"@id\": scoreUri\n          }\n        }), {\n          headers: {\n            \"Content-Type\": \"application/ld+json\",\n            \"If-None-Match\": getResponse.headers.etag,\n            \"Slug\": slug\n          }\n        }).then(postResponse => {\n          // 1.Note that we've created the session\n          // (for real-time client-side queueing)\n          dispatch({\n            type: CREATE_SESSION,\n            payload: postResponse\n          }); // 2.If we've been called inside a session context,\n          // post a corresponding queue annotation\n          // (for later static revisits, e.g. in archive)\n\n          if (session) {\n            dispatch(postAnnotation(session, etag, {\n              \"oa:hasTarget\": {\n                \"@id\": session\n              },\n              \"oa:motivatedBy\": {\n                \"@id\": \"motivation:queueNextSession\"\n              },\n              \"oa:hasBody\": {\n                \"@id\": postResponse.headers.location\n              }\n            }));\n          }\n        }).catch(function (error) {\n          if (error.response.status == 412) {\n            console.log(\"Mid-air collision while attempting to POST annotation. Retrying.\");\n            dispatch(() => {\n              setTimeout(() => {\n                dispatch(createSession(sessionsUri, scoreUri, {\n                  etag: getResponse.headers.etag,\n                  retries: retries - 1,\n                  performerUri: performerUri,\n                  slug: slug\n                }));\n              }, RETRY_DELAY);\n            });\n          } else {\n            console.log(\"Error while creating session: \", error);\n            console.log(\"Retrying.\");\n            dispatch(() => {\n              setTimeout(() => {\n                dispatch(createSession(sessionsUri, scoreUri, {\n                  etag: getResponse.headers.etag,\n                  retries: retries - 1,\n                  performerUri: performerUri,\n                  slug: slug\n                }));\n              }, RETRY_DELAY);\n            });\n          }\n        });\n      });\n    } else {\n      console.log(\"FAILED TO CREATE SESSION (MAX RETRIES EXCEEDED): \", sessionsUri, scoreUri, response.headers.etag, retries - 1, performerUri);\n      return {\n        type: SESSION_NOT_CREATED\n      };\n    }\n  };\n}\nexport function tickTimedResource(resourceUri, time) {\n  return {\n    type: TICK,\n    payload: {\n      uri: resourceUri,\n      time: time\n    }\n  };\n}\nexport function registerClock(clockUri) {\n  return {\n    type: \"REGISTER_CLOCK\",\n    payload: clockUri\n  };\n}\nexport function updateLatestRenderedPageNum(pageNum) {\n  return {\n    type: \"UPDATE_LATEST_RENDERED_PAGENUM\",\n    payload: pageNum\n  };\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/meld-clients-core/lib/actions/index.js"],"names":["axios","auth","jsonld","querystring","v4","uuidv4","prefix","ANNOTATION_HANDLED","ANNOTATION_NOT_HANDLED","ANNOTATION_PATCHED","ANNOTATION_POSTED","ANNOTATION_SKIPPED","SET_TRAVERSAL_OBJECTIVES","APPLY_TRAVERSAL_OBJECTIVE","HAS_BODY","FETCH_SCORE","FETCH_RIBBON_CONTENT","FETCH_CONCEPTUAL_SCORE","FETCH_TEI","FETCH_GRAPH","FETCH_GRAPH_DOCUMENT","FETCH_WORK","FETCH_TARGET_EXPRESSION","FETCH_COMPONENT_TARGET","PROCESS_COMPONENT_TARGET","FETCH_STRUCTURE","FETCH_MANIFESTATIONS","SCORE_PREV_PAGE","SCORE_NEXT_PAGE","SCORE_SET_OPTIONS","SCORE_PAGE_TO_TARGET","PROCESS_ANNOTATION","SESSION_GRAPH_ETAG","RESET_NEXT_SESSION_TRIGGER","TRANSITION_TO_NEXT_SESSION","REGISTER_PUBLISHED_PERFORMANCE_SCORE","MUZICODES_UPDATED","REALIZATION_OF","EXPRESSION","PART_OF","PART","KEY","HARMONY","CADENCE","DEGREE","CHORD_TYPE","HAS_STRUCTURE","SEQ","SEQPART","SCORE","CONTAINS","MOTIVATED_BY","SEGMENT","MUZICODE","PUBLISHED_AS","HAS_PERFORMANCE_MEDIUM","HAS_PIANO","CREATE_SESSION","SESSION_NOT_CREATED","TICK","TRAVERSAL_PREHOP","TRAVERSAL_HOP","TRAVERSAL_FAILED","TRAVERSAL_UNNECCESSARY","TRAVERSAL_CONSTRAINED","IGNORE_TRAVERSAL_OBJECTIVE_CHECK_ON_EMPTY_GRAPH","RUN_TRAVERSAL","REGISTER_TRAVERSAL","UPDATE_LATEST_RENDERED_PAGENUM","muzicodesUri","MAX_RETRIES","MAX_TRAVERSAL_HOPS","RETRY_DELAY","context","fetchScore","url","options","console","log","dispatch","fetch","mode","then","response","text","data","type","payload","config","fetchRibbonContent","promise","fetchTEI","uri","CETEI","getHTML5","registerTraversal","docUri","suppliedParams","defaultParams","extendObjectPrefix","extendObjectUri","extendObjectType","ignoreObjectPrefix","ignoreObjectUri","ignoreObjectType","followPropertyPrefix","followPropertyUri","ignorePpropertyPrefix","ignorePropertyUri","objectives","numHops","useEtag","etag","params","key","oldParamsMap","i","oldkey","newkey","unimplementedParams","URL","document","toString","passesTraversalConstraints","traverse","headers","status","get","endsWith","startsWith","traverseJSONLD","json","traverseRDF","catch","err","skolemize","obj","Array","isArray","map","o","Object","keys","k","replace","dataPromise","fromRDF","error","expand","expanded","flatten","flattened","skolemized","idLookup","entries","forEach","value","subjectUri","subjectDescription","pred","objs","concat","split","resourceUri","length","includes","prefixExcluded","filter","pre","prefixIncluded","checkTraversalObjectives","graph","framingPromises","push","frame","Promise","allSettled","framedResolved","resolvedFrame","ix","framed","setTraversalObjectives","fetchSessionGraph","warn","session","fetchConceptualScore","ensureArray","annotation","processComponentAnnotation","fetchGraph","topLevel","conceptualScore","targets","target","fetchComponentTarget","id","bodies","format","doc","processComponentTarget","compact","compacted","structureTarget","typecheck","part","fetchTargetExpression","chords","expressionObj","motif","n","parseInt","exec","segment","counter","urlBegins","cadenceData","cadence","degree","chordType","parts","p","fetchWork","work","works","fetchStructure","attachedScore","pubScore","publishedScore","performanceMedium","segline","structure","scoreSetOptions","pubScoreUri","scorePageToComponentTarget","MEI","scoreNextPageStatic","pageNum","scoreNextPage","nextSession","action","patchAndProcessAnnotation","scorePrevPageStatic","scorePrevPage","transitionToSession","thisSession","window","location","assign","resetNextSessionTrigger","postNextPageAnnotation","postAnnotation","JSON","stringify","postPrevPageAnnotation","retries","callback","uuid","method","body","setTimeout","markAnnotationProcessed","patchJson","patch","success","updateMuzicodes","mei","theObj","theKey","configureTraversalObjectives","createSession","sessionsUri","scoreUri","performerUri","slug","getResponse","post","postResponse","tickTimedResource","time","registerClock","clockUri","updateLatestRenderedPageNum"],"mappings":"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","sourcesContent":["import axios from 'axios';\nimport auth from 'solid-auth-client';\nimport jsonld from 'jsonld';\nimport querystring from 'querystring';\nimport { v4 as uuidv4 } from 'uuid';\nimport { prefix } from '../library/prefixes.js';\nimport { ANNOTATION_HANDLED, ANNOTATION_NOT_HANDLED, ANNOTATION_PATCHED, ANNOTATION_POSTED, ANNOTATION_SKIPPED } from './meldActions';\nexport const SET_TRAVERSAL_OBJECTIVES = \"SET_TRAVERSAL_OBJECTIVES\";\nexport const APPLY_TRAVERSAL_OBJECTIVE = \"APPLY_OBJECTIVE\";\nexport const HAS_BODY = \"oa:hasBody\";\nexport const FETCH_SCORE = 'FETCH_SCORE';\nexport const FETCH_RIBBON_CONTENT = 'FETCH_RIBBON_CONTENT';\nexport const FETCH_CONCEPTUAL_SCORE = 'FETCH_CONCEPTUAL_SCORE';\nexport const FETCH_TEI = 'FETCH_TEI';\nexport const FETCH_GRAPH = 'FETCH_GRAPH';\nexport const FETCH_GRAPH_DOCUMENT = 'FETCH_GRAPH_DOCUMENT';\nexport const FETCH_WORK = 'FETCH_WORK';\nexport const FETCH_TARGET_EXPRESSION = 'FETCH_TARGET_EXPRESSION';\nexport const FETCH_COMPONENT_TARGET = 'FETCH_COMPONENT_TARGET';\nexport const PROCESS_COMPONENT_TARGET = 'PROCESS_COMPONENT_TARGET';\nexport const FETCH_STRUCTURE = 'FETCH_STRUCTURE';\nexport const FETCH_MANIFESTATIONS = 'FETCH_MANIFESTATIONS';\nexport const SCORE_PREV_PAGE = 'SCORE_PREV_PAGE';\nexport const SCORE_NEXT_PAGE = 'SCORE_NEXT_PAGE';\nexport const SCORE_SET_OPTIONS = 'SCORE_SET_OPTIONS';\nexport const SCORE_PAGE_TO_TARGET = 'SCORE_PAGE_TO_TARGET';\nexport const PROCESS_ANNOTATION = 'PROCESS_ANNOTATION';\nexport const SESSION_GRAPH_ETAG = 'SESSION_GRAPH_ETAG';\nexport const RESET_NEXT_SESSION_TRIGGER = 'RESET_NEXT_SESSION_TRIGGER';\nexport const TRANSITION_TO_NEXT_SESSION = 'TRANSITION_TO_NEXT_SESSION';\nexport const REGISTER_PUBLISHED_PERFORMANCE_SCORE = 'REGISTER_PUBLISHED_PERFORMANCE_SCORE';\nexport const MUZICODES_UPDATED = 'MUZICODES_UPDATED';\nexport const REALIZATION_OF = 'frbr:realizationOf';\nexport const EXPRESSION = 'frbr:Expression';\nexport const PART_OF = 'frbr:partOf';\nexport const PART = 'frbr:part';\nexport const KEY = 'mo:key';\nexport const HARMONY = 'https://meld.linkedmusic.org/companion/vocab/harmony';\nexport const CADENCE = 'https://meld.linkedmusic.org/companion/vocab/cadentialGoal';\nexport const DEGREE = 'https://meld.linkedmusic.org/companion/vocab/hasDegree';\nexport const CHORD_TYPE = 'https://meld.linkedmusic.org/companion/vocab/chordType';\nexport const HAS_STRUCTURE = 'https://meld.linkedmusic.org/terms/hasStructure';\nexport const SEQ = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#Seq';\nexport const SEQPART = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#_';\nexport const SCORE = 'http://purl.org/ontology/mo/Score';\nexport const CONTAINS = 'http://www.w3.org/ns/ldp#contains';\nexport const MOTIVATED_BY = 'http://www.w3.org/ns/oa#motivatedBy';\nexport const SEGMENT = 'so:Segment';\nexport const MUZICODE = 'meld:Muzicode';\nexport const PUBLISHED_AS = 'http://purl.org/ontology/mo/published_as';\nexport const HAS_PERFORMANCE_MEDIUM = 'http://rdaregistry.info/Elements/e/p20215';\nexport const HAS_PIANO = \"http://id.loc.gov/authorities/performanceMediums/2013015550\";\nexport const CREATE_SESSION = \"CREATE_SESSION\";\nexport const SESSION_NOT_CREATED = \"SESSION_NOT_CREATED\";\nexport const TICK = \"TICK\";\nexport const TRAVERSAL_PREHOP = \"TRAVERSAL_PREHOP\";\nexport const TRAVERSAL_HOP = \"TRAVERSAL_HOP\";\nexport const TRAVERSAL_FAILED = \"TRAVERSAL_FAILED\";\nexport const TRAVERSAL_UNNECCESSARY = \"TRAVERSAL_UNNECCESSARY\";\nexport const TRAVERSAL_CONSTRAINED = \"TRAVERSAL_CONSTRAINED\";\nexport const IGNORE_TRAVERSAL_OBJECTIVE_CHECK_ON_EMPTY_GRAPH = \"IGNORE_TRAVERSAL_OBJECTIVE_CHECK_ON_EMPTY_GRAPH\";\nexport const RUN_TRAVERSAL = \"RUN_TRAVERSAL\";\nexport const REGISTER_TRAVERSAL = \"REGISTER_TRAVERSAL\";\nexport const UPDATE_LATEST_RENDERED_PAGENUM = \"UPDATE_LATEST_RENDERED_PAGENUM\";\nexport const muzicodesUri = \"http://127.0.0.1:5000/MUZICODES\";\nexport const MAX_RETRIES = 3;\nexport const MAX_TRAVERSAL_HOPS = 10;\nexport const RETRY_DELAY = 10; // TODO move context somewhere global -- most framing happens server side\n// anyway, but in cases where the framed URI contains a fragment (\"#\"), \n// we have to do it client-side\t\t\n\nconst context = {\n  \"popRoles\": \"http://pop.linkedmusic.org/roles/\",\n  \"mo\": \"http://purl.org/ontology/mo/\",\n  \"ldp\": \"http://www.w3.org/ns/ldp#\",\n  \"mp\": \"http://id.loc.gov/authorities/performanceMediums/\",\n  \"oa\": \"http://www.w3.org/ns/oa#\",\n  \"frbr\": \"http://purl.org/vocab/frbr/core#\",\n  \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n  \"meld\": \"https://meld.linkedmusic.org/terms/\",\n  \"motivation\": \"https://meld.linkedmusic.org/motivation/\",\n  \"so\": \"http://www.linkedmusic.org/ontologies/segment/\",\n  \"dct\": \"http://purl.org/dc/terms/\",\n  \"climb\": \"http://meld.linkedmusic.org/climb/terms/\",\n  \"mc\": \"http://meld.linkedmusic.org/climb/muzicodeTypes/\"\n};\nexport function fetchScore(url, options) {\n  console.log(\"FETCH_SCORE ACTION on URI: \", url);\n  return dispatch => {\n    auth.fetch(url, {\n      mode: 'cors'\n    }).then(response => {\n      return response.text();\n    }).then(data => {\n      dispatch({\n        type: FETCH_SCORE,\n        payload: {\n          data,\n          config: {\n            url,\n            options\n          }\n        }\n      });\n    });\n  };\n}\nexport function fetchRibbonContent(url) {\n  // console.log(\"FETCH_RIBBON_CONTENT ACTION on URI: \", uri);\n  const promise = auth.fetch(url);\n  return dispatch => {\n    auth.fetch(url, {\n      mode: 'cors'\n    }).then(response => {\n      return response.text();\n    }).then(data => {\n      dispatch({\n        type: FETCH_RIBBON_CONTENT,\n        payload: {\n          data,\n          config: {\n            url\n          }\n        }\n      });\n    });\n  };\n  /*\n  return {\n   type: FETCH_RIBBON_CONTENT,\n   payload: promise\n  }*/\n}\nexport function fetchTEI(uri) {\n  const promise = new CETEI().getHTML5(uri);\n  return dispatch => {\n    promise.then(data => {\n      dispatch({\n        type: FETCH_TEI,\n        payload: {\n          data: data,\n          uri: uri\n        }\n      });\n    });\n  };\n}\nexport function registerTraversal(docUri, suppliedParams = {}) {\n  // PURPOSE:\n  // *************************************************************************\n  // Traverse through a graph, looking for entities of interest\n  //   (keys of 'objectives') and undertaking actions in response\n  //   (values of 'objectives').\n  // For each subject, traverse along its predicates to its attached objects,\n  //   then recurse (each object becomes subject in next round).\n  // When recursing, check for instances of object-as-subject in the current\n  //   file (traverseInternal), AND do an HTTP GET to resolve the object URI\n  //   and recurse there (external traversal).\n  // If useEtag is specified, then worry about etags for external traversals\n  // \t (and re-request if the file has changed)\n  // \t n.b. this is only an issue for dynamic MELD deployments\n  // With each hop, decrement numHops.\n  // Stop when numHops reaches zero, or when there are no more objects\n  //   to traverse to.\n  // If an extendObjectPrefix is specified, only traverse to objects with\n  //  URIs that start with a prefix in the list.\n  // If an extendObjectUri is specified, only traverse to objects with\n  //  URIs in the list.\n  // If an extendObjectType is specified, only traverse to objects with\n  //  a type that's in the list.\n  // If an ignoreObjectPrefix is specified, only traverse to objects with\n  //  URIs that do NOT start with a prefix in the list.\n  // If an ignoreObjectUri is specified, only traverse to objects with\n  //  URIs that are NOT in the list.\n  // If an ignoreObjectType is specified, do NOT traverse to  objects with\n  //  types in the list.\n  // If a followPropertyPrefix is specified, only traverse to objects along\n  //  properties whose URIs start with a prefix in the list.\n  // If a followPropertyUri is specified, only traverse to objects along\n  //  properties with URIs in the list.\n  // If a ignorePpropertyPrefix is specified, only traverse to objects along\n  //  properties whose URIs do NOT start with a prefix in the list.\n  // If a followPropertyUri is specified, only traverse to objects along\n  //  properties with URIs that are NOT in the list.\n  // *************************************************************************\n  // create new params object to pass on in recursive calls\n  // n.b. must update here if function signature changes - the\n  // params object is also used to check supplied parameter names.\n  const defaultParams = {\n    extendObjectPrefix: [],\n    extendObjectUri: [],\n    extendObjectType: [],\n    ignoreObjectPrefix: [],\n    ignoreObjectUri: [],\n    ignoreObjectType: [],\n    followPropertyPrefix: [],\n    followPropertyUri: [],\n    ignorePpropertyPrefix: [],\n    ignorePropertyUri: [],\n    objectives: {},\n    numHops: MAX_TRAVERSAL_HOPS,\n    useEtag: false,\n    etag: \"\"\n  };\n  let params = { ...defaultParams\n  }; // Check for unknown parameter/option names, and issue warnings\n\n  var key;\n\n  for (key in suppliedParams) {\n    if (!(key in params)) {\n      console.log(\"registerTraversal: unrecognized option: \", key);\n    } else {\n      params[key] = suppliedParams[key];\n    }\n  } // For older app compatibility, map old parameter names to new\n\n\n  const oldParamsMap = [[\"objectPrefixWhitelist\", \"extendObjectPrefix\"], [\"objectUriWhitelist\", \"extendObjectUri\"], [\"objectTypeWhitelist\", \"extendObjectType\"], [\"objectPrefixBlacklist\", \"ignoreObjectPrefix\"], [\"objectUriBlacklist\", \"ignoreObjectUri\"], [\"objectTypeBlacklist\", \"ignoreObjectType\"], [\"propertyPrefixWhitelist\", \"followPropertyPrefix\"], [\"propertyUriWhitelist\", \"followPropertyUri\"], [\"propertyPrefixBlacklist\", \"ignorePropertyPrefix\"], [\"propertyUriBlacklist\", \"ignorePropertyUri\"]];\n\n  for (var i in oldParamsMap) {\n    var oldkey = oldParamsMap[i][0];\n    var newkey = oldParamsMap[i][1];\n\n    if (oldkey in suppliedParams && !(newkey in suppliedParams)) {\n      params[newkey] = suppliedParams[oldkey];\n    }\n  }\n\n  const unimplementedParams = (\"extendObjectType\", \"ignoreObjectType\", \"followPropertyPrefix\", \"followPropertyUri\", \"ignorePropertyPrefix\", \"ignorePropertyUri\");\n\n  for (key in unimplementedParams) {\n    if (key in params) {\n      console.log(\"registerTraversal: unimplemented option: \", key);\n    }\n  }\n\n  docUri = new URL(docUri, document.URL).toString();\n\n  if (passesTraversalConstraints({\n    \"@id\": docUri\n  }, params)) {\n    return {\n      type: REGISTER_TRAVERSAL,\n      payload: {\n        docUri,\n        params\n      }\n    };\n  } else {\n    return {\n      type: TRAVERSAL_CONSTRAINED\n    };\n  }\n}\nexport function traverse(docUri, params) {\n  // set up HTTP request\n  const headers = {\n    'Accept': 'application/ld+json'\n  };\n\n  if (params[\"useEtag\"]) {\n    headers['If-None-Match'] = params[\"etag\"];\n  }\n\n  console.log(\"FETCHING: \", docUri, params);\n  const promise = auth.fetch(docUri, {\n    headers: headers,\n    mode: 'cors'\n  });\n  return dispatch => {\n    dispatch({\n      type: RUN_TRAVERSAL,\n      payload: {\n        docUri\n      }\n    });\n    promise.then(response => {\n      if (response.status == 304) {\n        dispatch({\n          type: TRAVERSAL_UNNECCESSARY\n        });\n        return; // file not modified, i.e. etag matched, no updates required\n      }\n\n      console.log(response.headers.get(\"Content-Type\")); // attempt to decide content type (either explicitly provided or by file suffix)\n      // and proceed with traversal accordingly\n\n      if (docUri.endsWith(\".json\") || docUri.endsWith(\".jsonld\") || docUri.endsWith(\".json-ld\") || response.headers.get(\"Content-Type\").startsWith(\"application/ld+json\") || response.headers.get(\"Content-Type\").startsWith(\"application/json\")) {\n        // treat as JSON-LD document\n        dispatch(traverseJSONLD(dispatch, docUri, params, response.json()));\n      } else if (docUri.endsWith(\".ttl\") || docUri.endsWith(\".n3\") || docUri.endsWith(\".rdf\") || docUri.endsWith(\".nt\") || response.headers.get(\"Content-Type\").startsWith(\"application/rdf+xml\") || response.headers.get(\"Content-Type\").startsWith(\"application/x-turtle\") || response.headers.get(\"Content-Type\").startsWith(\"text/turtle\")) {\n        // treat as RDF document\n        // TODO: Translate RDF to JSON-LD, then proceed with traverseJSONLD as above\n        dispatch({\n          type: TRAVERSAL_FAILED\n        });\n        console.log(\"Can't handle this document: (We currently only support nq and JSON-LD)\", docUri, response); // dispatch(traverseRDF(dispatch, docUri, params, response.text()));\n      } else if (docUri.endsWith(\".nq\") || response.headers.get(\"Content-Type\").startsWith(\"application/nquads\")) {\n        dispatch(traverseRDF(dispatch, docUri, params, response.text()));\n      } else {\n        dispatch({\n          type: TRAVERSAL_FAILED\n        });\n        console.log(\"Don't know how to treat this document: \", docUri, response);\n      } // appropriately handle content types\n      //\t\t\tif(isRDF(response.headers.get(\"Content-Type\"))) {\n      //\t\t\t\ttoNQuads(\n      //\t\t\t\t\t\n      //\t\t\t}\n      //\t\t\tswitch(response.headers.get(\"Content-Type\")) {\n      //\t\t\t\t// If we are working with RDF, we need to convert it to JSON-LD.\n      //\t\t\t\t// Unfortunately jsonld.js only reads nquads.\n      //\t\t\t\t// Thus, convert non-nquad RDF formats to nquad first\n      //\t\t\t\tcase \"text/turtle\":\n      //\t\t\t\tcase \"application/trig\":\n      //\t\t\t\tcase \"application/n-triples\":\n      //\t\t\t\tcase \"text/n3\":\n      //\n\n    }).catch(err => {\n      dispatch({\n        type: TRAVERSAL_FAILED\n      });\n      console.log(\"Could not retrieve \", docUri, err);\n    });\n    return {\n      type: TRAVERSAL_PREHOP\n    };\n  };\n} //helper function: \n// skolemize blank nodes to prevent identifier clashes between documents\n// by detecting \"_:<blank-node-identifier>\"\n// and replacing with document uri appended with  /genid/<blank-node-identifier> \n// by virtue of traversal mechanism, we only ever visit each document once, \n// so clashes with the same document should not occur.\n\nfunction skolemize(obj, docUri) {\n  if (Array.isArray(obj)) {\n    // if fed an array, recur on each constitutent\n    obj = obj.map(o => skolemize(o, docUri));\n  } else if (obj === Object(obj)) {\n    // if fed an object, iterate over each key\n    Object.keys(obj).map(k => {\n      if (k === \"@id\") {\n        // found an @id, check for blank node and skolemize if necesssary\n        obj[\"@id\"] = obj[\"@id\"].replace(\"_:\", docUri + \"#genid-\");\n      } else {\n        // recur on value\n        obj[k] = skolemize(obj[k], docUri);\n      }\n    });\n  }\n\n  return obj;\n}\n\nfunction traverseRDF(dispatch, docUri, params, dataPromise) {\n  console.log(\"in traverseRDF for doc \", docUri, \"with exclude list \", params[\"ignoreObjectUri\"]); // expand the JSON-LD object so that we are working with full URIs, not compacted into prefixes\n\n  dataPromise.then(data => {\n    dispatch(traverseJSONLD(dispatch, docUri, params, jsonld.fromRDF(data)));\n  }).catch(err => console.error(err));\n  return {\n    type: TRAVERSAL_HOP\n  };\n}\n\nfunction traverseJSONLD(dispatch, docUri, params, dataPromise) {\n  console.log(\"in traverseJSONLD for doc \", docUri, \"with exclude list \", params[\"ignoreObjectUri\"]); // expand the JSON-LD object so that we are working with full URIs, not compacted into prefixes\n\n  dataPromise.then(data => {\n    console.log(\"attempting to expand: \", data);\n    jsonld.expand(data).then(expanded => {\n      console.log(\"Got expanded json: \", expanded); // flatten the expanded JSON-LD object so that each described entity has an ID at the top-level of the tree\n\n      jsonld.flatten(expanded).then(flattened => {\n        const skolemized = skolemize(flattened, docUri);\n        dispatch({\n          type: FETCH_GRAPH_DOCUMENT,\n          payload: {\n            data: skolemized,\n            uri: docUri\n          }\n        }); // convert the flattened array of JSON-LD structures into a lookup table using each entity's URI (\"@id\")\n\n        let idLookup = {};\n        Object.entries(skolemized).forEach(([key, value]) => {\n          idLookup[value[\"@id\"]] = value;\n        });\n        Object.entries(idLookup).forEach(([subjectUri, subjectDescription]) => {\n          // iterating through each entity within the document as the subject,\n          // look at its description (set of predicate-object tuples).\n          Object.entries(subjectDescription).forEach(([pred, objs]) => {\n            // because JSON-LD, objs could be a single object or an array of objects\n            // therefore, ensure consistency:\n            objs = Array.isArray(objs) ? objs : [objs];\n            objs.map(obj => {\n              if (obj === Object(obj)) {\n                // our *RDF* object is a *JAVASCRIPT* object\n                // but because we've flattened our document, we know that it will contain only an @id\n                // and that all of its other descriptors will be associated with that @id at the top-level\n                // (which we will handle in another iteration)\n                // CHECK FOR OBJECTIVES HERE\n                //console.log(\"<>\", subjectUri, pred, obj[\"@id\"], docUri);\n                // Now recurse (if exclusion/inclusion conditions and hop counter allow)\n                if (passesTraversalConstraints(obj, params)) {\n                  //                  console.log(\"registering next traversal!\", obj[\"@id\"])\n                  dispatch(registerTraversal(obj[\"@id\"], { ...params,\n                    // Remember that we've already visited the current document to avoid loops\n                    \"ignoreObjectUri\": params[\"ignoreObjectUri\"].concat(docUri.split(\"#\")[0]),\n                    \"numHops\": params[\"numHops\"] - 1\n                  }));\n                }\n              } else {// our *RDF* object is a literal\n                // n.b. exceptions where pred is @type, @id, etc. There, the obj is still a URI, not a literal\n                // Could test for those explicitly here.\n                // CHECK FOR OBJECTIVES HERE\n                //\tconsole.log(\"||\", subjectUri, pred, obj, docUri)\n              }\n            });\n          });\n        });\n      });\n    }).catch(error => console.log(\"EXPANSION ERROR: \", docUri, err));\n  });\n  return {\n    type: TRAVERSAL_HOP\n  };\n}\n\nfunction passesTraversalConstraints(obj, params) {\n  // filter function that returns TRUE if uri should be traversed to\n  // (with a given set of constraints in the params)\n  //\n  // test: ensure we haven't run out of hops\n  if (params[\"numHops\"] === 0) {\n    //console.log(\"Test 1: Out of hops\", obj, params)\n    return false;\n  } // test: ensure obj is not a literal\n\n\n  if (!(\"@id\" in obj)) {\n    // ////console.log(\"Test 2: Found a literal\", obj, params)\n    return false;\n  }\n\n  const resourceUri = obj[\"@id\"].split(\"#\")[0]; // don't traverse fragments of an excluded resource...\n  // test: object URI doesn't violate constraints\n\n  if (params[\"extendObjectUri\"].length) {\n    // URI inclusion list specified:\n    // only pass if included in URI inclusion list AND not in URI exclusion list\n    if (!params[\"extendObjectUri\"].includes(resourceUri) || params[\"ignoreObjectUri\"].includes(resourceUri)) {\n      //console.log(\"Test 3: object excluded (and not in inclusion list)\", obj, params)\n      return false;\n    }\n  } else {\n    // no URI inclusion list\n    // only pass if not in URI exclusion list\n    if (params[\"ignoreObjectUri\"].includes(resourceUri)) {\n      //console.log(\"Test 4: object excluded (without inclusion list)\", obj, params)\n      return false;\n    }\n  } // test: object URI doesn't violate PREFIX constraints\n\n\n  const prefixExcluded = params[\"ignoreObjectPrefix\"].filter(pre => {\n    return resourceUri.startsWith(pre.split(\"#\")[0]);\n  }); // only pass if prefix not excluded\n\n  if (prefixExcluded.length) {\n    //console.log(\"Test 5: prefix excluded\", obj, params)\n    return false;\n  }\n\n  if (params[\"extendObjectPrefix\"].length) {\n    // Prefix inclusion list specified:\n    const prefixIncluded = params[\"extendObjectPrefix\"].filter(pre => {\n      return resourceUri.startsWith(pre);\n    }); // only pass if included in prefix inclusion list\n\n    if (prefixIncluded.length === 0) {\n      //console.log(\"Test 6: prefix not in specified inclusion list\", obj, params)\n      return false;\n    }\n  } //console.log(\"Object passes all traversal constraint tests\", obj, params, params[\"extendObjectPrefix\"], params[\"ignoreObjectPrefix\"], params[\"ignoreObjectUri\"]);\n\n\n  return true;\n}\n\nexport function checkTraversalObjectives(graph, objectives) {\n  // check a given json-ld structure against a set of objectives (json-ld frames)\n  if (graph.length) {\n    return dispatch => {\n      let framingPromises = [];\n      objectives.forEach(obj => {\n        framingPromises.push(jsonld.frame(graph, obj));\n      });\n      Promise.allSettled(framingPromises).then(framedResolved => {\n        framedResolved.forEach((resolvedFrame, ix) => {\n          const framed = resolvedFrame[\"value\"];\n          dispatch({\n            type: APPLY_TRAVERSAL_OBJECTIVE,\n            payload: {\n              ix,\n              framed\n            }\n          });\n        });\n      });\n    };\n  } else {\n    return {\n      type: IGNORE_TRAVERSAL_OBJECTIVE_CHECK_ON_EMPTY_GRAPH\n    };\n  }\n}\nexport function setTraversalObjectives(objectives) {\n  return {\n    type: SET_TRAVERSAL_OBJECTIVES,\n    payload: objectives\n  };\n}\nexport function fetchSessionGraph(uri, etag = \"\") {\n  console.warn(\"DEPRECATION WARNING: The function fetchSessionGraph is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\"); // console.log(\"FETCH_SESSION_GRAPH ACTION ON URI: \", uri, \" with etag: \", etag);\n  // TODO add etag to header as If-None-Match and enable corresponding support on server\n  // so that it can respond with 304 instead of 200 (i.e. so it can ommit file body)\n\n  const promise = auth.fetch(uri, {\n    headers: {\n      'Accept': 'application/ld+json',\n      'If-None-Match': etag\n    },\n    mode: 'cors'\n  });\n  return dispatch => {\n    promise.then(response => {\n      if (response.status == 304) {\n        return; // don't need to do any new work\n      }\n\n      const framed = response.data;\n      const session = framed[\"@graph\"][0];\n\n      if (!etag) {\n        // first time through: follow your nose along the conceptual score\n        // to retrieve the published score (MEI file)\n        if (\"mo:performance_of\" in session) {\n          dispatch(fetchConceptualScore(session[\"@id\"], session[\"mo:performance_of\"][\"@id\"]));\n        } else {\n          console.log(\"SESSION IS NOT A PERFORMANCE OF A SCORE: \", session);\n        }\n      }\n\n      if (response.headers.etag !== etag) {\n        // we need to grab the graph data, either because this is the first time,\n        // or because session etag has changed (i.e. annotation has been posted/patched)\n        dispatch({\n          type: FETCH_GRAPH,\n          payload: framed\n        }); // take note of the new etag\n\n        dispatch({\n          type: SESSION_GRAPH_ETAG,\n          payload: {\n            uri: uri,\n            etag: response.headers.etag\n          }\n        });\n\n        if (\"ldp:contains\" in framed[\"@graph\"][0]) {\n          // there are one or more annotations to process\n          framed[\"@graph\"][0] = ensureArray(framed[\"@graph\"][0], \"ldp:contains\"); // process each annotation\n\n          framed[\"@graph\"][0][\"ldp:contains\"].map(annotation => {\n            dispatch(processComponentAnnotation(annotation, session[\"mo:performance_of\"][\"@id\"]));\n          });\n        }\n      }\n    });\n  };\n}\nexport function fetchGraph(uri) {\n  // console.log(\"FETCH_GRAPH ACTION ON URI: \", uri);\n  const promise = auth.fetch(uri);\n  return dispatch => {\n    promise.then(({\n      data\n    }) => {\n      // dispatch the graph data\n      dispatch({\n        type: FETCH_GRAPH,\n        payload: data\n      }); // walk through component annotations\n\n      data[\"@graph\"][0][\"ldp:contains\"].map(topLevel => {\n        topLevel[\"oa:hasBody\"].map(annotation => {\n          dispatch(processComponentAnnotation(annotation));\n        });\n      });\n    });\n  };\n}\n\nfunction processComponentAnnotation(annotation, conceptualScore = \"\") {\n  console.warn(\"DEPRECATION WARNING: The function processComponentAnnotation is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\");\n\n  if (\"meld:state\" in annotation && annotation[\"meld:state\"][\"@id\"] === \"meld:processed\") {\n    // We can skip this processed annotation\n    return {\n      type: ANNOTATION_SKIPPED,\n      payload: annotation\n    };\n  }\n\n  annotation = ensureArray(annotation, \"oa:hasTarget\"); // console.log(\"Processing component annotation: \", annotation, conceptualScore)\n\n  const targets = annotation[\"oa:hasTarget\"].map(target => {\n    return {\n      \"@id\": target[\"@id\"],\n      // DW TODO 20170830 may need to validate whether @type exists\n      \"@type\": target[\"@type\"]\n    };\n  });\n  return dispatch => {\n    targets.map(target => {\n      dispatch(fetchComponentTarget(target[\"@id\"], conceptualScore));\n    });\n    dispatch({\n      type: PROCESS_ANNOTATION,\n      payload: {\n        id: annotation[\"@id\"],\n        bodies: annotation[\"oa:hasBody\"],\n        targets: targets\n      }\n    });\n  };\n}\n\nexport function fetchComponentTarget(uri, conceptualScore = \"\") {\n  console.warn(\"DEPRECATION WARNING: The function fetchComponentTarget is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\"); // console.log(\"FETCH_COMPONENT_TARGET ACTION ON URI: \", uri);\n\n  const promise = auth.fetch(uri, {\n    headers: {\n      'Accept': 'application/ld+json'\n    },\n    mode: 'cors'\n  });\n  return dispatch => {\n    promise.then(data => {\n      // console.log(\"Attemping to frame data\", data);\n      if (!\"content-type\" in data.headers || data.headers.get(\"Content-Type\") !== \"application/json\" && data.headers.get(\"Content-Type\") !== \"application/ld+json\") {\n        // console.log(\"Converting to JSON...\");\n        // need to convert triples to json\n        // TODO handle arbitrary RDF format here (currently requires ntriples)\n        jsonld.fromRDF(data.data, {\n          format: 'application/n-quads'\n        }).then(doc => {\n          dispatch(processComponentTarget(doc, uri, conceptualScore));\n        }).catch(err => console.log(\"ERROR CONVERTING NQUADS TO JSON-LD: \", err));\n      } else {\n        // already in json format\n        dispatch(processComponentTarget(data.data, uri, conceptualScore));\n      }\n    });\n  };\n}\n\nfunction processComponentTarget(data, uri, conceptualScore) {\n  console.warn(\"DEPRECATION WARNING: The function processComponentTarget is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the checkTraversalObjectives function instead.\"); // console.log(\"PROCESS_COMPONENT_TARGET ACTION ON URI: \", uri);\n\n  return dispatch => {\n    jsonld.frame(data, {\n      \"@id\": uri\n    }).then(framed => {\n      jsonld.compact(framed, context).then(compacted => {\n        dispatch({\n          type: FETCH_COMPONENT_TARGET,\n          payload: {\n            conceptualScore: conceptualScore,\n            structureTarget: uri\n          }\n        }); // console.log(\"COMPACTED: \", compacted);\n\n        let typecheck = compacted;\n        typecheck = ensureArray(typecheck, \"@type\"); // have we found a segment?\n        // console.log(\"TYPECHECK: \", typecheck)\n\n        if (typecheck[\"@type\"].includes(SEGMENT) || typecheck[\"@type\"].includes(MUZICODE)) {\n          // TODO jsonldify context\n          // TODO refine muzicode semantics for this\n          // found a segment or muzicode!\n          // hand it off to the reducer to process the embodibag\n          // nb this is a different route to larrymeld (via expression)\n          // i.e. there is no partonomy here. So send the segment itself as the part.\n          dispatch({\n            type: FETCH_MANIFESTATIONS,\n            payload: {\n              target: compacted,\n              part: compacted\n            }\n          });\n        } else {\n          // if not, continue following links via the target's expression\n          dispatch(fetchTargetExpression(compacted));\n        }\n      }).catch(err => console.log(\"COMPACTING ERROR in processComponentTarget:\", err));\n    }).catch(err => {\n      type: ANNOTATION_NOT_HANDLED;\n    });\n  };\n}\n\nexport function fetchTargetExpression(compacted) {\n  console.warn(\"DEPRECATION WARNING: The function fetchTargetExpression is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\"); // traverse from the provided Expression, via a Segment, to Manifestation(s)\n  // console.log(\"In fetchTargetExpression: \", compacted);\n\n  return dispatch => {\n    dispatch({\n      type: FETCH_TARGET_EXPRESSION,\n      payload: compacted\n    });\n    let target = compacted;\n\n    if (target[\"@type\"].includes(EXPRESSION)) {\n      // found an expression\n      // Do we have a harmony declaration?\n      let chords = [];\n      let expressionObj = {};\n      expressionObj['@id'] = target['@id'];\n\n      if (PART_OF in target) {\n        expressionObj.motif = target[PART_OF]['@id'];\n        expressionObj.n = parseInt(/\\d*$/.exec(target['@id'])[0]); // FIXME: bad hack for not having seq available\n      }\n\n      if (REALIZATION_OF in target) {\n        expressionObj.segment = target[REALIZATION_OF]['@id'];\n      }\n\n      if (KEY in target) expressionObj.key = target[KEY]['@id'];\n\n      if (HARMONY in target) {\n        if (PART_OF in target) {\n          expressionObj.motif = target[PART_OF]['@id'];\n          expressionObj.chords = chords;\n        }\n\n        var counter = 1;\n        var urlBegins = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#_\";\n\n        while (urlBegins + counter in target[HARMONY]) {\n          chords.push(target[HARMONY][urlBegins + counter]);\n          counter++;\n        }\n      }\n\n      if (CADENCE in target) {\n        var cadenceData = target[CADENCE];\n        expressionObj.cadence = {};\n        if (DEGREE in cadenceData) expressionObj.cadence.degree = cadenceData[DEGREE]['@id'];\n        if (CHORD_TYPE in cadenceData) expressionObj.cadence.chordType = cadenceData[CHORD_TYPE]['@id'];\n      } // does it have any parts?\n\n\n      let parts = []; // console.log(\"part check: \", target)\n\n      if (PART in target) {\n        // sometimes we may have multiple parts or part sequences; sometimes only one\n        // so ensure we have an array to work with (even if it's length one)\n        // TODO refactor to use ensureArray helper function\n        if (!Array.isArray(target[PART])) {\n          target[PART] = [target[PART]];\n        } // now process each sequence\n\n\n        target[PART].map(p => {\n          if (\"@type\" in p && p[\"@type\"].includes(SEQ)) {\n            // it's an RDF sequence\n            Object.keys(p).map(part => {\n              if (part.startsWith(SEQPART)) {\n                parts.push(p[part][\"@id\"]);\n              }\n            });\n          } else {\n            parts.push(p[\"@id\"]);\n          }\n        }); // now fetch the work to continue on to the manifestations associated with these parts\n\n        if (REALIZATION_OF in target) {\n          dispatch(fetchWork(compacted, parts, target[REALIZATION_OF][\"@id\"], expressionObj));\n        } else {\n          console.log(\"Target is an unrealized expression: \", target);\n        }\n      } else {\n        console.log(\"Target expression without parts\", target);\n      }\n    } else {\n      console.log(\"fetchTargetExpression attempted on a non-Expression! \", target);\n    }\n  };\n}\nexport function fetchWork(target, parts, work, expressionObj) {\n  console.warn(\"DEPRECATION WARNING: The function fetchWork is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\"); // console.log(\"STARTING FETCHWORK WITH \", work, parts, expressionObj);\n\n  return dispatch => {\n    dispatch({\n      type: FETCH_WORK,\n      payload: {\n        target: target,\n        parts: parts,\n        works: work,\n        chords: expressionObj\n      }\n    });\n    auth.fetch(work).then(data => {\n      jsonld.fromRDF(data.data, (err, doc) => {\n        if (err) {\n          console.log(\"ERROR TRANSLATING NQUADS TO JSONLD: \", err, data.data);\n        } else {\n          jsonld.frame(doc, {\n            \"@id\": work\n          }, (err, framed) => {\n            if (err) {\n              console.log(\"FRAMING ERROR in fetchWork:\", err);\n            } else {\n              jsonld.compact(framed, context, (err, compacted) => {\n                if (err) {\n                  console.log(\"COMPACTING ERROR in fetchWork:\", err);\n                } else {\n                  work = compacted; // Check if there is a segment line, in which case fetch manifestations\n                  // else, check if this is part of another (\"parent\") work\n\n                  if (HAS_STRUCTURE in work) {\n                    dispatch(fetchStructure(target, parts, work[HAS_STRUCTURE][\"@id\"]));\n                  } else if (PART_OF in work) {\n                    // does our doc attach a Score which realizes the parent work?\n                    // FIXME HACKHACK:\n                    // framing expands the nice compacted URIs\n                    // so here we need to use full URIs instead of REALIZATION_OF as defined above\n                    jsonld.frame({\n                      \"@context\": context,\n                      \"@graph\": doc\n                    }, {\n                      \"http://purl.org/vocab/frbr/core#realizationOf\": work[PART_OF][\"@id\"]\n                    }, (err, framed) => {\n                      if (err) {\n                        console.log(\"FRAMING ERROR when fetching parent work\", err);\n                      } else {\n                        // console.log(\"Attached score:\", framed);\n                        const attachedScore = framed[\"@graph\"][0];\n\n                        if (attachedScore && \"@type\" in attachedScore && attachedScore[\"@type\"] === SCORE) {\n                          // FIXME breaks with multiple types\n                          // Found an attached Score!!!\n                          if (PUBLISHED_AS in attachedScore) {\n                            // for now: assume published scores\n                            // are attached in same file\n                            // FIXME enable external pub_scores\n                            attachedScore[PUBLISHED_AS].map(pubScore => {\n                              // console.log(\"FOUND PUB SCORE: \", pubScore);\n                              if (HAS_PERFORMANCE_MEDIUM in pubScore) {\n                                // console.log(\"FOUND PERF MEDIUM: \", pubScore[HAS_PERFORMANCE_MEDIUM]);\n                                dispatch({\n                                  type: REGISTER_PUBLISHED_PERFORMANCE_SCORE,\n                                  payload: {\n                                    work: work,\n                                    conceptualScore: attachedScore,\n                                    publishedScore: pubScore,\n                                    performanceMedium: pubScore[HAS_PERFORMANCE_MEDIUM]\n                                  }\n                                });\n\n                                if (pubScore[HAS_PERFORMANCE_MEDIUM]['@id'] == HAS_PIANO) {\n                                  dispatch(fetchScore(pubScore[\"@id\"]));\n                                } else {\n                                  dispatch(fetchRibbonContent(pubScore[\"@id\"]));\n                                }\n                              } else {// console.log(\"Published score without performance medium: \", pubScore[\"@id\"]);\n                              }\n                            });\n                          } else {// console.log(\"Unpublished score: \", attachedScore);\n                          }\n\n                          if (HAS_STRUCTURE in attachedScore) {\n                            dispatch(fetchStructure(target, parts, attachedScore[HAS_STRUCTURE][\"@id\"]));\n                          } else {// console.log(\"Score \", attachedScore[\"@id\"], \" attached to work \", work[\"@id\"], \" has no segment line!!\");\n                          }\n                        } else {\n                          // no attached Score, so we have to recurse on the parent work\n                          dispatch(fetchWork(target, parts, work[PART_OF][\"@id\"]));\n                        }\n                      }\n                    });\n                  } else {// console.log(\"Found work without segmentLine or partonomy! \", work);\n                  }\n                }\n              });\n            }\n          });\n        }\n      });\n    });\n  };\n}\nexport function fetchStructure(target, parts, segline) {\n  console.warn(\"DEPRECATION WARNING: The function fetchStructure is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\");\n  return dispatch => {\n    dispatch({\n      type: FETCH_STRUCTURE,\n      payload: {\n        target: target,\n        parts: parts,\n        structure: segline\n      }\n    });\n    auth.fetch(segline).then(data => {\n      jsonld.fromRDF(data.data, (err, doc) => {\n        if (err) {\n          console.log(\"ERROR TRANSLATING NQUADS TO JSONLD: \", err, data.data);\n        } else {\n          // frame the doc in terms of each part of the expression targetted by the annotation\n          parts.map(part => {\n            jsonld.frame(doc, {\n              \"@id\": part\n            }, (err, framed) => {\n              if (err) {\n                console.log(\"FRAMING ERROR in fetchStructure: \", err);\n              } else {\n                jsonld.compact(framed, context, (err, compacted) => {\n                  if (err) {\n                    console.log(\"COMPACTING ERROR in fetchStructure:\", err);\n                  } else {\n                    // and hand to reducers to process associated embodibags\n                    // (manifestations of the expression)\n                    // console.log(\"fetching manifestations\", doc, target, part, compacted);\n                    dispatch({\n                      type: FETCH_MANIFESTATIONS,\n                      payload: {\n                        target: target,\n                        part: compacted\n                      }\n                    });\n                  }\n                });\n              }\n            });\n          });\n        }\n      });\n    });\n  };\n}\nexport function fetchConceptualScore(session, uri) {\n  console.warn(\"DEPRECATION WARNING: The function fetchConceptualScore is considered deprecated as of meld-clients-core v2.0.0 and will be subject to removal in future versions. Please upgrade your application to use the registerTraversal and traverse functions instead.\");\n  return dispatch => {\n    // console.log(\"FETCH_CONCEPTUAL_SCORE ON URI: \", uri);\n    const promise = auth.fetch(uri, {\n      headers: {\n        'Accept': 'application/ld+json'\n      }\n    });\n    return dispatch => {\n      promise.then(response => {\n        const framed = response.data;\n        const conceptualScore = framed[\"@graph\"][0];\n\n        if (\"mo:published_as\" in conceptualScore) {\n          // dispatch the conceptual score (containing the mei URI) so that we can initialise a <Score> component\n          dispatch({\n            type: FETCH_CONCEPTUAL_SCORE,\n            payload: conceptualScore\n          });\n          dispatch(fetchScore(conceptualScore[\"mo:published_as\"][\"@id\"]));\n        } else {\n          console.log(\"Unpublished conceptual score: \", conceptualScore);\n        }\n        /*if(\"climb:next\" in conceptualScore) {\n            //TODO REVISIT FOR JAM -- NO LONGER RELEVANT FOR CLIMB, AS MUZICODES NEEDS TO MAKE A DECISION\n            // BEFORE THE 'DEFAULT' NEXT SCORE CAN BE DETERMINED\n          // for dynamic meld applications:\n          // create a new session for the default next score\n          // (which sessionControl will then queue up)\n          console.log(\"About to create next session for conceptual score: \", conceptualScore);\n          dispatch(\n            createSession(\n              session.substr(0,session.lastIndexOf(\"/\")),\n              conceptualScore[\"climb:next\"][\"@id\"]\n            )\n          )\n        }*/\n\n      });\n    };\n  };\n}\nexport function scoreSetOptions(pubScoreUri, options) {\n  return {\n    type: SCORE_SET_OPTIONS,\n    payload: {\n      options: options,\n      uri: pubScoreUri\n    }\n  };\n}\nexport function scorePageToComponentTarget(target, pubScoreUri, MEI) {\n  return {\n    type: SCORE_PAGE_TO_TARGET,\n    payload: {\n      data: MEI,\n      uri: pubScoreUri,\n      target: target\n    }\n  };\n}\nexport function scoreNextPageStatic(pubScoreUri, pageNum, MEI) {\n  return dispatch => {\n    dispatch({\n      type: SCORE_NEXT_PAGE,\n      payload: {\n        pageNum: pageNum,\n        data: MEI,\n        uri: pubScoreUri\n      }\n    });\n  };\n}\nexport function scoreNextPage(session, nextSession, etag, annotation, pubScoreUri, pageNum, MEI) {\n  return dispatch => {\n    if (MEI) {\n      // console.log(\"Attempting to action SCORE_NEXT_PAGE\");\n      const action = {\n        type: SCORE_NEXT_PAGE,\n        payload: {\n          pageNum: pageNum,\n          data: MEI,\n          uri: pubScoreUri,\n          nextSession: nextSession\n        }\n      };\n      dispatch(patchAndProcessAnnotation(action, session, etag, annotation));\n    } else {\n      dispatch({\n        type: ANNOTATION_NOT_HANDLED,\n        payload: \"Page flip attempted on non-existing MEI. Has it loaded yet?\"\n      });\n    }\n  };\n}\nexport function scorePrevPageStatic(pubScoreUri, pageNum, MEI) {\n  return dispatch => {\n    dispatch({\n      type: SCORE_PREV_PAGE,\n      payload: {\n        pageNum: pageNum,\n        data: MEI,\n        uri: pubScoreUri\n      }\n    });\n  };\n}\nexport function scorePrevPage(session, nextSession, etag, annotation, pubScoreUri, pageNum, MEI) {\n  return dispatch => {\n    if (MEI) {\n      const action = {\n        type: SCORE_PREV_PAGE,\n        payload: {\n          pageNum: pageNum,\n          data: MEI,\n          uri: pubScoreUri,\n          nextSession: nextSession\n        }\n      };\n      dispatch(patchAndProcessAnnotation(action, session, etag, annotation));\n    } else {\n      dispatch({\n        type: ANNOTATION_NOT_HANDLED,\n        payload: \"Page flip attempted on non-existing MEI. Has it loaded yet?\"\n      });\n    }\n  };\n}\nexport function transitionToSession(thisSession, nextSession) {\n  // TODO do this properly using react.router to avoid full reload\n  window.location.assign('?session=' + nextSession);\n  return {\n    type: ANNOTATION_HANDLED\n  };\n}\nexport function resetNextSessionTrigger() {\n  return {\n    type: RESET_NEXT_SESSION_TRIGGER\n  };\n}\nexport function postNextPageAnnotation(session, etag) {\n  return dispatch => {\n    dispatch(postAnnotation(session, etag, JSON.stringify({\n      \"oa:hasTarget\": {\n        \"@id\": session\n      },\n      \"oa:motivatedBy\": {\n        \"@id\": \"motivation:nextPageOrPiece\"\n      }\n    })));\n  };\n}\nexport function postPrevPageAnnotation(session, etag) {\n  return dispatch => {\n    dispatch(postAnnotation(session, etag, JSON.stringify({\n      \"oa:hasTarget\": {\n        \"@id\": session\n      },\n      \"oa:motivatedBy\": {\n        \"@id\": \"motivation:prevPageOrPiece\"\n      }\n    })));\n  };\n}\nexport function postAnnotation(session, etag, json, retries = MAX_RETRIES, callback = {}) {\n  let uuid = uuidv4();\n\n  if (retries === \"\") {\n    retries = MAX_RETRIES;\n  }\n\n  if (!(\"id\" in json) && !(\"@id\" in json)) {\n    // bootstrap a UUID for this annotation\n    json[\"@id\"] = session + uuid + \".jsonld\";\n  }\n\n  return dispatch => {\n    if (retries) {\n      console.log(\"Posting annotation: \", session, etag, json);\n      auth.fetch(session, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/ld+json',\n          'If-None-Match': etag,\n          'Slug': uuid + \".jsonld\"\n        },\n        body: JSON.stringify(json)\n      }).then(response => {\n        typeof callback === \"function\" && callback(response);\n      }).catch(function (error) {\n        if (!error.response) {\n          console.log(error, \"Annotation post failed. Giving up.\");\n          return {\n            type: ANNOTATION_NOT_HANDLED\n          };\n        }\n\n        if (error.response.status == 412) {\n          console.log(\"Mid-air collision while attempting to POST annotation. Retrying.\", session, etag, json); // GET the session resource to figure out new etag\n\n          auth.fetch(session).then(response => {\n            return dispatch => {\n              // and try again\n              setTimeout(() => {\n                dispatch(postAnnotation(session, response.headers.get('etag'), json, retries - 1));\n              }, RETRY_DELAY);\n            };\n          });\n        } else {\n          console.log(\"Retrying.\");\n          setTimeout(() => {\n            dispatch(postAnnotation(session, response.headers.get(etag), json, retries - 1));\n          }, RETRY_DELAY);\n        }\n      });\n      return {\n        type: ANNOTATION_POSTED\n      };\n    } else {\n      console.log(\"FAILED TO POST ANNOTATION (MAX RETRIES EXCEEDED): \", session, etag, json);\n      return {\n        type: ANNOTATION_NOT_HANDLED\n      };\n    }\n  };\n}\nexport function markAnnotationProcessed(session, etag, annotation, retries = MAX_RETRIES) {\n  if (retries) {\n    // console.log(\"PATCHING: \", session, etag, annotation);\n    const patchJson = JSON.stringify({\n      \"@id\": annotation[\"@id\"],\n      \"meld:state\": {\n        \"@id\": \"meld:processed\"\n      }\n    });\n    axios.patch(session, patchJson, {\n      headers: {\n        'Content-Type': 'application/ld+json',\n        'If-None-Match': etag\n      }\n    }).catch(function (error) {\n      if (error.response.status == 412) {\n        console.log(\"Mid-air collision while attempting to MARK annotation processed. Retrying.\", session, etag, annotation); // GET the session resource to figure out new etag\n\n        auth.fetch(session).then(response => {\n          // and try again\n          return dispatch => {\n            setTimeout(() => {\n              dispatch(markAnnotationProcessed(session, response.headers.etag, annotation, retries - 1));\n            }, RETRY_DELAY);\n          };\n        });\n      } else {\n        console.log(\"Error while patching annotation: \", error);\n        console.log(\"Retrying.\");\n        return dispatch => {\n          setTimeout(() => {\n            dispatch(markAnnotationProcessed(session, response.headers.etag, annotation, retries - 1));\n          }, RETRY_DELAY);\n        };\n      }\n    }).then(\"Done?\");\n    return {\n      type: ANNOTATION_PATCHED\n    };\n  } else {\n    console.log(\"FAILED TO PATCH ANNOTATION (MAX RETRIES EXCEEDED): \", session, etag, annotation);\n    return {\n      type: ANNOTATION_NOT_HANDLED\n    };\n  }\n}\nexport function patchAndProcessAnnotation(action, session, etag, annotation, success = {\n  type: ANNOTATION_PATCHED\n}, retries = MAX_RETRIES) {\n  if (retries) {\n    // console.log(\"PATCHING: \", session, etag, annotation);\n    const patchJson = JSON.stringify({\n      \"@id\": annotation[\"@id\"],\n      \"meld:state\": {\n        \"@id\": \"meld:processed\"\n      }\n    });\n    return dispatch => {\n      axios.patch(session, patchJson, {\n        headers: {\n          'Content-Type': 'application/ld+json',\n          'If-None-Match': etag\n        }\n      }).then(function (response) {\n        // console.log(\"Dispatching action: \", action);\n        dispatch(action); // console.log(\"Dispatching success callback: \", success)\n\n        dispatch(success);\n      }).catch(function (error) {\n        if (error.response.status == 412) {\n          console.log(\"Mid-air collision while attempting to PATCH annotation. Retrying.\", session, etag, annotation); // GET the session resource to figure out new etag\n\n          auth.fetch(session).then(response => {\n            // and try again\n            return dispatch => {\n              setTimeout(() => {\n                dispatch(patchAndProcessAnnotation(action, session, response.headers.etag, annotation, success, retries - 1));\n              }, RETRY_DELAY);\n            };\n          });\n        } else {\n          console.log(\"Error while patching annotation: \", error);\n          console.log(\"Retrying.\");\n          return dispatch => {\n            setTimeout(() => {\n              dispatch(patchAndProcessAnnotation(action, session, response.headers.etag, annotation, success, retries - 1));\n            }, RETRY_DELAY);\n          };\n        }\n      });\n    };\n  } else {\n    console.log(\"FAILED TO PATCH ANNOTATION (MAX RETRIES EXCEEDED): \", session, etag, annotation);\n    return {\n      type: ANNOTATION_NOT_HANDLED\n    };\n  }\n}\nexport function updateMuzicodes(muzicodesUri, session, mei = \"\") {\n  // inform the muzicodes service that our session has loaded\n  // console.log(\"Updating muzicodes:\", muzicodesUri, session);\n  const params = querystring.stringify({\n    \"name\": \"meld.load\",\n    \"meldcollection\": session,\n    \"meldmei\": mei\n  });\n  auth.fetch(muzicodesUri, params);\n  return {\n    type: MUZICODES_UPDATED\n  };\n} // helper function to ensure that a given key of a JSON obj\n// is an array, rather than a single value\n// this is so that we can use the same approach for one and for\n// many values\n\nexport function ensureArray(theObj, theKey) {\n  if (theObj !== null && typeof theObj === 'object') {\n    if (!theKey in theObj) {\n      console.log(\"ensureArray: KEY NOT IN OBJECT!\", theKey, theObj);\n    } else if (!Array.isArray(theObj[theKey])) {\n      theObj[theKey] = [theObj[theKey]];\n    }\n\n    return theObj;\n  } else {\n    console.log(\"ensureArray: Provided structure is NOT AN OBJECT!\");\n  }\n} // Function to set up the objectives (objects containing JSON-LD frames)\n// matched against the graph being built during a traversal.\n// Typically called once, on componentWillMount\n\nexport function configureTraversalObjectives(objectives) {\n  return {\n    type: SET_TRAVERSAL_OBJECTIVES,\n    payload: objectives\n  };\n}\nexport function createSession(sessionsUri, scoreUri, {\n  session = \"\",\n  etag = \"\",\n  retries = MAX_RETRIES,\n  performerUri = \"\",\n  slug = \"\"\n} = {}) {\n  return dispatch => {\n    if (retries) {\n      // console.log(\"Trying to create session: \", sessionsUri, scoreUri, etag, retries, performerUri);\n      auth.fetch(sessionsUri).then(getResponse => {\n        axios.post(sessionsUri, JSON.stringify({\n          \"@type\": [\"mo:Performance\", \"ldp:BasicContainer\"],\n          \"mo:performance_of\": {\n            \"@id\": scoreUri\n          }\n        }), {\n          headers: {\n            \"Content-Type\": \"application/ld+json\",\n            \"If-None-Match\": getResponse.headers.etag,\n            \"Slug\": slug\n          }\n        }).then(postResponse => {\n          // 1.Note that we've created the session\n          // (for real-time client-side queueing)\n          dispatch({\n            type: CREATE_SESSION,\n            payload: postResponse\n          }); // 2.If we've been called inside a session context,\n          // post a corresponding queue annotation\n          // (for later static revisits, e.g. in archive)\n\n          if (session) {\n            dispatch(postAnnotation(session, etag, {\n              \"oa:hasTarget\": {\n                \"@id\": session\n              },\n              \"oa:motivatedBy\": {\n                \"@id\": \"motivation:queueNextSession\"\n              },\n              \"oa:hasBody\": {\n                \"@id\": postResponse.headers.location\n              }\n            }));\n          }\n        }).catch(function (error) {\n          if (error.response.status == 412) {\n            console.log(\"Mid-air collision while attempting to POST annotation. Retrying.\");\n            dispatch(() => {\n              setTimeout(() => {\n                dispatch(createSession(sessionsUri, scoreUri, {\n                  etag: getResponse.headers.etag,\n                  retries: retries - 1,\n                  performerUri: performerUri,\n                  slug: slug\n                }));\n              }, RETRY_DELAY);\n            });\n          } else {\n            console.log(\"Error while creating session: \", error);\n            console.log(\"Retrying.\");\n            dispatch(() => {\n              setTimeout(() => {\n                dispatch(createSession(sessionsUri, scoreUri, {\n                  etag: getResponse.headers.etag,\n                  retries: retries - 1,\n                  performerUri: performerUri,\n                  slug: slug\n                }));\n              }, RETRY_DELAY);\n            });\n          }\n        });\n      });\n    } else {\n      console.log(\"FAILED TO CREATE SESSION (MAX RETRIES EXCEEDED): \", sessionsUri, scoreUri, response.headers.etag, retries - 1, performerUri);\n      return {\n        type: SESSION_NOT_CREATED\n      };\n    }\n  };\n}\nexport function tickTimedResource(resourceUri, time) {\n  return {\n    type: TICK,\n    payload: {\n      uri: resourceUri,\n      time: time\n    }\n  };\n}\nexport function registerClock(clockUri) {\n  return {\n    type: \"REGISTER_CLOCK\",\n    payload: clockUri\n  };\n}\nexport function updateLatestRenderedPageNum(pageNum) {\n  return {\n    type: \"UPDATE_LATEST_RENDERED_PAGENUM\",\n    payload: pageNum\n  };\n}"]},"metadata":{},"sourceType":"module"}