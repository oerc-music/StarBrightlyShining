{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationBgpLeftDeepSmallest = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst context_entries_1 = require(\"@comunica/context-entries\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst rdf_terms_1 = require(\"rdf-terms\");\n/**\n * A comunica Query Operation Actor that resolves BGPs in a left-deep manner\n * based on the pattern with the smallest item count.\n */\n\n\nclass ActorQueryOperationBgpLeftDeepSmallest extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n  constructor(args) {\n    super(args, 'bgp');\n  }\n  /**\n   * Create a new bindings stream\n   * that takes every binding of the base stream,\n   * materializes the remaining patterns with it,\n   * and emits all bindings from this new set of patterns.\n   * @param {BindingsStream} baseStream The base stream.\n   * @param {Algebra.Pattern[]} patterns The patterns to materialize with each binding of the base stream.\n   * @param {{ pattern: Algebra.Pattern, bindings: IPatternBindings }[]) => Promise<IActorQueryOperationOutput>}\n   *    patternBinder A callback\n   * to retrieve the bindings stream of an array of patterns.\n   * @return {BindingsStream}\n   */\n\n\n  static createLeftDeepStream(baseStream, patterns, patternBinder) {\n    return new asynciterator_1.MultiTransformIterator(baseStream, {\n      autoStart: false,\n\n      multiTransform(bindings) {\n        const bindingsMerger = subBindings => subBindings.merge(bindings);\n\n        return new asynciterator_1.TransformIterator(async () => (await patternBinder(ActorQueryOperationBgpLeftDeepSmallest.materializePatterns(patterns, bindings))).transform({\n          map: bindingsMerger\n        }), {\n          maxBufferSize: 128\n        });\n      }\n\n    });\n  }\n  /**\n   * Get the combined list of variables of the given pattern outputs.\n   * @param {IActorQueryOperationOutput[]} patternOutputs An array of query operation outputs\n   * @return {string[]} The array of variable names.\n   */\n\n\n  static getCombinedVariables(patternOutputs) {\n    const withDuplicates = [].concat.apply([], patternOutputs.map(patternOutput => patternOutput.variables));\n    return [...new Set(withDuplicates)];\n  }\n  /**\n   * Find the pattern index with the smallest number of elements.\n   * @param {{[p: string]: any}[]} metadatas An array of optional metadata objects for the patterns.\n   * @return {number} The index of the pattern with the smallest number of elements.\n   */\n\n\n  static getSmallestPatternId(metadatas) {\n    let smallestId = -1;\n    let smallestCount = Number.POSITIVE_INFINITY;\n\n    for (const [i, meta] of metadatas.entries()) {\n      const count = ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(meta);\n\n      if (count <= smallestCount) {\n        smallestCount = count;\n        smallestId = i;\n      }\n    }\n\n    return smallestId;\n  }\n  /**\n   * Estimate an upper bound for the total number of items from the given metadata.\n   * @param {{[p: string]: any}} smallestPattern The optional metadata for the pattern\n   *                                             with the smallest number of elements.\n   * @param {{[p: string]: any}[]} otherPatterns The array of optional metadata for the other patterns.\n   * @return {number} The estimated number of total items.\n   */\n\n\n  static estimateCombinedTotalItems(smallestPattern, otherPatterns) {\n    const smallestCount = ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(smallestPattern);\n    return otherPatterns.map(otherPattern => smallestCount * ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(otherPattern)).reduce((sum, element) => sum + element, 0);\n  }\n  /**\n   * Get the estimated number of items from the given metadata.\n   * @param {{[p: string]: any}} metadata An optional metadata object.\n   * @return {number} The estimated number of items, or `Infinity` if metadata is falsy.\n   */\n\n\n  static getTotalItems(metadata) {\n    const {\n      totalItems\n    } = metadata !== null && metadata !== void 0 ? metadata : {};\n    return totalItems || totalItems === 0 ? totalItems : Number.POSITIVE_INFINITY;\n  }\n  /**\n   * Materialize all patterns in the given pattern array with the given bindings.\n   * @param {Pattern[]} patterns SPARQL algebra patterns.\n   * @param {Bindings} bindings A bindings object.\n   * @return { pattern: Algebra.Pattern, bindings: IPatternBindings }[] An array of patterns with their bindings.\n   */\n\n\n  static materializePatterns(patterns, bindings) {\n    return patterns.map(pattern => ActorQueryOperationBgpLeftDeepSmallest.materializePattern(pattern, bindings));\n  }\n  /**\n   * Materialize a pattern with the given bindings.\n   * @param {Pattern} pattern A SPARQL algebra pattern.\n   * @param {Bindings} bindings A bindings object.\n   * @return { pattern: Algebra.Pattern, bindings: IPatternBindings } A new materialized pattern.\n   */\n\n\n  static materializePattern(pattern, bindings) {\n    const bindingsOut = {};\n    const patternOut = Object.assign(rdf_terms_1.mapTerms(pattern, (term, termPosition) => {\n      const materializedTerm = ActorQueryOperationBgpLeftDeepSmallest.materializeTerm(term, bindings);\n\n      if (term !== materializedTerm) {\n        bindingsOut[termPosition] = term;\n      }\n\n      return materializedTerm;\n    }), {\n      type: 'pattern',\n      context: pattern.context\n    });\n    return {\n      pattern: patternOut,\n      bindings: bindingsOut\n    };\n  }\n  /**\n   * Materialize a term with the given binding.\n   *\n   * If the given term is a variable (or blank node)\n   * and that variable exist in the given bindings object,\n   * the value of that binding is returned.\n   * In all other cases, the term itself is returned.\n   *\n   * @param {RDF.Term} term A term.\n   * @param {Bindings} bindings A bindings object.\n   * @return {RDF.Term} The materialized term.\n   */\n\n\n  static materializeTerm(term, bindings) {\n    if (term.termType === 'Variable') {\n      const value = bindings.get(rdf_string_1.termToString(term));\n\n      if (value) {\n        return value;\n      }\n    }\n\n    return term;\n  }\n  /**\n   * Check if at least one of the given outputs has an empty output, i.e., when the estimated count is zero.\n   * @param {IActorQueryOperationOutputBindings[]} patternOutputs Pattern outputs.\n   * @return {Promise<boolean>} A promise for indicating whether or not at least one of the outputs is empty.\n   */\n\n\n  static async hasOneEmptyPatternOutput(patternOutputs) {\n    for (const patternOutput of patternOutputs) {\n      if (patternOutput.metadata) {\n        const metadata = await patternOutput.metadata();\n\n        if (!ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(metadata)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  async testOperation(pattern, context) {\n    if (pattern.patterns.length < 2) {\n      throw new Error(`Actor ${this.name} can only operate on BGPs with at least two patterns.`);\n    }\n\n    return true;\n  }\n\n  async runOperation(pattern, context) {\n    // Get the total number of items for all patterns by resolving the quad patterns\n    const patternOutputs = (await Promise.all(pattern.patterns.map(subPattern => this.mediatorQueryOperation.mediate({\n      operation: subPattern,\n      context\n    })))).map(bus_query_operation_1.ActorQueryOperation.getSafeBindings); // If a triple pattern has no matches, the entire graph pattern has no matches.\n\n    if (await ActorQueryOperationBgpLeftDeepSmallest.hasOneEmptyPatternOutput(patternOutputs)) {\n      return {\n        bindingsStream: new asynciterator_1.ArrayIterator([], {\n          autoStart: false\n        }),\n        metadata: () => Promise.resolve({\n          totalItems: 0\n        }),\n        type: 'bindings',\n        variables: ActorQueryOperationBgpLeftDeepSmallest.getCombinedVariables(patternOutputs),\n        canContainUndefs: false\n      };\n    } // Find the pattern with the smallest number of elements\n\n\n    const metadatas = await Promise.all(patternOutputs.map(async patternOutput => patternOutput.metadata ? await patternOutput.metadata() : {}));\n    const smallestId = ActorQueryOperationBgpLeftDeepSmallest.getSmallestPatternId(metadatas);\n    this.logDebug(context, 'Smallest pattern: ', () => ({\n      pattern: pattern.patterns[smallestId],\n      metadata: metadatas[smallestId]\n    })); // Close the non-smallest streams\n\n    for (const [i, element] of patternOutputs.entries()) {\n      if (i !== smallestId) {\n        element.bindingsStream.close();\n      }\n    } // Take the pattern with the smallest number of items\n\n\n    const smallestPattern = patternOutputs.slice(smallestId)[0];\n    const remainingPatterns = [...pattern.patterns];\n    remainingPatterns.splice(smallestId, 1);\n    const remainingMetadatas = [...metadatas];\n    remainingMetadatas.splice(smallestId, 1); // Check if the output type is correct\n\n    bus_query_operation_1.ActorQueryOperation.validateQueryOutput(smallestPattern, 'bindings'); // Materialize the remaining patterns for each binding in the stream.\n\n    const subContext = context && context.set(context_entries_1.KeysQueryOperation.bgpCurrentMetadata, metadatas[smallestId]).set(context_entries_1.KeysQueryOperation.bgpParentMetadata, remainingMetadatas);\n    const bindingsStream = ActorQueryOperationBgpLeftDeepSmallest.createLeftDeepStream(smallestPattern.bindingsStream, remainingPatterns, async patterns => {\n      // Send the materialized patterns to the mediator for recursive BGP evaluation.\n      const operation = {\n        type: 'bgp',\n        patterns: patterns.map(pat => pat.pattern)\n      };\n      const bindings = patterns.map(pat => pat.bindings);\n      return bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n        operation,\n        context: subContext.set(context_entries_1.KeysQueryOperation.bgpPatternBindings, bindings)\n      })).bindingsStream;\n    }); // Prepare variables and metadata\n\n    const variables = ActorQueryOperationBgpLeftDeepSmallest.getCombinedVariables(patternOutputs);\n\n    const metadata = () => Promise.resolve({\n      totalItems: ActorQueryOperationBgpLeftDeepSmallest.estimateCombinedTotalItems(metadatas[smallestId], metadatas.slice(smallestId))\n    });\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      variables,\n      metadata,\n      canContainUndefs: false\n    };\n  }\n\n}\n\nexports.ActorQueryOperationBgpLeftDeepSmallest = ActorQueryOperationBgpLeftDeepSmallest;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-bgp-left-deep-smallest/lib/ActorQueryOperationBgpLeftDeepSmallest.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationBgpLeftDeepSmallest","bus_query_operation_1","require","context_entries_1","asynciterator_1","rdf_string_1","rdf_terms_1","ActorQueryOperationTypedMediated","constructor","args","createLeftDeepStream","baseStream","patterns","patternBinder","MultiTransformIterator","autoStart","multiTransform","bindings","bindingsMerger","subBindings","merge","TransformIterator","materializePatterns","transform","map","maxBufferSize","getCombinedVariables","patternOutputs","withDuplicates","concat","apply","patternOutput","variables","Set","getSmallestPatternId","metadatas","smallestId","smallestCount","Number","POSITIVE_INFINITY","i","meta","entries","count","getTotalItems","estimateCombinedTotalItems","smallestPattern","otherPatterns","otherPattern","reduce","sum","element","metadata","totalItems","pattern","materializePattern","bindingsOut","patternOut","assign","mapTerms","term","termPosition","materializedTerm","materializeTerm","type","context","termType","get","termToString","hasOneEmptyPatternOutput","testOperation","length","Error","name","runOperation","Promise","all","subPattern","mediatorQueryOperation","mediate","operation","ActorQueryOperation","getSafeBindings","bindingsStream","ArrayIterator","resolve","canContainUndefs","logDebug","close","slice","remainingPatterns","splice","remainingMetadatas","validateQueryOutput","subContext","set","KeysQueryOperation","bgpCurrentMetadata","bgpParentMetadata","pat","bgpPatternBindings"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationBgpLeftDeepSmallest = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst context_entries_1 = require(\"@comunica/context-entries\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst rdf_terms_1 = require(\"rdf-terms\");\n/**\n * A comunica Query Operation Actor that resolves BGPs in a left-deep manner\n * based on the pattern with the smallest item count.\n */\nclass ActorQueryOperationBgpLeftDeepSmallest extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n    constructor(args) {\n        super(args, 'bgp');\n    }\n    /**\n     * Create a new bindings stream\n     * that takes every binding of the base stream,\n     * materializes the remaining patterns with it,\n     * and emits all bindings from this new set of patterns.\n     * @param {BindingsStream} baseStream The base stream.\n     * @param {Algebra.Pattern[]} patterns The patterns to materialize with each binding of the base stream.\n     * @param {{ pattern: Algebra.Pattern, bindings: IPatternBindings }[]) => Promise<IActorQueryOperationOutput>}\n     *    patternBinder A callback\n     * to retrieve the bindings stream of an array of patterns.\n     * @return {BindingsStream}\n     */\n    static createLeftDeepStream(baseStream, patterns, patternBinder) {\n        return new asynciterator_1.MultiTransformIterator(baseStream, {\n            autoStart: false,\n            multiTransform(bindings) {\n                const bindingsMerger = (subBindings) => subBindings.merge(bindings);\n                return new asynciterator_1.TransformIterator(async () => (await patternBinder(ActorQueryOperationBgpLeftDeepSmallest.materializePatterns(patterns, bindings))).transform({ map: bindingsMerger }), { maxBufferSize: 128 });\n            },\n        });\n    }\n    /**\n     * Get the combined list of variables of the given pattern outputs.\n     * @param {IActorQueryOperationOutput[]} patternOutputs An array of query operation outputs\n     * @return {string[]} The array of variable names.\n     */\n    static getCombinedVariables(patternOutputs) {\n        const withDuplicates = [].concat.apply([], patternOutputs.map(patternOutput => patternOutput.variables));\n        return [...new Set(withDuplicates)];\n    }\n    /**\n     * Find the pattern index with the smallest number of elements.\n     * @param {{[p: string]: any}[]} metadatas An array of optional metadata objects for the patterns.\n     * @return {number} The index of the pattern with the smallest number of elements.\n     */\n    static getSmallestPatternId(metadatas) {\n        let smallestId = -1;\n        let smallestCount = Number.POSITIVE_INFINITY;\n        for (const [i, meta] of metadatas.entries()) {\n            const count = ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(meta);\n            if (count <= smallestCount) {\n                smallestCount = count;\n                smallestId = i;\n            }\n        }\n        return smallestId;\n    }\n    /**\n     * Estimate an upper bound for the total number of items from the given metadata.\n     * @param {{[p: string]: any}} smallestPattern The optional metadata for the pattern\n     *                                             with the smallest number of elements.\n     * @param {{[p: string]: any}[]} otherPatterns The array of optional metadata for the other patterns.\n     * @return {number} The estimated number of total items.\n     */\n    static estimateCombinedTotalItems(smallestPattern, otherPatterns) {\n        const smallestCount = ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(smallestPattern);\n        return otherPatterns\n            .map(otherPattern => smallestCount * ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(otherPattern))\n            .reduce((sum, element) => sum + element, 0);\n    }\n    /**\n     * Get the estimated number of items from the given metadata.\n     * @param {{[p: string]: any}} metadata An optional metadata object.\n     * @return {number} The estimated number of items, or `Infinity` if metadata is falsy.\n     */\n    static getTotalItems(metadata) {\n        const { totalItems } = metadata !== null && metadata !== void 0 ? metadata : {};\n        return totalItems || totalItems === 0 ? totalItems : Number.POSITIVE_INFINITY;\n    }\n    /**\n     * Materialize all patterns in the given pattern array with the given bindings.\n     * @param {Pattern[]} patterns SPARQL algebra patterns.\n     * @param {Bindings} bindings A bindings object.\n     * @return { pattern: Algebra.Pattern, bindings: IPatternBindings }[] An array of patterns with their bindings.\n     */\n    static materializePatterns(patterns, bindings) {\n        return patterns.map(pattern => ActorQueryOperationBgpLeftDeepSmallest.materializePattern(pattern, bindings));\n    }\n    /**\n     * Materialize a pattern with the given bindings.\n     * @param {Pattern} pattern A SPARQL algebra pattern.\n     * @param {Bindings} bindings A bindings object.\n     * @return { pattern: Algebra.Pattern, bindings: IPatternBindings } A new materialized pattern.\n     */\n    static materializePattern(pattern, bindings) {\n        const bindingsOut = {};\n        const patternOut = Object.assign(rdf_terms_1.mapTerms(pattern, (term, termPosition) => {\n            const materializedTerm = ActorQueryOperationBgpLeftDeepSmallest.materializeTerm(term, bindings);\n            if (term !== materializedTerm) {\n                bindingsOut[termPosition] = term;\n            }\n            return materializedTerm;\n        }), { type: 'pattern', context: pattern.context });\n        return { pattern: patternOut, bindings: bindingsOut };\n    }\n    /**\n     * Materialize a term with the given binding.\n     *\n     * If the given term is a variable (or blank node)\n     * and that variable exist in the given bindings object,\n     * the value of that binding is returned.\n     * In all other cases, the term itself is returned.\n     *\n     * @param {RDF.Term} term A term.\n     * @param {Bindings} bindings A bindings object.\n     * @return {RDF.Term} The materialized term.\n     */\n    static materializeTerm(term, bindings) {\n        if (term.termType === 'Variable') {\n            const value = bindings.get(rdf_string_1.termToString(term));\n            if (value) {\n                return value;\n            }\n        }\n        return term;\n    }\n    /**\n     * Check if at least one of the given outputs has an empty output, i.e., when the estimated count is zero.\n     * @param {IActorQueryOperationOutputBindings[]} patternOutputs Pattern outputs.\n     * @return {Promise<boolean>} A promise for indicating whether or not at least one of the outputs is empty.\n     */\n    static async hasOneEmptyPatternOutput(patternOutputs) {\n        for (const patternOutput of patternOutputs) {\n            if (patternOutput.metadata) {\n                const metadata = await patternOutput.metadata();\n                if (!ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(metadata)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    async testOperation(pattern, context) {\n        if (pattern.patterns.length < 2) {\n            throw new Error(`Actor ${this.name} can only operate on BGPs with at least two patterns.`);\n        }\n        return true;\n    }\n    async runOperation(pattern, context) {\n        // Get the total number of items for all patterns by resolving the quad patterns\n        const patternOutputs = (await Promise.all(pattern.patterns\n            .map((subPattern) => this.mediatorQueryOperation.mediate({ operation: subPattern, context }))))\n            .map(bus_query_operation_1.ActorQueryOperation.getSafeBindings);\n        // If a triple pattern has no matches, the entire graph pattern has no matches.\n        if (await ActorQueryOperationBgpLeftDeepSmallest.hasOneEmptyPatternOutput(patternOutputs)) {\n            return {\n                bindingsStream: new asynciterator_1.ArrayIterator([], { autoStart: false }),\n                metadata: () => Promise.resolve({ totalItems: 0 }),\n                type: 'bindings',\n                variables: ActorQueryOperationBgpLeftDeepSmallest.getCombinedVariables(patternOutputs),\n                canContainUndefs: false,\n            };\n        }\n        // Find the pattern with the smallest number of elements\n        const metadatas = await Promise.all(patternOutputs.map(async (patternOutput) => patternOutput.metadata ? await patternOutput.metadata() : {}));\n        const smallestId = ActorQueryOperationBgpLeftDeepSmallest.getSmallestPatternId(metadatas);\n        this.logDebug(context, 'Smallest pattern: ', () => ({ pattern: pattern.patterns[smallestId], metadata: metadatas[smallestId] }));\n        // Close the non-smallest streams\n        for (const [i, element] of patternOutputs.entries()) {\n            if (i !== smallestId) {\n                element.bindingsStream.close();\n            }\n        }\n        // Take the pattern with the smallest number of items\n        const smallestPattern = patternOutputs.slice(smallestId)[0];\n        const remainingPatterns = [...pattern.patterns];\n        remainingPatterns.splice(smallestId, 1);\n        const remainingMetadatas = [...metadatas];\n        remainingMetadatas.splice(smallestId, 1);\n        // Check if the output type is correct\n        bus_query_operation_1.ActorQueryOperation.validateQueryOutput(smallestPattern, 'bindings');\n        // Materialize the remaining patterns for each binding in the stream.\n        const subContext = context && context\n            .set(context_entries_1.KeysQueryOperation.bgpCurrentMetadata, metadatas[smallestId])\n            .set(context_entries_1.KeysQueryOperation.bgpParentMetadata, remainingMetadatas);\n        const bindingsStream = ActorQueryOperationBgpLeftDeepSmallest.createLeftDeepStream(smallestPattern.bindingsStream, remainingPatterns, async (patterns) => {\n            // Send the materialized patterns to the mediator for recursive BGP evaluation.\n            const operation = { type: 'bgp', patterns: patterns.map(pat => pat.pattern) };\n            const bindings = patterns.map(pat => pat.bindings);\n            return bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation, context: subContext.set(context_entries_1.KeysQueryOperation.bgpPatternBindings, bindings) })).bindingsStream;\n        });\n        // Prepare variables and metadata\n        const variables = ActorQueryOperationBgpLeftDeepSmallest.getCombinedVariables(patternOutputs);\n        const metadata = () => Promise.resolve({\n            totalItems: ActorQueryOperationBgpLeftDeepSmallest.estimateCombinedTotalItems(metadatas[smallestId], metadatas.slice(smallestId)),\n        });\n        return { type: 'bindings', bindingsStream, variables, metadata, canContainUndefs: false };\n    }\n}\nexports.ActorQueryOperationBgpLeftDeepSmallest = ActorQueryOperationBgpLeftDeepSmallest;\n//# sourceMappingURL=ActorQueryOperationBgpLeftDeepSmallest.js.map"]},"metadata":{},"sourceType":"script"}