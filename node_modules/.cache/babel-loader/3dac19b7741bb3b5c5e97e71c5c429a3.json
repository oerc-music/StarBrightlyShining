{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BindingsIndex = void 0;\n\nconst rdf_string_1 = require(\"rdf-string\");\n/**\n * A simple efficient tree-based index for maintaining bindings,\n * and checking whether or not a bindings is contained in this index.\n *\n * This will consider bindings with a variable term or a missing term\n * as a 'match-all' with other terms.\n */\n\n\nclass BindingsIndex {\n  constructor(keys) {\n    this.data = {};\n    this.keys = keys;\n  }\n\n  static hashTerm(term) {\n    return term && term.termType !== 'Variable' ? rdf_string_1.termToString(term) : '';\n  }\n  /**\n   * Add the given bindings to the index.\n   * @param {Bindings} bindings A bindings.\n   */\n\n\n  add(bindings) {\n    if (this.isBindingsValid(bindings)) {\n      let dataIt = this.data;\n\n      for (const key of this.keys) {\n        const dataKey = BindingsIndex.hashTerm(bindings.get(key));\n        let subDataIt = dataIt[dataKey];\n\n        if (!subDataIt) {\n          subDataIt = dataIt[dataKey] = {};\n        }\n\n        dataIt = subDataIt;\n      }\n    }\n  }\n  /**\n   * Check if the given bindings is contained in this index.\n   * @param {Bindings} bindings A bindings.\n   * @return {boolean} If it exists in the index.\n   */\n\n\n  contains(bindings) {\n    // Always return false if the bindings contain none of the expected keys\n    if (!this.isBindingsValid(bindings)) {\n      return false;\n    }\n\n    return this.containsRecursive(bindings, this.keys, [this.data]);\n  }\n\n  isBindingsValid(bindings) {\n    let validKeys = false;\n\n    for (const key of this.keys) {\n      if (bindings.get(key)) {\n        validKeys = true;\n        break;\n      }\n    }\n\n    return validKeys;\n  }\n\n  containsRecursive(bindings, keys, dataIndexes) {\n    if (keys.length === 0) {\n      return true;\n    }\n\n    let key; // eslint-disable-next-line prefer-const\n\n    [key, ...keys] = keys;\n\n    for (const data of dataIndexes) {\n      // If the index contained a variable, all terms will match.\n      const dataKey = BindingsIndex.hashTerm(bindings.get(key));\n\n      if (!dataKey) {\n        // Iterate over all entries\n        let subDatas = Object.keys(data).map(subKey => data[subKey]);\n\n        if (subDatas.length === 0) {\n          subDatas = [{}];\n        }\n\n        if (this.containsRecursive(bindings, keys, subDatas)) {\n          return true;\n        }\n      } else {\n        // Check the entry for the term, and the variable term.\n        const subDatas = [data[dataKey], data['']].filter(Boolean);\n\n        if (subDatas.length === 0) {\n          continue;\n        }\n\n        if (this.containsRecursive(bindings, keys, subDatas)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n}\n\nexports.BindingsIndex = BindingsIndex;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-minus/lib/BindingsIndex.js"],"names":["Object","defineProperty","exports","value","BindingsIndex","rdf_string_1","require","constructor","keys","data","hashTerm","term","termType","termToString","add","bindings","isBindingsValid","dataIt","key","dataKey","get","subDataIt","contains","containsRecursive","validKeys","dataIndexes","length","subDatas","map","subKey","filter","Boolean"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BindingsIndex = void 0;\nconst rdf_string_1 = require(\"rdf-string\");\n/**\n * A simple efficient tree-based index for maintaining bindings,\n * and checking whether or not a bindings is contained in this index.\n *\n * This will consider bindings with a variable term or a missing term\n * as a 'match-all' with other terms.\n */\nclass BindingsIndex {\n    constructor(keys) {\n        this.data = {};\n        this.keys = keys;\n    }\n    static hashTerm(term) {\n        return term && term.termType !== 'Variable' ? rdf_string_1.termToString(term) : '';\n    }\n    /**\n     * Add the given bindings to the index.\n     * @param {Bindings} bindings A bindings.\n     */\n    add(bindings) {\n        if (this.isBindingsValid(bindings)) {\n            let dataIt = this.data;\n            for (const key of this.keys) {\n                const dataKey = BindingsIndex.hashTerm(bindings.get(key));\n                let subDataIt = dataIt[dataKey];\n                if (!subDataIt) {\n                    subDataIt = dataIt[dataKey] = {};\n                }\n                dataIt = subDataIt;\n            }\n        }\n    }\n    /**\n     * Check if the given bindings is contained in this index.\n     * @param {Bindings} bindings A bindings.\n     * @return {boolean} If it exists in the index.\n     */\n    contains(bindings) {\n        // Always return false if the bindings contain none of the expected keys\n        if (!this.isBindingsValid(bindings)) {\n            return false;\n        }\n        return this.containsRecursive(bindings, this.keys, [this.data]);\n    }\n    isBindingsValid(bindings) {\n        let validKeys = false;\n        for (const key of this.keys) {\n            if (bindings.get(key)) {\n                validKeys = true;\n                break;\n            }\n        }\n        return validKeys;\n    }\n    containsRecursive(bindings, keys, dataIndexes) {\n        if (keys.length === 0) {\n            return true;\n        }\n        let key;\n        // eslint-disable-next-line prefer-const\n        [key, ...keys] = keys;\n        for (const data of dataIndexes) {\n            // If the index contained a variable, all terms will match.\n            const dataKey = BindingsIndex.hashTerm(bindings.get(key));\n            if (!dataKey) {\n                // Iterate over all entries\n                let subDatas = Object.keys(data).map(subKey => data[subKey]);\n                if (subDatas.length === 0) {\n                    subDatas = [{}];\n                }\n                if (this.containsRecursive(bindings, keys, subDatas)) {\n                    return true;\n                }\n            }\n            else {\n                // Check the entry for the term, and the variable term.\n                const subDatas = [data[dataKey], data['']].filter(Boolean);\n                if (subDatas.length === 0) {\n                    continue;\n                }\n                if (this.containsRecursive(bindings, keys, subDatas)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\nexports.BindingsIndex = BindingsIndex;\n//# sourceMappingURL=BindingsIndex.js.map"]},"metadata":{},"sourceType":"script"}