{"ast":null,"code":"var Transform = require('stream').Transform;\n\nvar util = require('util');\n\nvar sax = require('sax');\n\nvar elem = require('./elem');\n\nvar debug = require('debug')('sax-stream');\n\nmodule.exports = XmlNode;\n\nfunction XmlNode(options) {\n  if (!(this instanceof XmlNode)) {\n    return new XmlNode(options);\n  }\n\n  Transform.call(this, {\n    highWaterMark: options.highWaterMark || 350,\n    objectMode: true\n  });\n  this.records = [];\n  this.error = null;\n  this.parser = this.createSaxParser(options);\n}\n\nutil.inherits(XmlNode, Transform);\n\nXmlNode.prototype.createSaxParser = function (options) {\n  function matchSingle(name) {\n    return name === options.tag;\n  }\n\n  function matchAny(name) {\n    return options.tag.indexOf(name) !== -1;\n  }\n\n  function pushBare(tag, record) {\n    self.records.push(record);\n  }\n\n  function pushWithTag(tag, record) {\n    self.records.push({\n      tag: tag,\n      record: record\n    });\n  }\n\n  var self = this,\n      record,\n      parser = sax.parser(options.strict || false, prepareParserOptions(options));\n  var matchesTag = matchSingle,\n      push = pushBare;\n\n  if (Array.isArray(options.tag)) {\n    matchesTag = matchAny;\n    push = pushWithTag;\n  }\n\n  parser.onopentag = function (node) {\n    debug('Open \"%s\"', node.name);\n\n    if (record) {\n      record = elem.addChild(record, node.name);\n    } else if (matchesTag(node.name)) {\n      record = {};\n    }\n\n    if (record && Object.keys(node.attributes).length) {\n      record.attribs = node.attributes;\n    }\n  };\n\n  parser.onclosetag = function (tag) {\n    debug('Closed \"%s\"', tag);\n\n    if (matchesTag(tag) && !record.parent) {\n      debug('Emitting record', record);\n      push(tag, record);\n      record = undefined;\n    } else if (record) {\n      record = record.parent;\n    }\n  };\n\n  parser.ontext = function (value) {\n    if (record) {\n      elem.addText(record, value);\n    }\n  };\n\n  parser.oncdata = function (value) {\n    if (record) {\n      elem.concatText(record, value);\n    }\n  };\n\n  parser.onerror = function (err) {\n    self.error = err;\n  };\n\n  parser.onend = function () {\n    debug('onend - flushing remaining items');\n    self.pushAll(self.callback);\n    self.callback = null;\n  };\n\n  return parser;\n};\n\nXmlNode.prototype.pushAll = function (callback) {\n  if (this.error) {\n    callback(this.error);\n    this.error = null;\n    return;\n  }\n\n  debug('pushing %d', this.records.length);\n  this.records.forEach(this.push.bind(this));\n  this.records.length = 0;\n  callback();\n};\n\nXmlNode.prototype._transform = function (chunk, encoding, callback) {\n  this.parser.write(chunk.toString());\n  this.pushAll(callback);\n};\n\nXmlNode.prototype._flush = function (callback) {\n  var self = this;\n  self.callback = callback;\n  self.parser.close();\n};\n\nfunction prepareParserOptions(options) {\n  return ['trim', 'normalize', 'lowercase', 'xmlns', 'position', 'strictEntities', 'noscript'].reduce(function (opts, name) {\n    if (name in options) {\n      opts[name] = options[name];\n    }\n\n    return opts;\n  }, {\n    position: false\n  });\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/sax-stream/lib/xmlnode.js"],"names":["Transform","require","util","sax","elem","debug","module","exports","XmlNode","options","call","highWaterMark","objectMode","records","error","parser","createSaxParser","inherits","prototype","matchSingle","name","tag","matchAny","indexOf","pushBare","record","self","push","pushWithTag","strict","prepareParserOptions","matchesTag","Array","isArray","onopentag","node","addChild","Object","keys","attributes","length","attribs","onclosetag","parent","undefined","ontext","value","addText","oncdata","concatText","onerror","err","onend","pushAll","callback","forEach","bind","_transform","chunk","encoding","write","toString","_flush","close","reduce","opts","position"],"mappings":"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","sourcesContent":["var Transform = require('stream').Transform;\nvar util = require('util');\nvar sax = require('sax');\nvar elem = require('./elem');\nvar debug = require('debug')('sax-stream');\n\nmodule.exports = XmlNode;\n\nfunction XmlNode(options) {\n  if (!(this instanceof XmlNode)) {\n    return new XmlNode(options);\n  }\n\n  Transform.call(this, {\n    highWaterMark: options.highWaterMark || 350,\n    objectMode: true\n  });\n  this.records = [];\n  this.error = null;\n  this.parser = this.createSaxParser(options);\n}\n\nutil.inherits(XmlNode, Transform);\n\n\nXmlNode.prototype.createSaxParser = function (options) {\n\n  function matchSingle(name) {\n    return name === options.tag;\n  }\n\n  function matchAny(name) {\n    return options.tag.indexOf(name) !== -1;\n  }\n\n  function pushBare(tag, record) {\n    self.records.push(record);\n  }\n\n  function pushWithTag(tag, record) {\n    self.records.push({\n      tag: tag,\n      record: record\n    });\n  }\n\n  var self = this,\n  record,\n  parser = sax.parser(options.strict || false, prepareParserOptions(options));\n\n\n  var matchesTag = matchSingle, push = pushBare;\n  if (Array.isArray(options.tag)) {\n    matchesTag = matchAny;\n    push = pushWithTag;\n  }\n\n  parser.onopentag = function(node) {\n    debug('Open \"%s\"', node.name);\n    if (record) {\n      record = elem.addChild(record, node.name);\n    } else if (matchesTag(node.name)) {\n      record = {};\n    }\n    if (record && Object.keys(node.attributes).length) {\n      record.attribs = node.attributes;\n    }\n  };\n\n  parser.onclosetag = function(tag) {\n    debug('Closed \"%s\"', tag);\n    if (matchesTag(tag) && !record.parent) {\n      debug('Emitting record', record);\n      push(tag, record);\n      record = undefined;\n    } else if (record) {\n      record = record.parent;\n    }\n  };\n\n  parser.ontext = function(value) {\n    if (record) {\n      elem.addText(record, value);\n    }\n  };\n\n  parser.oncdata = function (value) {\n    if (record) {\n      elem.concatText(record, value);\n    }\n  };\n\n  parser.onerror = function(err) {\n    self.error = err;\n  };\n\n  parser.onend = function() {\n    debug('onend - flushing remaining items');\n    self.pushAll(self.callback);\n    self.callback = null;\n  };\n\n  return parser;\n};\n\nXmlNode.prototype.pushAll = function (callback) {\n  if (this.error) {\n    callback(this.error);\n    this.error = null;\n    return;\n  }\n  debug('pushing %d', this.records.length);\n  this.records.forEach(this.push.bind(this));\n  this.records.length = 0;\n  callback();\n};\n\nXmlNode.prototype._transform = function (chunk, encoding, callback) {\n  this.parser.write(chunk.toString());\n  this.pushAll(callback);\n};\n\nXmlNode.prototype._flush = function (callback) {\n  var self = this;\n  self.callback = callback;\n  self.parser.close();\n};\n\nfunction prepareParserOptions(options) {\n  return [\n    'trim',\n    'normalize',\n    'lowercase',\n    'xmlns',\n    'position',\n    'strictEntities',\n    'noscript'\n  ].reduce(function(opts, name) {\n    if (name in options) {\n      opts[name] = options[name];\n    }\n    return opts;\n  }, {\n    position: false\n  });\n}\n"]},"metadata":{},"sourceType":"script"}