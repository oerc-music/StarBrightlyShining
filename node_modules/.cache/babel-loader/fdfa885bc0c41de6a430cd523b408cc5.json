{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Util = void 0;\n\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n\nconst RdfaProfile_1 = require(\"./RdfaProfile\");\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n/**\n * A collection of utility functions.\n */\n\n\nclass Util {\n  constructor(dataFactory, baseIRI) {\n    this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();\n    this.baseIRI = this.dataFactory.namedNode(baseIRI || '');\n    this.baseIRIDocument = this.baseIRI;\n  }\n  /**\n   * Retrieve the prefixes of the current tag's attributes.\n   * @param {{[p: string]: string}} attributes A tag's attributes.\n   * @param {{[p: string]: string}} parentPrefixes The prefixes from the parent tag.\n   * @param {boolean} xmlnsPrefixMappings If prefixes should be extracted from xmlnsPrefixMappings.\n   * @return {{[p: string]: string}} The new prefixes.\n   */\n\n\n  static parsePrefixes(attributes, parentPrefixes, xmlnsPrefixMappings) {\n    const additionalPrefixes = {};\n\n    if (xmlnsPrefixMappings) {\n      for (const attribute in attributes) {\n        if (attribute.startsWith('xmlns')) {\n          additionalPrefixes[attribute.substr(6)] = attributes[attribute];\n        }\n      }\n    }\n\n    if (attributes.prefix || Object.keys(additionalPrefixes).length > 0) {\n      const prefixes = Object.assign(Object.assign({}, parentPrefixes), additionalPrefixes);\n\n      if (attributes.prefix) {\n        let prefixMatch; // tslint:disable-next-line:no-conditional-assignment\n\n        while (prefixMatch = Util.PREFIX_REGEX.exec(attributes.prefix)) {\n          prefixes[prefixMatch[1]] = prefixMatch[2];\n        }\n      }\n\n      return prefixes;\n    } else {\n      return parentPrefixes;\n    }\n  }\n  /**\n   * Expand the given term value based on the given prefixes.\n   * @param {string} term A term value.\n   * @param {{[p: string]: string}[]} prefixes The available prefixes.\n   * @return {string} An expanded URL, or the term as-is.\n   */\n\n\n  static expandPrefixedTerm(term, activeTag) {\n    // Check if the term is prefixed\n    const colonIndex = term.indexOf(':');\n    let prefix;\n    let local;\n\n    if (colonIndex >= 0) {\n      prefix = term.substr(0, colonIndex);\n      local = term.substr(colonIndex + 1);\n    } // Expand default namespace\n\n\n    if (prefix === '') {\n      return 'http://www.w3.org/1999/xhtml/vocab#' + local;\n    } // Try to expand the prefix\n\n\n    if (prefix) {\n      const prefixElement = activeTag.prefixesAll[prefix];\n\n      if (prefixElement) {\n        return prefixElement + local;\n      }\n    } // Try to expand the term\n\n\n    if (term) {\n      const expandedTerm = activeTag.prefixesAll[term.toLocaleLowerCase()];\n\n      if (expandedTerm) {\n        return expandedTerm;\n      }\n    }\n\n    return term;\n  }\n  /**\n   * Check if the given IRI is valid.\n   * @param {string} iri A potential IRI.\n   * @return {boolean} If the given IRI is valid.\n   */\n\n\n  static isValidIri(iri) {\n    return Util.IRI_REGEX.test(iri);\n  }\n  /**\n   * Determine the RDFa profile from the given content type.\n   * Defaults to the default RDFa profile (all features enabled) for unknown content types.\n   * @param {string} contentType A content type.\n   * @returns {RdfaProfile} An RDFa profile.\n   */\n\n\n  static contentTypeToProfile(contentType) {\n    return RdfaProfile_1.RDFA_CONTENTTYPES[contentType] || '';\n  }\n  /**\n   * Get the base IRI.\n   * @param {string} baseIriValue A base IRI value.\n   * @return A base IRI named node.\n   */\n\n\n  getBaseIRI(baseIriValue) {\n    let href = baseIriValue;\n    const fragmentIndex = href.indexOf('#');\n\n    if (fragmentIndex >= 0) {\n      href = href.substr(0, fragmentIndex);\n    }\n\n    return this.dataFactory.namedNode(relative_to_absolute_iri_1.resolve(href, this.baseIRI.value));\n  }\n  /**\n   * If the term is a boolean, return the baseIRI, otherwise return the term as-is.\n   * @param {Term | boolean} term A term or boolean, where the boolean indicates the baseIRI.\n   * @param {IActiveTag} activeTag An active tag.\n   * @returns {Term} A term.\n   */\n\n\n  getResourceOrBaseIri(term, activeTag) {\n    return term === true ? this.getBaseIriTerm(activeTag) : term;\n  }\n  /**\n   * Get the active base IRI as an RDF term.\n   * @param {IActiveTag} activeTag The active tag.\n   * @return {NamedNode} The base IRI term.\n   */\n\n\n  getBaseIriTerm(activeTag) {\n    return activeTag.localBaseIRI || this.baseIRI;\n  }\n\n  createVocabIris(terms, activeTag, allowTerms, allowBlankNode) {\n    return terms.split(/\\s+/).filter(term => term && (allowTerms || term.indexOf(':') >= 0)).map(property => this.createIri(property, activeTag, true, true, allowBlankNode)).filter(term => term != null);\n  }\n  /**\n   * Create a new literal node.\n   * @param {string} literal The literal value.\n   * @param {IActiveTag} activeTag The current active tag.\n   * @return {Literal} A new literal node.\n   */\n\n\n  createLiteral(literal, activeTag) {\n    if (activeTag.interpretObjectAsTime && !activeTag.datatype) {\n      for (const entry of Util.TIME_REGEXES) {\n        if (literal.match(entry.regex)) {\n          activeTag.datatype = this.dataFactory.namedNode(Util.XSD + entry.type);\n          break;\n        }\n      }\n    }\n\n    return this.dataFactory.literal(literal, activeTag.datatype || activeTag.language);\n  }\n  /**\n   * Create a blank node.\n   * @returns {BlankNode} A new blank node.\n   */\n\n\n  createBlankNode() {\n    if (this.blankNodeFactory) {\n      return this.blankNodeFactory();\n    }\n\n    return this.dataFactory.blankNode();\n  }\n\n  createIri(term, activeTag, vocab, allowSafeCurie, allowBlankNode) {\n    term = term || '';\n\n    if (!allowSafeCurie) {\n      if (!vocab) {\n        term = relative_to_absolute_iri_1.resolve(term, this.getBaseIriTerm(activeTag).value);\n      }\n\n      if (!Util.isValidIri(term)) {\n        return null;\n      }\n\n      return this.dataFactory.namedNode(term);\n    } // Handle strict CURIEs\n\n\n    if (term.length > 0 && term[0] === '[' && term[term.length - 1] === ']') {\n      term = term.substr(1, term.length - 2); // Strict CURIEs MUST have a prefix separator\n\n      if (term.indexOf(':') < 0) {\n        return null;\n      }\n    } // Handle blank nodes\n\n\n    if (term.startsWith('_:')) {\n      return allowBlankNode ? this.dataFactory.blankNode(term.substr(2) || 'b_identity') : null;\n    } // Handle vocab IRIs\n\n\n    if (vocab) {\n      if (activeTag.vocab && term.indexOf(':') < 0) {\n        return this.dataFactory.namedNode(activeTag.vocab + term);\n      }\n    } // Handle prefixed IRIs\n\n\n    let iri = Util.expandPrefixedTerm(term, activeTag); // Resolve against baseIRI if in base-mode, or if the term was a prefixed relative IRI\n\n    if (!vocab) {\n      iri = relative_to_absolute_iri_1.resolve(iri, this.getBaseIriTerm(activeTag).value);\n    } else if (term !== iri) {\n      iri = relative_to_absolute_iri_1.resolve(iri, this.baseIRIDocument.value);\n    }\n\n    if (!Util.isValidIri(iri)) {\n      return null;\n    }\n\n    return this.dataFactory.namedNode(iri);\n  }\n\n}\n\nexports.Util = Util;\nUtil.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nUtil.XSD = 'http://www.w3.org/2001/XMLSchema#';\nUtil.RDFA = 'http://www.w3.org/ns/rdfa#';\nUtil.PREFIX_REGEX = /\\s*([^:\\s]*)*:\\s*([^\\s]*)*\\s*/g;\nUtil.TIME_REGEXES = [{\n  regex: /^-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\\.[0-9])?S)?)?$/,\n  type: 'duration'\n}, {\n  regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\\+-][0-9][0-9]:[0-9][0-9]))$/,\n  type: 'dateTime'\n}, {\n  regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/,\n  type: 'date'\n}, {\n  regex: /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\\+-][0-9][0-9]:[0-9][0-9]))$/,\n  type: 'time'\n}, {\n  regex: /^[0-9]+-[0-9][0-9]$/,\n  type: 'gYearMonth'\n}, {\n  regex: /^[0-9]+$/,\n  type: 'gYear'\n}];\nUtil.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`]*$/;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/rdfa-streaming-parser/lib/Util.js"],"names":["Object","defineProperty","exports","value","Util","relative_to_absolute_iri_1","require","RdfaProfile_1","rdf_data_factory_1","constructor","dataFactory","baseIRI","DataFactory","namedNode","baseIRIDocument","parsePrefixes","attributes","parentPrefixes","xmlnsPrefixMappings","additionalPrefixes","attribute","startsWith","substr","prefix","keys","length","prefixes","assign","prefixMatch","PREFIX_REGEX","exec","expandPrefixedTerm","term","activeTag","colonIndex","indexOf","local","prefixElement","prefixesAll","expandedTerm","toLocaleLowerCase","isValidIri","iri","IRI_REGEX","test","contentTypeToProfile","contentType","RDFA_CONTENTTYPES","getBaseIRI","baseIriValue","href","fragmentIndex","resolve","getResourceOrBaseIri","getBaseIriTerm","localBaseIRI","createVocabIris","terms","allowTerms","allowBlankNode","split","filter","map","property","createIri","createLiteral","literal","interpretObjectAsTime","datatype","entry","TIME_REGEXES","match","regex","XSD","type","language","createBlankNode","blankNodeFactory","blankNode","vocab","allowSafeCurie","RDF","RDFA"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,IAAR,GAAe,KAAK,CAApB;;AACA,MAAMC,0BAA0B,GAAGC,OAAO,CAAC,0BAAD,CAA1C;;AACA,MAAMC,aAAa,GAAGD,OAAO,CAAC,eAAD,CAA7B;;AACA,MAAME,kBAAkB,GAAGF,OAAO,CAAC,kBAAD,CAAlC;AACA;AACA;AACA;;;AACA,MAAMF,IAAN,CAAW;AACPK,EAAAA,WAAW,CAACC,WAAD,EAAcC,OAAd,EAAuB;AAC9B,SAAKD,WAAL,GAAmBA,WAAW,IAAI,IAAIF,kBAAkB,CAACI,WAAvB,EAAlC;AACA,SAAKD,OAAL,GAAe,KAAKD,WAAL,CAAiBG,SAAjB,CAA2BF,OAAO,IAAI,EAAtC,CAAf;AACA,SAAKG,eAAL,GAAuB,KAAKH,OAA5B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACwB,SAAbI,aAAa,CAACC,UAAD,EAAaC,cAAb,EAA6BC,mBAA7B,EAAkD;AAClE,UAAMC,kBAAkB,GAAG,EAA3B;;AACA,QAAID,mBAAJ,EAAyB;AACrB,WAAK,MAAME,SAAX,IAAwBJ,UAAxB,EAAoC;AAChC,YAAII,SAAS,CAACC,UAAV,CAAqB,OAArB,CAAJ,EAAmC;AAC/BF,UAAAA,kBAAkB,CAACC,SAAS,CAACE,MAAV,CAAiB,CAAjB,CAAD,CAAlB,GAA0CN,UAAU,CAACI,SAAD,CAApD;AACH;AACJ;AACJ;;AACD,QAAIJ,UAAU,CAACO,MAAX,IAAqBvB,MAAM,CAACwB,IAAP,CAAYL,kBAAZ,EAAgCM,MAAhC,GAAyC,CAAlE,EAAqE;AACjE,YAAMC,QAAQ,GAAG1B,MAAM,CAAC2B,MAAP,CAAc3B,MAAM,CAAC2B,MAAP,CAAc,EAAd,EAAkBV,cAAlB,CAAd,EAAiDE,kBAAjD,CAAjB;;AACA,UAAIH,UAAU,CAACO,MAAf,EAAuB;AACnB,YAAIK,WAAJ,CADmB,CAEnB;;AACA,eAAOA,WAAW,GAAGxB,IAAI,CAACyB,YAAL,CAAkBC,IAAlB,CAAuBd,UAAU,CAACO,MAAlC,CAArB,EAAgE;AAC5DG,UAAAA,QAAQ,CAACE,WAAW,CAAC,CAAD,CAAZ,CAAR,GAA2BA,WAAW,CAAC,CAAD,CAAtC;AACH;AACJ;;AACD,aAAOF,QAAP;AACH,KAVD,MAWK;AACD,aAAOT,cAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;;;AAC6B,SAAlBc,kBAAkB,CAACC,IAAD,EAAOC,SAAP,EAAkB;AACvC;AACA,UAAMC,UAAU,GAAGF,IAAI,CAACG,OAAL,CAAa,GAAb,CAAnB;AACA,QAAIZ,MAAJ;AACA,QAAIa,KAAJ;;AACA,QAAIF,UAAU,IAAI,CAAlB,EAAqB;AACjBX,MAAAA,MAAM,GAAGS,IAAI,CAACV,MAAL,CAAY,CAAZ,EAAeY,UAAf,CAAT;AACAE,MAAAA,KAAK,GAAGJ,IAAI,CAACV,MAAL,CAAYY,UAAU,GAAG,CAAzB,CAAR;AACH,KARsC,CASvC;;;AACA,QAAIX,MAAM,KAAK,EAAf,EAAmB;AACf,aAAO,wCAAwCa,KAA/C;AACH,KAZsC,CAavC;;;AACA,QAAIb,MAAJ,EAAY;AACR,YAAMc,aAAa,GAAGJ,SAAS,CAACK,WAAV,CAAsBf,MAAtB,CAAtB;;AACA,UAAIc,aAAJ,EAAmB;AACf,eAAOA,aAAa,GAAGD,KAAvB;AACH;AACJ,KAnBsC,CAoBvC;;;AACA,QAAIJ,IAAJ,EAAU;AACN,YAAMO,YAAY,GAAGN,SAAS,CAACK,WAAV,CAAsBN,IAAI,CAACQ,iBAAL,EAAtB,CAArB;;AACA,UAAID,YAAJ,EAAkB;AACd,eAAOA,YAAP;AACH;AACJ;;AACD,WAAOP,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACqB,SAAVS,UAAU,CAACC,GAAD,EAAM;AACnB,WAAOtC,IAAI,CAACuC,SAAL,CAAeC,IAAf,CAAoBF,GAApB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AAC+B,SAApBG,oBAAoB,CAACC,WAAD,EAAc;AACrC,WAAOvC,aAAa,CAACwC,iBAAd,CAAgCD,WAAhC,KAAgD,EAAvD;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIE,EAAAA,UAAU,CAACC,YAAD,EAAe;AACrB,QAAIC,IAAI,GAAGD,YAAX;AACA,UAAME,aAAa,GAAGD,IAAI,CAACf,OAAL,CAAa,GAAb,CAAtB;;AACA,QAAIgB,aAAa,IAAI,CAArB,EAAwB;AACpBD,MAAAA,IAAI,GAAGA,IAAI,CAAC5B,MAAL,CAAY,CAAZ,EAAe6B,aAAf,CAAP;AACH;;AACD,WAAO,KAAKzC,WAAL,CAAiBG,SAAjB,CAA2BR,0BAA0B,CAAC+C,OAA3B,CAAmCF,IAAnC,EAAyC,KAAKvC,OAAL,CAAaR,KAAtD,CAA3B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIkD,EAAAA,oBAAoB,CAACrB,IAAD,EAAOC,SAAP,EAAkB;AAClC,WAAOD,IAAI,KAAK,IAAT,GAAgB,KAAKsB,cAAL,CAAoBrB,SAApB,CAAhB,GAAiDD,IAAxD;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIsB,EAAAA,cAAc,CAACrB,SAAD,EAAY;AACtB,WAAOA,SAAS,CAACsB,YAAV,IAA0B,KAAK5C,OAAtC;AACH;;AACD6C,EAAAA,eAAe,CAACC,KAAD,EAAQxB,SAAR,EAAmByB,UAAnB,EAA+BC,cAA/B,EAA+C;AAC1D,WAAOF,KAAK,CAACG,KAAN,CAAY,KAAZ,EACFC,MADE,CACM7B,IAAD,IAAUA,IAAI,KAAK0B,UAAU,IAAI1B,IAAI,CAACG,OAAL,CAAa,GAAb,KAAqB,CAAxC,CADnB,EAEF2B,GAFE,CAEGC,QAAD,IAAc,KAAKC,SAAL,CAAeD,QAAf,EAAyB9B,SAAzB,EAAoC,IAApC,EAA0C,IAA1C,EAAgD0B,cAAhD,CAFhB,EAGFE,MAHE,CAGM7B,IAAD,IAAUA,IAAI,IAAI,IAHvB,CAAP;AAIH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIiC,EAAAA,aAAa,CAACC,OAAD,EAAUjC,SAAV,EAAqB;AAC9B,QAAIA,SAAS,CAACkC,qBAAV,IAAmC,CAAClC,SAAS,CAACmC,QAAlD,EAA4D;AACxD,WAAK,MAAMC,KAAX,IAAoBjE,IAAI,CAACkE,YAAzB,EAAuC;AACnC,YAAIJ,OAAO,CAACK,KAAR,CAAcF,KAAK,CAACG,KAApB,CAAJ,EAAgC;AAC5BvC,UAAAA,SAAS,CAACmC,QAAV,GAAqB,KAAK1D,WAAL,CAAiBG,SAAjB,CAA2BT,IAAI,CAACqE,GAAL,GAAWJ,KAAK,CAACK,IAA5C,CAArB;AACA;AACH;AACJ;AACJ;;AACD,WAAO,KAAKhE,WAAL,CAAiBwD,OAAjB,CAAyBA,OAAzB,EAAkCjC,SAAS,CAACmC,QAAV,IAAsBnC,SAAS,CAAC0C,QAAlE,CAAP;AACH;AACD;AACJ;AACA;AACA;;;AACIC,EAAAA,eAAe,GAAG;AACd,QAAI,KAAKC,gBAAT,EAA2B;AACvB,aAAO,KAAKA,gBAAL,EAAP;AACH;;AACD,WAAO,KAAKnE,WAAL,CAAiBoE,SAAjB,EAAP;AACH;;AACDd,EAAAA,SAAS,CAAChC,IAAD,EAAOC,SAAP,EAAkB8C,KAAlB,EAAyBC,cAAzB,EAAyCrB,cAAzC,EAAyD;AAC9D3B,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;;AACA,QAAI,CAACgD,cAAL,EAAqB;AACjB,UAAI,CAACD,KAAL,EAAY;AACR/C,QAAAA,IAAI,GAAG3B,0BAA0B,CAAC+C,OAA3B,CAAmCpB,IAAnC,EAAyC,KAAKsB,cAAL,CAAoBrB,SAApB,EAA+B9B,KAAxE,CAAP;AACH;;AACD,UAAI,CAACC,IAAI,CAACqC,UAAL,CAAgBT,IAAhB,CAAL,EAA4B;AACxB,eAAO,IAAP;AACH;;AACD,aAAO,KAAKtB,WAAL,CAAiBG,SAAjB,CAA2BmB,IAA3B,CAAP;AACH,KAV6D,CAW9D;;;AACA,QAAIA,IAAI,CAACP,MAAL,GAAc,CAAd,IAAmBO,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA/B,IAAsCA,IAAI,CAACA,IAAI,CAACP,MAAL,GAAc,CAAf,CAAJ,KAA0B,GAApE,EAAyE;AACrEO,MAAAA,IAAI,GAAGA,IAAI,CAACV,MAAL,CAAY,CAAZ,EAAeU,IAAI,CAACP,MAAL,GAAc,CAA7B,CAAP,CADqE,CAErE;;AACA,UAAIO,IAAI,CAACG,OAAL,CAAa,GAAb,IAAoB,CAAxB,EAA2B;AACvB,eAAO,IAAP;AACH;AACJ,KAlB6D,CAmB9D;;;AACA,QAAIH,IAAI,CAACX,UAAL,CAAgB,IAAhB,CAAJ,EAA2B;AACvB,aAAOsC,cAAc,GAAG,KAAKjD,WAAL,CAAiBoE,SAAjB,CAA2B9C,IAAI,CAACV,MAAL,CAAY,CAAZ,KAAkB,YAA7C,CAAH,GAAgE,IAArF;AACH,KAtB6D,CAuB9D;;;AACA,QAAIyD,KAAJ,EAAW;AACP,UAAI9C,SAAS,CAAC8C,KAAV,IAAmB/C,IAAI,CAACG,OAAL,CAAa,GAAb,IAAoB,CAA3C,EAA8C;AAC1C,eAAO,KAAKzB,WAAL,CAAiBG,SAAjB,CAA2BoB,SAAS,CAAC8C,KAAV,GAAkB/C,IAA7C,CAAP;AACH;AACJ,KA5B6D,CA6B9D;;;AACA,QAAIU,GAAG,GAAGtC,IAAI,CAAC2B,kBAAL,CAAwBC,IAAxB,EAA8BC,SAA9B,CAAV,CA9B8D,CA+B9D;;AACA,QAAI,CAAC8C,KAAL,EAAY;AACRrC,MAAAA,GAAG,GAAGrC,0BAA0B,CAAC+C,OAA3B,CAAmCV,GAAnC,EAAwC,KAAKY,cAAL,CAAoBrB,SAApB,EAA+B9B,KAAvE,CAAN;AACH,KAFD,MAGK,IAAI6B,IAAI,KAAKU,GAAb,EAAkB;AACnBA,MAAAA,GAAG,GAAGrC,0BAA0B,CAAC+C,OAA3B,CAAmCV,GAAnC,EAAwC,KAAK5B,eAAL,CAAqBX,KAA7D,CAAN;AACH;;AACD,QAAI,CAACC,IAAI,CAACqC,UAAL,CAAgBC,GAAhB,CAAL,EAA2B;AACvB,aAAO,IAAP;AACH;;AACD,WAAO,KAAKhC,WAAL,CAAiBG,SAAjB,CAA2B6B,GAA3B,CAAP;AACH;;AAlMM;;AAoMXxC,OAAO,CAACE,IAAR,GAAeA,IAAf;AACAA,IAAI,CAAC6E,GAAL,GAAW,6CAAX;AACA7E,IAAI,CAACqE,GAAL,GAAW,mCAAX;AACArE,IAAI,CAAC8E,IAAL,GAAY,4BAAZ;AACA9E,IAAI,CAACyB,YAAL,GAAoB,gCAApB;AACAzB,IAAI,CAACkE,YAAL,GAAoB,CAChB;AACIE,EAAAA,KAAK,EAAE,iFADX;AAEIE,EAAAA,IAAI,EAAE;AAFV,CADgB,EAKhB;AACIF,EAAAA,KAAK,EAAE,oGADX;AAEIE,EAAAA,IAAI,EAAE;AAFV,CALgB,EAShB;AAAEF,EAAAA,KAAK,EAAE,kCAAT;AAA6CE,EAAAA,IAAI,EAAE;AAAnD,CATgB,EAUhB;AAAEF,EAAAA,KAAK,EAAE,uEAAT;AAAkFE,EAAAA,IAAI,EAAE;AAAxF,CAVgB,EAWhB;AAAEF,EAAAA,KAAK,EAAE,qBAAT;AAAgCE,EAAAA,IAAI,EAAE;AAAtC,CAXgB,EAYhB;AAAEF,EAAAA,KAAK,EAAE,UAAT;AAAqBE,EAAAA,IAAI,EAAE;AAA3B,CAZgB,CAApB;AAcAtE,IAAI,CAACuC,SAAL,GAAiB,kDAAjB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst RdfaProfile_1 = require(\"./RdfaProfile\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n/**\n * A collection of utility functions.\n */\nclass Util {\n    constructor(dataFactory, baseIRI) {\n        this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();\n        this.baseIRI = this.dataFactory.namedNode(baseIRI || '');\n        this.baseIRIDocument = this.baseIRI;\n    }\n    /**\n     * Retrieve the prefixes of the current tag's attributes.\n     * @param {{[p: string]: string}} attributes A tag's attributes.\n     * @param {{[p: string]: string}} parentPrefixes The prefixes from the parent tag.\n     * @param {boolean} xmlnsPrefixMappings If prefixes should be extracted from xmlnsPrefixMappings.\n     * @return {{[p: string]: string}} The new prefixes.\n     */\n    static parsePrefixes(attributes, parentPrefixes, xmlnsPrefixMappings) {\n        const additionalPrefixes = {};\n        if (xmlnsPrefixMappings) {\n            for (const attribute in attributes) {\n                if (attribute.startsWith('xmlns')) {\n                    additionalPrefixes[attribute.substr(6)] = attributes[attribute];\n                }\n            }\n        }\n        if (attributes.prefix || Object.keys(additionalPrefixes).length > 0) {\n            const prefixes = Object.assign(Object.assign({}, parentPrefixes), additionalPrefixes);\n            if (attributes.prefix) {\n                let prefixMatch;\n                // tslint:disable-next-line:no-conditional-assignment\n                while (prefixMatch = Util.PREFIX_REGEX.exec(attributes.prefix)) {\n                    prefixes[prefixMatch[1]] = prefixMatch[2];\n                }\n            }\n            return prefixes;\n        }\n        else {\n            return parentPrefixes;\n        }\n    }\n    /**\n     * Expand the given term value based on the given prefixes.\n     * @param {string} term A term value.\n     * @param {{[p: string]: string}[]} prefixes The available prefixes.\n     * @return {string} An expanded URL, or the term as-is.\n     */\n    static expandPrefixedTerm(term, activeTag) {\n        // Check if the term is prefixed\n        const colonIndex = term.indexOf(':');\n        let prefix;\n        let local;\n        if (colonIndex >= 0) {\n            prefix = term.substr(0, colonIndex);\n            local = term.substr(colonIndex + 1);\n        }\n        // Expand default namespace\n        if (prefix === '') {\n            return 'http://www.w3.org/1999/xhtml/vocab#' + local;\n        }\n        // Try to expand the prefix\n        if (prefix) {\n            const prefixElement = activeTag.prefixesAll[prefix];\n            if (prefixElement) {\n                return prefixElement + local;\n            }\n        }\n        // Try to expand the term\n        if (term) {\n            const expandedTerm = activeTag.prefixesAll[term.toLocaleLowerCase()];\n            if (expandedTerm) {\n                return expandedTerm;\n            }\n        }\n        return term;\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return Util.IRI_REGEX.test(iri);\n    }\n    /**\n     * Determine the RDFa profile from the given content type.\n     * Defaults to the default RDFa profile (all features enabled) for unknown content types.\n     * @param {string} contentType A content type.\n     * @returns {RdfaProfile} An RDFa profile.\n     */\n    static contentTypeToProfile(contentType) {\n        return RdfaProfile_1.RDFA_CONTENTTYPES[contentType] || '';\n    }\n    /**\n     * Get the base IRI.\n     * @param {string} baseIriValue A base IRI value.\n     * @return A base IRI named node.\n     */\n    getBaseIRI(baseIriValue) {\n        let href = baseIriValue;\n        const fragmentIndex = href.indexOf('#');\n        if (fragmentIndex >= 0) {\n            href = href.substr(0, fragmentIndex);\n        }\n        return this.dataFactory.namedNode(relative_to_absolute_iri_1.resolve(href, this.baseIRI.value));\n    }\n    /**\n     * If the term is a boolean, return the baseIRI, otherwise return the term as-is.\n     * @param {Term | boolean} term A term or boolean, where the boolean indicates the baseIRI.\n     * @param {IActiveTag} activeTag An active tag.\n     * @returns {Term} A term.\n     */\n    getResourceOrBaseIri(term, activeTag) {\n        return term === true ? this.getBaseIriTerm(activeTag) : term;\n    }\n    /**\n     * Get the active base IRI as an RDF term.\n     * @param {IActiveTag} activeTag The active tag.\n     * @return {NamedNode} The base IRI term.\n     */\n    getBaseIriTerm(activeTag) {\n        return activeTag.localBaseIRI || this.baseIRI;\n    }\n    createVocabIris(terms, activeTag, allowTerms, allowBlankNode) {\n        return terms.split(/\\s+/)\n            .filter((term) => term && (allowTerms || term.indexOf(':') >= 0))\n            .map((property) => this.createIri(property, activeTag, true, true, allowBlankNode))\n            .filter((term) => term != null);\n    }\n    /**\n     * Create a new literal node.\n     * @param {string} literal The literal value.\n     * @param {IActiveTag} activeTag The current active tag.\n     * @return {Literal} A new literal node.\n     */\n    createLiteral(literal, activeTag) {\n        if (activeTag.interpretObjectAsTime && !activeTag.datatype) {\n            for (const entry of Util.TIME_REGEXES) {\n                if (literal.match(entry.regex)) {\n                    activeTag.datatype = this.dataFactory.namedNode(Util.XSD + entry.type);\n                    break;\n                }\n            }\n        }\n        return this.dataFactory.literal(literal, activeTag.datatype || activeTag.language);\n    }\n    /**\n     * Create a blank node.\n     * @returns {BlankNode} A new blank node.\n     */\n    createBlankNode() {\n        if (this.blankNodeFactory) {\n            return this.blankNodeFactory();\n        }\n        return this.dataFactory.blankNode();\n    }\n    createIri(term, activeTag, vocab, allowSafeCurie, allowBlankNode) {\n        term = term || '';\n        if (!allowSafeCurie) {\n            if (!vocab) {\n                term = relative_to_absolute_iri_1.resolve(term, this.getBaseIriTerm(activeTag).value);\n            }\n            if (!Util.isValidIri(term)) {\n                return null;\n            }\n            return this.dataFactory.namedNode(term);\n        }\n        // Handle strict CURIEs\n        if (term.length > 0 && term[0] === '[' && term[term.length - 1] === ']') {\n            term = term.substr(1, term.length - 2);\n            // Strict CURIEs MUST have a prefix separator\n            if (term.indexOf(':') < 0) {\n                return null;\n            }\n        }\n        // Handle blank nodes\n        if (term.startsWith('_:')) {\n            return allowBlankNode ? this.dataFactory.blankNode(term.substr(2) || 'b_identity') : null;\n        }\n        // Handle vocab IRIs\n        if (vocab) {\n            if (activeTag.vocab && term.indexOf(':') < 0) {\n                return this.dataFactory.namedNode(activeTag.vocab + term);\n            }\n        }\n        // Handle prefixed IRIs\n        let iri = Util.expandPrefixedTerm(term, activeTag);\n        // Resolve against baseIRI if in base-mode, or if the term was a prefixed relative IRI\n        if (!vocab) {\n            iri = relative_to_absolute_iri_1.resolve(iri, this.getBaseIriTerm(activeTag).value);\n        }\n        else if (term !== iri) {\n            iri = relative_to_absolute_iri_1.resolve(iri, this.baseIRIDocument.value);\n        }\n        if (!Util.isValidIri(iri)) {\n            return null;\n        }\n        return this.dataFactory.namedNode(iri);\n    }\n}\nexports.Util = Util;\nUtil.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nUtil.XSD = 'http://www.w3.org/2001/XMLSchema#';\nUtil.RDFA = 'http://www.w3.org/ns/rdfa#';\nUtil.PREFIX_REGEX = /\\s*([^:\\s]*)*:\\s*([^\\s]*)*\\s*/g;\nUtil.TIME_REGEXES = [\n    {\n        regex: /^-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\\.[0-9])?S)?)?$/,\n        type: 'duration',\n    },\n    {\n        regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\\+-][0-9][0-9]:[0-9][0-9]))$/,\n        type: 'dateTime',\n    },\n    { regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/, type: 'date' },\n    { regex: /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\\+-][0-9][0-9]:[0-9][0-9]))$/, type: 'time' },\n    { regex: /^[0-9]+-[0-9][0-9]$/, type: 'gYearMonth' },\n    { regex: /^[0-9]+$/, type: 'gYear' },\n];\nUtil.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`]*$/;\n//# sourceMappingURL=Util.js.map"]},"metadata":{},"sourceType":"script"}