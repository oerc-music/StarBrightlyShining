{"ast":null,"code":"import update from 'immutability-helper';\nimport JSum from 'jsum';\nimport { APPLY_TRAVERSAL_OBJECTIVE, ensureArray, FETCH_GRAPH, FETCH_GRAPH_DOCUMENT, FETCH_WORK, SESSION_GRAPH_ETAG, SET_TRAVERSAL_OBJECTIVES } from '../actions/index';\nimport { QUEUE_NEXT_SESSION } from '../actions/meldActions';\nconst INIT_STATE = {\n  //    graph: {  \n  //        annoGraph: {}, \n  //        targetsById: {}, \n  //        targetsByType: {}\n  //    },\n  etags: {},\n  nextSession: \"\",\n  info: {},\n  graph: [],\n  graphDocs: [],\n  objectives: [],\n  outcomes: [],\n  outcomesHash: \"\",\n  allObjectivesApplied: false\n};\nexport default function (state = INIT_STATE, action) {\n  switch (action.type) {\n    case FETCH_GRAPH:\n      let byId = {};\n      let byType = {};\n      let payload = action.payload;\n\n      if (typeof payload === \"string\") {\n        payload = JSON.parse(payload);\n      }\n\n      payload = ensureArray(payload, \"@graph\");\n      payload = payload[\"@graph\"][0];\n\n      if (\"ldp:contains\" in payload) {\n        payload = ensureArray(payload, \"ldp:contains\");\n        payload[\"ldp:contains\"].map(a => {\n          if (\"meld:state\" in a && a[\"meld:state\"][\"@id\"] == \"meld:processed\") {\n            // Decide whether we want to render the processed annotation\n            // ... and modify its motivation if necessary to signal its new purpose\n            // This is required for annotations that both have renderings (should always show)\n            // and side effects (should only happen once)\n            if (a[\"oa:motivatedBy\"][\"@id\"] === \"motivation:muzicodeTriggered\") {\n              a[\"oa:motivatedBy\"][\"@id\"] = \"motivation:archivedMuzicodeTrigger\";\n              delete a[\"meld:state\"];\n            } else {\n              // We can skip this processed annotation\n              return;\n            }\n          }\n\n          a = ensureArray(a, \"oa:hasTarget\");\n          a[\"oa:hasTarget\"].map(targetResource => {\n            // lookup target IDs to get types and component annotations\n            if (targetResource[\"@id\"] in byId) {\n              byId[targetResource[\"@id\"]][\"annotations\"].push(a);\n            } else {\n              byId[targetResource[\"@id\"]] = {\n                \"type\": targetResource[\"@type\"],\n                \"annotations\": [a]\n              };\n            } // lookup target type to get target ID\n\n\n            if (targetResource[\"@type\"] in byType) {\n              byType[targetResource[\"@type\"]].push({\n                [targetResource[\"@id\"]]: true\n              });\n            } else {\n              byType[targetResource[\"@type\"]] = [{\n                [targetResource[\"@id\"]]: true\n              }];\n            }\n          });\n        });\n      } else {\n        console.log(\"Graph contains no annotations: \", payload);\n      }\n\n      return update(state, {\n        annoGraph: {\n          $set: payload\n        },\n        targetsById: {\n          $set: byId\n        },\n        targetsByType: {\n          $set: byType\n        }\n      });\n\n    case SESSION_GRAPH_ETAG:\n      return update(state, {\n        etags: {\n          $set: {\n            [action.payload.uri]: action.payload.etag\n          }\n        }\n      });\n\n    case QUEUE_NEXT_SESSION:\n      // console.log(\"Setting next session: \", action.payload);\n      return update(state, {\n        nextSession: {\n          $set: action.payload\n        }\n      });\n\n    case FETCH_WORK:\n      if (action.payload.info) {\n        return update(state, {\n          info: {\n            $merge: {\n              [action.payload.target[\"@id\"]]: action.payload.info\n            }\n          }\n        });\n      }\n\n      break;\n\n    case SET_TRAVERSAL_OBJECTIVES:\n      // register the set of objectives provided by the MELD application\n      // and initialise the outcomes in a corresponding array.\n      // Typically run once on mount.\n      return update(state, {\n        objectives: {\n          $set: action.payload\n        },\n        outcomes: {\n          $set: new Array(action.payload.length)\n        }\n      });\n\n    case FETCH_GRAPH_DOCUMENT:\n      // new graph fragment has arrived. If we don't have it from a previous traversal, add it to our graph.\n      if (!state.graphDocs.includes(action.payload.uri)) {\n        // console.log(state.graph, state.graphDocs, action)\n        return update(state, {\n          graph: {\n            $push: action.payload.data\n          },\n          graphDocs: {\n            $push: [action.payload.uri]\n          }\n        });\n      } else {//console.log(\"FETCH_GRAPH_DOCUMENT: ignoring as already seen: \", action.payload.uri);\n      }\n\n      break;\n\n    case APPLY_TRAVERSAL_OBJECTIVE:\n      // an objective has been applied against the graph. Store the outcome at the\n      // appropriate index.\n      let updatedOutcomes = state.outcomes;\n      updatedOutcomes[action.payload.ix] = action.payload.framed;\n      let updatedOutcomesHash = JSum.digest(updatedOutcomes, 'md5', 'hex');\n\n      if (action.payload.ix === state.objectives.length - 1) {\n        console.log(\"About to switch on allObjectivesApplied with\", updatedOutcomes, state);\n      }\n\n      return update(state, {\n        outcomes: {\n          $set: updatedOutcomes\n        },\n        outcomesHash: {\n          $set: updatedOutcomesHash\n        },\n        allObjectivesApplied: {\n          $set: action.payload.ix === state.objectives.length - 1 ? true : false\n        }\n      });\n\n    default:\n      return state;\n  }\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/meld-clients-core/lib/reducers/reducer_graph.js"],"names":["update","JSum","APPLY_TRAVERSAL_OBJECTIVE","ensureArray","FETCH_GRAPH","FETCH_GRAPH_DOCUMENT","FETCH_WORK","SESSION_GRAPH_ETAG","SET_TRAVERSAL_OBJECTIVES","QUEUE_NEXT_SESSION","INIT_STATE","etags","nextSession","info","graph","graphDocs","objectives","outcomes","outcomesHash","allObjectivesApplied","state","action","type","byId","byType","payload","JSON","parse","map","a","targetResource","push","console","log","annoGraph","$set","targetsById","targetsByType","uri","etag","$merge","target","Array","length","includes","$push","data","updatedOutcomes","ix","framed","updatedOutcomesHash","digest"],"mappings":"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","sourcesContent":["import update from 'immutability-helper';\nimport JSum from 'jsum';\nimport { APPLY_TRAVERSAL_OBJECTIVE, ensureArray, FETCH_GRAPH, FETCH_GRAPH_DOCUMENT, FETCH_WORK, SESSION_GRAPH_ETAG, SET_TRAVERSAL_OBJECTIVES } from '../actions/index';\nimport { QUEUE_NEXT_SESSION } from '../actions/meldActions';\nconst INIT_STATE = {\n  //    graph: {  \n  //        annoGraph: {}, \n  //        targetsById: {}, \n  //        targetsByType: {}\n  //    },\n  etags: {},\n  nextSession: \"\",\n  info: {},\n  graph: [],\n  graphDocs: [],\n  objectives: [],\n  outcomes: [],\n  outcomesHash: \"\",\n  allObjectivesApplied: false\n};\nexport default function (state = INIT_STATE, action) {\n  switch (action.type) {\n    case FETCH_GRAPH:\n      let byId = {};\n      let byType = {};\n      let payload = action.payload;\n\n      if (typeof payload === \"string\") {\n        payload = JSON.parse(payload);\n      }\n\n      payload = ensureArray(payload, \"@graph\");\n      payload = payload[\"@graph\"][0];\n\n      if (\"ldp:contains\" in payload) {\n        payload = ensureArray(payload, \"ldp:contains\");\n        payload[\"ldp:contains\"].map(a => {\n          if (\"meld:state\" in a && a[\"meld:state\"][\"@id\"] == \"meld:processed\") {\n            // Decide whether we want to render the processed annotation\n            // ... and modify its motivation if necessary to signal its new purpose\n            // This is required for annotations that both have renderings (should always show)\n            // and side effects (should only happen once)\n            if (a[\"oa:motivatedBy\"][\"@id\"] === \"motivation:muzicodeTriggered\") {\n              a[\"oa:motivatedBy\"][\"@id\"] = \"motivation:archivedMuzicodeTrigger\";\n              delete a[\"meld:state\"];\n            } else {\n              // We can skip this processed annotation\n              return;\n            }\n          }\n\n          a = ensureArray(a, \"oa:hasTarget\");\n          a[\"oa:hasTarget\"].map(targetResource => {\n            // lookup target IDs to get types and component annotations\n            if (targetResource[\"@id\"] in byId) {\n              byId[targetResource[\"@id\"]][\"annotations\"].push(a);\n            } else {\n              byId[targetResource[\"@id\"]] = {\n                \"type\": targetResource[\"@type\"],\n                \"annotations\": [a]\n              };\n            } // lookup target type to get target ID\n\n\n            if (targetResource[\"@type\"] in byType) {\n              byType[targetResource[\"@type\"]].push({\n                [targetResource[\"@id\"]]: true\n              });\n            } else {\n              byType[targetResource[\"@type\"]] = [{\n                [targetResource[\"@id\"]]: true\n              }];\n            }\n          });\n        });\n      } else {\n        console.log(\"Graph contains no annotations: \", payload);\n      }\n\n      return update(state, {\n        annoGraph: {\n          $set: payload\n        },\n        targetsById: {\n          $set: byId\n        },\n        targetsByType: {\n          $set: byType\n        }\n      });\n\n    case SESSION_GRAPH_ETAG:\n      return update(state, {\n        etags: {\n          $set: {\n            [action.payload.uri]: action.payload.etag\n          }\n        }\n      });\n\n    case QUEUE_NEXT_SESSION:\n      // console.log(\"Setting next session: \", action.payload);\n      return update(state, {\n        nextSession: {\n          $set: action.payload\n        }\n      });\n\n    case FETCH_WORK:\n      if (action.payload.info) {\n        return update(state, {\n          info: {\n            $merge: {\n              [action.payload.target[\"@id\"]]: action.payload.info\n            }\n          }\n        });\n      }\n\n      break;\n\n    case SET_TRAVERSAL_OBJECTIVES:\n      // register the set of objectives provided by the MELD application\n      // and initialise the outcomes in a corresponding array.\n      // Typically run once on mount.\n      return update(state, {\n        objectives: {\n          $set: action.payload\n        },\n        outcomes: {\n          $set: new Array(action.payload.length)\n        }\n      });\n\n    case FETCH_GRAPH_DOCUMENT:\n      // new graph fragment has arrived. If we don't have it from a previous traversal, add it to our graph.\n      if (!state.graphDocs.includes(action.payload.uri)) {\n        // console.log(state.graph, state.graphDocs, action)\n        return update(state, {\n          graph: {\n            $push: action.payload.data\n          },\n          graphDocs: {\n            $push: [action.payload.uri]\n          }\n        });\n      } else {//console.log(\"FETCH_GRAPH_DOCUMENT: ignoring as already seen: \", action.payload.uri);\n      }\n\n      break;\n\n    case APPLY_TRAVERSAL_OBJECTIVE:\n      // an objective has been applied against the graph. Store the outcome at the\n      // appropriate index.\n      let updatedOutcomes = state.outcomes;\n      updatedOutcomes[action.payload.ix] = action.payload.framed;\n      let updatedOutcomesHash = JSum.digest(updatedOutcomes, 'md5', 'hex');\n\n      if (action.payload.ix === state.objectives.length - 1) {\n        console.log(\"About to switch on allObjectivesApplied with\", updatedOutcomes, state);\n      }\n\n      return update(state, {\n        outcomes: {\n          $set: updatedOutcomes\n        },\n        outcomesHash: {\n          $set: updatedOutcomesHash\n        },\n        allObjectivesApplied: {\n          $set: action.payload.ix === state.objectives.length - 1 ? true : false\n        }\n      });\n\n    default:\n      return state;\n  }\n}"]},"metadata":{},"sourceType":"module"}