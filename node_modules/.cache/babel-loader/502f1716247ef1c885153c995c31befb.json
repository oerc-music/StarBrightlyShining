{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RdfaParser = void 0;\n\nconst htmlparser2_1 = require(\"htmlparser2\");\n\nconst stream_1 = require(\"stream\");\n\nconst INITIAL_CONTEXT_XHTML = require(\"./initial-context-xhtml.json\");\n\nconst INITIAL_CONTEXT = require(\"./initial-context.json\");\n\nconst RdfaProfile_1 = require(\"./RdfaProfile\");\n\nconst Util_1 = require(\"./Util\");\n/**\n * A stream transformer that parses RDFa (text) streams to an {@link RDF.Stream}.\n */\n\n\nclass RdfaParser extends stream_1.Transform {\n  constructor(options) {\n    super({\n      readableObjectMode: true\n    });\n    this.activeTagStack = [];\n    options = options || {};\n    this.options = options;\n    this.util = new Util_1.Util(options.dataFactory, options.baseIRI);\n    this.defaultGraph = options.defaultGraph || this.util.dataFactory.defaultGraph();\n    const profile = options.contentType ? Util_1.Util.contentTypeToProfile(options.contentType) : options.profile || '';\n    this.features = options.features || RdfaProfile_1.RDFA_FEATURES[profile];\n    this.htmlParseListener = options.htmlParseListener;\n    this.rdfaPatterns = this.features.copyRdfaPatterns ? {} : null;\n    this.pendingRdfaPatternCopies = this.features.copyRdfaPatterns ? {} : null;\n    this.parser = this.initializeParser(profile === 'xml');\n    this.activeTagStack.push({\n      incompleteTriples: [],\n      inlist: false,\n      language: options.language,\n      listMapping: {},\n      listMappingLocal: {},\n      name: '',\n      prefixesAll: Object.assign(Object.assign({}, INITIAL_CONTEXT['@context']), this.features.xhtmlInitialContext ? INITIAL_CONTEXT_XHTML['@context'] : {}),\n      prefixesCustom: {},\n      skipElement: false,\n      vocab: options.vocab\n    });\n  }\n  /**\n   * Parses the given text stream into a quad stream.\n   * @param {NodeJS.EventEmitter} stream A text stream.\n   * @return {RDF.Stream} A quad stream.\n   */\n\n\n  import(stream) {\n    const output = new stream_1.PassThrough({\n      readableObjectMode: true\n    });\n    stream.on('error', error => parsed.emit('error', error));\n    stream.on('data', data => output.push(data));\n    stream.on('end', () => output.push(null));\n    const parsed = output.pipe(new RdfaParser(this.options));\n    return parsed;\n  }\n\n  _transform(chunk, encoding, callback) {\n    this.parser.write(chunk);\n    callback();\n  }\n\n  _flush(callback) {\n    this.parser.end();\n    callback();\n  }\n\n  onTagOpen(name, attributes) {\n    // Determine the parent tag (ignore skipped tags)\n    let parentTagI = this.activeTagStack.length - 1;\n\n    while (parentTagI > 0 && this.activeTagStack[parentTagI].skipElement) {\n      parentTagI--;\n    }\n\n    let parentTag = this.activeTagStack[parentTagI]; // If we skipped a tag, make sure we DO use the lang, prefixes and vocab of the skipped tag\n\n    if (parentTagI !== this.activeTagStack.length - 1) {\n      parentTag = Object.assign(Object.assign({}, parentTag), {\n        language: this.activeTagStack[this.activeTagStack.length - 1].language,\n        prefixesAll: this.activeTagStack[this.activeTagStack.length - 1].prefixesAll,\n        prefixesCustom: this.activeTagStack[this.activeTagStack.length - 1].prefixesCustom,\n        vocab: this.activeTagStack[this.activeTagStack.length - 1].vocab\n      });\n    } // Create a new active tag and inherit language scope and baseIRI from parent\n\n\n    const activeTag = {\n      collectChildTags: parentTag.collectChildTags,\n      incompleteTriples: [],\n      inlist: 'inlist' in attributes,\n      listMapping: [],\n      listMappingLocal: parentTag.listMapping,\n      localBaseIRI: parentTag.localBaseIRI,\n      name,\n      prefixesAll: null,\n      prefixesCustom: null,\n      skipElement: false\n    };\n    this.activeTagStack.push(activeTag); // Save the tag contents if needed\n\n    if (activeTag.collectChildTags) {\n      // Add explicitly defined xmlns, xmlns:* and prefixes to attributes, as required by the spec (Step 11, note)\n      // Sort prefixes alphabetically for deterministic namespace declaration order\n      for (const prefix of Object.keys(parentTag.prefixesCustom).sort()) {\n        const suffix = parentTag.prefixesCustom[prefix];\n        const attributeKey = prefix === '' ? 'xmlns' : 'xmlns:' + prefix;\n\n        if (!(attributeKey in attributes)) {\n          attributes[attributeKey] = suffix;\n        }\n      }\n\n      const attributesSerialized = Object.keys(attributes).map(key => `${key}=\"${attributes[key]}\"`).join(' ');\n      activeTag.text = [`<${name}${attributesSerialized ? ' ' + attributesSerialized : ''}>`];\n\n      if (this.features.skipHandlingXmlLiteralChildren) {\n        return;\n      }\n    }\n\n    let allowTermsInRelPredicates = true;\n    let allowTermsInRevPredicates = true;\n\n    if (this.features.onlyAllowUriRelRevIfProperty) {\n      // Ignore illegal rel/rev values when property is present\n      if ('property' in attributes && 'rel' in attributes) {\n        allowTermsInRelPredicates = false;\n\n        if (attributes.rel.indexOf(':') < 0) {\n          delete attributes.rel;\n        }\n      }\n\n      if ('property' in attributes && 'rev' in attributes) {\n        allowTermsInRevPredicates = false;\n\n        if (attributes.rev.indexOf(':') < 0) {\n          delete attributes.rev;\n        }\n      }\n    }\n\n    if (this.features.copyRdfaPatterns) {\n      // Save the tag if needed\n      if (parentTag.collectedPatternTag) {\n        const patternTag = {\n          attributes,\n          children: [],\n          name,\n          referenced: false,\n          rootPattern: false,\n          text: []\n        };\n        parentTag.collectedPatternTag.children.push(patternTag);\n        activeTag.collectedPatternTag = patternTag;\n        return;\n      } // Store tags with type rdfa:Pattern as patterns\n\n\n      if (attributes.typeof === 'rdfa:Pattern') {\n        activeTag.collectedPatternTag = {\n          attributes,\n          children: [],\n          name,\n          parentTag,\n          referenced: false,\n          rootPattern: true,\n          text: []\n        };\n        return;\n      } // Instantiate patterns on rdfa:copy\n\n\n      if (attributes.property === 'rdfa:copy') {\n        const copyTargetPatternId = attributes.resource || attributes.href || attributes.src;\n\n        if (this.rdfaPatterns[copyTargetPatternId]) {\n          this.emitPatternCopy(parentTag, this.rdfaPatterns[copyTargetPatternId], copyTargetPatternId);\n        } else {\n          if (!this.pendingRdfaPatternCopies[copyTargetPatternId]) {\n            this.pendingRdfaPatternCopies[copyTargetPatternId] = [];\n          }\n\n          this.pendingRdfaPatternCopies[copyTargetPatternId].push(parentTag);\n        }\n\n        return;\n      }\n    } // <base> tags override the baseIRI of the whole document\n\n\n    if (this.features.baseTag && name === 'base' && attributes.href) {\n      this.util.baseIRI = this.util.getBaseIRI(attributes.href);\n    } // xml:base attributes override the baseIRI of the current tag and children\n\n\n    if (this.features.xmlBase && attributes['xml:base']) {\n      activeTag.localBaseIRI = this.util.getBaseIRI(attributes['xml:base']);\n    } // <time> tags set an initial datatype\n\n\n    if (this.features.timeTag && name === 'time' && !attributes.datatype) {\n      activeTag.interpretObjectAsTime = true;\n    } // Processing based on https://www.w3.org/TR/rdfa-core/#s_rdfaindetail\n    // 1: initialize values\n\n\n    let newSubject;\n    let currentObjectResource;\n    let typedResource; // 2: handle vocab attribute to set active vocabulary\n    // Vocab sets the active vocabulary\n\n    if ('vocab' in attributes) {\n      if (attributes.vocab) {\n        activeTag.vocab = attributes.vocab;\n        this.emitTriple(this.util.getBaseIriTerm(activeTag), this.util.dataFactory.namedNode(Util_1.Util.RDFA + 'usesVocabulary'), this.util.dataFactory.namedNode(activeTag.vocab));\n      } else {\n        // If vocab is set to '', then we fallback to the root vocab as defined via the parser constructor\n        activeTag.vocab = this.activeTagStack[0].vocab;\n      }\n    } else {\n      activeTag.vocab = parentTag.vocab;\n    } // 3: handle prefixes\n\n\n    activeTag.prefixesCustom = Util_1.Util.parsePrefixes(attributes, parentTag.prefixesCustom, this.features.xmlnsPrefixMappings);\n    activeTag.prefixesAll = Object.keys(activeTag.prefixesCustom).length > 0 ? Object.assign(Object.assign({}, parentTag.prefixesAll), activeTag.prefixesCustom) : parentTag.prefixesAll; // Handle role attribute\n\n    if (this.features.roleAttribute && attributes.role) {\n      const roleSubject = attributes.id ? this.util.createIri('#' + attributes.id, activeTag, false, false, false) : this.util.createBlankNode(); // Temporarily override vocab\n\n      const vocabOld = activeTag.vocab;\n      activeTag.vocab = 'http://www.w3.org/1999/xhtml/vocab#';\n\n      for (const role of this.util.createVocabIris(attributes.role, activeTag, true, false)) {\n        this.emitTriple(roleSubject, this.util.dataFactory.namedNode('http://www.w3.org/1999/xhtml/vocab#role'), role);\n      }\n\n      activeTag.vocab = vocabOld;\n    } // 4: handle language\n    // Save language attribute value in active tag\n\n\n    if ('xml:lang' in attributes || this.features.langAttribute && 'lang' in attributes) {\n      activeTag.language = attributes['xml:lang'] || attributes.lang;\n    } else {\n      activeTag.language = parentTag.language;\n    }\n\n    const isRootTag = this.activeTagStack.length === 2;\n\n    if (!('rel' in attributes) && !('rev' in attributes)) {\n      // 5: Determine the new subject when rel and rev are not present\n      if ('property' in attributes && !('content' in attributes) && !('datatype' in attributes)) {\n        // 5.1: property is present, but not content and datatype\n        // Determine new subject\n        if ('about' in attributes) {\n          newSubject = this.util.createIri(attributes.about, activeTag, false, true, true);\n          activeTag.explicitNewSubject = !!newSubject;\n        } else if (isRootTag) {\n          newSubject = true;\n        } else if (parentTag.object) {\n          newSubject = parentTag.object;\n        } // Determine type\n\n\n        if ('typeof' in attributes) {\n          if ('about' in attributes) {\n            typedResource = this.util.createIri(attributes.about, activeTag, false, true, true);\n          }\n\n          if (!typedResource && isRootTag) {\n            typedResource = true;\n          }\n\n          if (!typedResource && 'resource' in attributes) {\n            typedResource = this.util.createIri(attributes.resource, activeTag, false, true, true);\n          }\n\n          if (!typedResource && ('href' in attributes || 'src' in attributes)) {\n            typedResource = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);\n          }\n\n          if (!typedResource && this.isInheritSubjectInHeadBody(name)) {\n            typedResource = newSubject;\n          }\n\n          if (!typedResource) {\n            typedResource = this.util.createBlankNode();\n          }\n\n          currentObjectResource = typedResource;\n        }\n      } else {\n        // 5.2\n        if ('about' in attributes || 'resource' in attributes) {\n          newSubject = this.util.createIri(attributes.about || attributes.resource, activeTag, false, true, true);\n          activeTag.explicitNewSubject = !!newSubject;\n        }\n\n        if (!newSubject && ('href' in attributes || 'src' in attributes)) {\n          newSubject = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);\n          activeTag.explicitNewSubject = !!newSubject;\n        }\n\n        if (!newSubject) {\n          if (isRootTag) {\n            newSubject = true;\n          } else if (this.isInheritSubjectInHeadBody(name)) {\n            newSubject = parentTag.object;\n          } else if ('typeof' in attributes) {\n            newSubject = this.util.createBlankNode();\n            activeTag.explicitNewSubject = true;\n          } else if (parentTag.object) {\n            newSubject = parentTag.object;\n\n            if (!('property' in attributes)) {\n              activeTag.skipElement = true;\n            }\n          }\n        } // Determine type\n\n\n        if ('typeof' in attributes) {\n          typedResource = newSubject;\n        }\n      }\n    } else {\n      // either rel or rev is present\n      // 6: Determine the new subject when rel or rev are present\n      // Define new subject\n      if ('about' in attributes) {\n        newSubject = this.util.createIri(attributes.about, activeTag, false, true, true);\n        activeTag.explicitNewSubject = !!newSubject;\n\n        if ('typeof' in attributes) {\n          typedResource = newSubject;\n        }\n      } else if (isRootTag) {\n        newSubject = true;\n      } else if (parentTag.object) {\n        newSubject = parentTag.object;\n      } // Define object\n\n\n      if ('resource' in attributes) {\n        currentObjectResource = this.util.createIri(attributes.resource, activeTag, false, true, true);\n      }\n\n      if (!currentObjectResource) {\n        if ('href' in attributes || 'src' in attributes) {\n          currentObjectResource = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);\n        } else if ('typeof' in attributes && !('about' in attributes) && !this.isInheritSubjectInHeadBody(name)) {\n          currentObjectResource = this.util.createBlankNode();\n        }\n      } // Set typed resource\n\n\n      if ('typeof' in attributes && !('about' in attributes)) {\n        if (this.isInheritSubjectInHeadBody(name)) {\n          typedResource = newSubject;\n        } else {\n          typedResource = currentObjectResource;\n        }\n      }\n    } // 7: If a typed resource was defined, emit it as a triple\n\n\n    if (typedResource) {\n      for (const type of this.util.createVocabIris(attributes.typeof, activeTag, true, true)) {\n        this.emitTriple(this.util.getResourceOrBaseIri(typedResource, activeTag), this.util.dataFactory.namedNode(Util_1.Util.RDF + 'type'), type);\n      }\n    } // 8: Reset list mapping if we have a new subject\n\n\n    if (newSubject) {\n      activeTag.listMapping = {};\n    } // 9: If an object was defined, emit triples for it\n\n\n    if (currentObjectResource) {\n      // Handle list mapping\n      if ('rel' in attributes && 'inlist' in attributes) {\n        for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)) {\n          this.addListMapping(activeTag, newSubject, predicate, currentObjectResource);\n        }\n      } // Determine predicates using rel or rev (unless rel and inlist are present)\n\n\n      if (!('rel' in attributes && 'inlist' in attributes)) {\n        if ('rel' in attributes) {\n          for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)) {\n            this.emitTriple(this.util.getResourceOrBaseIri(newSubject, activeTag), predicate, this.util.getResourceOrBaseIri(currentObjectResource, activeTag));\n          }\n        }\n\n        if ('rev' in attributes) {\n          for (const predicate of this.util.createVocabIris(attributes.rev, activeTag, allowTermsInRevPredicates, false)) {\n            this.emitTriple(this.util.getResourceOrBaseIri(currentObjectResource, activeTag), predicate, this.util.getResourceOrBaseIri(newSubject, activeTag));\n          }\n        }\n      }\n    } // 10: Store incomplete triples if we don't have an object, but we do have predicates\n\n\n    if (!currentObjectResource) {\n      if ('rel' in attributes) {\n        if ('inlist' in attributes) {\n          for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)) {\n            this.addListMapping(activeTag, newSubject, predicate, null);\n            activeTag.incompleteTriples.push({\n              predicate,\n              reverse: false,\n              list: true\n            });\n          }\n        } else {\n          for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)) {\n            activeTag.incompleteTriples.push({\n              predicate,\n              reverse: false\n            });\n          }\n        }\n      }\n\n      if ('rev' in attributes) {\n        for (const predicate of this.util.createVocabIris(attributes.rev, activeTag, allowTermsInRevPredicates, false)) {\n          activeTag.incompleteTriples.push({\n            predicate,\n            reverse: true\n          });\n        }\n      } // Set a blank node object, so the children can make use of this when completing the triples\n\n\n      if (activeTag.incompleteTriples.length > 0) {\n        currentObjectResource = this.util.createBlankNode();\n      }\n    } // 11: Determine current property value\n\n\n    if ('property' in attributes) {\n      // Create predicates\n      activeTag.predicates = this.util.createVocabIris(attributes.property, activeTag, true, false); // Save datatype attribute value in active tag\n\n      let localObjectResource;\n\n      if ('datatype' in attributes) {\n        activeTag.datatype = this.util.createIri(attributes.datatype, activeTag, true, true, false);\n\n        if (activeTag.datatype && (activeTag.datatype.value === Util_1.Util.RDF + 'XMLLiteral' || this.features.htmlDatatype && activeTag.datatype.value === Util_1.Util.RDF + 'HTML')) {\n          activeTag.collectChildTags = true;\n        }\n      } else {\n        // Try to determine resource\n        if (!('rev' in attributes) && !('rel' in attributes) && !('content' in attributes)) {\n          if ('resource' in attributes) {\n            localObjectResource = this.util.createIri(attributes.resource, activeTag, false, true, true);\n          }\n\n          if (!localObjectResource && 'href' in attributes) {\n            localObjectResource = this.util.createIri(attributes.href, activeTag, false, false, true);\n          }\n\n          if (!localObjectResource && 'src' in attributes) {\n            localObjectResource = this.util.createIri(attributes.src, activeTag, false, false, true);\n          }\n        }\n\n        if ('typeof' in attributes && !('about' in attributes)) {\n          localObjectResource = typedResource;\n        }\n      }\n\n      if ('content' in attributes) {\n        // Emit triples based on content attribute has preference over text content\n        const object = this.util.createLiteral(attributes.content, activeTag);\n\n        if ('inlist' in attributes) {\n          for (const predicate of activeTag.predicates) {\n            this.addListMapping(activeTag, newSubject, predicate, object);\n          }\n        } else {\n          const subject = this.util.getResourceOrBaseIri(newSubject, activeTag);\n\n          for (const predicate of activeTag.predicates) {\n            this.emitTriple(subject, predicate, object);\n          }\n        } // Unset predicate to avoid text contents to produce new triples\n\n\n        activeTag.predicates = null;\n      } else if (this.features.datetimeAttribute && 'datetime' in attributes) {\n        activeTag.interpretObjectAsTime = true; // Datetime attribute on time tag has preference over text content\n\n        const object = this.util.createLiteral(attributes.datetime, activeTag);\n\n        if ('inlist' in attributes) {\n          for (const predicate of activeTag.predicates) {\n            this.addListMapping(activeTag, newSubject, predicate, object);\n          }\n        } else {\n          const subject = this.util.getResourceOrBaseIri(newSubject, activeTag);\n\n          for (const predicate of activeTag.predicates) {\n            this.emitTriple(subject, predicate, object);\n          }\n        } // Unset predicate to avoid text contents to produce new triples\n\n\n        activeTag.predicates = null;\n      } else if (localObjectResource) {\n        // Emit triples for all resource objects\n        const object = this.util.getResourceOrBaseIri(localObjectResource, activeTag);\n\n        if ('inlist' in attributes) {\n          for (const predicate of activeTag.predicates) {\n            this.addListMapping(activeTag, newSubject, predicate, object);\n          }\n        } else {\n          const subject = this.util.getResourceOrBaseIri(newSubject, activeTag);\n\n          for (const predicate of activeTag.predicates) {\n            this.emitTriple(subject, predicate, object);\n          }\n        } // Unset predicate to avoid text contents to produce new triples\n\n\n        activeTag.predicates = null;\n      }\n    } // 12: Complete incomplete triples\n\n\n    let incompleteTriplesCompleted = false;\n\n    if (!activeTag.skipElement && newSubject && parentTag.incompleteTriples.length > 0) {\n      incompleteTriplesCompleted = true;\n      const subject = this.util.getResourceOrBaseIri(parentTag.subject, activeTag);\n      const object = this.util.getResourceOrBaseIri(newSubject, activeTag);\n\n      for (const incompleteTriple of parentTag.incompleteTriples) {\n        if (!incompleteTriple.reverse) {\n          if (incompleteTriple.list) {\n            // Find the active tag that defined the list by going up the stack\n            let firstInListTag = null;\n\n            for (let i = this.activeTagStack.length - 1; i >= 0; i--) {\n              if (this.activeTagStack[i].inlist) {\n                firstInListTag = this.activeTagStack[i];\n                break;\n              }\n            } // firstInListTag is guaranteed to be non-null\n\n\n            this.addListMapping(firstInListTag, newSubject, incompleteTriple.predicate, object);\n          } else {\n            this.emitTriple(subject, incompleteTriple.predicate, object);\n          }\n        } else {\n          this.emitTriple(object, incompleteTriple.predicate, subject);\n        }\n      }\n    }\n\n    if (!incompleteTriplesCompleted && parentTag.incompleteTriples.length > 0) {\n      activeTag.incompleteTriples = activeTag.incompleteTriples.concat(parentTag.incompleteTriples);\n    } // 13: Save evaluation context into active tag\n\n\n    activeTag.subject = newSubject || parentTag.subject;\n    activeTag.object = currentObjectResource || newSubject;\n  }\n\n  onText(data) {\n    const activeTag = this.activeTagStack[this.activeTagStack.length - 1]; // Collect text in pattern tag if needed\n\n    if (this.features.copyRdfaPatterns && activeTag.collectedPatternTag) {\n      activeTag.collectedPatternTag.text.push(data);\n      return;\n    } // Save the text inside the active tag\n\n\n    if (!activeTag.text) {\n      activeTag.text = [];\n    }\n\n    activeTag.text.push(data);\n  }\n\n  onTagClose() {\n    // Get the active tag\n    const activeTag = this.activeTagStack[this.activeTagStack.length - 1];\n    const parentTag = this.activeTagStack[this.activeTagStack.length - 2];\n\n    if (!(activeTag.collectChildTags && parentTag.collectChildTags && this.features.skipHandlingXmlLiteralChildren)) {\n      // If we detect a finalized rdfa:Pattern tag, store it\n      if (this.features.copyRdfaPatterns && activeTag.collectedPatternTag && activeTag.collectedPatternTag.rootPattern) {\n        const patternId = activeTag.collectedPatternTag.attributes.resource; // Remove resource and typeof attributes to avoid it being seen as a new pattern\n\n        delete activeTag.collectedPatternTag.attributes.resource;\n        delete activeTag.collectedPatternTag.attributes.typeof; // Store the pattern\n\n        this.rdfaPatterns[patternId] = activeTag.collectedPatternTag; // Apply all pending copies for this pattern\n\n        if (this.pendingRdfaPatternCopies[patternId]) {\n          for (const tag of this.pendingRdfaPatternCopies[patternId]) {\n            this.emitPatternCopy(tag, activeTag.collectedPatternTag, patternId);\n          }\n\n          delete this.pendingRdfaPatternCopies[patternId];\n        } // Remove the active tag from the stack\n\n\n        this.activeTagStack.pop();\n        return;\n      } // Emit all triples that were determined in the active tag\n\n\n      if (activeTag.predicates) {\n        const subject = this.util.getResourceOrBaseIri(activeTag.subject, activeTag);\n        let textSegments = activeTag.text || [];\n\n        if (activeTag.collectChildTags && parentTag.collectChildTags) {\n          // If we are inside an XMLLiteral child that also has RDFa content, ignore the tag name that was collected.\n          textSegments = textSegments.slice(1);\n        }\n\n        const object = this.util.createLiteral(textSegments.join(''), activeTag);\n\n        if (activeTag.inlist) {\n          for (const predicate of activeTag.predicates) {\n            this.addListMapping(activeTag, subject, predicate, object);\n          }\n        } else {\n          for (const predicate of activeTag.predicates) {\n            this.emitTriple(subject, predicate, object);\n          }\n        } // Reset text, unless the parent is also collecting text\n\n\n        if (!parentTag.predicates) {\n          activeTag.text = null;\n        }\n      } // 14: Handle local list mapping\n\n\n      if (activeTag.object && Object.keys(activeTag.listMapping).length > 0) {\n        const subject = this.util.getResourceOrBaseIri(activeTag.object, activeTag);\n\n        for (const predicateValue in activeTag.listMapping) {\n          const predicate = this.util.dataFactory.namedNode(predicateValue);\n          const values = activeTag.listMapping[predicateValue];\n\n          if (values.length > 0) {\n            // Non-empty list, emit linked list of rdf:first and rdf:rest chains\n            const bnodes = values.map(() => this.util.createBlankNode());\n\n            for (let i = 0; i < values.length; i++) {\n              const object = this.util.getResourceOrBaseIri(values[i], activeTag);\n              this.emitTriple(bnodes[i], this.util.dataFactory.namedNode(Util_1.Util.RDF + 'first'), object);\n              this.emitTriple(bnodes[i], this.util.dataFactory.namedNode(Util_1.Util.RDF + 'rest'), i < values.length - 1 ? bnodes[i + 1] : this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));\n            } // Emit triple for the first linked list chain\n\n\n            this.emitTriple(subject, predicate, bnodes[0]);\n          } else {\n            // Empty list, just emit rdf:nil\n            this.emitTriple(subject, predicate, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));\n          }\n        }\n      }\n    } // Remove the active tag from the stack\n\n\n    this.activeTagStack.pop(); // Save the tag contents if needed\n\n    if (activeTag.collectChildTags && activeTag.text) {\n      activeTag.text.push(`</${activeTag.name}>`);\n    } // If we still have text contents, try to append it to the parent tag\n\n\n    if (activeTag.text && parentTag) {\n      if (!parentTag.text) {\n        parentTag.text = activeTag.text;\n      } else {\n        parentTag.text = parentTag.text.concat(activeTag.text);\n      }\n    }\n  }\n\n  onEnd() {\n    if (this.features.copyRdfaPatterns) {\n      this.features.copyRdfaPatterns = false; // Emit all unreferenced patterns\n\n      for (const patternId in this.rdfaPatterns) {\n        const pattern = this.rdfaPatterns[patternId];\n\n        if (!pattern.referenced) {\n          pattern.attributes.typeof = 'rdfa:Pattern';\n          pattern.attributes.resource = patternId;\n          this.emitPatternCopy(pattern.parentTag, pattern, patternId);\n          pattern.referenced = false;\n          delete pattern.attributes.typeof;\n          delete pattern.attributes.resource;\n        }\n      } // Emit all unreferenced copy links\n\n\n      for (const patternId in this.pendingRdfaPatternCopies) {\n        for (const parentTag of this.pendingRdfaPatternCopies[patternId]) {\n          this.activeTagStack.push(parentTag);\n          this.onTagOpen('link', {\n            property: 'rdfa:copy',\n            href: patternId\n          });\n          this.onTagClose();\n          this.activeTagStack.pop();\n        }\n      }\n\n      this.features.copyRdfaPatterns = true;\n    }\n  }\n  /**\n   * If the new subject can be inherited from the parent object\n   * if the resource defines no new subject.\n   * @param {string} name The current tag name.\n   * @returns {boolean} If the subject can be inherited.\n   */\n\n\n  isInheritSubjectInHeadBody(name) {\n    return this.features.inheritSubjectInHeadBody && (name === 'head' || name === 'body');\n  }\n  /**\n   * Add a list mapping for the given predicate and object in the active tag.\n   * @param {IActiveTag} activeTag The active tag.\n   * @param {Term | boolean} subject A subject term, this will only be used to create a separate list\n   *                                 if activeTag.explicitNewSubject is true.\n   * @param {Term} predicate A predicate term.\n   * @param {Term | boolean} currentObjectResource The current object resource.\n   */\n\n\n  addListMapping(activeTag, subject, predicate, currentObjectResource) {\n    if (activeTag.explicitNewSubject) {\n      const bNode = this.util.createBlankNode();\n      this.emitTriple(this.util.getResourceOrBaseIri(subject, activeTag), predicate, bNode);\n      this.emitTriple(bNode, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'first'), this.util.getResourceOrBaseIri(currentObjectResource, activeTag));\n      this.emitTriple(bNode, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'rest'), this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));\n    } else {\n      let predicateList = activeTag.listMappingLocal[predicate.value];\n\n      if (!predicateList) {\n        activeTag.listMappingLocal[predicate.value] = predicateList = [];\n      }\n\n      if (currentObjectResource) {\n        predicateList.push(currentObjectResource);\n      }\n    }\n  }\n  /**\n   * Emit the given triple to the stream.\n   * @param {Term} subject A subject term.\n   * @param {Term} predicate A predicate term.\n   * @param {Term} object An object term.\n   */\n\n\n  emitTriple(subject, predicate, object) {\n    // Validate IRIs\n    if (subject.termType === 'NamedNode' && subject.value.indexOf(':') < 0 || predicate.termType === 'NamedNode' && predicate.value.indexOf(':') < 0 || object.termType === 'NamedNode' && object.value.indexOf(':') < 0) {\n      return;\n    }\n\n    this.push(this.util.dataFactory.quad(subject, predicate, object, this.defaultGraph));\n  }\n  /**\n   * Emit an instantiation of the given pattern with the given parent tag.\n   * @param {IActiveTag} parentTag The parent tag to instantiate in.\n   * @param {IRdfaPattern} pattern The pattern to instantiate.\n   * @param {string} rootPatternId The pattern id.\n   */\n\n\n  emitPatternCopy(parentTag, pattern, rootPatternId) {\n    this.activeTagStack.push(parentTag);\n    pattern.referenced = true; // Ensure that blank nodes within patterns are instantiated only once.\n    // All next pattern copies will reuse the instantiated blank nodes from the first pattern.\n\n    if (!pattern.constructedBlankNodes) {\n      pattern.constructedBlankNodes = [];\n\n      this.util.blankNodeFactory = () => {\n        const bNode = this.util.dataFactory.blankNode();\n        pattern.constructedBlankNodes.push(bNode);\n        return bNode;\n      };\n    } else {\n      let blankNodeIndex = 0;\n\n      this.util.blankNodeFactory = () => pattern.constructedBlankNodes[blankNodeIndex++];\n    } // Apply everything within the pattern\n\n\n    this.emitPatternCopyAbsolute(pattern, true, rootPatternId);\n    this.util.blankNodeFactory = null;\n    this.activeTagStack.pop();\n  }\n  /**\n   * Emit an instantiation of the given pattern with the given parent tag.\n   *\n   * This should probably not be called directly,\n   * call {@link emitPatternCopy} instead.\n   *\n   * @param {IRdfaPattern} pattern The pattern to instantiate.\n   * @param {boolean} root If this is the root call for the given pattern.\n   * @param {string} rootPatternId The pattern id.\n   */\n\n\n  emitPatternCopyAbsolute(pattern, root, rootPatternId) {\n    // Stop on detection of cyclic patterns\n    if (!root && pattern.attributes.property === 'rdfa:copy' && pattern.attributes.href === rootPatternId) {\n      return;\n    }\n\n    this.onTagOpen(pattern.name, pattern.attributes);\n\n    for (const text of pattern.text) {\n      this.onText(text);\n    }\n\n    for (const child of pattern.children) {\n      this.emitPatternCopyAbsolute(child, false, rootPatternId);\n    }\n\n    this.onTagClose();\n  }\n\n  initializeParser(xmlMode) {\n    return new htmlparser2_1.Parser({\n      onclosetag: () => {\n        try {\n          this.onTagClose();\n\n          if (this.htmlParseListener) {\n            this.htmlParseListener.onTagClose();\n          }\n        } catch (e) {\n          this.emit('error', e);\n        }\n      },\n      onend: () => {\n        try {\n          this.onEnd();\n\n          if (this.htmlParseListener) {\n            this.htmlParseListener.onEnd();\n          }\n        } catch (e) {\n          this.emit('error', e);\n        }\n      },\n      onopentag: (name, attributes) => {\n        try {\n          this.onTagOpen(name, attributes);\n\n          if (this.htmlParseListener) {\n            this.htmlParseListener.onTagOpen(name, attributes);\n          }\n        } catch (e) {\n          this.emit('error', e);\n        }\n      },\n      ontext: data => {\n        try {\n          this.onText(data);\n\n          if (this.htmlParseListener) {\n            this.htmlParseListener.onText(data);\n          }\n        } catch (e) {\n          this.emit('error', e);\n        }\n      }\n    }, {\n      decodeEntities: true,\n      recognizeSelfClosing: true,\n      xmlMode\n    });\n  }\n\n}\n\nexports.RdfaParser = RdfaParser;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/rdfa-streaming-parser/lib/RdfaParser.js"],"names":["Object","defineProperty","exports","value","RdfaParser","htmlparser2_1","require","stream_1","INITIAL_CONTEXT_XHTML","INITIAL_CONTEXT","RdfaProfile_1","Util_1","Transform","constructor","options","readableObjectMode","activeTagStack","util","Util","dataFactory","baseIRI","defaultGraph","profile","contentType","contentTypeToProfile","features","RDFA_FEATURES","htmlParseListener","rdfaPatterns","copyRdfaPatterns","pendingRdfaPatternCopies","parser","initializeParser","push","incompleteTriples","inlist","language","listMapping","listMappingLocal","name","prefixesAll","assign","xhtmlInitialContext","prefixesCustom","skipElement","vocab","import","stream","output","PassThrough","on","error","parsed","emit","data","pipe","_transform","chunk","encoding","callback","write","_flush","end","onTagOpen","attributes","parentTagI","length","parentTag","activeTag","collectChildTags","localBaseIRI","prefix","keys","sort","suffix","attributeKey","attributesSerialized","map","key","join","text","skipHandlingXmlLiteralChildren","allowTermsInRelPredicates","allowTermsInRevPredicates","onlyAllowUriRelRevIfProperty","rel","indexOf","rev","collectedPatternTag","patternTag","children","referenced","rootPattern","typeof","property","copyTargetPatternId","resource","href","src","emitPatternCopy","baseTag","getBaseIRI","xmlBase","timeTag","datatype","interpretObjectAsTime","newSubject","currentObjectResource","typedResource","emitTriple","getBaseIriTerm","namedNode","RDFA","parsePrefixes","xmlnsPrefixMappings","roleAttribute","role","roleSubject","id","createIri","createBlankNode","vocabOld","createVocabIris","langAttribute","lang","isRootTag","about","explicitNewSubject","object","isInheritSubjectInHeadBody","type","getResourceOrBaseIri","RDF","predicate","addListMapping","reverse","list","predicates","localObjectResource","htmlDatatype","createLiteral","content","subject","datetimeAttribute","datetime","incompleteTriplesCompleted","incompleteTriple","firstInListTag","i","concat","onText","onTagClose","patternId","tag","pop","textSegments","slice","predicateValue","values","bnodes","onEnd","pattern","inheritSubjectInHeadBody","bNode","predicateList","termType","quad","rootPatternId","constructedBlankNodes","blankNodeFactory","blankNode","blankNodeIndex","emitPatternCopyAbsolute","root","child","xmlMode","Parser","onclosetag","e","onend","onopentag","ontext","decodeEntities","recognizeSelfClosing"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RdfaParser = void 0;\nconst htmlparser2_1 = require(\"htmlparser2\");\nconst stream_1 = require(\"stream\");\nconst INITIAL_CONTEXT_XHTML = require(\"./initial-context-xhtml.json\");\nconst INITIAL_CONTEXT = require(\"./initial-context.json\");\nconst RdfaProfile_1 = require(\"./RdfaProfile\");\nconst Util_1 = require(\"./Util\");\n/**\n * A stream transformer that parses RDFa (text) streams to an {@link RDF.Stream}.\n */\nclass RdfaParser extends stream_1.Transform {\n    constructor(options) {\n        super({ readableObjectMode: true });\n        this.activeTagStack = [];\n        options = options || {};\n        this.options = options;\n        this.util = new Util_1.Util(options.dataFactory, options.baseIRI);\n        this.defaultGraph = options.defaultGraph || this.util.dataFactory.defaultGraph();\n        const profile = options.contentType ? Util_1.Util.contentTypeToProfile(options.contentType) : options.profile || '';\n        this.features = options.features || RdfaProfile_1.RDFA_FEATURES[profile];\n        this.htmlParseListener = options.htmlParseListener;\n        this.rdfaPatterns = this.features.copyRdfaPatterns ? {} : null;\n        this.pendingRdfaPatternCopies = this.features.copyRdfaPatterns ? {} : null;\n        this.parser = this.initializeParser(profile === 'xml');\n        this.activeTagStack.push({\n            incompleteTriples: [],\n            inlist: false,\n            language: options.language,\n            listMapping: {},\n            listMappingLocal: {},\n            name: '',\n            prefixesAll: Object.assign(Object.assign({}, INITIAL_CONTEXT['@context']), this.features.xhtmlInitialContext ? INITIAL_CONTEXT_XHTML['@context'] : {}),\n            prefixesCustom: {},\n            skipElement: false,\n            vocab: options.vocab,\n        });\n    }\n    /**\n     * Parses the given text stream into a quad stream.\n     * @param {NodeJS.EventEmitter} stream A text stream.\n     * @return {RDF.Stream} A quad stream.\n     */\n    import(stream) {\n        const output = new stream_1.PassThrough({ readableObjectMode: true });\n        stream.on('error', (error) => parsed.emit('error', error));\n        stream.on('data', (data) => output.push(data));\n        stream.on('end', () => output.push(null));\n        const parsed = output.pipe(new RdfaParser(this.options));\n        return parsed;\n    }\n    _transform(chunk, encoding, callback) {\n        this.parser.write(chunk);\n        callback();\n    }\n    _flush(callback) {\n        this.parser.end();\n        callback();\n    }\n    onTagOpen(name, attributes) {\n        // Determine the parent tag (ignore skipped tags)\n        let parentTagI = this.activeTagStack.length - 1;\n        while (parentTagI > 0 && this.activeTagStack[parentTagI].skipElement) {\n            parentTagI--;\n        }\n        let parentTag = this.activeTagStack[parentTagI];\n        // If we skipped a tag, make sure we DO use the lang, prefixes and vocab of the skipped tag\n        if (parentTagI !== this.activeTagStack.length - 1) {\n            parentTag = Object.assign(Object.assign({}, parentTag), { language: this.activeTagStack[this.activeTagStack.length - 1].language, prefixesAll: this.activeTagStack[this.activeTagStack.length - 1].prefixesAll, prefixesCustom: this.activeTagStack[this.activeTagStack.length - 1].prefixesCustom, vocab: this.activeTagStack[this.activeTagStack.length - 1].vocab });\n        }\n        // Create a new active tag and inherit language scope and baseIRI from parent\n        const activeTag = {\n            collectChildTags: parentTag.collectChildTags,\n            incompleteTriples: [],\n            inlist: 'inlist' in attributes,\n            listMapping: [],\n            listMappingLocal: parentTag.listMapping,\n            localBaseIRI: parentTag.localBaseIRI,\n            name,\n            prefixesAll: null,\n            prefixesCustom: null,\n            skipElement: false,\n        };\n        this.activeTagStack.push(activeTag);\n        // Save the tag contents if needed\n        if (activeTag.collectChildTags) {\n            // Add explicitly defined xmlns, xmlns:* and prefixes to attributes, as required by the spec (Step 11, note)\n            // Sort prefixes alphabetically for deterministic namespace declaration order\n            for (const prefix of Object.keys(parentTag.prefixesCustom).sort()) {\n                const suffix = parentTag.prefixesCustom[prefix];\n                const attributeKey = prefix === '' ? 'xmlns' : 'xmlns:' + prefix;\n                if (!(attributeKey in attributes)) {\n                    attributes[attributeKey] = suffix;\n                }\n            }\n            const attributesSerialized = Object.keys(attributes).map((key) => `${key}=\"${attributes[key]}\"`).join(' ');\n            activeTag.text = [`<${name}${attributesSerialized ? ' ' + attributesSerialized : ''}>`];\n            if (this.features.skipHandlingXmlLiteralChildren) {\n                return;\n            }\n        }\n        let allowTermsInRelPredicates = true;\n        let allowTermsInRevPredicates = true;\n        if (this.features.onlyAllowUriRelRevIfProperty) {\n            // Ignore illegal rel/rev values when property is present\n            if ('property' in attributes && 'rel' in attributes) {\n                allowTermsInRelPredicates = false;\n                if (attributes.rel.indexOf(':') < 0) {\n                    delete attributes.rel;\n                }\n            }\n            if ('property' in attributes && 'rev' in attributes) {\n                allowTermsInRevPredicates = false;\n                if (attributes.rev.indexOf(':') < 0) {\n                    delete attributes.rev;\n                }\n            }\n        }\n        if (this.features.copyRdfaPatterns) {\n            // Save the tag if needed\n            if (parentTag.collectedPatternTag) {\n                const patternTag = {\n                    attributes,\n                    children: [],\n                    name,\n                    referenced: false,\n                    rootPattern: false,\n                    text: [],\n                };\n                parentTag.collectedPatternTag.children.push(patternTag);\n                activeTag.collectedPatternTag = patternTag;\n                return;\n            }\n            // Store tags with type rdfa:Pattern as patterns\n            if (attributes.typeof === 'rdfa:Pattern') {\n                activeTag.collectedPatternTag = {\n                    attributes,\n                    children: [],\n                    name,\n                    parentTag,\n                    referenced: false,\n                    rootPattern: true,\n                    text: [],\n                };\n                return;\n            }\n            // Instantiate patterns on rdfa:copy\n            if (attributes.property === 'rdfa:copy') {\n                const copyTargetPatternId = attributes.resource || attributes.href || attributes.src;\n                if (this.rdfaPatterns[copyTargetPatternId]) {\n                    this.emitPatternCopy(parentTag, this.rdfaPatterns[copyTargetPatternId], copyTargetPatternId);\n                }\n                else {\n                    if (!this.pendingRdfaPatternCopies[copyTargetPatternId]) {\n                        this.pendingRdfaPatternCopies[copyTargetPatternId] = [];\n                    }\n                    this.pendingRdfaPatternCopies[copyTargetPatternId].push(parentTag);\n                }\n                return;\n            }\n        }\n        // <base> tags override the baseIRI of the whole document\n        if (this.features.baseTag && name === 'base' && attributes.href) {\n            this.util.baseIRI = this.util.getBaseIRI(attributes.href);\n        }\n        // xml:base attributes override the baseIRI of the current tag and children\n        if (this.features.xmlBase && attributes['xml:base']) {\n            activeTag.localBaseIRI = this.util.getBaseIRI(attributes['xml:base']);\n        }\n        // <time> tags set an initial datatype\n        if (this.features.timeTag && name === 'time' && !attributes.datatype) {\n            activeTag.interpretObjectAsTime = true;\n        }\n        // Processing based on https://www.w3.org/TR/rdfa-core/#s_rdfaindetail\n        // 1: initialize values\n        let newSubject;\n        let currentObjectResource;\n        let typedResource;\n        // 2: handle vocab attribute to set active vocabulary\n        // Vocab sets the active vocabulary\n        if ('vocab' in attributes) {\n            if (attributes.vocab) {\n                activeTag.vocab = attributes.vocab;\n                this.emitTriple(this.util.getBaseIriTerm(activeTag), this.util.dataFactory.namedNode(Util_1.Util.RDFA + 'usesVocabulary'), this.util.dataFactory.namedNode(activeTag.vocab));\n            }\n            else {\n                // If vocab is set to '', then we fallback to the root vocab as defined via the parser constructor\n                activeTag.vocab = this.activeTagStack[0].vocab;\n            }\n        }\n        else {\n            activeTag.vocab = parentTag.vocab;\n        }\n        // 3: handle prefixes\n        activeTag.prefixesCustom = Util_1.Util.parsePrefixes(attributes, parentTag.prefixesCustom, this.features.xmlnsPrefixMappings);\n        activeTag.prefixesAll = Object.keys(activeTag.prefixesCustom).length > 0\n            ? Object.assign(Object.assign({}, parentTag.prefixesAll), activeTag.prefixesCustom) : parentTag.prefixesAll;\n        // Handle role attribute\n        if (this.features.roleAttribute && attributes.role) {\n            const roleSubject = attributes.id\n                ? this.util.createIri('#' + attributes.id, activeTag, false, false, false)\n                : this.util.createBlankNode();\n            // Temporarily override vocab\n            const vocabOld = activeTag.vocab;\n            activeTag.vocab = 'http://www.w3.org/1999/xhtml/vocab#';\n            for (const role of this.util.createVocabIris(attributes.role, activeTag, true, false)) {\n                this.emitTriple(roleSubject, this.util.dataFactory.namedNode('http://www.w3.org/1999/xhtml/vocab#role'), role);\n            }\n            activeTag.vocab = vocabOld;\n        }\n        // 4: handle language\n        // Save language attribute value in active tag\n        if ('xml:lang' in attributes || (this.features.langAttribute && 'lang' in attributes)) {\n            activeTag.language = attributes['xml:lang'] || attributes.lang;\n        }\n        else {\n            activeTag.language = parentTag.language;\n        }\n        const isRootTag = this.activeTagStack.length === 2;\n        if (!('rel' in attributes) && !('rev' in attributes)) {\n            // 5: Determine the new subject when rel and rev are not present\n            if ('property' in attributes && !('content' in attributes) && !('datatype' in attributes)) {\n                // 5.1: property is present, but not content and datatype\n                // Determine new subject\n                if ('about' in attributes) {\n                    newSubject = this.util.createIri(attributes.about, activeTag, false, true, true);\n                    activeTag.explicitNewSubject = !!newSubject;\n                }\n                else if (isRootTag) {\n                    newSubject = true;\n                }\n                else if (parentTag.object) {\n                    newSubject = parentTag.object;\n                }\n                // Determine type\n                if ('typeof' in attributes) {\n                    if ('about' in attributes) {\n                        typedResource = this.util.createIri(attributes.about, activeTag, false, true, true);\n                    }\n                    if (!typedResource && isRootTag) {\n                        typedResource = true;\n                    }\n                    if (!typedResource && 'resource' in attributes) {\n                        typedResource = this.util.createIri(attributes.resource, activeTag, false, true, true);\n                    }\n                    if (!typedResource && ('href' in attributes || 'src' in attributes)) {\n                        typedResource = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);\n                    }\n                    if (!typedResource && this.isInheritSubjectInHeadBody(name)) {\n                        typedResource = newSubject;\n                    }\n                    if (!typedResource) {\n                        typedResource = this.util.createBlankNode();\n                    }\n                    currentObjectResource = typedResource;\n                }\n            }\n            else {\n                // 5.2\n                if ('about' in attributes || 'resource' in attributes) {\n                    newSubject = this.util.createIri(attributes.about || attributes.resource, activeTag, false, true, true);\n                    activeTag.explicitNewSubject = !!newSubject;\n                }\n                if (!newSubject && ('href' in attributes || 'src' in attributes)) {\n                    newSubject = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);\n                    activeTag.explicitNewSubject = !!newSubject;\n                }\n                if (!newSubject) {\n                    if (isRootTag) {\n                        newSubject = true;\n                    }\n                    else if (this.isInheritSubjectInHeadBody(name)) {\n                        newSubject = parentTag.object;\n                    }\n                    else if ('typeof' in attributes) {\n                        newSubject = this.util.createBlankNode();\n                        activeTag.explicitNewSubject = true;\n                    }\n                    else if (parentTag.object) {\n                        newSubject = parentTag.object;\n                        if (!('property' in attributes)) {\n                            activeTag.skipElement = true;\n                        }\n                    }\n                }\n                // Determine type\n                if ('typeof' in attributes) {\n                    typedResource = newSubject;\n                }\n            }\n        }\n        else { // either rel or rev is present\n            // 6: Determine the new subject when rel or rev are present\n            // Define new subject\n            if ('about' in attributes) {\n                newSubject = this.util.createIri(attributes.about, activeTag, false, true, true);\n                activeTag.explicitNewSubject = !!newSubject;\n                if ('typeof' in attributes) {\n                    typedResource = newSubject;\n                }\n            }\n            else if (isRootTag) {\n                newSubject = true;\n            }\n            else if (parentTag.object) {\n                newSubject = parentTag.object;\n            }\n            // Define object\n            if ('resource' in attributes) {\n                currentObjectResource = this.util.createIri(attributes.resource, activeTag, false, true, true);\n            }\n            if (!currentObjectResource) {\n                if ('href' in attributes || 'src' in attributes) {\n                    currentObjectResource = this.util.createIri(attributes.href || attributes.src, activeTag, false, false, true);\n                }\n                else if ('typeof' in attributes && !('about' in attributes) && !this.isInheritSubjectInHeadBody(name)) {\n                    currentObjectResource = this.util.createBlankNode();\n                }\n            }\n            // Set typed resource\n            if ('typeof' in attributes && !('about' in attributes)) {\n                if (this.isInheritSubjectInHeadBody(name)) {\n                    typedResource = newSubject;\n                }\n                else {\n                    typedResource = currentObjectResource;\n                }\n            }\n        }\n        // 7: If a typed resource was defined, emit it as a triple\n        if (typedResource) {\n            for (const type of this.util.createVocabIris(attributes.typeof, activeTag, true, true)) {\n                this.emitTriple(this.util.getResourceOrBaseIri(typedResource, activeTag), this.util.dataFactory.namedNode(Util_1.Util.RDF + 'type'), type);\n            }\n        }\n        // 8: Reset list mapping if we have a new subject\n        if (newSubject) {\n            activeTag.listMapping = {};\n        }\n        // 9: If an object was defined, emit triples for it\n        if (currentObjectResource) {\n            // Handle list mapping\n            if ('rel' in attributes && 'inlist' in attributes) {\n                for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)) {\n                    this.addListMapping(activeTag, newSubject, predicate, currentObjectResource);\n                }\n            }\n            // Determine predicates using rel or rev (unless rel and inlist are present)\n            if (!('rel' in attributes && 'inlist' in attributes)) {\n                if ('rel' in attributes) {\n                    for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)) {\n                        this.emitTriple(this.util.getResourceOrBaseIri(newSubject, activeTag), predicate, this.util.getResourceOrBaseIri(currentObjectResource, activeTag));\n                    }\n                }\n                if ('rev' in attributes) {\n                    for (const predicate of this.util.createVocabIris(attributes.rev, activeTag, allowTermsInRevPredicates, false)) {\n                        this.emitTriple(this.util.getResourceOrBaseIri(currentObjectResource, activeTag), predicate, this.util.getResourceOrBaseIri(newSubject, activeTag));\n                    }\n                }\n            }\n        }\n        // 10: Store incomplete triples if we don't have an object, but we do have predicates\n        if (!currentObjectResource) {\n            if ('rel' in attributes) {\n                if ('inlist' in attributes) {\n                    for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)) {\n                        this.addListMapping(activeTag, newSubject, predicate, null);\n                        activeTag.incompleteTriples.push({ predicate, reverse: false, list: true });\n                    }\n                }\n                else {\n                    for (const predicate of this.util.createVocabIris(attributes.rel, activeTag, allowTermsInRelPredicates, false)) {\n                        activeTag.incompleteTriples.push({ predicate, reverse: false });\n                    }\n                }\n            }\n            if ('rev' in attributes) {\n                for (const predicate of this.util.createVocabIris(attributes.rev, activeTag, allowTermsInRevPredicates, false)) {\n                    activeTag.incompleteTriples.push({ predicate, reverse: true });\n                }\n            }\n            // Set a blank node object, so the children can make use of this when completing the triples\n            if (activeTag.incompleteTriples.length > 0) {\n                currentObjectResource = this.util.createBlankNode();\n            }\n        }\n        // 11: Determine current property value\n        if ('property' in attributes) {\n            // Create predicates\n            activeTag.predicates = this.util.createVocabIris(attributes.property, activeTag, true, false);\n            // Save datatype attribute value in active tag\n            let localObjectResource;\n            if ('datatype' in attributes) {\n                activeTag.datatype = this.util.createIri(attributes.datatype, activeTag, true, true, false);\n                if (activeTag.datatype\n                    && (activeTag.datatype.value === Util_1.Util.RDF + 'XMLLiteral'\n                        || (this.features.htmlDatatype && activeTag.datatype.value === Util_1.Util.RDF + 'HTML'))) {\n                    activeTag.collectChildTags = true;\n                }\n            }\n            else {\n                // Try to determine resource\n                if (!('rev' in attributes) && !('rel' in attributes) && !('content' in attributes)) {\n                    if ('resource' in attributes) {\n                        localObjectResource = this.util.createIri(attributes.resource, activeTag, false, true, true);\n                    }\n                    if (!localObjectResource && 'href' in attributes) {\n                        localObjectResource = this.util.createIri(attributes.href, activeTag, false, false, true);\n                    }\n                    if (!localObjectResource && 'src' in attributes) {\n                        localObjectResource = this.util.createIri(attributes.src, activeTag, false, false, true);\n                    }\n                }\n                if ('typeof' in attributes && !('about' in attributes)) {\n                    localObjectResource = typedResource;\n                }\n            }\n            if ('content' in attributes) {\n                // Emit triples based on content attribute has preference over text content\n                const object = this.util.createLiteral(attributes.content, activeTag);\n                if ('inlist' in attributes) {\n                    for (const predicate of activeTag.predicates) {\n                        this.addListMapping(activeTag, newSubject, predicate, object);\n                    }\n                }\n                else {\n                    const subject = this.util.getResourceOrBaseIri(newSubject, activeTag);\n                    for (const predicate of activeTag.predicates) {\n                        this.emitTriple(subject, predicate, object);\n                    }\n                }\n                // Unset predicate to avoid text contents to produce new triples\n                activeTag.predicates = null;\n            }\n            else if (this.features.datetimeAttribute && 'datetime' in attributes) {\n                activeTag.interpretObjectAsTime = true;\n                // Datetime attribute on time tag has preference over text content\n                const object = this.util.createLiteral(attributes.datetime, activeTag);\n                if ('inlist' in attributes) {\n                    for (const predicate of activeTag.predicates) {\n                        this.addListMapping(activeTag, newSubject, predicate, object);\n                    }\n                }\n                else {\n                    const subject = this.util.getResourceOrBaseIri(newSubject, activeTag);\n                    for (const predicate of activeTag.predicates) {\n                        this.emitTriple(subject, predicate, object);\n                    }\n                }\n                // Unset predicate to avoid text contents to produce new triples\n                activeTag.predicates = null;\n            }\n            else if (localObjectResource) {\n                // Emit triples for all resource objects\n                const object = this.util.getResourceOrBaseIri(localObjectResource, activeTag);\n                if ('inlist' in attributes) {\n                    for (const predicate of activeTag.predicates) {\n                        this.addListMapping(activeTag, newSubject, predicate, object);\n                    }\n                }\n                else {\n                    const subject = this.util.getResourceOrBaseIri(newSubject, activeTag);\n                    for (const predicate of activeTag.predicates) {\n                        this.emitTriple(subject, predicate, object);\n                    }\n                }\n                // Unset predicate to avoid text contents to produce new triples\n                activeTag.predicates = null;\n            }\n        }\n        // 12: Complete incomplete triples\n        let incompleteTriplesCompleted = false;\n        if (!activeTag.skipElement && newSubject && parentTag.incompleteTriples.length > 0) {\n            incompleteTriplesCompleted = true;\n            const subject = this.util.getResourceOrBaseIri(parentTag.subject, activeTag);\n            const object = this.util.getResourceOrBaseIri(newSubject, activeTag);\n            for (const incompleteTriple of parentTag.incompleteTriples) {\n                if (!incompleteTriple.reverse) {\n                    if (incompleteTriple.list) {\n                        // Find the active tag that defined the list by going up the stack\n                        let firstInListTag = null;\n                        for (let i = this.activeTagStack.length - 1; i >= 0; i--) {\n                            if (this.activeTagStack[i].inlist) {\n                                firstInListTag = this.activeTagStack[i];\n                                break;\n                            }\n                        }\n                        // firstInListTag is guaranteed to be non-null\n                        this.addListMapping(firstInListTag, newSubject, incompleteTriple.predicate, object);\n                    }\n                    else {\n                        this.emitTriple(subject, incompleteTriple.predicate, object);\n                    }\n                }\n                else {\n                    this.emitTriple(object, incompleteTriple.predicate, subject);\n                }\n            }\n        }\n        if (!incompleteTriplesCompleted && parentTag.incompleteTriples.length > 0) {\n            activeTag.incompleteTriples = activeTag.incompleteTriples.concat(parentTag.incompleteTriples);\n        }\n        // 13: Save evaluation context into active tag\n        activeTag.subject = newSubject || parentTag.subject;\n        activeTag.object = currentObjectResource || newSubject;\n    }\n    onText(data) {\n        const activeTag = this.activeTagStack[this.activeTagStack.length - 1];\n        // Collect text in pattern tag if needed\n        if (this.features.copyRdfaPatterns && activeTag.collectedPatternTag) {\n            activeTag.collectedPatternTag.text.push(data);\n            return;\n        }\n        // Save the text inside the active tag\n        if (!activeTag.text) {\n            activeTag.text = [];\n        }\n        activeTag.text.push(data);\n    }\n    onTagClose() {\n        // Get the active tag\n        const activeTag = this.activeTagStack[this.activeTagStack.length - 1];\n        const parentTag = this.activeTagStack[this.activeTagStack.length - 2];\n        if (!(activeTag.collectChildTags && parentTag.collectChildTags && this.features.skipHandlingXmlLiteralChildren)) {\n            // If we detect a finalized rdfa:Pattern tag, store it\n            if (this.features.copyRdfaPatterns && activeTag.collectedPatternTag\n                && activeTag.collectedPatternTag.rootPattern) {\n                const patternId = activeTag.collectedPatternTag.attributes.resource;\n                // Remove resource and typeof attributes to avoid it being seen as a new pattern\n                delete activeTag.collectedPatternTag.attributes.resource;\n                delete activeTag.collectedPatternTag.attributes.typeof;\n                // Store the pattern\n                this.rdfaPatterns[patternId] = activeTag.collectedPatternTag;\n                // Apply all pending copies for this pattern\n                if (this.pendingRdfaPatternCopies[patternId]) {\n                    for (const tag of this.pendingRdfaPatternCopies[patternId]) {\n                        this.emitPatternCopy(tag, activeTag.collectedPatternTag, patternId);\n                    }\n                    delete this.pendingRdfaPatternCopies[patternId];\n                }\n                // Remove the active tag from the stack\n                this.activeTagStack.pop();\n                return;\n            }\n            // Emit all triples that were determined in the active tag\n            if (activeTag.predicates) {\n                const subject = this.util.getResourceOrBaseIri(activeTag.subject, activeTag);\n                let textSegments = activeTag.text || [];\n                if (activeTag.collectChildTags && parentTag.collectChildTags) {\n                    // If we are inside an XMLLiteral child that also has RDFa content, ignore the tag name that was collected.\n                    textSegments = textSegments.slice(1);\n                }\n                const object = this.util.createLiteral(textSegments.join(''), activeTag);\n                if (activeTag.inlist) {\n                    for (const predicate of activeTag.predicates) {\n                        this.addListMapping(activeTag, subject, predicate, object);\n                    }\n                }\n                else {\n                    for (const predicate of activeTag.predicates) {\n                        this.emitTriple(subject, predicate, object);\n                    }\n                }\n                // Reset text, unless the parent is also collecting text\n                if (!parentTag.predicates) {\n                    activeTag.text = null;\n                }\n            }\n            // 14: Handle local list mapping\n            if (activeTag.object && Object.keys(activeTag.listMapping).length > 0) {\n                const subject = this.util.getResourceOrBaseIri(activeTag.object, activeTag);\n                for (const predicateValue in activeTag.listMapping) {\n                    const predicate = this.util.dataFactory.namedNode(predicateValue);\n                    const values = activeTag.listMapping[predicateValue];\n                    if (values.length > 0) {\n                        // Non-empty list, emit linked list of rdf:first and rdf:rest chains\n                        const bnodes = values.map(() => this.util.createBlankNode());\n                        for (let i = 0; i < values.length; i++) {\n                            const object = this.util.getResourceOrBaseIri(values[i], activeTag);\n                            this.emitTriple(bnodes[i], this.util.dataFactory.namedNode(Util_1.Util.RDF + 'first'), object);\n                            this.emitTriple(bnodes[i], this.util.dataFactory.namedNode(Util_1.Util.RDF + 'rest'), (i < values.length - 1) ? bnodes[i + 1] : this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));\n                        }\n                        // Emit triple for the first linked list chain\n                        this.emitTriple(subject, predicate, bnodes[0]);\n                    }\n                    else {\n                        // Empty list, just emit rdf:nil\n                        this.emitTriple(subject, predicate, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));\n                    }\n                }\n            }\n        }\n        // Remove the active tag from the stack\n        this.activeTagStack.pop();\n        // Save the tag contents if needed\n        if (activeTag.collectChildTags && activeTag.text) {\n            activeTag.text.push(`</${activeTag.name}>`);\n        }\n        // If we still have text contents, try to append it to the parent tag\n        if (activeTag.text && parentTag) {\n            if (!parentTag.text) {\n                parentTag.text = activeTag.text;\n            }\n            else {\n                parentTag.text = parentTag.text.concat(activeTag.text);\n            }\n        }\n    }\n    onEnd() {\n        if (this.features.copyRdfaPatterns) {\n            this.features.copyRdfaPatterns = false;\n            // Emit all unreferenced patterns\n            for (const patternId in this.rdfaPatterns) {\n                const pattern = this.rdfaPatterns[patternId];\n                if (!pattern.referenced) {\n                    pattern.attributes.typeof = 'rdfa:Pattern';\n                    pattern.attributes.resource = patternId;\n                    this.emitPatternCopy(pattern.parentTag, pattern, patternId);\n                    pattern.referenced = false;\n                    delete pattern.attributes.typeof;\n                    delete pattern.attributes.resource;\n                }\n            }\n            // Emit all unreferenced copy links\n            for (const patternId in this.pendingRdfaPatternCopies) {\n                for (const parentTag of this.pendingRdfaPatternCopies[patternId]) {\n                    this.activeTagStack.push(parentTag);\n                    this.onTagOpen('link', { property: 'rdfa:copy', href: patternId });\n                    this.onTagClose();\n                    this.activeTagStack.pop();\n                }\n            }\n            this.features.copyRdfaPatterns = true;\n        }\n    }\n    /**\n     * If the new subject can be inherited from the parent object\n     * if the resource defines no new subject.\n     * @param {string} name The current tag name.\n     * @returns {boolean} If the subject can be inherited.\n     */\n    isInheritSubjectInHeadBody(name) {\n        return this.features.inheritSubjectInHeadBody && (name === 'head' || name === 'body');\n    }\n    /**\n     * Add a list mapping for the given predicate and object in the active tag.\n     * @param {IActiveTag} activeTag The active tag.\n     * @param {Term | boolean} subject A subject term, this will only be used to create a separate list\n     *                                 if activeTag.explicitNewSubject is true.\n     * @param {Term} predicate A predicate term.\n     * @param {Term | boolean} currentObjectResource The current object resource.\n     */\n    addListMapping(activeTag, subject, predicate, currentObjectResource) {\n        if (activeTag.explicitNewSubject) {\n            const bNode = this.util.createBlankNode();\n            this.emitTriple(this.util.getResourceOrBaseIri(subject, activeTag), predicate, bNode);\n            this.emitTriple(bNode, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'first'), this.util.getResourceOrBaseIri(currentObjectResource, activeTag));\n            this.emitTriple(bNode, this.util.dataFactory.namedNode(Util_1.Util.RDF + 'rest'), this.util.dataFactory.namedNode(Util_1.Util.RDF + 'nil'));\n        }\n        else {\n            let predicateList = activeTag.listMappingLocal[predicate.value];\n            if (!predicateList) {\n                activeTag.listMappingLocal[predicate.value] = predicateList = [];\n            }\n            if (currentObjectResource) {\n                predicateList.push(currentObjectResource);\n            }\n        }\n    }\n    /**\n     * Emit the given triple to the stream.\n     * @param {Term} subject A subject term.\n     * @param {Term} predicate A predicate term.\n     * @param {Term} object An object term.\n     */\n    emitTriple(subject, predicate, object) {\n        // Validate IRIs\n        if ((subject.termType === 'NamedNode' && subject.value.indexOf(':') < 0)\n            || (predicate.termType === 'NamedNode' && predicate.value.indexOf(':') < 0)\n            || (object.termType === 'NamedNode' && object.value.indexOf(':') < 0)) {\n            return;\n        }\n        this.push(this.util.dataFactory.quad(subject, predicate, object, this.defaultGraph));\n    }\n    /**\n     * Emit an instantiation of the given pattern with the given parent tag.\n     * @param {IActiveTag} parentTag The parent tag to instantiate in.\n     * @param {IRdfaPattern} pattern The pattern to instantiate.\n     * @param {string} rootPatternId The pattern id.\n     */\n    emitPatternCopy(parentTag, pattern, rootPatternId) {\n        this.activeTagStack.push(parentTag);\n        pattern.referenced = true;\n        // Ensure that blank nodes within patterns are instantiated only once.\n        // All next pattern copies will reuse the instantiated blank nodes from the first pattern.\n        if (!pattern.constructedBlankNodes) {\n            pattern.constructedBlankNodes = [];\n            this.util.blankNodeFactory = () => {\n                const bNode = this.util.dataFactory.blankNode();\n                pattern.constructedBlankNodes.push(bNode);\n                return bNode;\n            };\n        }\n        else {\n            let blankNodeIndex = 0;\n            this.util.blankNodeFactory = () => pattern.constructedBlankNodes[blankNodeIndex++];\n        }\n        // Apply everything within the pattern\n        this.emitPatternCopyAbsolute(pattern, true, rootPatternId);\n        this.util.blankNodeFactory = null;\n        this.activeTagStack.pop();\n    }\n    /**\n     * Emit an instantiation of the given pattern with the given parent tag.\n     *\n     * This should probably not be called directly,\n     * call {@link emitPatternCopy} instead.\n     *\n     * @param {IRdfaPattern} pattern The pattern to instantiate.\n     * @param {boolean} root If this is the root call for the given pattern.\n     * @param {string} rootPatternId The pattern id.\n     */\n    emitPatternCopyAbsolute(pattern, root, rootPatternId) {\n        // Stop on detection of cyclic patterns\n        if (!root && pattern.attributes.property === 'rdfa:copy' && pattern.attributes.href === rootPatternId) {\n            return;\n        }\n        this.onTagOpen(pattern.name, pattern.attributes);\n        for (const text of pattern.text) {\n            this.onText(text);\n        }\n        for (const child of pattern.children) {\n            this.emitPatternCopyAbsolute(child, false, rootPatternId);\n        }\n        this.onTagClose();\n    }\n    initializeParser(xmlMode) {\n        return new htmlparser2_1.Parser({\n            onclosetag: () => {\n                try {\n                    this.onTagClose();\n                    if (this.htmlParseListener) {\n                        this.htmlParseListener.onTagClose();\n                    }\n                }\n                catch (e) {\n                    this.emit('error', e);\n                }\n            },\n            onend: () => {\n                try {\n                    this.onEnd();\n                    if (this.htmlParseListener) {\n                        this.htmlParseListener.onEnd();\n                    }\n                }\n                catch (e) {\n                    this.emit('error', e);\n                }\n            },\n            onopentag: (name, attributes) => {\n                try {\n                    this.onTagOpen(name, attributes);\n                    if (this.htmlParseListener) {\n                        this.htmlParseListener.onTagOpen(name, attributes);\n                    }\n                }\n                catch (e) {\n                    this.emit('error', e);\n                }\n            },\n            ontext: (data) => {\n                try {\n                    this.onText(data);\n                    if (this.htmlParseListener) {\n                        this.htmlParseListener.onText(data);\n                    }\n                }\n                catch (e) {\n                    this.emit('error', e);\n                }\n            },\n        }, {\n            decodeEntities: true,\n            recognizeSelfClosing: true,\n            xmlMode,\n        });\n    }\n}\nexports.RdfaParser = RdfaParser;\n//# sourceMappingURL=RdfaParser.js.map"]},"metadata":{},"sourceType":"script"}