{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.definitions = void 0;\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst hash_js_1 = require(\"hash.js\");\n\nconst spark_md5_1 = require(\"spark-md5\");\n\nconst decimal_js_1 = require(\"decimal.js\");\n\nconst uuid = require(\"uuid\");\n\nconst immutable_1 = require(\"immutable\");\n\nconst E = require(\"../expressions\");\n\nconst C = require(\"../util/Consts\");\n\nconst Err = require(\"../util/Errors\");\n\nconst P = require(\"../util/Parsing\");\n\nconst X = require(\"./XPathFunctions\");\n\nconst Consts_1 = require(\"../util/Consts\");\n\nconst Transformation_1 = require(\"../Transformation\");\n\nconst Helpers_1 = require(\"./Helpers\");\n\nconst DF = new rdf_data_factory_1.DataFactory(); // ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// Begin definitions\n// ----------------------------------------------------------------------------\n// Operator Mapping\n// https://www.w3.org/TR/sparql11-query/#OperatorMapping\n// ----------------------------------------------------------------------------\n\nconst not = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(val => Helpers_1.bool(!val.coerceEBV())).collect()\n};\nconst unaryPlus = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(val => Helpers_1.number(val.typedValue, val.typeURL.value)).collect()\n};\nconst unaryMinus = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(val => Helpers_1.number(-val.typedValue, val.typeURL.value)).collect()\n};\nconst multiplication = {\n  arity: 2,\n  overloads: Helpers_1.declare().arithmetic((left, right) => decimal_js_1.Decimal.mul(left, right).toNumber()).collect()\n};\nconst division = {\n  arity: 2,\n  overloads: Helpers_1.declare().arithmetic((left, right) => decimal_js_1.Decimal.div(left, right).toNumber()).onBinaryTyped(['integer', 'integer'], (left, right) => {\n    if (right === 0) {\n      throw new Err.ExpressionError('Integer division by 0');\n    }\n\n    return Helpers_1.number(decimal_js_1.Decimal.div(left, right).toNumber(), Consts_1.TypeURL.XSD_DECIMAL);\n  }).collect()\n};\nconst addition = {\n  arity: 2,\n  overloads: Helpers_1.declare().arithmetic((left, right) => decimal_js_1.Decimal.add(left, right).toNumber()).collect()\n};\nconst subtraction = {\n  arity: 2,\n  overloads: Helpers_1.declare().arithmetic((left, right) => decimal_js_1.Decimal.sub(left, right).toNumber()).collect()\n}; // https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal\n\nconst equality = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest((left, right) => left === right).stringTest((left, right) => left.localeCompare(right) === 0).booleanTest((left, right) => left === right).dateTimeTest((left, right) => left.getTime() === right.getTime()).set(['term', 'term'], ([left, right]) => Helpers_1.bool(RDFTermEqual(left, right))).collect()\n};\n\nfunction RDFTermEqual(_left, _right) {\n  const left = _left.toRDF();\n\n  const right = _right.toRDF();\n\n  const val = left.equals(right);\n\n  if (left.termType === 'Literal' && right.termType === 'Literal') {\n    throw new Err.RDFEqualTypeError([_left, _right]);\n  }\n\n  return val;\n}\n\nconst inequality = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest((left, right) => left !== right).stringTest((left, right) => left.localeCompare(right) !== 0).booleanTest((left, right) => left !== right).dateTimeTest((left, right) => left.getTime() !== right.getTime()).set(['term', 'term'], ([left, right]) => Helpers_1.bool(!RDFTermEqual(left, right))).collect()\n};\nconst lesserThan = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest((left, right) => left < right).stringTest((left, right) => left.localeCompare(right) === -1).booleanTest((left, right) => left < right).dateTimeTest((left, right) => left.getTime() < right.getTime()).collect()\n};\nconst greaterThan = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest((left, right) => left > right).stringTest((left, right) => left.localeCompare(right) === 1).booleanTest((left, right) => left > right).dateTimeTest((left, right) => left.getTime() > right.getTime()).collect()\n};\nconst lesserThanEqual = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest((left, right) => left <= right).stringTest((left, right) => left.localeCompare(right) !== 1).booleanTest((left, right) => left <= right).dateTimeTest((left, right) => left.getTime() <= right.getTime()).collect()\n};\nconst greaterThanEqual = {\n  arity: 2,\n  overloads: Helpers_1.declare().numberTest((left, right) => left >= right).stringTest((left, right) => left.localeCompare(right) !== -1).booleanTest((left, right) => left >= right).dateTimeTest((left, right) => left.getTime() >= right.getTime()).collect()\n}; // ----------------------------------------------------------------------------\n// Functions on RDF Terms\n// https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n// ----------------------------------------------------------------------------\n\nconst isIRI = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(term => Helpers_1.bool(term.termType === 'namedNode')).collect()\n};\nconst isBlank = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(term => Helpers_1.bool(term.termType === 'blankNode')).collect()\n};\nconst isLiteral = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(term => Helpers_1.bool(term.termType === 'literal')).collect()\n};\nconst isNumeric = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(term => Helpers_1.bool(true)).onTerm1(term => Helpers_1.bool(false)).collect()\n};\nconst toString = {\n  arity: 1,\n  overloads: Helpers_1.declare().onTerm1(term => Helpers_1.string(term.str())).collect()\n};\nconst lang = {\n  arity: 1,\n  overloads: Helpers_1.declare().onLiteral1(lit => Helpers_1.string(lit.language || '')).collect()\n};\nconst datatype = {\n  arity: 1,\n  overloads: Helpers_1.declare().onLiteral1(lit => new E.NamedNode(lit.typeURL.value)).collect()\n}; // See special operators\n// const IRI = {};\n// See special functions\n// const BNODE = {};\n\nconst STRDT = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinary(['string', 'namedNode'], (str, iri) => {\n    const lit = DF.literal(str.typedValue, DF.namedNode(iri.value));\n    return Transformation_1.transformLiteral(lit);\n  }).collect()\n};\nconst STRLANG = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], (val, language) => new E.LangStringLiteral(val, language.toLowerCase())).collect()\n};\nconst UUID = {\n  arity: 0,\n  overloads: Helpers_1.declare().set([], () => new E.NamedNode(`urn:uuid:${uuid.v4()}`)).collect()\n};\nconst STRUUID = {\n  arity: 0,\n  overloads: Helpers_1.declare().set([], () => Helpers_1.string(uuid.v4())).collect()\n}; // ----------------------------------------------------------------------------\n// Functions on strings\n// https://www.w3.org/TR/sparql11-query/#func-forms\n// ----------------------------------------------------------------------------\n\nconst STRLEN = {\n  arity: 1,\n  overloads: Helpers_1.declare().onStringly1(str => Helpers_1.number([...str.typedValue].length, Consts_1.TypeURL.XSD_INTEGER)).collect()\n};\nconst SUBSTR = {\n  arity: [2, 3],\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'integer'], (source, startingLoc) => {\n    return Helpers_1.string([...source].slice(startingLoc - 1).join(''));\n  }).onBinary(['langString', 'integer'], (source, startingLoc) => {\n    const sub = [...source.typedValue].slice(startingLoc.typedValue - 1).join('');\n    return Helpers_1.langString(sub, source.language);\n  }).onTernaryTyped(['string', 'integer', 'integer'], (source, startingLoc, length) => {\n    return Helpers_1.string([...source].slice(startingLoc - 1, length).join(''));\n  }).onTernary(['langString', 'integer', 'integer'], (source, startingLoc, length) => {\n    const sub = [...source.typedValue].slice(startingLoc.typedValue - 1, length.typedValue).join('');\n    return Helpers_1.langString(sub, source.language);\n  }).collect()\n};\nconst UCASE = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(lit => Helpers_1.string(lit.toUpperCase())).onLangString1(lit => Helpers_1.langString(lit.typedValue.toUpperCase(), lit.language)).collect()\n};\nconst LCASE = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(lit => Helpers_1.string(lit.toLowerCase())).onLangString1(lit => Helpers_1.langString(lit.typedValue.toLowerCase(), lit.language)).collect()\n};\nconst STRSTARTS = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], (arg1, arg2) => Helpers_1.bool(arg1.startsWith(arg2))).onBinaryTyped(['langString', 'string'], (arg1, arg2) => Helpers_1.bool(arg1.startsWith(arg2))).onBinary(['langString', 'langString'], (arg1, arg2) => {\n    if (arg1.language !== arg2.language) {\n      throw new Err.IncompatibleLanguageOperation(arg1, arg2);\n    }\n\n    return Helpers_1.bool(arg1.typedValue.startsWith(arg2.typedValue));\n  }).collect()\n};\nconst STRENDS = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], (arg1, arg2) => Helpers_1.bool(arg1.endsWith(arg2))).onBinaryTyped(['langString', 'string'], (arg1, arg2) => Helpers_1.bool(arg1.endsWith(arg2))).onBinary(['langString', 'langString'], (arg1, arg2) => {\n    if (arg1.language !== arg2.language) {\n      throw new Err.IncompatibleLanguageOperation(arg1, arg2);\n    }\n\n    return Helpers_1.bool(arg1.typedValue.endsWith(arg2.typedValue));\n  }).collect()\n};\nconst CONTAINS = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], (arg1, arg2) => Helpers_1.bool(arg1.includes(arg2))).onBinaryTyped(['langString', 'string'], (arg1, arg2) => Helpers_1.bool(arg1.includes(arg2))).onBinary(['langString', 'langString'], (arg1, arg2) => {\n    if (arg1.language !== arg2.language) {\n      throw new Err.IncompatibleLanguageOperation(arg1, arg2);\n    }\n\n    return Helpers_1.bool(arg1.typedValue.includes(arg2.typedValue));\n  }).collect()\n};\nconst STRBEFORE = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], (arg1, arg2) => Helpers_1.string(arg1.substr(0, arg1.indexOf(arg2)))).onBinary(['langString', 'string'], (arg1, arg2) => {\n    const [a1, a2] = [arg1.typedValue, arg2.typedValue];\n    const sub = arg1.typedValue.substr(0, a1.indexOf(a2));\n    return sub || !a2 ? Helpers_1.langString(sub, arg1.language) : Helpers_1.string(sub);\n  }).onBinary(['langString', 'langString'], (arg1, arg2) => {\n    if (arg1.language !== arg2.language) {\n      throw new Err.IncompatibleLanguageOperation(arg1, arg2);\n    }\n\n    const [a1, a2] = [arg1.typedValue, arg2.typedValue];\n    const sub = arg1.typedValue.substr(0, a1.indexOf(a2));\n    return sub || !a2 ? Helpers_1.langString(sub, arg1.language) : Helpers_1.string(sub);\n  }).collect()\n};\nconst STRAFTER = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], (arg1, arg2) => Helpers_1.string(arg1.substr(arg1.indexOf(arg2)).substr(arg2.length))).onBinary(['langString', 'string'], (arg1, arg2) => {\n    const [a1, a2] = [arg1.typedValue, arg2.typedValue];\n    const sub = a1.substr(a1.indexOf(a2)).substr(a2.length);\n    return sub || !a2 ? Helpers_1.langString(sub, arg1.language) : Helpers_1.string(sub);\n  }).onBinary(['langString', 'langString'], (arg1, arg2) => {\n    if (arg1.language !== arg2.language) {\n      throw new Err.IncompatibleLanguageOperation(arg1, arg2);\n    }\n\n    const [a1, a2] = [arg1.typedValue, arg2.typedValue];\n    const sub = a1.substr(a1.indexOf(a2)).substr(a2.length);\n    return sub || !a2 ? Helpers_1.langString(sub, arg1.language) : Helpers_1.string(sub);\n  }).collect()\n};\nconst ENCODE_FOR_URI = {\n  arity: 1,\n  overloads: Helpers_1.declare().onStringly1Typed(val => Helpers_1.string(encodeURI(val))).collect()\n}; // See special operators\n// const CONCAT = {}\n\nconst langmatches = {\n  arity: 2,\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], (tag, range) => Helpers_1.bool(X.langMatches(tag, range))).collect()\n};\n\nconst regex2 = (text, pattern) => Helpers_1.bool(X.matches(text, pattern));\n\nconst regex3 = (text, pattern, flags) => Helpers_1.bool(X.matches(text, pattern, flags));\n\nconst REGEX = {\n  arity: [2, 3],\n  overloads: Helpers_1.declare().onBinaryTyped(['string', 'string'], regex2).onBinaryTyped(['langString', 'string'], regex2).onTernaryTyped(['string', 'string', 'string'], regex3).onTernaryTyped(['langString', 'string', 'string'], regex3).collect()\n};\nconst REPLACE = {\n  arity: [3, 4],\n  overloads: Helpers_1.declare().onTernaryTyped(['string', 'string', 'string'], (arg, pattern, replacement) => Helpers_1.string(X.replace(arg, pattern, replacement))).set(['langString', 'string', 'string'], ([arg, pattern, replacement]) => {\n    const result = X.replace(arg.typedValue, pattern.typedValue, replacement.typedValue);\n    return Helpers_1.langString(result, arg.language);\n  }).onQuaternaryTyped(['string', 'string', 'string', 'string'], (arg, pattern, replacement, flags) => Helpers_1.string(X.replace(arg, pattern, replacement, flags))).set(['langString', 'string', 'string', 'string'], ([arg, pattern, replacement, flags]) => {\n    const result = X.replace(arg.typedValue, pattern.typedValue, replacement.typedValue, flags.typedValue);\n    return Helpers_1.langString(result, arg.language);\n  }).collect()\n}; // ----------------------------------------------------------------------------\n// Functions on numerics\n// https://www.w3.org/TR/sparql11-query/#func-numerics\n// ----------------------------------------------------------------------------\n\nconst abs = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(num => Helpers_1.number(Math.abs(num.typedValue), num.typeURL.value)).collect()\n};\nconst round = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(num => Helpers_1.number(Math.round(num.typedValue), num.typeURL.value)).collect()\n};\nconst ceil = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(num => Helpers_1.number(Math.ceil(num.typedValue), num.typeURL.value)).collect()\n};\nconst floor = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(num => Helpers_1.number(Math.floor(num.typedValue), num.typeURL.value)).collect()\n};\nconst rand = {\n  arity: 0,\n  overloads: Helpers_1.declare().set([], () => Helpers_1.number(Math.random(), Consts_1.TypeURL.XSD_DOUBLE)).collect()\n}; // ----------------------------------------------------------------------------\n// Functions on Dates and Times\n// https://www.w3.org/TR/sparql11-query/#func-date-time\n// ----------------------------------------------------------------------------\n\nfunction parseDate(dateLit) {\n  return P.parseXSDDateTime(dateLit.str());\n} // See special operators\n// const now = {};\n\n\nconst year = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(date => Helpers_1.number(Number(parseDate(date).year), Consts_1.TypeURL.XSD_INTEGER)).collect()\n};\nconst month = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(date => Helpers_1.number(Number(parseDate(date).month), Consts_1.TypeURL.XSD_INTEGER)).collect()\n};\nconst day = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(date => Helpers_1.number(Number(parseDate(date).day), Consts_1.TypeURL.XSD_INTEGER)).collect()\n};\nconst hours = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(date => Helpers_1.number(Number(parseDate(date).hours), Consts_1.TypeURL.XSD_INTEGER)).collect()\n};\nconst minutes = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(date => Helpers_1.number(Number(parseDate(date).minutes), Consts_1.TypeURL.XSD_INTEGER)).collect()\n};\nconst seconds = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(date => Helpers_1.number(Number(parseDate(date).seconds), Consts_1.TypeURL.XSD_DECIMAL)).collect()\n};\nconst timezone = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(date => {\n    const duration = X.formatDayTimeDuration(parseDate(date).timezone);\n\n    if (!duration) {\n      throw new Err.InvalidTimezoneCall(date.strValue);\n    }\n\n    return new E.Literal(duration, C.make(Consts_1.TypeURL.XSD_DAYTIME_DURATION), duration);\n  }).collect()\n};\nconst tz = {\n  arity: 1,\n  overloads: Helpers_1.declare().onDateTime1(date => Helpers_1.string(parseDate(date).timezone)).collect()\n}; // ----------------------------------------------------------------------------\n// Hash functions\n// https://www.w3.org/TR/sparql11-query/#func-hash\n// ----------------------------------------------------------------------------\n\nconst MD5 = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(str => Helpers_1.string(spark_md5_1.hash(str))).collect()\n};\nconst SHA1 = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(str => Helpers_1.string(hash_js_1.sha1().update(str).digest('hex'))).collect()\n};\nconst SHA256 = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(str => Helpers_1.string(hash_js_1.sha256().update(str).digest('hex'))).collect()\n};\nconst SHA384 = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(str => Helpers_1.string(hash_js_1.sha384().update(str).digest('hex'))).collect()\n};\nconst SHA512 = {\n  arity: 1,\n  overloads: Helpers_1.declare().onString1Typed(str => Helpers_1.string(hash_js_1.sha512().update(str).digest('hex'))).collect()\n}; // End definitions.\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\n/*\n * Collect all the definitions from above into an object\n */\n\nconst _definitions = {\n  // --------------------------------------------------------------------------\n  // Operator Mapping\n  // https://www.w3.org/TR/sparql11-query/#OperatorMapping\n  // --------------------------------------------------------------------------\n  '!': not,\n  'UPLUS': unaryPlus,\n  'UMINUS': unaryMinus,\n  '*': multiplication,\n  '/': division,\n  '+': addition,\n  '-': subtraction,\n  '=': equality,\n  '!=': inequality,\n  '<': lesserThan,\n  '>': greaterThan,\n  '<=': lesserThanEqual,\n  '>=': greaterThanEqual,\n  // --------------------------------------------------------------------------\n  // Functions on RDF Terms\n  // https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n  // --------------------------------------------------------------------------\n  'isiri': isIRI,\n  'isblank': isBlank,\n  'isliteral': isLiteral,\n  'isnumeric': isNumeric,\n  'str': toString,\n  'lang': lang,\n  'datatype': datatype,\n  // 'iri': IRI (see special operators),\n  // 'uri': IRI (see special operators),\n  // 'BNODE': BNODE (see special operators),\n  'strdt': STRDT,\n  'strlang': STRLANG,\n  'uuid': UUID,\n  'struuid': STRUUID,\n  // --------------------------------------------------------------------------\n  // Functions on strings\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  'strlen': STRLEN,\n  'substr': SUBSTR,\n  'ucase': UCASE,\n  'lcase': LCASE,\n  'strstarts': STRSTARTS,\n  'strends': STRENDS,\n  'contains': CONTAINS,\n  'strbefore': STRBEFORE,\n  'strafter': STRAFTER,\n  'encode_for_uri': ENCODE_FOR_URI,\n  // 'concat': CONCAT (see special operators)\n  'langmatches': langmatches,\n  'regex': REGEX,\n  'replace': REPLACE,\n  // --------------------------------------------------------------------------\n  // Functions on numerics\n  // https://www.w3.org/TR/sparql11-query/#func-numerics\n  // --------------------------------------------------------------------------\n  'abs': abs,\n  'round': round,\n  'ceil': ceil,\n  'floor': floor,\n  'rand': rand,\n  // --------------------------------------------------------------------------\n  // Functions on Dates and Times\n  // https://www.w3.org/TR/sparql11-query/#func-date-time\n  // --------------------------------------------------------------------------\n  // 'now': now (see special operators),\n  'year': year,\n  'month': month,\n  'day': day,\n  'hours': hours,\n  'minutes': minutes,\n  'seconds': seconds,\n  'timezone': timezone,\n  'tz': tz,\n  // --------------------------------------------------------------------------\n  // Hash functions\n  // https://www.w3.org/TR/sparql11-query/#func-hash\n  // --------------------------------------------------------------------------\n  'md5': MD5,\n  'sha1': SHA1,\n  'sha256': SHA256,\n  'sha384': SHA384,\n  'sha512': SHA512\n};\nexports.definitions = immutable_1.Map(_definitions);","map":{"version":3,"sources":["../../../lib/functions/RegularFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["import {DataFactory} from 'rdf-data-factory';\nimport {sha1, sha256, sha384, sha512} from 'hash.js';\nimport {hash as md5} from 'spark-md5';\nimport {Decimal} from 'decimal.js';\nimport * as uuid from 'uuid';\n\nimport { Map } from 'immutable';\n\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport * as P from '../util/Parsing';\nimport * as X from './XPathFunctions';\n\nimport { TypeURL } from '../util/Consts';\n\nimport { transformLiteral } from '../Transformation';\nimport { OverloadMap } from './Core';\nimport { bool, declare, langString, log, number, string } from './Helpers';\n\nconst DF = new DataFactory();\n\ntype Term = E.TermExpression;\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// Begin definitions\n\n// ----------------------------------------------------------------------------\n// Operator Mapping\n// https://www.w3.org/TR/sparql11-query/#OperatorMapping\n// ----------------------------------------------------------------------------\n\nconst not = {\n  arity: 1,\n  overloads: declare()\n    .onTerm1((val) => bool(!val.coerceEBV()))\n    .collect(),\n};\n\nconst unaryPlus = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val) => number(val.typedValue, val.typeURL.value as TypeURL))\n    .collect(),\n};\n\nconst unaryMinus = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val) => number(-val.typedValue, val.typeURL.value as TypeURL))\n    .collect(),\n};\n\nconst multiplication = {\n  arity: 2,\n  overloads: declare()\n    .arithmetic((left, right) => Decimal.mul(left, right).toNumber())\n    .collect(),\n};\n\nconst division = {\n  arity: 2,\n  overloads: declare()\n    .arithmetic((left, right) => Decimal.div(left, right).toNumber())\n    .onBinaryTyped(\n      ['integer', 'integer'],\n      (left: number, right: number) => {\n        if (right === 0) {\n          throw new Err.ExpressionError('Integer division by 0');\n        }\n        return number(Decimal.div(left, right).toNumber(), TypeURL.XSD_DECIMAL);\n      })\n    .collect(),\n};\n\nconst addition = {\n  arity: 2,\n  overloads: declare()\n    .arithmetic((left, right) => Decimal.add(left, right).toNumber())\n    .collect(),\n};\n\nconst subtraction = {\n  arity: 2,\n  overloads: declare()\n    .arithmetic((left, right) => Decimal.sub(left, right).toNumber())\n    .collect(),\n};\n\n// https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal\nconst equality = {\n  arity: 2,\n  overloads: declare()\n    .numberTest((left, right) => left === right)\n    .stringTest((left, right) => left.localeCompare(right) === 0)\n    .booleanTest((left, right) => left === right)\n    .dateTimeTest((left, right) => left.getTime() === right.getTime())\n    .set(\n      ['term', 'term'],\n      ([left, right]) => bool(RDFTermEqual(left, right)),\n    )\n    .collect(),\n};\n\nfunction RDFTermEqual(_left: Term, _right: Term) {\n  const left = _left.toRDF();\n  const right = _right.toRDF();\n  const val = left.equals(right);\n  if ((left.termType === 'Literal') && (right.termType === 'Literal')) {\n    throw new Err.RDFEqualTypeError([_left, _right]);\n  }\n  return val;\n}\n\nconst inequality = {\n  arity: 2,\n  overloads: declare()\n    .numberTest((left, right) => left !== right)\n    .stringTest((left, right) => left.localeCompare(right) !== 0)\n    .booleanTest((left, right) => left !== right)\n    .dateTimeTest((left, right) => left.getTime() !== right.getTime())\n    .set(\n      ['term', 'term'],\n      ([left, right]) => bool(!RDFTermEqual(left, right)),\n    )\n    .collect(),\n};\n\nconst lesserThan = {\n  arity: 2,\n  overloads: declare()\n    .numberTest((left, right) => left < right)\n    .stringTest((left, right) => left.localeCompare(right) === -1)\n    .booleanTest((left, right) => left < right)\n    .dateTimeTest((left, right) => left.getTime() < right.getTime())\n    .collect(),\n};\n\nconst greaterThan = {\n  arity: 2,\n  overloads: declare()\n    .numberTest((left, right) => left > right)\n    .stringTest((left, right) => left.localeCompare(right) === 1)\n    .booleanTest((left, right) => left > right)\n    .dateTimeTest((left, right) => left.getTime() > right.getTime())\n    .collect(),\n};\n\nconst lesserThanEqual = {\n  arity: 2,\n  overloads: declare()\n    .numberTest((left, right) => left <= right)\n    .stringTest((left, right) => left.localeCompare(right) !== 1)\n    .booleanTest((left, right) => left <= right)\n    .dateTimeTest((left, right) => left.getTime() <= right.getTime())\n    .collect(),\n};\n\nconst greaterThanEqual = {\n  arity: 2,\n  overloads: declare()\n    .numberTest((left, right) => left >= right)\n    .stringTest((left, right) => left.localeCompare(right) !== -1)\n    .booleanTest((left, right) => left >= right)\n    .dateTimeTest((left, right) => left.getTime() >= right.getTime())\n    .collect(),\n};\n\n// ----------------------------------------------------------------------------\n// Functions on RDF Terms\n// https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n// ----------------------------------------------------------------------------\n\nconst isIRI = {\n  arity: 1,\n  overloads: declare()\n    .onTerm1((term) => bool(term.termType === 'namedNode'))\n    .collect(),\n};\n\nconst isBlank = {\n  arity: 1,\n  overloads: declare()\n    .onTerm1((term) => bool(term.termType === 'blankNode'))\n    .collect(),\n};\n\nconst isLiteral = {\n  arity: 1,\n  overloads: declare()\n    .onTerm1((term) => bool(term.termType === 'literal'))\n    .collect(),\n};\n\nconst isNumeric = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((term) => bool(true))\n    .onTerm1((term) => bool(false))\n    .collect(),\n};\n\nconst toString = {\n  arity: 1,\n  overloads: declare()\n    .onTerm1((term) => string(term.str()))\n    .collect(),\n};\n\nconst lang = {\n  arity: 1,\n  overloads: declare()\n    .onLiteral1((lit) => string(lit.language || ''))\n    .collect(),\n};\n\nconst datatype = {\n  arity: 1,\n  overloads: declare()\n    .onLiteral1((lit) => new E.NamedNode(lit.typeURL.value))\n    .collect(),\n};\n\n// See special operators\n// const IRI = {};\n\n// See special functions\n// const BNODE = {};\n\nconst STRDT = {\n  arity: 2,\n  overloads: declare()\n    .onBinary(\n      ['string', 'namedNode'],\n      (str: E.StringLiteral, iri: E.NamedNode) => {\n        const lit = DF.literal(str.typedValue, DF.namedNode(iri.value));\n        return transformLiteral(lit);\n      })\n    .collect(),\n};\n\nconst STRLANG = {\n  arity: 2,\n  overloads: declare()\n    .onBinaryTyped(\n      ['string', 'string'],\n      (val: string, language: string) => new E.LangStringLiteral(val, language.toLowerCase()),\n    )\n    .collect(),\n};\n\nconst UUID = {\n  arity: 0,\n  overloads: declare()\n    .set([], () => new E.NamedNode(`urn:uuid:${uuid.v4()}`))\n    .collect(),\n};\n\nconst STRUUID = {\n  arity: 0,\n  overloads: declare()\n    .set([], () => string(uuid.v4()))\n    .collect(),\n};\n\n// ----------------------------------------------------------------------------\n// Functions on strings\n// https://www.w3.org/TR/sparql11-query/#func-forms\n// ----------------------------------------------------------------------------\n\nconst STRLEN = {\n  arity: 1,\n  overloads: declare()\n    .onStringly1((str) => number([...str.typedValue].length, TypeURL.XSD_INTEGER))\n    .collect(),\n};\n\nconst SUBSTR = {\n  arity: [2, 3],\n  overloads: declare()\n    .onBinaryTyped(\n      ['string', 'integer'],\n      (source: string, startingLoc: number) => {\n        return string([...source].slice(startingLoc - 1).join(''));\n      })\n    .onBinary(\n      ['langString', 'integer'],\n      (source: E.LangStringLiteral, startingLoc: E.NumericLiteral) => {\n        const sub = [...source.typedValue].slice(startingLoc.typedValue - 1).join('');\n        return langString(sub, source.language);\n      })\n    .onTernaryTyped(['string', 'integer', 'integer'],\n      (source: string, startingLoc: number, length: number) => {\n        return string([...source].slice(startingLoc - 1, length).join(''));\n      })\n    .onTernary(['langString', 'integer', 'integer'],\n      (source: E.LangStringLiteral, startingLoc: E.NumericLiteral, length: E.NumericLiteral) => {\n        const sub = [...source.typedValue].slice(startingLoc.typedValue - 1, length.typedValue).join('');\n        return langString(sub, source.language);\n      })\n    .collect(),\n};\n\nconst UCASE = {\n  arity: 1,\n  overloads: declare()\n    .onString1Typed((lit) => string(lit.toUpperCase()))\n    .onLangString1((lit) => langString(lit.typedValue.toUpperCase(), lit.language))\n    .collect(),\n};\n\nconst LCASE = {\n  arity: 1,\n  overloads: declare()\n    .onString1Typed((lit) => string(lit.toLowerCase()))\n    .onLangString1((lit) => langString(lit.typedValue.toLowerCase(), lit.language))\n    .collect(),\n};\n\nconst STRSTARTS = {\n  arity: 2,\n  overloads: declare()\n    .onBinaryTyped(\n      ['string', 'string'],\n      (arg1: string, arg2: string) => bool(arg1.startsWith(arg2)),\n    )\n    .onBinaryTyped(\n      ['langString', 'string'],\n      (arg1: string, arg2: string) => bool(arg1.startsWith(arg2)),\n    )\n    .onBinary(\n      ['langString', 'langString'],\n      (arg1: E.LangStringLiteral, arg2: E.LangStringLiteral) => {\n        if (arg1.language !== arg2.language) {\n          throw new Err.IncompatibleLanguageOperation(arg1, arg2);\n        }\n        return bool(arg1.typedValue.startsWith(arg2.typedValue));\n      })\n    .collect(),\n};\n\nconst STRENDS = {\n  arity: 2,\n  overloads: declare()\n    .onBinaryTyped(\n      ['string', 'string'],\n      (arg1: string, arg2: string) => bool(arg1.endsWith(arg2)),\n    )\n    .onBinaryTyped(\n      ['langString', 'string'],\n      (arg1: string, arg2: string) => bool(arg1.endsWith(arg2)),\n    )\n    .onBinary(\n      ['langString', 'langString'],\n      (arg1: E.LangStringLiteral, arg2: E.LangStringLiteral) => {\n        if (arg1.language !== arg2.language) {\n          throw new Err.IncompatibleLanguageOperation(arg1, arg2);\n        }\n        return bool(arg1.typedValue.endsWith(arg2.typedValue));\n      })\n    .collect(),\n};\n\nconst CONTAINS = {\n  arity: 2,\n  overloads: declare()\n    .onBinaryTyped(\n      ['string', 'string'],\n      (arg1: string, arg2: string) => bool(arg1.includes(arg2)),\n    )\n    .onBinaryTyped(\n      ['langString', 'string'],\n      (arg1: string, arg2: string) => bool(arg1.includes(arg2)),\n    )\n    .onBinary(\n      ['langString', 'langString'],\n      (arg1: E.LangStringLiteral, arg2: E.LangStringLiteral) => {\n        if (arg1.language !== arg2.language) {\n          throw new Err.IncompatibleLanguageOperation(arg1, arg2);\n        }\n        return bool(arg1.typedValue.includes(arg2.typedValue));\n      })\n    .collect(),\n};\n\nconst STRBEFORE = {\n  arity: 2,\n  overloads: declare()\n    .onBinaryTyped(\n      ['string', 'string'],\n      (arg1: string, arg2: string) => string(arg1.substr(0, arg1.indexOf(arg2))),\n    )\n    .onBinary(\n      ['langString', 'string'],\n      (arg1: E.LangStringLiteral, arg2: E.StringLiteral) => {\n        const [a1, a2] = [arg1.typedValue, arg2.typedValue];\n        const sub = arg1.typedValue.substr(0, a1.indexOf(a2));\n        return (sub || !a2) ? langString(sub, arg1.language) : string(sub);\n      },\n    )\n    .onBinary(\n      ['langString', 'langString'],\n      (arg1: E.LangStringLiteral, arg2: E.LangStringLiteral) => {\n        if (arg1.language !== arg2.language) {\n          throw new Err.IncompatibleLanguageOperation(arg1, arg2);\n        }\n        const [a1, a2] = [arg1.typedValue, arg2.typedValue];\n        const sub = arg1.typedValue.substr(0, a1.indexOf(a2));\n        return (sub || !a2) ? langString(sub, arg1.language) : string(sub);\n      })\n    .collect(),\n};\n\nconst STRAFTER = {\n  arity: 2,\n  overloads: declare()\n    .onBinaryTyped(\n      ['string', 'string'],\n      (arg1: string, arg2: string) => string(arg1.substr(arg1.indexOf(arg2)).substr(arg2.length)),\n    )\n    .onBinary(\n      ['langString', 'string'],\n      (arg1: E.LangStringLiteral, arg2: E.StringLiteral) => {\n        const [a1, a2] = [arg1.typedValue, arg2.typedValue];\n        const sub = a1.substr(a1.indexOf(a2)).substr(a2.length);\n        return (sub || !a2) ? langString(sub, arg1.language) : string(sub);\n      },\n    )\n    .onBinary(\n      ['langString', 'langString'],\n      (arg1: E.LangStringLiteral, arg2: E.LangStringLiteral) => {\n        if (arg1.language !== arg2.language) {\n          throw new Err.IncompatibleLanguageOperation(arg1, arg2);\n        }\n        const [a1, a2] = [arg1.typedValue, arg2.typedValue];\n        const sub = a1.substr(a1.indexOf(a2)).substr(a2.length);\n        return (sub || !a2) ? langString(sub, arg1.language) : string(sub);\n      })\n    .collect(),\n};\n\nconst ENCODE_FOR_URI = {\n  arity: 1,\n  overloads: declare()\n    .onStringly1Typed((val) => string(encodeURI(val))).collect(),\n};\n\n// See special operators\n// const CONCAT = {}\n\nconst langmatches = {\n  arity: 2,\n  overloads: declare()\n    .onBinaryTyped(\n      ['string', 'string'],\n      (tag: string, range: string) => bool(X.langMatches(tag, range)),\n    ).collect(),\n};\n\nconst regex2 = (text: string, pattern: string) => bool(X.matches(text, pattern));\nconst regex3 = (text: string, pattern: string, flags: string) => bool(X.matches(text, pattern, flags));\nconst REGEX = {\n  arity: [2, 3],\n  overloads: declare()\n    .onBinaryTyped(['string', 'string'], regex2)\n    .onBinaryTyped(['langString', 'string'], regex2)\n    .onTernaryTyped(['string', 'string', 'string'], regex3)\n    .onTernaryTyped(['langString', 'string', 'string'], regex3)\n    .collect(),\n};\n\nconst REPLACE = {\n  arity: [3, 4],\n  overloads: declare()\n    .onTernaryTyped(\n      ['string', 'string', 'string'],\n      (arg: string, pattern: string, replacement: string) =>\n        string(X.replace(arg, pattern, replacement)),\n    )\n    .set(\n      ['langString', 'string', 'string'],\n      ([arg, pattern, replacement]: [E.LangStringLiteral, E.StringLiteral, E.StringLiteral]) => {\n        const result = X.replace(arg.typedValue, pattern.typedValue, replacement.typedValue);\n        return langString(result, arg.language);\n      },\n    )\n    .onQuaternaryTyped(\n      ['string', 'string', 'string', 'string'],\n      (arg: string, pattern: string, replacement: string, flags: string) =>\n        string(X.replace(arg, pattern, replacement, flags)),\n    )\n    .set(\n      ['langString', 'string', 'string', 'string'],\n      ([arg, pattern, replacement, flags]\n        : [E.LangStringLiteral, E.StringLiteral, E.StringLiteral, E.StringLiteral]) => {\n        const result = X.replace(arg.typedValue, pattern.typedValue, replacement.typedValue, flags.typedValue);\n        return langString(result, arg.language);\n      },\n    )\n    .collect(),\n};\n\n// ----------------------------------------------------------------------------\n// Functions on numerics\n// https://www.w3.org/TR/sparql11-query/#func-numerics\n// ----------------------------------------------------------------------------\n\nconst abs = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1(\n      (num) => number(Math.abs(num.typedValue), num.typeURL.value as C.TypeURL))\n    .collect(),\n};\n\nconst round = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1(\n      (num) => number(Math.round(num.typedValue), num.typeURL.value as C.TypeURL))\n    .collect(),\n};\n\nconst ceil = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1(\n      (num) => number(Math.ceil(num.typedValue), num.typeURL.value as C.TypeURL))\n    .collect(),\n};\n\nconst floor = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1(\n      (num) => number(Math.floor(num.typedValue), num.typeURL.value as C.TypeURL))\n    .collect(),\n};\n\nconst rand = {\n  arity: 0,\n  overloads: declare()\n    .set([], () => number(Math.random(), TypeURL.XSD_DOUBLE))\n    .collect(),\n};\n\n// ----------------------------------------------------------------------------\n// Functions on Dates and Times\n// https://www.w3.org/TR/sparql11-query/#func-date-time\n// ----------------------------------------------------------------------------\n\nfunction parseDate(dateLit: E.DateTimeLiteral): P.SplittedDate {\n  return P.parseXSDDateTime(dateLit.str());\n}\n\n// See special operators\n// const now = {};\n\nconst year = {\n  arity: 1,\n  overloads: declare()\n    .onDateTime1(\n      (date) => number(Number(parseDate(date).year), TypeURL.XSD_INTEGER))\n    .collect(),\n};\n\nconst month = {\n  arity: 1,\n  overloads: declare()\n    .onDateTime1(\n      (date) => number(Number(parseDate(date).month), TypeURL.XSD_INTEGER))\n    .collect(),\n};\n\nconst day = {\n  arity: 1,\n  overloads: declare()\n    .onDateTime1(\n      (date) => number(Number(parseDate(date).day), TypeURL.XSD_INTEGER))\n    .collect(),\n};\n\nconst hours = {\n  arity: 1,\n  overloads: declare()\n    .onDateTime1(\n      (date) => number(Number(parseDate(date).hours), TypeURL.XSD_INTEGER))\n    .collect(),\n};\n\nconst minutes = {\n  arity: 1,\n  overloads: declare()\n    .onDateTime1(\n      (date) => number(Number(parseDate(date).minutes), TypeURL.XSD_INTEGER))\n    .collect(),\n};\n\nconst seconds = {\n  arity: 1,\n  overloads: declare()\n    .onDateTime1(\n      (date) => number(Number(parseDate(date).seconds), TypeURL.XSD_DECIMAL))\n    .collect(),\n};\n\nconst timezone = {\n  arity: 1,\n  overloads: declare()\n    .onDateTime1(\n      (date) => {\n        const duration = X.formatDayTimeDuration(parseDate(date).timezone);\n        if (!duration) {\n          throw new Err.InvalidTimezoneCall(date.strValue);\n        }\n        return new E.Literal(duration, C.make(TypeURL.XSD_DAYTIME_DURATION), duration);\n      },\n    )\n    .collect(),\n};\n\nconst tz = {\n  arity: 1,\n  overloads: declare()\n    .onDateTime1(\n      (date) => string(parseDate(date).timezone))\n    .collect(),\n};\n\n// ----------------------------------------------------------------------------\n// Hash functions\n// https://www.w3.org/TR/sparql11-query/#func-hash\n// ----------------------------------------------------------------------------\n\nconst MD5 = {\n  arity: 1,\n  overloads: declare()\n    .onString1Typed((str) => string(md5(str)))\n    .collect(),\n};\n\nconst SHA1 = {\n  arity: 1,\n  overloads: declare()\n    .onString1Typed((str) => string(sha1().update(str).digest('hex')))\n    .collect(),\n};\n\nconst SHA256 = {\n  arity: 1,\n  overloads: declare()\n    .onString1Typed((str) => string(sha256().update(str).digest('hex')))\n    .collect(),\n};\n\nconst SHA384 = {\n  arity: 1,\n  overloads: declare()\n    .onString1Typed((str) => string(sha384().update(str).digest('hex')))\n    .collect(),\n};\n\nconst SHA512 = {\n  arity: 1,\n  overloads: declare()\n    .onString1Typed((str) => string(sha512().update(str).digest('hex')))\n    .collect(),\n};\n\n// End definitions.\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\n/*\n * Collect all the definitions from above into an object\n */\nconst _definitions: { [key in C.RegularOperator]: Definition } = {\n  // --------------------------------------------------------------------------\n  // Operator Mapping\n  // https://www.w3.org/TR/sparql11-query/#OperatorMapping\n  // --------------------------------------------------------------------------\n  '!': not,\n  'UPLUS': unaryPlus,\n  'UMINUS': unaryMinus,\n  '*': multiplication,\n  '/': division,\n  '+': addition,\n  '-': subtraction,\n  '=': equality,\n  '!=': inequality,\n  '<': lesserThan,\n  '>': greaterThan,\n  '<=': lesserThanEqual,\n  '>=': greaterThanEqual,\n\n  // --------------------------------------------------------------------------\n  // Functions on RDF Terms\n  // https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n  // --------------------------------------------------------------------------\n  'isiri': isIRI,\n  'isblank': isBlank,\n  'isliteral': isLiteral,\n  'isnumeric': isNumeric,\n  'str': toString,\n  'lang': lang,\n  'datatype': datatype,\n  // 'iri': IRI (see special operators),\n  // 'uri': IRI (see special operators),\n  // 'BNODE': BNODE (see special operators),\n  'strdt': STRDT,\n  'strlang': STRLANG,\n  'uuid': UUID,\n  'struuid': STRUUID,\n\n  // --------------------------------------------------------------------------\n  // Functions on strings\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  'strlen': STRLEN,\n  'substr': SUBSTR,\n  'ucase': UCASE,\n  'lcase': LCASE,\n  'strstarts': STRSTARTS,\n  'strends': STRENDS,\n  'contains': CONTAINS,\n  'strbefore': STRBEFORE,\n  'strafter': STRAFTER,\n  'encode_for_uri': ENCODE_FOR_URI,\n  // 'concat': CONCAT (see special operators)\n  'langmatches': langmatches,\n  'regex': REGEX,\n  'replace': REPLACE,\n\n  // --------------------------------------------------------------------------\n  // Functions on numerics\n  // https://www.w3.org/TR/sparql11-query/#func-numerics\n  // --------------------------------------------------------------------------\n  'abs': abs,\n  'round': round,\n  'ceil': ceil,\n  'floor': floor,\n  'rand': rand,\n\n  // --------------------------------------------------------------------------\n  // Functions on Dates and Times\n  // https://www.w3.org/TR/sparql11-query/#func-date-time\n  // --------------------------------------------------------------------------\n  // 'now': now (see special operators),\n  'year': year,\n  'month': month,\n  'day': day,\n  'hours': hours,\n  'minutes': minutes,\n  'seconds': seconds,\n  'timezone': timezone,\n  'tz': tz,\n\n  // --------------------------------------------------------------------------\n  // Hash functions\n  // https://www.w3.org/TR/sparql11-query/#func-hash\n  // --------------------------------------------------------------------------\n  'md5': MD5,\n  'sha1': SHA1,\n  'sha256': SHA256,\n  'sha384': SHA384,\n  'sha512': SHA512,\n};\n\n// ----------------------------------------------------------------------------\n// The definitions and functionality for all operators\n// ----------------------------------------------------------------------------\n\nexport interface Definition {\n  arity: number | number[];\n  overloads: OverloadMap;\n}\n\nexport const definitions = Map<C.RegularOperator, Definition>(_definitions);\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}