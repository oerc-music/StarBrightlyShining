{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationFromQuad = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica From Query Operation Actor.\n */\n\n\nclass ActorQueryOperationFromQuad extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n  constructor(args) {\n    super(args, 'from');\n  }\n  /**\n   * Create a deep copy of the given operation.\n   * @param {Operation} operation An operation.\n   * @param {(subOperation: Operation) => Operation} recursiveCb A callback for recursive operation calls.\n   * @return {Operation} The copied operation.\n   */\n\n\n  static copyOperation(operation, recursiveCb) {\n    const copiedOperation = {};\n\n    for (const key of Object.keys(operation)) {\n      if (Array.isArray(operation[key])) {\n        if (key === 'variables') {\n          copiedOperation[key] = operation[key];\n        } else {\n          copiedOperation[key] = operation[key].map(recursiveCb);\n        }\n      } else if (ActorQueryOperationFromQuad.ALGEBRA_TYPES.includes(operation[key].type)) {\n        copiedOperation[key] = recursiveCb(operation[key]);\n      } else {\n        copiedOperation[key] = operation[key];\n      }\n    }\n\n    return copiedOperation;\n  }\n  /**\n   * Recursively transform the given operation to use the given graphs as default graph\n   * This will (possibly) create a new operation and not modify the given operation.\n   * @param {Operation} operation An operation.\n   * @param {RDF.Term[]} defaultGraphs Graph terms.\n   * @return {Operation} A new operation.\n   */\n\n\n  static applyOperationDefaultGraph(operation, defaultGraphs) {\n    // If the operation is a BGP or Path, change the graph.\n    if (operation.type === 'bgp' && operation.patterns.length > 0 || operation.type === 'path') {\n      if (operation.type === 'bgp') {\n        return ActorQueryOperationFromQuad.joinOperations(operation.patterns.map(pattern => {\n          if (pattern.graph.termType !== 'DefaultGraph') {\n            return ActorQueryOperationFromQuad.FACTORY.createBgp([pattern]);\n          }\n\n          const bgps = defaultGraphs.map(graph => ActorQueryOperationFromQuad.FACTORY.createBgp([ActorQueryOperationFromQuad.FACTORY.createPattern(pattern.subject, pattern.predicate, pattern.object, graph)]));\n          return ActorQueryOperationFromQuad.unionOperations(bgps);\n        }));\n      }\n\n      if (operation.graph.termType !== 'DefaultGraph') {\n        return operation;\n      }\n\n      const paths = defaultGraphs.map(graph => ActorQueryOperationFromQuad.FACTORY.createPath(operation.subject, operation.predicate, operation.object, graph));\n      return ActorQueryOperationFromQuad.joinOperations(paths);\n    }\n\n    return ActorQueryOperationFromQuad.copyOperation(operation, subOperation => this.applyOperationDefaultGraph(subOperation, defaultGraphs));\n  }\n  /**\n   * Recursively transform the given operation to use the given graphs as named graph\n   * This will (possibly) create a new operation and not modify the given operation.\n   * @param {Operation} operation An operation.\n   * @param {RDF.Term[]} namedGraphs Graph terms.\n   * @param {RDF.Term[]} defaultGraphs Default graph terms.\n   * @return {Operation} A new operation.\n   */\n\n\n  static applyOperationNamedGraph(operation, namedGraphs, defaultGraphs) {\n    // If the operation is a BGP or Path, change the graph.\n    if (operation.type === 'bgp' && operation.patterns.length > 0 || operation.type === 'path') {\n      const patternGraph = operation.type === 'bgp' ? operation.patterns[0].graph : operation.graph;\n\n      if (patternGraph.termType === 'DefaultGraph') {\n        // SPARQL spec (8.2) describes that when FROM NAMED's are used without a FROM, the default graph must be empty.\n        // The FROMs are transformed before this step to a named node, so this will not apply to this case anymore.\n        return {\n          type: 'bgp',\n          patterns: []\n        };\n      }\n\n      if (patternGraph.termType === 'Variable') {\n        if (namedGraphs.length === 1) {\n          const graph = namedGraphs[0]; // If the pattern graph is a variable, replace the graph and bind the variable using VALUES\n\n          const bindings = {};\n          bindings[`?${patternGraph.value}`] = graph;\n          const values = ActorQueryOperationFromQuad.FACTORY.createValues([patternGraph], [bindings]);\n          const pattern = operation.type === 'bgp' ? ActorQueryOperationFromQuad.FACTORY.createBgp(operation.patterns.map(pat => ActorQueryOperationFromQuad.FACTORY.createPattern(pat.subject, pat.predicate, pat.object, graph))) : ActorQueryOperationFromQuad.FACTORY.createPath(operation.subject, operation.predicate, operation.object, graph);\n          return ActorQueryOperationFromQuad.FACTORY.createJoin(values, pattern);\n        } // If the pattern graph is a variable, take the union of the pattern applied to each available named graph\n\n\n        return ActorQueryOperationFromQuad.unionOperations(namedGraphs.map(graph => ActorQueryOperationFromQuad.applyOperationNamedGraph(operation, [graph], defaultGraphs)));\n      } // The pattern's graph is defined (including the default graphs)\n\n\n      const isNamedGraphAvailable = [...namedGraphs, ...defaultGraphs].some(namedGraph => namedGraph.equals(patternGraph));\n\n      if (isNamedGraphAvailable) {\n        // Return the pattern as-is if the pattern's graph was selected in a FROM NAMED\n        return operation;\n      } // No-op if the pattern's graph was not selected in a FROM NAMED.\n\n\n      return {\n        type: 'bgp',\n        patterns: []\n      };\n    }\n\n    return ActorQueryOperationFromQuad.copyOperation(operation, subOperation => this.applyOperationNamedGraph(subOperation, namedGraphs, defaultGraphs));\n  }\n  /**\n   * Transform the given array of operations into a join operation.\n   * @param {Operation[]} operations An array of operations, must contain at least one operation.\n   * @return {Join} A join operation.\n   */\n\n\n  static joinOperations(operations) {\n    if (operations.length === 1) {\n      return operations[0];\n    }\n\n    if (operations.length === 2) {\n      return ActorQueryOperationFromQuad.FACTORY.createJoin(operations[0], operations[1]);\n    }\n\n    if (operations.length > 2) {\n      return ActorQueryOperationFromQuad.FACTORY.createJoin(operations.shift(), this.joinOperations(operations));\n    }\n\n    throw new Error('A join can only be applied on at least one operation');\n  }\n  /**\n   * Transform the given array of operations into a union operation.\n   * @param {Operation[]} operations An array of operations, must contain at least one operation.\n   * @return {Union} A union operation.\n   */\n\n\n  static unionOperations(operations) {\n    if (operations.length === 1) {\n      return operations[0];\n    }\n\n    if (operations.length === 2) {\n      return ActorQueryOperationFromQuad.FACTORY.createUnion(operations[0], operations[1]);\n    }\n\n    if (operations.length > 2) {\n      return ActorQueryOperationFromQuad.FACTORY.createUnion(operations.shift(), this.unionOperations(operations));\n    }\n\n    throw new Error('A union can only be applied on at least one operation');\n  }\n  /**\n   * Transform an operation based on the default and named graphs in the pattern.\n   *\n   * FROM sets the default graph.\n   * If multiple are available, take the union of the operation for all of them at quad-pattern level.\n   *\n   * FROM NAMED indicates which named graphs are available.\n   * This will rewrite the query so that only triples from the given named graphs can be selected.\n   *\n   * @param {From} pattern A from operation.\n   * @return {Operation} The transformed operation.\n   */\n\n\n  static createOperation(pattern) {\n    let operation = pattern.input;\n\n    if (pattern.default.length > 0) {\n      operation = ActorQueryOperationFromQuad.applyOperationDefaultGraph(operation, pattern.default);\n    }\n\n    if (pattern.named.length > 0 || pattern.default.length > 0) {\n      operation = ActorQueryOperationFromQuad.applyOperationNamedGraph(operation, pattern.named, pattern.default);\n    }\n\n    return operation;\n  }\n\n  async testOperation(pattern, context) {\n    return true;\n  }\n\n  async runOperation(pattern, context) {\n    const operation = ActorQueryOperationFromQuad.createOperation(pattern);\n    return this.mediatorQueryOperation.mediate({\n      operation,\n      context\n    });\n  }\n\n}\n\nexports.ActorQueryOperationFromQuad = ActorQueryOperationFromQuad;\nActorQueryOperationFromQuad.FACTORY = new sparqlalgebrajs_1.Factory();\nActorQueryOperationFromQuad.ALGEBRA_TYPES = Object.keys(sparqlalgebrajs_1.Algebra.types).map(key => sparqlalgebrajs_1.Algebra.types[key]);","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-from-quad/lib/ActorQueryOperationFromQuad.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationFromQuad","bus_query_operation_1","require","sparqlalgebrajs_1","ActorQueryOperationTypedMediated","constructor","args","copyOperation","operation","recursiveCb","copiedOperation","key","keys","Array","isArray","map","ALGEBRA_TYPES","includes","type","applyOperationDefaultGraph","defaultGraphs","patterns","length","joinOperations","pattern","graph","termType","FACTORY","createBgp","bgps","createPattern","subject","predicate","object","unionOperations","paths","createPath","subOperation","applyOperationNamedGraph","namedGraphs","patternGraph","bindings","values","createValues","pat","createJoin","isNamedGraphAvailable","some","namedGraph","equals","operations","shift","Error","createUnion","createOperation","input","default","named","testOperation","context","runOperation","mediatorQueryOperation","mediate","Factory","Algebra","types"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,2BAAR,GAAsC,KAAK,CAA3C;;AACA,MAAMC,qBAAqB,GAAGC,OAAO,CAAC,+BAAD,CAArC;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,iBAAD,CAAjC;AACA;AACA;AACA;;;AACA,MAAMF,2BAAN,SAA0CC,qBAAqB,CAACG,gCAAhE,CAAiG;AAC7FC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAMA,IAAN,EAAY,MAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACwB,SAAbC,aAAa,CAACC,SAAD,EAAYC,WAAZ,EAAyB;AACzC,UAAMC,eAAe,GAAG,EAAxB;;AACA,SAAK,MAAMC,GAAX,IAAkBf,MAAM,CAACgB,IAAP,CAAYJ,SAAZ,CAAlB,EAA0C;AACtC,UAAIK,KAAK,CAACC,OAAN,CAAcN,SAAS,CAACG,GAAD,CAAvB,CAAJ,EAAmC;AAC/B,YAAIA,GAAG,KAAK,WAAZ,EAAyB;AACrBD,UAAAA,eAAe,CAACC,GAAD,CAAf,GAAuBH,SAAS,CAACG,GAAD,CAAhC;AACH,SAFD,MAGK;AACDD,UAAAA,eAAe,CAACC,GAAD,CAAf,GAAuBH,SAAS,CAACG,GAAD,CAAT,CAAeI,GAAf,CAAmBN,WAAnB,CAAvB;AACH;AACJ,OAPD,MAQK,IAAIT,2BAA2B,CAACgB,aAA5B,CAA0CC,QAA1C,CAAmDT,SAAS,CAACG,GAAD,CAAT,CAAeO,IAAlE,CAAJ,EAA6E;AAC9ER,QAAAA,eAAe,CAACC,GAAD,CAAf,GAAuBF,WAAW,CAACD,SAAS,CAACG,GAAD,CAAV,CAAlC;AACH,OAFI,MAGA;AACDD,QAAAA,eAAe,CAACC,GAAD,CAAf,GAAuBH,SAAS,CAACG,GAAD,CAAhC;AACH;AACJ;;AACD,WAAOD,eAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACqC,SAA1BS,0BAA0B,CAACX,SAAD,EAAYY,aAAZ,EAA2B;AACxD;AACA,QAAKZ,SAAS,CAACU,IAAV,KAAmB,KAAnB,IAA4BV,SAAS,CAACa,QAAV,CAAmBC,MAAnB,GAA4B,CAAzD,IAA+Dd,SAAS,CAACU,IAAV,KAAmB,MAAtF,EAA8F;AAC1F,UAAIV,SAAS,CAACU,IAAV,KAAmB,KAAvB,EAA8B;AAC1B,eAAOlB,2BAA2B,CAACuB,cAA5B,CAA2Cf,SAAS,CAACa,QAAV,CAAmBN,GAAnB,CAAwBS,OAAD,IAAa;AAClF,cAAIA,OAAO,CAACC,KAAR,CAAcC,QAAd,KAA2B,cAA/B,EAA+C;AAC3C,mBAAO1B,2BAA2B,CAAC2B,OAA5B,CAAoCC,SAApC,CAA8C,CAACJ,OAAD,CAA9C,CAAP;AACH;;AACD,gBAAMK,IAAI,GAAGT,aAAa,CAACL,GAAd,CAAmBU,KAAD,IAAWzB,2BAA2B,CAAC2B,OAA5B,CAAoCC,SAApC,CAA8C,CAAC5B,2BAA2B,CAAC2B,OAA5B,CAChFG,aADgF,CAClEN,OAAO,CAACO,OAD0D,EACjDP,OAAO,CAACQ,SADyC,EAC9BR,OAAO,CAACS,MADsB,EACdR,KADc,CAAD,CAA9C,CAA7B,CAAb;AAEA,iBAAOzB,2BAA2B,CAACkC,eAA5B,CAA4CL,IAA5C,CAAP;AACH,SAPiD,CAA3C,CAAP;AAQH;;AACD,UAAIrB,SAAS,CAACiB,KAAV,CAAgBC,QAAhB,KAA6B,cAAjC,EAAiD;AAC7C,eAAOlB,SAAP;AACH;;AACD,YAAM2B,KAAK,GAAGf,aAAa,CAACL,GAAd,CAAmBU,KAAD,IAAWzB,2BAA2B,CAAC2B,OAA5B,CACtCS,UADsC,CAC3B5B,SAAS,CAACuB,OADiB,EACRvB,SAAS,CAACwB,SADF,EACaxB,SAAS,CAACyB,MADvB,EAC+BR,KAD/B,CAA7B,CAAd;AAEA,aAAOzB,2BAA2B,CAACuB,cAA5B,CAA2CY,KAA3C,CAAP;AACH;;AACD,WAAOnC,2BAA2B,CAACO,aAA5B,CAA0CC,SAA1C,EAAsD6B,YAAD,IAAkB,KAAKlB,0BAAL,CAAgCkB,YAAhC,EAA8CjB,aAA9C,CAAvE,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmC,SAAxBkB,wBAAwB,CAAC9B,SAAD,EAAY+B,WAAZ,EAAyBnB,aAAzB,EAAwC;AACnE;AACA,QAAKZ,SAAS,CAACU,IAAV,KAAmB,KAAnB,IAA4BV,SAAS,CAACa,QAAV,CAAmBC,MAAnB,GAA4B,CAAzD,IAA+Dd,SAAS,CAACU,IAAV,KAAmB,MAAtF,EAA8F;AAC1F,YAAMsB,YAAY,GAAGhC,SAAS,CAACU,IAAV,KAAmB,KAAnB,GAA2BV,SAAS,CAACa,QAAV,CAAmB,CAAnB,EAAsBI,KAAjD,GAAyDjB,SAAS,CAACiB,KAAxF;;AACA,UAAIe,YAAY,CAACd,QAAb,KAA0B,cAA9B,EAA8C;AAC1C;AACA;AACA,eAAO;AAAER,UAAAA,IAAI,EAAE,KAAR;AAAeG,UAAAA,QAAQ,EAAE;AAAzB,SAAP;AACH;;AACD,UAAImB,YAAY,CAACd,QAAb,KAA0B,UAA9B,EAA0C;AACtC,YAAIa,WAAW,CAACjB,MAAZ,KAAuB,CAA3B,EAA8B;AAC1B,gBAAMG,KAAK,GAAGc,WAAW,CAAC,CAAD,CAAzB,CAD0B,CAE1B;;AACA,gBAAME,QAAQ,GAAG,EAAjB;AACAA,UAAAA,QAAQ,CAAE,IAAGD,YAAY,CAACzC,KAAM,EAAxB,CAAR,GAAqC0B,KAArC;AACA,gBAAMiB,MAAM,GAAG1C,2BAA2B,CAAC2B,OAA5B,CACVgB,YADU,CACG,CAACH,YAAD,CADH,EACmB,CAACC,QAAD,CADnB,CAAf;AAEA,gBAAMjB,OAAO,GAAGhB,SAAS,CAACU,IAAV,KAAmB,KAAnB,GACZlB,2BAA2B,CAAC2B,OAA5B,CACKC,SADL,CACepB,SAAS,CAACa,QAAV,CAAmBN,GAAnB,CAAwB6B,GAAD,IAAS5C,2BAA2B,CAAC2B,OAA5B,CAC1CG,aAD0C,CAC5Bc,GAAG,CAACb,OADwB,EACfa,GAAG,CAACZ,SADW,EACAY,GAAG,CAACX,MADJ,EACYR,KADZ,CAAhC,CADf,CADY,GAIZzB,2BAA2B,CAAC2B,OAA5B,CACKS,UADL,CACgB5B,SAAS,CAACuB,OAD1B,EACmCvB,SAAS,CAACwB,SAD7C,EACwDxB,SAAS,CAACyB,MADlE,EAC0ER,KAD1E,CAJJ;AAMA,iBAAOzB,2BAA2B,CAAC2B,OAA5B,CAAoCkB,UAApC,CAA+CH,MAA/C,EAAuDlB,OAAvD,CAAP;AACH,SAfqC,CAgBtC;;;AACA,eAAOxB,2BAA2B,CAACkC,eAA5B,CAA4CK,WAAW,CAACxB,GAAZ,CAAiBU,KAAD,IAAWzB,2BAA2B,CAACsC,wBAA5B,CAAqD9B,SAArD,EAAgE,CAACiB,KAAD,CAAhE,EAAyEL,aAAzE,CAA3B,CAA5C,CAAP;AACH,OAzByF,CA0B1F;;;AACA,YAAM0B,qBAAqB,GAAG,CAAC,GAAGP,WAAJ,EAAiB,GAAGnB,aAApB,EAAmC2B,IAAnC,CAAyCC,UAAD,IAAgBA,UAAU,CAACC,MAAX,CAAkBT,YAAlB,CAAxD,CAA9B;;AACA,UAAIM,qBAAJ,EAA2B;AACvB;AACA,eAAOtC,SAAP;AACH,OA/ByF,CAgC1F;;;AACA,aAAO;AAAEU,QAAAA,IAAI,EAAE,KAAR;AAAeG,QAAAA,QAAQ,EAAE;AAAzB,OAAP;AACH;;AACD,WAAOrB,2BAA2B,CAACO,aAA5B,CAA0CC,SAA1C,EAAsD6B,YAAD,IAAkB,KAAKC,wBAAL,CAA8BD,YAA9B,EAA4CE,WAA5C,EAAyDnB,aAAzD,CAAvE,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACyB,SAAdG,cAAc,CAAC2B,UAAD,EAAa;AAC9B,QAAIA,UAAU,CAAC5B,MAAX,KAAsB,CAA1B,EAA6B;AACzB,aAAO4B,UAAU,CAAC,CAAD,CAAjB;AACH;;AACD,QAAIA,UAAU,CAAC5B,MAAX,KAAsB,CAA1B,EAA6B;AACzB,aAAOtB,2BAA2B,CAAC2B,OAA5B,CAAoCkB,UAApC,CAA+CK,UAAU,CAAC,CAAD,CAAzD,EAA8DA,UAAU,CAAC,CAAD,CAAxE,CAAP;AACH;;AACD,QAAIA,UAAU,CAAC5B,MAAX,GAAoB,CAAxB,EAA2B;AACvB,aAAOtB,2BAA2B,CAAC2B,OAA5B,CAAoCkB,UAApC,CAA+CK,UAAU,CAACC,KAAX,EAA/C,EAAmE,KAAK5B,cAAL,CAAoB2B,UAApB,CAAnE,CAAP;AACH;;AACD,UAAM,IAAIE,KAAJ,CAAU,sDAAV,CAAN;AACH;AACD;AACJ;AACA;AACA;AACA;;;AAC0B,SAAflB,eAAe,CAACgB,UAAD,EAAa;AAC/B,QAAIA,UAAU,CAAC5B,MAAX,KAAsB,CAA1B,EAA6B;AACzB,aAAO4B,UAAU,CAAC,CAAD,CAAjB;AACH;;AACD,QAAIA,UAAU,CAAC5B,MAAX,KAAsB,CAA1B,EAA6B;AACzB,aAAOtB,2BAA2B,CAAC2B,OAA5B,CAAoC0B,WAApC,CAAgDH,UAAU,CAAC,CAAD,CAA1D,EAA+DA,UAAU,CAAC,CAAD,CAAzE,CAAP;AACH;;AACD,QAAIA,UAAU,CAAC5B,MAAX,GAAoB,CAAxB,EAA2B;AACvB,aAAOtB,2BAA2B,CAAC2B,OAA5B,CAAoC0B,WAApC,CAAgDH,UAAU,CAACC,KAAX,EAAhD,EAAoE,KAAKjB,eAAL,CAAqBgB,UAArB,CAApE,CAAP;AACH;;AACD,UAAM,IAAIE,KAAJ,CAAU,uDAAV,CAAN;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC0B,SAAfE,eAAe,CAAC9B,OAAD,EAAU;AAC5B,QAAIhB,SAAS,GAAGgB,OAAO,CAAC+B,KAAxB;;AACA,QAAI/B,OAAO,CAACgC,OAAR,CAAgBlC,MAAhB,GAAyB,CAA7B,EAAgC;AAC5Bd,MAAAA,SAAS,GAAGR,2BAA2B,CAACmB,0BAA5B,CAAuDX,SAAvD,EAAkEgB,OAAO,CAACgC,OAA1E,CAAZ;AACH;;AACD,QAAIhC,OAAO,CAACiC,KAAR,CAAcnC,MAAd,GAAuB,CAAvB,IAA4BE,OAAO,CAACgC,OAAR,CAAgBlC,MAAhB,GAAyB,CAAzD,EAA4D;AACxDd,MAAAA,SAAS,GAAGR,2BAA2B,CAACsC,wBAA5B,CAAqD9B,SAArD,EAAgEgB,OAAO,CAACiC,KAAxE,EAA+EjC,OAAO,CAACgC,OAAvF,CAAZ;AACH;;AACD,WAAOhD,SAAP;AACH;;AACkB,QAAbkD,aAAa,CAAClC,OAAD,EAAUmC,OAAV,EAAmB;AAClC,WAAO,IAAP;AACH;;AACiB,QAAZC,YAAY,CAACpC,OAAD,EAAUmC,OAAV,EAAmB;AACjC,UAAMnD,SAAS,GAAGR,2BAA2B,CAACsD,eAA5B,CAA4C9B,OAA5C,CAAlB;AACA,WAAO,KAAKqC,sBAAL,CAA4BC,OAA5B,CAAoC;AAAEtD,MAAAA,SAAF;AAAamD,MAAAA;AAAb,KAApC,CAAP;AACH;;AAxK4F;;AA0KjG7D,OAAO,CAACE,2BAAR,GAAsCA,2BAAtC;AACAA,2BAA2B,CAAC2B,OAA5B,GAAsC,IAAIxB,iBAAiB,CAAC4D,OAAtB,EAAtC;AACA/D,2BAA2B,CAACgB,aAA5B,GAA4CpB,MAAM,CAACgB,IAAP,CAAYT,iBAAiB,CAAC6D,OAAlB,CAA0BC,KAAtC,EAA6ClD,GAA7C,CAAiDJ,GAAG,IAAIR,iBAAiB,CAAC6D,OAAlB,CAA0BC,KAA1B,CAAgCtD,GAAhC,CAAxD,CAA5C","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationFromQuad = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica From Query Operation Actor.\n */\nclass ActorQueryOperationFromQuad extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n    constructor(args) {\n        super(args, 'from');\n    }\n    /**\n     * Create a deep copy of the given operation.\n     * @param {Operation} operation An operation.\n     * @param {(subOperation: Operation) => Operation} recursiveCb A callback for recursive operation calls.\n     * @return {Operation} The copied operation.\n     */\n    static copyOperation(operation, recursiveCb) {\n        const copiedOperation = {};\n        for (const key of Object.keys(operation)) {\n            if (Array.isArray(operation[key])) {\n                if (key === 'variables') {\n                    copiedOperation[key] = operation[key];\n                }\n                else {\n                    copiedOperation[key] = operation[key].map(recursiveCb);\n                }\n            }\n            else if (ActorQueryOperationFromQuad.ALGEBRA_TYPES.includes(operation[key].type)) {\n                copiedOperation[key] = recursiveCb(operation[key]);\n            }\n            else {\n                copiedOperation[key] = operation[key];\n            }\n        }\n        return copiedOperation;\n    }\n    /**\n     * Recursively transform the given operation to use the given graphs as default graph\n     * This will (possibly) create a new operation and not modify the given operation.\n     * @param {Operation} operation An operation.\n     * @param {RDF.Term[]} defaultGraphs Graph terms.\n     * @return {Operation} A new operation.\n     */\n    static applyOperationDefaultGraph(operation, defaultGraphs) {\n        // If the operation is a BGP or Path, change the graph.\n        if ((operation.type === 'bgp' && operation.patterns.length > 0) || operation.type === 'path') {\n            if (operation.type === 'bgp') {\n                return ActorQueryOperationFromQuad.joinOperations(operation.patterns.map((pattern) => {\n                    if (pattern.graph.termType !== 'DefaultGraph') {\n                        return ActorQueryOperationFromQuad.FACTORY.createBgp([pattern]);\n                    }\n                    const bgps = defaultGraphs.map((graph) => ActorQueryOperationFromQuad.FACTORY.createBgp([ActorQueryOperationFromQuad.FACTORY\n                            .createPattern(pattern.subject, pattern.predicate, pattern.object, graph)]));\n                    return ActorQueryOperationFromQuad.unionOperations(bgps);\n                }));\n            }\n            if (operation.graph.termType !== 'DefaultGraph') {\n                return operation;\n            }\n            const paths = defaultGraphs.map((graph) => ActorQueryOperationFromQuad.FACTORY\n                .createPath(operation.subject, operation.predicate, operation.object, graph));\n            return ActorQueryOperationFromQuad.joinOperations(paths);\n        }\n        return ActorQueryOperationFromQuad.copyOperation(operation, (subOperation) => this.applyOperationDefaultGraph(subOperation, defaultGraphs));\n    }\n    /**\n     * Recursively transform the given operation to use the given graphs as named graph\n     * This will (possibly) create a new operation and not modify the given operation.\n     * @param {Operation} operation An operation.\n     * @param {RDF.Term[]} namedGraphs Graph terms.\n     * @param {RDF.Term[]} defaultGraphs Default graph terms.\n     * @return {Operation} A new operation.\n     */\n    static applyOperationNamedGraph(operation, namedGraphs, defaultGraphs) {\n        // If the operation is a BGP or Path, change the graph.\n        if ((operation.type === 'bgp' && operation.patterns.length > 0) || operation.type === 'path') {\n            const patternGraph = operation.type === 'bgp' ? operation.patterns[0].graph : operation.graph;\n            if (patternGraph.termType === 'DefaultGraph') {\n                // SPARQL spec (8.2) describes that when FROM NAMED's are used without a FROM, the default graph must be empty.\n                // The FROMs are transformed before this step to a named node, so this will not apply to this case anymore.\n                return { type: 'bgp', patterns: [] };\n            }\n            if (patternGraph.termType === 'Variable') {\n                if (namedGraphs.length === 1) {\n                    const graph = namedGraphs[0];\n                    // If the pattern graph is a variable, replace the graph and bind the variable using VALUES\n                    const bindings = {};\n                    bindings[`?${patternGraph.value}`] = graph;\n                    const values = ActorQueryOperationFromQuad.FACTORY\n                        .createValues([patternGraph], [bindings]);\n                    const pattern = operation.type === 'bgp' ?\n                        ActorQueryOperationFromQuad.FACTORY\n                            .createBgp(operation.patterns.map((pat) => ActorQueryOperationFromQuad.FACTORY\n                            .createPattern(pat.subject, pat.predicate, pat.object, graph))) :\n                        ActorQueryOperationFromQuad.FACTORY\n                            .createPath(operation.subject, operation.predicate, operation.object, graph);\n                    return ActorQueryOperationFromQuad.FACTORY.createJoin(values, pattern);\n                }\n                // If the pattern graph is a variable, take the union of the pattern applied to each available named graph\n                return ActorQueryOperationFromQuad.unionOperations(namedGraphs.map((graph) => ActorQueryOperationFromQuad.applyOperationNamedGraph(operation, [graph], defaultGraphs)));\n            }\n            // The pattern's graph is defined (including the default graphs)\n            const isNamedGraphAvailable = [...namedGraphs, ...defaultGraphs].some((namedGraph) => namedGraph.equals(patternGraph));\n            if (isNamedGraphAvailable) {\n                // Return the pattern as-is if the pattern's graph was selected in a FROM NAMED\n                return operation;\n            }\n            // No-op if the pattern's graph was not selected in a FROM NAMED.\n            return { type: 'bgp', patterns: [] };\n        }\n        return ActorQueryOperationFromQuad.copyOperation(operation, (subOperation) => this.applyOperationNamedGraph(subOperation, namedGraphs, defaultGraphs));\n    }\n    /**\n     * Transform the given array of operations into a join operation.\n     * @param {Operation[]} operations An array of operations, must contain at least one operation.\n     * @return {Join} A join operation.\n     */\n    static joinOperations(operations) {\n        if (operations.length === 1) {\n            return operations[0];\n        }\n        if (operations.length === 2) {\n            return ActorQueryOperationFromQuad.FACTORY.createJoin(operations[0], operations[1]);\n        }\n        if (operations.length > 2) {\n            return ActorQueryOperationFromQuad.FACTORY.createJoin(operations.shift(), this.joinOperations(operations));\n        }\n        throw new Error('A join can only be applied on at least one operation');\n    }\n    /**\n     * Transform the given array of operations into a union operation.\n     * @param {Operation[]} operations An array of operations, must contain at least one operation.\n     * @return {Union} A union operation.\n     */\n    static unionOperations(operations) {\n        if (operations.length === 1) {\n            return operations[0];\n        }\n        if (operations.length === 2) {\n            return ActorQueryOperationFromQuad.FACTORY.createUnion(operations[0], operations[1]);\n        }\n        if (operations.length > 2) {\n            return ActorQueryOperationFromQuad.FACTORY.createUnion(operations.shift(), this.unionOperations(operations));\n        }\n        throw new Error('A union can only be applied on at least one operation');\n    }\n    /**\n     * Transform an operation based on the default and named graphs in the pattern.\n     *\n     * FROM sets the default graph.\n     * If multiple are available, take the union of the operation for all of them at quad-pattern level.\n     *\n     * FROM NAMED indicates which named graphs are available.\n     * This will rewrite the query so that only triples from the given named graphs can be selected.\n     *\n     * @param {From} pattern A from operation.\n     * @return {Operation} The transformed operation.\n     */\n    static createOperation(pattern) {\n        let operation = pattern.input;\n        if (pattern.default.length > 0) {\n            operation = ActorQueryOperationFromQuad.applyOperationDefaultGraph(operation, pattern.default);\n        }\n        if (pattern.named.length > 0 || pattern.default.length > 0) {\n            operation = ActorQueryOperationFromQuad.applyOperationNamedGraph(operation, pattern.named, pattern.default);\n        }\n        return operation;\n    }\n    async testOperation(pattern, context) {\n        return true;\n    }\n    async runOperation(pattern, context) {\n        const operation = ActorQueryOperationFromQuad.createOperation(pattern);\n        return this.mediatorQueryOperation.mediate({ operation, context });\n    }\n}\nexports.ActorQueryOperationFromQuad = ActorQueryOperationFromQuad;\nActorQueryOperationFromQuad.FACTORY = new sparqlalgebrajs_1.Factory();\nActorQueryOperationFromQuad.ALGEBRA_TYPES = Object.keys(sparqlalgebrajs_1.Algebra.types).map(key => sparqlalgebrajs_1.Algebra.types[key]);\n//# sourceMappingURL=ActorQueryOperationFromQuad.js.map"]},"metadata":{},"sourceType":"script"}