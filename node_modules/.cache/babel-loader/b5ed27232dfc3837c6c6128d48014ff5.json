{"ast":null,"code":"/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict'; // eslint-disable-next-line no-unused-vars\n\nconst TERMS = ['subject', 'predicate', 'object', 'graph'];\nconst RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nconst RDF_LANGSTRING = RDF + 'langString';\nconst XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\nconst TYPE_NAMED_NODE = 'NamedNode';\nconst TYPE_BLANK_NODE = 'BlankNode';\nconst TYPE_LITERAL = 'Literal';\nconst TYPE_DEFAULT_GRAPH = 'DefaultGraph'; // build regexes\n\nconst REGEX = {};\n\n(() => {\n  const iri = '(?:<([^:]+:[^>]*)>)'; // https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL\n\n  const PN_CHARS_BASE = 'A-Z' + 'a-z' + '\\u00C0-\\u00D6' + '\\u00D8-\\u00F6' + '\\u00F8-\\u02FF' + '\\u0370-\\u037D' + '\\u037F-\\u1FFF' + '\\u200C-\\u200D' + '\\u2070-\\u218F' + '\\u2C00-\\u2FEF' + '\\u3001-\\uD7FF' + '\\uF900-\\uFDCF' + '\\uFDF0-\\uFFFD'; // TODO:\n  //'\\u10000-\\uEFFFF';\n\n  const PN_CHARS_U = PN_CHARS_BASE + '_';\n  const PN_CHARS = PN_CHARS_U + '0-9' + '-' + '\\u00B7' + '\\u0300-\\u036F' + '\\u203F-\\u2040';\n  const BLANK_NODE_LABEL = '(_:' + '(?:[' + PN_CHARS_U + '0-9])' + '(?:(?:[' + PN_CHARS + '.])*(?:[' + PN_CHARS + ']))?' + ')';\n  const bnode = BLANK_NODE_LABEL;\n  const plain = '\"([^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*)\"';\n  const datatype = '(?:\\\\^\\\\^' + iri + ')';\n  const language = '(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))';\n  const literal = '(?:' + plain + '(?:' + datatype + '|' + language + ')?)';\n  const ws = '[ \\\\t]+';\n  const wso = '[ \\\\t]*'; // define quad part regexes\n\n  const subject = '(?:' + iri + '|' + bnode + ')' + ws;\n  const property = iri + ws;\n  const object = '(?:' + iri + '|' + bnode + '|' + literal + ')' + wso;\n  const graphName = '(?:\\\\.|(?:(?:' + iri + '|' + bnode + ')' + wso + '\\\\.))'; // end of line and empty regexes\n\n  REGEX.eoln = /(?:\\r\\n)|(?:\\n)|(?:\\r)/g;\n  REGEX.empty = new RegExp('^' + wso + '$'); // full quad regex\n\n  REGEX.quad = new RegExp('^' + wso + subject + property + object + graphName + wso + '$');\n})();\n\nmodule.exports = class NQuads {\n  /**\n   * Parses RDF in the form of N-Quads.\n   *\n   * @param input the N-Quads input to parse.\n   *\n   * @return an RDF dataset (an array of quads per http://rdf.js.org/).\n   */\n  static parse(input) {\n    // build RDF dataset\n    const dataset = [];\n    const graphs = {}; // split N-Quad input into lines\n\n    const lines = input.split(REGEX.eoln);\n    let lineNumber = 0;\n\n    for (const line of lines) {\n      lineNumber++; // skip empty lines\n\n      if (REGEX.empty.test(line)) {\n        continue;\n      } // parse quad\n\n\n      const match = line.match(REGEX.quad);\n\n      if (match === null) {\n        throw new Error('N-Quads parse error on line ' + lineNumber + '.');\n      } // create RDF quad\n\n\n      const quad = {\n        subject: null,\n        predicate: null,\n        object: null,\n        graph: null\n      }; // get subject\n\n      if (match[1] !== undefined) {\n        quad.subject = {\n          termType: TYPE_NAMED_NODE,\n          value: match[1]\n        };\n      } else {\n        quad.subject = {\n          termType: TYPE_BLANK_NODE,\n          value: match[2]\n        };\n      } // get predicate\n\n\n      quad.predicate = {\n        termType: TYPE_NAMED_NODE,\n        value: match[3]\n      }; // get object\n\n      if (match[4] !== undefined) {\n        quad.object = {\n          termType: TYPE_NAMED_NODE,\n          value: match[4]\n        };\n      } else if (match[5] !== undefined) {\n        quad.object = {\n          termType: TYPE_BLANK_NODE,\n          value: match[5]\n        };\n      } else {\n        quad.object = {\n          termType: TYPE_LITERAL,\n          value: undefined,\n          datatype: {\n            termType: TYPE_NAMED_NODE\n          }\n        };\n\n        if (match[7] !== undefined) {\n          quad.object.datatype.value = match[7];\n        } else if (match[8] !== undefined) {\n          quad.object.datatype.value = RDF_LANGSTRING;\n          quad.object.language = match[8];\n        } else {\n          quad.object.datatype.value = XSD_STRING;\n        }\n\n        quad.object.value = _unescape(match[6]);\n      } // get graph\n\n\n      if (match[9] !== undefined) {\n        quad.graph = {\n          termType: TYPE_NAMED_NODE,\n          value: match[9]\n        };\n      } else if (match[10] !== undefined) {\n        quad.graph = {\n          termType: TYPE_BLANK_NODE,\n          value: match[10]\n        };\n      } else {\n        quad.graph = {\n          termType: TYPE_DEFAULT_GRAPH,\n          value: ''\n        };\n      } // only add quad if it is unique in its graph\n\n\n      if (!(quad.graph.value in graphs)) {\n        graphs[quad.graph.value] = [quad];\n        dataset.push(quad);\n      } else {\n        let unique = true;\n        const quads = graphs[quad.graph.value];\n\n        for (const q of quads) {\n          if (_compareTriples(q, quad)) {\n            unique = false;\n            break;\n          }\n        }\n\n        if (unique) {\n          quads.push(quad);\n          dataset.push(quad);\n        }\n      }\n    }\n\n    return dataset;\n  }\n  /**\n   * Converts an RDF dataset to N-Quads.\n   *\n   * @param dataset (array of quads) the RDF dataset to convert.\n   *\n   * @return the N-Quads string.\n   */\n\n\n  static serialize(dataset) {\n    if (!Array.isArray(dataset)) {\n      dataset = NQuads.legacyDatasetToQuads(dataset);\n    }\n\n    const quads = [];\n\n    for (const quad of dataset) {\n      quads.push(NQuads.serializeQuad(quad));\n    }\n\n    return quads.sort().join('');\n  }\n  /**\n   * Converts an RDF quad to an N-Quad string (a single quad).\n   *\n   * @param quad the RDF quad convert.\n   *\n   * @return the N-Quad string.\n   */\n\n\n  static serializeQuad(quad) {\n    const s = quad.subject;\n    const p = quad.predicate;\n    const o = quad.object;\n    const g = quad.graph;\n    let nquad = ''; // subject can only be NamedNode or BlankNode\n\n    if (s.termType === TYPE_NAMED_NODE) {\n      nquad += `<${s.value}>`;\n    } else {\n      nquad += `${s.value}`;\n    } // predicate can only be NamedNode\n\n\n    nquad += ` <${p.value}> `; // object is NamedNode, BlankNode, or Literal\n\n    if (o.termType === TYPE_NAMED_NODE) {\n      nquad += `<${o.value}>`;\n    } else if (o.termType === TYPE_BLANK_NODE) {\n      nquad += o.value;\n    } else {\n      nquad += `\"${_escape(o.value)}\"`;\n\n      if (o.datatype.value === RDF_LANGSTRING) {\n        if (o.language) {\n          nquad += `@${o.language}`;\n        }\n      } else if (o.datatype.value !== XSD_STRING) {\n        nquad += `^^<${o.datatype.value}>`;\n      }\n    } // graph can only be NamedNode or BlankNode (or DefaultGraph, but that\n    // does not add to `nquad`)\n\n\n    if (g.termType === TYPE_NAMED_NODE) {\n      nquad += ` <${g.value}>`;\n    } else if (g.termType === TYPE_BLANK_NODE) {\n      nquad += ` ${g.value}`;\n    }\n\n    nquad += ' .\\n';\n    return nquad;\n  }\n  /**\n   * Converts a legacy-formatted dataset to an array of quads dataset per\n   * http://rdf.js.org/.\n   *\n   * @param dataset the legacy dataset to convert.\n   *\n   * @return the array of quads dataset.\n   */\n\n\n  static legacyDatasetToQuads(dataset) {\n    const quads = [];\n    const termTypeMap = {\n      'blank node': TYPE_BLANK_NODE,\n      IRI: TYPE_NAMED_NODE,\n      literal: TYPE_LITERAL\n    };\n\n    for (const graphName in dataset) {\n      const triples = dataset[graphName];\n      triples.forEach(triple => {\n        const quad = {};\n\n        for (const componentName in triple) {\n          const oldComponent = triple[componentName];\n          const newComponent = {\n            termType: termTypeMap[oldComponent.type],\n            value: oldComponent.value\n          };\n\n          if (newComponent.termType === TYPE_LITERAL) {\n            newComponent.datatype = {\n              termType: TYPE_NAMED_NODE\n            };\n\n            if ('datatype' in oldComponent) {\n              newComponent.datatype.value = oldComponent.datatype;\n            }\n\n            if ('language' in oldComponent) {\n              if (!('datatype' in oldComponent)) {\n                newComponent.datatype.value = RDF_LANGSTRING;\n              }\n\n              newComponent.language = oldComponent.language;\n            } else if (!('datatype' in oldComponent)) {\n              newComponent.datatype.value = XSD_STRING;\n            }\n          }\n\n          quad[componentName] = newComponent;\n        }\n\n        if (graphName === '@default') {\n          quad.graph = {\n            termType: TYPE_DEFAULT_GRAPH,\n            value: ''\n          };\n        } else {\n          quad.graph = {\n            termType: graphName.startsWith('_:') ? TYPE_BLANK_NODE : TYPE_NAMED_NODE,\n            value: graphName\n          };\n        }\n\n        quads.push(quad);\n      });\n    }\n\n    return quads;\n  }\n\n};\n/**\n * Compares two RDF triples for equality.\n *\n * @param t1 the first triple.\n * @param t2 the second triple.\n *\n * @return true if the triples are the same, false if not.\n */\n\nfunction _compareTriples(t1, t2) {\n  // compare subject and object types first as it is the quickest check\n  if (!(t1.subject.termType === t2.subject.termType && t1.object.termType === t2.object.termType)) {\n    return false;\n  } // compare values\n\n\n  if (!(t1.subject.value === t2.subject.value && t1.predicate.value === t2.predicate.value && t1.object.value === t2.object.value)) {\n    return false;\n  }\n\n  if (t1.object.termType !== TYPE_LITERAL) {\n    // no `datatype` or `language` to check\n    return true;\n  }\n\n  return t1.object.datatype.termType === t2.object.datatype.termType && t1.object.language === t2.object.language && t1.object.datatype.value === t2.object.datatype.value;\n}\n\nconst _escapeRegex = /[\"\\\\\\n\\r]/g;\n/**\n * Escape string to N-Quads literal\n */\n\nfunction _escape(s) {\n  return s.replace(_escapeRegex, function (match) {\n    switch (match) {\n      case '\"':\n        return '\\\\\"';\n\n      case '\\\\':\n        return '\\\\\\\\';\n\n      case '\\n':\n        return '\\\\n';\n\n      case '\\r':\n        return '\\\\r';\n    }\n  });\n}\n\nconst _unescapeRegex = /(?:\\\\([tbnrf\"'\\\\]))|(?:\\\\u([0-9A-Fa-f]{4}))|(?:\\\\U([0-9A-Fa-f]{8}))/g;\n/**\n * Unescape N-Quads literal to string\n */\n\nfunction _unescape(s) {\n  return s.replace(_unescapeRegex, function (match, code, u, U) {\n    if (code) {\n      switch (code) {\n        case 't':\n          return '\\t';\n\n        case 'b':\n          return '\\b';\n\n        case 'n':\n          return '\\n';\n\n        case 'r':\n          return '\\r';\n\n        case 'f':\n          return '\\f';\n\n        case '\"':\n          return '\"';\n\n        case '\\'':\n          return '\\'';\n\n        case '\\\\':\n          return '\\\\';\n      }\n    }\n\n    if (u) {\n      return String.fromCharCode(parseInt(u, 16));\n    }\n\n    if (U) {\n      // FIXME: support larger values\n      throw new Error('Unsupported U escape');\n    }\n  });\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/rdf-canonize/lib/NQuads.js"],"names":["TERMS","RDF","RDF_LANGSTRING","XSD_STRING","TYPE_NAMED_NODE","TYPE_BLANK_NODE","TYPE_LITERAL","TYPE_DEFAULT_GRAPH","REGEX","iri","PN_CHARS_BASE","PN_CHARS_U","PN_CHARS","BLANK_NODE_LABEL","bnode","plain","datatype","language","literal","ws","wso","subject","property","object","graphName","eoln","empty","RegExp","quad","module","exports","NQuads","parse","input","dataset","graphs","lines","split","lineNumber","line","test","match","Error","predicate","graph","undefined","termType","value","_unescape","push","unique","quads","q","_compareTriples","serialize","Array","isArray","legacyDatasetToQuads","serializeQuad","sort","join","s","p","o","g","nquad","_escape","termTypeMap","IRI","triples","forEach","triple","componentName","oldComponent","newComponent","type","startsWith","t1","t2","_escapeRegex","replace","_unescapeRegex","code","u","U","String","fromCharCode","parseInt"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n// eslint-disable-next-line no-unused-vars\nconst TERMS = ['subject', 'predicate', 'object', 'graph'];\nconst RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nconst RDF_LANGSTRING = RDF + 'langString';\nconst XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\n\nconst TYPE_NAMED_NODE = 'NamedNode';\nconst TYPE_BLANK_NODE = 'BlankNode';\nconst TYPE_LITERAL = 'Literal';\nconst TYPE_DEFAULT_GRAPH = 'DefaultGraph';\n\n// build regexes\nconst REGEX = {};\n(() => {\n  const iri = '(?:<([^:]+:[^>]*)>)';\n  // https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL\n  const PN_CHARS_BASE =\n    'A-Z' + 'a-z' +\n    '\\u00C0-\\u00D6' +\n    '\\u00D8-\\u00F6' +\n    '\\u00F8-\\u02FF' +\n    '\\u0370-\\u037D' +\n    '\\u037F-\\u1FFF' +\n    '\\u200C-\\u200D' +\n    '\\u2070-\\u218F' +\n    '\\u2C00-\\u2FEF' +\n    '\\u3001-\\uD7FF' +\n    '\\uF900-\\uFDCF' +\n    '\\uFDF0-\\uFFFD';\n    // TODO:\n    //'\\u10000-\\uEFFFF';\n  const PN_CHARS_U =\n    PN_CHARS_BASE +\n    '_';\n  const PN_CHARS =\n    PN_CHARS_U +\n    '0-9' +\n    '-' +\n    '\\u00B7' +\n    '\\u0300-\\u036F' +\n    '\\u203F-\\u2040';\n  const BLANK_NODE_LABEL =\n    '(_:' +\n      '(?:[' + PN_CHARS_U + '0-9])' +\n      '(?:(?:[' + PN_CHARS + '.])*(?:[' + PN_CHARS + ']))?' +\n    ')';\n  const bnode = BLANK_NODE_LABEL;\n  const plain = '\"([^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*)\"';\n  const datatype = '(?:\\\\^\\\\^' + iri + ')';\n  const language = '(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))';\n  const literal = '(?:' + plain + '(?:' + datatype + '|' + language + ')?)';\n  const ws = '[ \\\\t]+';\n  const wso = '[ \\\\t]*';\n\n  // define quad part regexes\n  const subject = '(?:' + iri + '|' + bnode + ')' + ws;\n  const property = iri + ws;\n  const object = '(?:' + iri + '|' + bnode + '|' + literal + ')' + wso;\n  const graphName = '(?:\\\\.|(?:(?:' + iri + '|' + bnode + ')' + wso + '\\\\.))';\n\n  // end of line and empty regexes\n  REGEX.eoln = /(?:\\r\\n)|(?:\\n)|(?:\\r)/g;\n  REGEX.empty = new RegExp('^' + wso + '$');\n\n  // full quad regex\n  REGEX.quad = new RegExp(\n    '^' + wso + subject + property + object + graphName + wso + '$');\n})();\n\nmodule.exports = class NQuads {\n  /**\n   * Parses RDF in the form of N-Quads.\n   *\n   * @param input the N-Quads input to parse.\n   *\n   * @return an RDF dataset (an array of quads per http://rdf.js.org/).\n   */\n  static parse(input) {\n    // build RDF dataset\n    const dataset = [];\n\n    const graphs = {};\n\n    // split N-Quad input into lines\n    const lines = input.split(REGEX.eoln);\n    let lineNumber = 0;\n    for(const line of lines) {\n      lineNumber++;\n\n      // skip empty lines\n      if(REGEX.empty.test(line)) {\n        continue;\n      }\n\n      // parse quad\n      const match = line.match(REGEX.quad);\n      if(match === null) {\n        throw new Error('N-Quads parse error on line ' + lineNumber + '.');\n      }\n\n      // create RDF quad\n      const quad = {subject: null, predicate: null, object: null, graph: null};\n\n      // get subject\n      if(match[1] !== undefined) {\n        quad.subject = {termType: TYPE_NAMED_NODE, value: match[1]};\n      } else {\n        quad.subject = {termType: TYPE_BLANK_NODE, value: match[2]};\n      }\n\n      // get predicate\n      quad.predicate = {termType: TYPE_NAMED_NODE, value: match[3]};\n\n      // get object\n      if(match[4] !== undefined) {\n        quad.object = {termType: TYPE_NAMED_NODE, value: match[4]};\n      } else if(match[5] !== undefined) {\n        quad.object = {termType: TYPE_BLANK_NODE, value: match[5]};\n      } else {\n        quad.object = {\n          termType: TYPE_LITERAL,\n          value: undefined,\n          datatype: {\n            termType: TYPE_NAMED_NODE\n          }\n        };\n        if(match[7] !== undefined) {\n          quad.object.datatype.value = match[7];\n        } else if(match[8] !== undefined) {\n          quad.object.datatype.value = RDF_LANGSTRING;\n          quad.object.language = match[8];\n        } else {\n          quad.object.datatype.value = XSD_STRING;\n        }\n        quad.object.value = _unescape(match[6]);\n      }\n\n      // get graph\n      if(match[9] !== undefined) {\n        quad.graph = {\n          termType: TYPE_NAMED_NODE,\n          value: match[9]\n        };\n      } else if(match[10] !== undefined) {\n        quad.graph = {\n          termType: TYPE_BLANK_NODE,\n          value: match[10]\n        };\n      } else {\n        quad.graph = {\n          termType: TYPE_DEFAULT_GRAPH,\n          value: ''\n        };\n      }\n\n      // only add quad if it is unique in its graph\n      if(!(quad.graph.value in graphs)) {\n        graphs[quad.graph.value] = [quad];\n        dataset.push(quad);\n      } else {\n        let unique = true;\n        const quads = graphs[quad.graph.value];\n        for(const q of quads) {\n          if(_compareTriples(q, quad)) {\n            unique = false;\n            break;\n          }\n        }\n        if(unique) {\n          quads.push(quad);\n          dataset.push(quad);\n        }\n      }\n    }\n\n    return dataset;\n  }\n\n  /**\n   * Converts an RDF dataset to N-Quads.\n   *\n   * @param dataset (array of quads) the RDF dataset to convert.\n   *\n   * @return the N-Quads string.\n   */\n  static serialize(dataset) {\n    if(!Array.isArray(dataset)) {\n      dataset = NQuads.legacyDatasetToQuads(dataset);\n    }\n    const quads = [];\n    for(const quad of dataset) {\n      quads.push(NQuads.serializeQuad(quad));\n    }\n    return quads.sort().join('');\n  }\n\n  /**\n   * Converts an RDF quad to an N-Quad string (a single quad).\n   *\n   * @param quad the RDF quad convert.\n   *\n   * @return the N-Quad string.\n   */\n  static serializeQuad(quad) {\n    const s = quad.subject;\n    const p = quad.predicate;\n    const o = quad.object;\n    const g = quad.graph;\n\n    let nquad = '';\n\n    // subject can only be NamedNode or BlankNode\n    if(s.termType === TYPE_NAMED_NODE) {\n      nquad += `<${s.value}>`;\n    } else {\n      nquad += `${s.value}`;\n    }\n\n    // predicate can only be NamedNode\n    nquad += ` <${p.value}> `;\n\n    // object is NamedNode, BlankNode, or Literal\n    if(o.termType === TYPE_NAMED_NODE) {\n      nquad += `<${o.value}>`;\n    } else if(o.termType === TYPE_BLANK_NODE) {\n      nquad += o.value;\n    } else {\n      nquad += `\"${_escape(o.value)}\"`;\n      if(o.datatype.value === RDF_LANGSTRING) {\n        if(o.language) {\n          nquad += `@${o.language}`;\n        }\n      } else if(o.datatype.value !== XSD_STRING) {\n        nquad += `^^<${o.datatype.value}>`;\n      }\n    }\n\n    // graph can only be NamedNode or BlankNode (or DefaultGraph, but that\n    // does not add to `nquad`)\n    if(g.termType === TYPE_NAMED_NODE) {\n      nquad += ` <${g.value}>`;\n    } else if(g.termType === TYPE_BLANK_NODE) {\n      nquad += ` ${g.value}`;\n    }\n\n    nquad += ' .\\n';\n    return nquad;\n  }\n\n  /**\n   * Converts a legacy-formatted dataset to an array of quads dataset per\n   * http://rdf.js.org/.\n   *\n   * @param dataset the legacy dataset to convert.\n   *\n   * @return the array of quads dataset.\n   */\n  static legacyDatasetToQuads(dataset) {\n    const quads = [];\n\n    const termTypeMap = {\n      'blank node': TYPE_BLANK_NODE,\n      IRI: TYPE_NAMED_NODE,\n      literal: TYPE_LITERAL\n    };\n\n    for(const graphName in dataset) {\n      const triples = dataset[graphName];\n      triples.forEach(triple => {\n        const quad = {};\n        for(const componentName in triple) {\n          const oldComponent = triple[componentName];\n          const newComponent = {\n            termType: termTypeMap[oldComponent.type],\n            value: oldComponent.value\n          };\n          if(newComponent.termType === TYPE_LITERAL) {\n            newComponent.datatype = {\n              termType: TYPE_NAMED_NODE\n            };\n            if('datatype' in oldComponent) {\n              newComponent.datatype.value = oldComponent.datatype;\n            }\n            if('language' in oldComponent) {\n              if(!('datatype' in oldComponent)) {\n                newComponent.datatype.value = RDF_LANGSTRING;\n              }\n              newComponent.language = oldComponent.language;\n            } else if(!('datatype' in oldComponent)) {\n              newComponent.datatype.value = XSD_STRING;\n            }\n          }\n          quad[componentName] = newComponent;\n        }\n        if(graphName === '@default') {\n          quad.graph = {\n            termType: TYPE_DEFAULT_GRAPH,\n            value: ''\n          };\n        } else {\n          quad.graph = {\n            termType: graphName.startsWith('_:') ?\n              TYPE_BLANK_NODE : TYPE_NAMED_NODE,\n            value: graphName\n          };\n        }\n        quads.push(quad);\n      });\n    }\n\n    return quads;\n  }\n};\n\n/**\n * Compares two RDF triples for equality.\n *\n * @param t1 the first triple.\n * @param t2 the second triple.\n *\n * @return true if the triples are the same, false if not.\n */\nfunction _compareTriples(t1, t2) {\n  // compare subject and object types first as it is the quickest check\n  if(!(t1.subject.termType === t2.subject.termType &&\n    t1.object.termType === t2.object.termType)) {\n    return false;\n  }\n  // compare values\n  if(!(t1.subject.value === t2.subject.value &&\n    t1.predicate.value === t2.predicate.value &&\n    t1.object.value === t2.object.value)) {\n    return false;\n  }\n  if(t1.object.termType !== TYPE_LITERAL) {\n    // no `datatype` or `language` to check\n    return true;\n  }\n  return (\n    (t1.object.datatype.termType === t2.object.datatype.termType) &&\n    (t1.object.language === t2.object.language) &&\n    (t1.object.datatype.value === t2.object.datatype.value)\n  );\n}\n\nconst _escapeRegex = /[\"\\\\\\n\\r]/g;\n/**\n * Escape string to N-Quads literal\n */\nfunction _escape(s) {\n  return s.replace(_escapeRegex, function(match) {\n    switch(match) {\n      case '\"': return '\\\\\"';\n      case '\\\\': return '\\\\\\\\';\n      case '\\n': return '\\\\n';\n      case '\\r': return '\\\\r';\n    }\n  });\n}\n\nconst _unescapeRegex =\n  /(?:\\\\([tbnrf\"'\\\\]))|(?:\\\\u([0-9A-Fa-f]{4}))|(?:\\\\U([0-9A-Fa-f]{8}))/g;\n/**\n * Unescape N-Quads literal to string\n */\nfunction _unescape(s) {\n  return s.replace(_unescapeRegex, function(match, code, u, U) {\n    if(code) {\n      switch(code) {\n        case 't': return '\\t';\n        case 'b': return '\\b';\n        case 'n': return '\\n';\n        case 'r': return '\\r';\n        case 'f': return '\\f';\n        case '\"': return '\"';\n        case '\\'': return '\\'';\n        case '\\\\': return '\\\\';\n      }\n    }\n    if(u) {\n      return String.fromCharCode(parseInt(u, 16));\n    }\n    if(U) {\n      // FIXME: support larger values\n      throw new Error('Unsupported U escape');\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"script"}