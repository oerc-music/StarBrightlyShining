{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContainerHandlerIndex = void 0;\n\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n\nconst EntryHandlerPredicate_1 = require(\"../entryhandler/EntryHandlerPredicate\");\n\nconst Util_1 = require(\"../Util\");\n/**\n * Container handler for @index.\n *\n * This will ignore the current key and add this entry to the parent node.\n */\n\n\nclass ContainerHandlerIndex {\n  canCombineWithGraph() {\n    return true;\n  }\n\n  async handle(containers, parsingContext, util, keys, value, depth) {\n    if (!Array.isArray(value)) {\n      const graphContainer = ('@graph' in containers); // Check if the container is a property-based container by checking if there is a valid @index.\n\n      const context = await parsingContext.getContext(keys);\n      const indexKey = keys[depth - 1];\n      const indexPropertyRaw = Util_1.Util.getContextValueIndex(context, indexKey);\n\n      if (indexPropertyRaw) {\n        // Validate the @index value\n        if (jsonld_context_parser_1.Util.isPotentialKeyword(indexPropertyRaw)) {\n          throw new jsonld_context_parser_1.ErrorCoded(`Keywords can not be used as @index value, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n        }\n\n        if (typeof indexPropertyRaw !== 'string') {\n          throw new jsonld_context_parser_1.ErrorCoded(`@index values must be strings, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n        } // When @index is used, values must be node values, unless @type: @id is defined in the context\n\n\n        if (typeof value !== 'object') {\n          // Error if we don't have @type: @id\n          if (Util_1.Util.getContextValueType(context, indexKey) !== '@id') {\n            throw new jsonld_context_parser_1.ErrorCoded(`Property-based index containers require nodes as values or strings with @type: @id, but got: ${value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n          } // Add an @id to the stack, so our expanded @index value can make use of it\n\n\n          const id = util.resourceToTerm(context, value);\n\n          if (id) {\n            parsingContext.idStack[depth + 1] = [id];\n          }\n        } // Expand the @index value\n\n\n        const indexProperty = util.createVocabOrBaseTerm(context, indexPropertyRaw);\n\n        if (indexProperty) {\n          const indexValues = await util.valueToTerm(context, indexPropertyRaw, await util.getContainerKey(keys[depth], keys, depth), depth, keys);\n\n          if (graphContainer) {\n            // When we're in a graph container, attach the index to the graph identifier\n            const graphId = await util.getGraphContainerValue(keys, depth + 1);\n\n            for (const indexValue of indexValues) {\n              parsingContext.emitQuad(depth, util.dataFactory.quad(graphId, indexProperty, indexValue, util.getDefaultGraph()));\n            }\n          } else {\n            // Otherwise, attach the index to the node identifier\n            for (const indexValue of indexValues) {\n              await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, indexProperty, indexValue, false);\n            }\n          }\n        }\n      }\n\n      const depthOffset = graphContainer ? 2 : 1;\n      await parsingContext.newOnValueJob(keys.slice(0, keys.length - depthOffset), value, depth - depthOffset, true); // Flush any pending flush buffers\n\n      await parsingContext.handlePendingContainerFlushBuffers();\n    }\n\n    parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n  }\n\n}\n\nexports.ContainerHandlerIndex = ContainerHandlerIndex;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIndex.js"],"names":["Object","defineProperty","exports","value","ContainerHandlerIndex","jsonld_context_parser_1","require","EntryHandlerPredicate_1","Util_1","canCombineWithGraph","handle","containers","parsingContext","util","keys","depth","Array","isArray","graphContainer","context","getContext","indexKey","indexPropertyRaw","Util","getContextValueIndex","isPotentialKeyword","ErrorCoded","ERROR_CODES","INVALID_TERM_DEFINITION","getContextValueType","INVALID_VALUE_OBJECT","id","resourceToTerm","idStack","indexProperty","createVocabOrBaseTerm","indexValues","valueToTerm","getContainerKey","graphId","getGraphContainerValue","indexValue","emitQuad","dataFactory","quad","getDefaultGraph","EntryHandlerPredicate","handlePredicateObject","depthOffset","newOnValueJob","slice","length","handlePendingContainerFlushBuffers","emittedStack"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerIndex = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst EntryHandlerPredicate_1 = require(\"../entryhandler/EntryHandlerPredicate\");\nconst Util_1 = require(\"../Util\");\n/**\n * Container handler for @index.\n *\n * This will ignore the current key and add this entry to the parent node.\n */\nclass ContainerHandlerIndex {\n    canCombineWithGraph() {\n        return true;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        if (!Array.isArray(value)) {\n            const graphContainer = '@graph' in containers;\n            // Check if the container is a property-based container by checking if there is a valid @index.\n            const context = await parsingContext.getContext(keys);\n            const indexKey = keys[depth - 1];\n            const indexPropertyRaw = Util_1.Util.getContextValueIndex(context, indexKey);\n            if (indexPropertyRaw) {\n                // Validate the @index value\n                if (jsonld_context_parser_1.Util.isPotentialKeyword(indexPropertyRaw)) {\n                    throw new jsonld_context_parser_1.ErrorCoded(`Keywords can not be used as @index value, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                if (typeof indexPropertyRaw !== 'string') {\n                    throw new jsonld_context_parser_1.ErrorCoded(`@index values must be strings, got: ${indexPropertyRaw}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                // When @index is used, values must be node values, unless @type: @id is defined in the context\n                if (typeof value !== 'object') {\n                    // Error if we don't have @type: @id\n                    if (Util_1.Util.getContextValueType(context, indexKey) !== '@id') {\n                        throw new jsonld_context_parser_1.ErrorCoded(`Property-based index containers require nodes as values or strings with @type: @id, but got: ${value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                    }\n                    // Add an @id to the stack, so our expanded @index value can make use of it\n                    const id = util.resourceToTerm(context, value);\n                    if (id) {\n                        parsingContext.idStack[depth + 1] = [id];\n                    }\n                }\n                // Expand the @index value\n                const indexProperty = util.createVocabOrBaseTerm(context, indexPropertyRaw);\n                if (indexProperty) {\n                    const indexValues = await util.valueToTerm(context, indexPropertyRaw, await util.getContainerKey(keys[depth], keys, depth), depth, keys);\n                    if (graphContainer) {\n                        // When we're in a graph container, attach the index to the graph identifier\n                        const graphId = await util.getGraphContainerValue(keys, depth + 1);\n                        for (const indexValue of indexValues) {\n                            parsingContext.emitQuad(depth, util.dataFactory.quad(graphId, indexProperty, indexValue, util.getDefaultGraph()));\n                        }\n                    }\n                    else {\n                        // Otherwise, attach the index to the node identifier\n                        for (const indexValue of indexValues) {\n                            await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, indexProperty, indexValue, false);\n                        }\n                    }\n                }\n            }\n            const depthOffset = graphContainer ? 2 : 1;\n            await parsingContext.newOnValueJob(keys.slice(0, keys.length - depthOffset), value, depth - depthOffset, true);\n            // Flush any pending flush buffers\n            await parsingContext.handlePendingContainerFlushBuffers();\n        }\n        parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n    }\n}\nexports.ContainerHandlerIndex = ContainerHandlerIndex;\n//# sourceMappingURL=ContainerHandlerIndex.js.map"]},"metadata":{},"sourceType":"script"}