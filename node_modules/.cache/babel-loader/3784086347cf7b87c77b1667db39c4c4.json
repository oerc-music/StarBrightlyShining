{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorRdfParseHtml = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst bus_rdf_parse_1 = require(\"@comunica/bus-rdf-parse\");\n\nconst WritableStream_1 = require(\"htmlparser2/lib/WritableStream\");\n/**\n * A comunica HTML RDF Parse Actor.\n * It creates an HTML parser, and delegates its events via the bus-rdf-parse-html bus to other HTML parsing actors.\n */\n\n\nclass ActorRdfParseHtml extends bus_rdf_parse_1.ActorRdfParseFixedMediaTypes {\n  constructor(args) {\n    super(args);\n  }\n\n  async runHandle(action, mediaType, context) {\n    const quads = new stream_1.Readable({\n      objectMode: true\n    });\n\n    quads._read = async () => {\n      // Only initialize once\n      quads._read = () => {// Do nothing\n      }; // Create callbacks action\n\n\n      let endBarrier = 1;\n\n      function emit(quad) {\n        quads.emit('data', quad);\n      }\n\n      function error(subError) {\n        quads.emit('error', subError);\n      }\n\n      function end() {\n        if (--endBarrier === 0) {\n          quads.push(null);\n        }\n      }\n\n      const htmlAction = {\n        baseIRI: action.baseIRI,\n        context,\n        emit,\n        end,\n        error,\n        headers: action.headers\n      }; // Register html parse listeners\n\n      Promise.all(this.busRdfParseHtml.publish(htmlAction)).then(async outputs => {\n        endBarrier += outputs.length;\n        const htmlParseListeners = [];\n\n        for (const output of outputs) {\n          const {\n            htmlParseListener\n          } = await output.actor.run(htmlAction);\n          htmlParseListeners.push(htmlParseListener);\n        } // Create parser\n\n\n        const parser = new WritableStream_1.WritableStream({\n          onclosetag() {\n            try {\n              for (const htmlParseListener of htmlParseListeners) {\n                htmlParseListener.onTagClose();\n              }\n            } catch (error_) {\n              error(error_);\n            }\n          },\n\n          onend() {\n            try {\n              for (const htmlParseListener of htmlParseListeners) {\n                htmlParseListener.onEnd();\n              }\n            } catch (error_) {\n              error(error_);\n            }\n\n            end();\n          },\n\n          onopentag(name, attributes) {\n            try {\n              for (const htmlParseListener of htmlParseListeners) {\n                htmlParseListener.onTagOpen(name, attributes);\n              }\n            } catch (error_) {\n              error(error_);\n            }\n          },\n\n          ontext(data) {\n            try {\n              for (const htmlParseListener of htmlParseListeners) {\n                htmlParseListener.onText(data);\n              }\n            } catch (error_) {\n              error(error_);\n            }\n          }\n\n        }, {\n          decodeEntities: true,\n          recognizeSelfClosing: true,\n          xmlMode: false\n        }); // Push stream to parser\n\n        action.input.on('error', error);\n        action.input.pipe(parser);\n      }).catch(error);\n    };\n\n    return {\n      quads\n    };\n  }\n\n}\n\nexports.ActorRdfParseHtml = ActorRdfParseHtml;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-rdf-parse-html/lib/ActorRdfParseHtml.js"],"names":["Object","defineProperty","exports","value","ActorRdfParseHtml","stream_1","require","bus_rdf_parse_1","WritableStream_1","ActorRdfParseFixedMediaTypes","constructor","args","runHandle","action","mediaType","context","quads","Readable","objectMode","_read","endBarrier","emit","quad","error","subError","end","push","htmlAction","baseIRI","headers","Promise","all","busRdfParseHtml","publish","then","outputs","length","htmlParseListeners","output","htmlParseListener","actor","run","parser","WritableStream","onclosetag","onTagClose","error_","onend","onEnd","onopentag","name","attributes","onTagOpen","ontext","data","onText","decodeEntities","recognizeSelfClosing","xmlMode","input","on","pipe","catch"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,iBAAR,GAA4B,KAAK,CAAjC;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMC,eAAe,GAAGD,OAAO,CAAC,yBAAD,CAA/B;;AACA,MAAME,gBAAgB,GAAGF,OAAO,CAAC,gCAAD,CAAhC;AACA;AACA;AACA;AACA;;;AACA,MAAMF,iBAAN,SAAgCG,eAAe,CAACE,4BAAhD,CAA6E;AACzEC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAMA,IAAN;AACH;;AACc,QAATC,SAAS,CAACC,MAAD,EAASC,SAAT,EAAoBC,OAApB,EAA6B;AACxC,UAAMC,KAAK,GAAG,IAAIX,QAAQ,CAACY,QAAb,CAAsB;AAAEC,MAAAA,UAAU,EAAE;AAAd,KAAtB,CAAd;;AACAF,IAAAA,KAAK,CAACG,KAAN,GAAc,YAAY;AACtB;AACAH,MAAAA,KAAK,CAACG,KAAN,GAAc,MAAM,CAChB;AACH,OAFD,CAFsB,CAKtB;;;AACA,UAAIC,UAAU,GAAG,CAAjB;;AACA,eAASC,IAAT,CAAcC,IAAd,EAAoB;AAChBN,QAAAA,KAAK,CAACK,IAAN,CAAW,MAAX,EAAmBC,IAAnB;AACH;;AACD,eAASC,KAAT,CAAeC,QAAf,EAAyB;AACrBR,QAAAA,KAAK,CAACK,IAAN,CAAW,OAAX,EAAoBG,QAApB;AACH;;AACD,eAASC,GAAT,GAAe;AACX,YAAI,EAAEL,UAAF,KAAiB,CAArB,EAAwB;AACpBJ,UAAAA,KAAK,CAACU,IAAN,CAAW,IAAX;AACH;AACJ;;AACD,YAAMC,UAAU,GAAG;AACfC,QAAAA,OAAO,EAAEf,MAAM,CAACe,OADD;AAEfb,QAAAA,OAFe;AAGfM,QAAAA,IAHe;AAIfI,QAAAA,GAJe;AAKfF,QAAAA,KALe;AAMfM,QAAAA,OAAO,EAAEhB,MAAM,CAACgB;AAND,OAAnB,CAlBsB,CA0BtB;;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAKC,eAAL,CAAqBC,OAArB,CAA6BN,UAA7B,CAAZ,EACKO,IADL,CACU,MAAOC,OAAP,IAAmB;AACzBf,QAAAA,UAAU,IAAIe,OAAO,CAACC,MAAtB;AACA,cAAMC,kBAAkB,GAAG,EAA3B;;AACA,aAAK,MAAMC,MAAX,IAAqBH,OAArB,EAA8B;AAC1B,gBAAM;AAAEI,YAAAA;AAAF,cAAwB,MAAMD,MAAM,CAACE,KAAP,CAAaC,GAAb,CAAiBd,UAAjB,CAApC;AACAU,UAAAA,kBAAkB,CAACX,IAAnB,CAAwBa,iBAAxB;AACH,SANwB,CAOzB;;;AACA,cAAMG,MAAM,GAAG,IAAIlC,gBAAgB,CAACmC,cAArB,CAAoC;AAC/CC,UAAAA,UAAU,GAAG;AACT,gBAAI;AACA,mBAAK,MAAML,iBAAX,IAAgCF,kBAAhC,EAAoD;AAChDE,gBAAAA,iBAAiB,CAACM,UAAlB;AACH;AACJ,aAJD,CAKA,OAAOC,MAAP,EAAe;AACXvB,cAAAA,KAAK,CAACuB,MAAD,CAAL;AACH;AACJ,WAV8C;;AAW/CC,UAAAA,KAAK,GAAG;AACJ,gBAAI;AACA,mBAAK,MAAMR,iBAAX,IAAgCF,kBAAhC,EAAoD;AAChDE,gBAAAA,iBAAiB,CAACS,KAAlB;AACH;AACJ,aAJD,CAKA,OAAOF,MAAP,EAAe;AACXvB,cAAAA,KAAK,CAACuB,MAAD,CAAL;AACH;;AACDrB,YAAAA,GAAG;AACN,WArB8C;;AAsB/CwB,UAAAA,SAAS,CAACC,IAAD,EAAOC,UAAP,EAAmB;AACxB,gBAAI;AACA,mBAAK,MAAMZ,iBAAX,IAAgCF,kBAAhC,EAAoD;AAChDE,gBAAAA,iBAAiB,CAACa,SAAlB,CAA4BF,IAA5B,EAAkCC,UAAlC;AACH;AACJ,aAJD,CAKA,OAAOL,MAAP,EAAe;AACXvB,cAAAA,KAAK,CAACuB,MAAD,CAAL;AACH;AACJ,WA/B8C;;AAgC/CO,UAAAA,MAAM,CAACC,IAAD,EAAO;AACT,gBAAI;AACA,mBAAK,MAAMf,iBAAX,IAAgCF,kBAAhC,EAAoD;AAChDE,gBAAAA,iBAAiB,CAACgB,MAAlB,CAAyBD,IAAzB;AACH;AACJ,aAJD,CAKA,OAAOR,MAAP,EAAe;AACXvB,cAAAA,KAAK,CAACuB,MAAD,CAAL;AACH;AACJ;;AAzC8C,SAApC,EA0CZ;AACCU,UAAAA,cAAc,EAAE,IADjB;AAECC,UAAAA,oBAAoB,EAAE,IAFvB;AAGCC,UAAAA,OAAO,EAAE;AAHV,SA1CY,CAAf,CARyB,CAuDzB;;AACA7C,QAAAA,MAAM,CAAC8C,KAAP,CAAaC,EAAb,CAAgB,OAAhB,EAAyBrC,KAAzB;AACAV,QAAAA,MAAM,CAAC8C,KAAP,CAAaE,IAAb,CAAkBnB,MAAlB;AACH,OA3DD,EA2DGoB,KA3DH,CA2DSvC,KA3DT;AA4DH,KAvFD;;AAwFA,WAAO;AAAEP,MAAAA;AAAF,KAAP;AACH;;AA/FwE;;AAiG7Ed,OAAO,CAACE,iBAAR,GAA4BA,iBAA5B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorRdfParseHtml = void 0;\nconst stream_1 = require(\"stream\");\nconst bus_rdf_parse_1 = require(\"@comunica/bus-rdf-parse\");\nconst WritableStream_1 = require(\"htmlparser2/lib/WritableStream\");\n/**\n * A comunica HTML RDF Parse Actor.\n * It creates an HTML parser, and delegates its events via the bus-rdf-parse-html bus to other HTML parsing actors.\n */\nclass ActorRdfParseHtml extends bus_rdf_parse_1.ActorRdfParseFixedMediaTypes {\n    constructor(args) {\n        super(args);\n    }\n    async runHandle(action, mediaType, context) {\n        const quads = new stream_1.Readable({ objectMode: true });\n        quads._read = async () => {\n            // Only initialize once\n            quads._read = () => {\n                // Do nothing\n            };\n            // Create callbacks action\n            let endBarrier = 1;\n            function emit(quad) {\n                quads.emit('data', quad);\n            }\n            function error(subError) {\n                quads.emit('error', subError);\n            }\n            function end() {\n                if (--endBarrier === 0) {\n                    quads.push(null);\n                }\n            }\n            const htmlAction = {\n                baseIRI: action.baseIRI,\n                context,\n                emit,\n                end,\n                error,\n                headers: action.headers,\n            };\n            // Register html parse listeners\n            Promise.all(this.busRdfParseHtml.publish(htmlAction))\n                .then(async (outputs) => {\n                endBarrier += outputs.length;\n                const htmlParseListeners = [];\n                for (const output of outputs) {\n                    const { htmlParseListener } = await output.actor.run(htmlAction);\n                    htmlParseListeners.push(htmlParseListener);\n                }\n                // Create parser\n                const parser = new WritableStream_1.WritableStream({\n                    onclosetag() {\n                        try {\n                            for (const htmlParseListener of htmlParseListeners) {\n                                htmlParseListener.onTagClose();\n                            }\n                        }\n                        catch (error_) {\n                            error(error_);\n                        }\n                    },\n                    onend() {\n                        try {\n                            for (const htmlParseListener of htmlParseListeners) {\n                                htmlParseListener.onEnd();\n                            }\n                        }\n                        catch (error_) {\n                            error(error_);\n                        }\n                        end();\n                    },\n                    onopentag(name, attributes) {\n                        try {\n                            for (const htmlParseListener of htmlParseListeners) {\n                                htmlParseListener.onTagOpen(name, attributes);\n                            }\n                        }\n                        catch (error_) {\n                            error(error_);\n                        }\n                    },\n                    ontext(data) {\n                        try {\n                            for (const htmlParseListener of htmlParseListeners) {\n                                htmlParseListener.onText(data);\n                            }\n                        }\n                        catch (error_) {\n                            error(error_);\n                        }\n                    },\n                }, {\n                    decodeEntities: true,\n                    recognizeSelfClosing: true,\n                    xmlMode: false,\n                });\n                // Push stream to parser\n                action.input.on('error', error);\n                action.input.pipe(parser);\n            }).catch(error);\n        };\n        return { quads };\n    }\n}\nexports.ActorRdfParseHtml = ActorRdfParseHtml;\n//# sourceMappingURL=ActorRdfParseHtml.js.map"]},"metadata":{},"sourceType":"script"}