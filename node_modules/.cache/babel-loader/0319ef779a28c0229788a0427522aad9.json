{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorSparqlParseAlgebra = void 0;\n\nconst bus_sparql_parse_1 = require(\"@comunica/bus-sparql-parse\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n\nconst sparqljs_1 = require(\"sparqljs\");\n/**\n * A comunica Algebra SPARQL Parse Actor.\n */\n\n\nclass ActorSparqlParseAlgebra extends bus_sparql_parse_1.ActorSparqlParse {\n  constructor(args) {\n    super(args);\n    this.prefixes = Object.freeze(this.prefixes);\n  }\n\n  async test(action) {\n    if (action.queryFormat && action.queryFormat !== 'sparql') {\n      throw new Error('This actor can only parse SPARQL queries');\n    }\n\n    return true;\n  }\n\n  async run(action) {\n    const parser = new sparqljs_1.Parser({\n      prefixes: this.prefixes,\n      baseIRI: action.baseIRI\n    }); // Resets the identifier counter used for blank nodes\n    // provides nicer and more consistent output if there are multiple calls\n\n    parser._resetBlanks();\n\n    const parsedSyntax = parser.parse(action.query);\n    const baseIRI = parsedSyntax.type === 'query' ? parsedSyntax.base : undefined;\n    return {\n      baseIRI,\n      operation: sparqlalgebrajs_1.translate(parsedSyntax, {\n        quads: true,\n        prefixes: this.prefixes,\n        blankToVariable: true,\n        baseIRI: action.baseIRI\n      })\n    };\n  }\n\n}\n\nexports.ActorSparqlParseAlgebra = ActorSparqlParseAlgebra;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-sparql-parse-algebra/lib/ActorSparqlParseAlgebra.js"],"names":["Object","defineProperty","exports","value","ActorSparqlParseAlgebra","bus_sparql_parse_1","require","sparqlalgebrajs_1","sparqljs_1","ActorSparqlParse","constructor","args","prefixes","freeze","test","action","queryFormat","Error","run","parser","Parser","baseIRI","_resetBlanks","parsedSyntax","parse","query","type","base","undefined","operation","translate","quads","blankToVariable"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,uBAAR,GAAkC,KAAK,CAAvC;;AACA,MAAMC,kBAAkB,GAAGC,OAAO,CAAC,4BAAD,CAAlC;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,iBAAD,CAAjC;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,UAAD,CAA1B;AACA;AACA;AACA;;;AACA,MAAMF,uBAAN,SAAsCC,kBAAkB,CAACI,gBAAzD,CAA0E;AACtEC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAMA,IAAN;AACA,SAAKC,QAAL,GAAgBZ,MAAM,CAACa,MAAP,CAAc,KAAKD,QAAnB,CAAhB;AACH;;AACS,QAAJE,IAAI,CAACC,MAAD,EAAS;AACf,QAAIA,MAAM,CAACC,WAAP,IAAsBD,MAAM,CAACC,WAAP,KAAuB,QAAjD,EAA2D;AACvD,YAAM,IAAIC,KAAJ,CAAU,0CAAV,CAAN;AACH;;AACD,WAAO,IAAP;AACH;;AACQ,QAAHC,GAAG,CAACH,MAAD,EAAS;AACd,UAAMI,MAAM,GAAG,IAAIX,UAAU,CAACY,MAAf,CAAsB;AAAER,MAAAA,QAAQ,EAAE,KAAKA,QAAjB;AAA2BS,MAAAA,OAAO,EAAEN,MAAM,CAACM;AAA3C,KAAtB,CAAf,CADc,CAEd;AACA;;AACAF,IAAAA,MAAM,CAACG,YAAP;;AACA,UAAMC,YAAY,GAAGJ,MAAM,CAACK,KAAP,CAAaT,MAAM,CAACU,KAApB,CAArB;AACA,UAAMJ,OAAO,GAAGE,YAAY,CAACG,IAAb,KAAsB,OAAtB,GAAgCH,YAAY,CAACI,IAA7C,GAAoDC,SAApE;AACA,WAAO;AACHP,MAAAA,OADG;AAEHQ,MAAAA,SAAS,EAAEtB,iBAAiB,CAACuB,SAAlB,CAA4BP,YAA5B,EAA0C;AAAEQ,QAAAA,KAAK,EAAE,IAAT;AAAenB,QAAAA,QAAQ,EAAE,KAAKA,QAA9B;AAAwCoB,QAAAA,eAAe,EAAE,IAAzD;AAA+DX,QAAAA,OAAO,EAAEN,MAAM,CAACM;AAA/E,OAA1C;AAFR,KAAP;AAIH;;AAtBqE;;AAwB1EnB,OAAO,CAACE,uBAAR,GAAkCA,uBAAlC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorSparqlParseAlgebra = void 0;\nconst bus_sparql_parse_1 = require(\"@comunica/bus-sparql-parse\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\nconst sparqljs_1 = require(\"sparqljs\");\n/**\n * A comunica Algebra SPARQL Parse Actor.\n */\nclass ActorSparqlParseAlgebra extends bus_sparql_parse_1.ActorSparqlParse {\n    constructor(args) {\n        super(args);\n        this.prefixes = Object.freeze(this.prefixes);\n    }\n    async test(action) {\n        if (action.queryFormat && action.queryFormat !== 'sparql') {\n            throw new Error('This actor can only parse SPARQL queries');\n        }\n        return true;\n    }\n    async run(action) {\n        const parser = new sparqljs_1.Parser({ prefixes: this.prefixes, baseIRI: action.baseIRI });\n        // Resets the identifier counter used for blank nodes\n        // provides nicer and more consistent output if there are multiple calls\n        parser._resetBlanks();\n        const parsedSyntax = parser.parse(action.query);\n        const baseIRI = parsedSyntax.type === 'query' ? parsedSyntax.base : undefined;\n        return {\n            baseIRI,\n            operation: sparqlalgebrajs_1.translate(parsedSyntax, { quads: true, prefixes: this.prefixes, blankToVariable: true, baseIRI: action.baseIRI }),\n        };\n    }\n}\nexports.ActorSparqlParseAlgebra = ActorSparqlParseAlgebra;\n//# sourceMappingURL=ActorSparqlParseAlgebra.js.map"]},"metadata":{},"sourceType":"script"}