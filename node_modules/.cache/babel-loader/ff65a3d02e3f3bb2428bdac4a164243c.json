{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cloneNode = exports.Element = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;\nvar nodeTypes = new Map([[\"tag\"\n/* Tag */\n, 1], [\"script\"\n/* Script */\n, 1], [\"style\"\n/* Style */\n, 1], [\"directive\"\n/* Directive */\n, 1], [\"text\"\n/* Text */\n, 3], [\"cdata\"\n/* CDATA */\n, 4], [\"comment\"\n/* Comment */\n, 8]]);\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\n\nvar Node = function () {\n  /**\n   *\n   * @param type The type of the node.\n   */\n  function Node(type) {\n    this.type = type;\n    /** Parent of the node */\n\n    this.parent = null;\n    /** Previous sibling */\n\n    this.prev = null;\n    /** Next sibling */\n\n    this.next = null;\n    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n\n    this.startIndex = null;\n    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n\n    this.endIndex = null;\n  }\n\n  Object.defineProperty(Node.prototype, \"nodeType\", {\n    // Read-only aliases\n    get: function () {\n      var _a;\n\n      return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"parentNode\", {\n    // Read-write aliases for properties\n    get: function () {\n      return this.parent;\n    },\n    set: function (parent) {\n      this.parent = parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"previousSibling\", {\n    get: function () {\n      return this.prev;\n    },\n    set: function (prev) {\n      this.prev = prev;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Node.prototype, \"nextSibling\", {\n    get: function () {\n      return this.next;\n    },\n    set: function (next) {\n      this.next = next;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Clone this node, and optionally its children.\n   *\n   * @param recursive Clone child nodes as well.\n   * @returns A clone of the node.\n   */\n\n  Node.prototype.cloneNode = function (recursive) {\n    if (recursive === void 0) {\n      recursive = false;\n    }\n\n    return cloneNode(this, recursive);\n  };\n\n  return Node;\n}();\n\nexports.Node = Node;\n\nvar DataNode = function (_super) {\n  __extends(DataNode, _super);\n  /**\n   * @param type The type of the node\n   * @param data The content of the data node\n   */\n\n\n  function DataNode(type, data) {\n    var _this = _super.call(this, type) || this;\n\n    _this.data = data;\n    return _this;\n  }\n\n  Object.defineProperty(DataNode.prototype, \"nodeValue\", {\n    get: function () {\n      return this.data;\n    },\n    set: function (data) {\n      this.data = data;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return DataNode;\n}(Node);\n\nexports.DataNode = DataNode;\n\nvar Text = function (_super) {\n  __extends(Text, _super);\n\n  function Text(data) {\n    return _super.call(this, \"text\"\n    /* Text */\n    , data) || this;\n  }\n\n  return Text;\n}(DataNode);\n\nexports.Text = Text;\n\nvar Comment = function (_super) {\n  __extends(Comment, _super);\n\n  function Comment(data) {\n    return _super.call(this, \"comment\"\n    /* Comment */\n    , data) || this;\n  }\n\n  return Comment;\n}(DataNode);\n\nexports.Comment = Comment;\n\nvar ProcessingInstruction = function (_super) {\n  __extends(ProcessingInstruction, _super);\n\n  function ProcessingInstruction(name, data) {\n    var _this = _super.call(this, \"directive\"\n    /* Directive */\n    , data) || this;\n\n    _this.name = name;\n    return _this;\n  }\n\n  return ProcessingInstruction;\n}(DataNode);\n\nexports.ProcessingInstruction = ProcessingInstruction;\n\nvar NodeWithChildren = function (_super) {\n  __extends(NodeWithChildren, _super);\n  /**\n   *\n   * @param type Type of the node.\n   * @param children Children of the node. Only certain node types can have children.\n   */\n\n\n  function NodeWithChildren(type, children) {\n    var _this = _super.call(this, type) || this;\n\n    _this.children = children;\n    return _this;\n  }\n\n  Object.defineProperty(NodeWithChildren.prototype, \"firstChild\", {\n    // Aliases\n    get: function () {\n      var _a;\n\n      return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeWithChildren.prototype, \"lastChild\", {\n    get: function () {\n      return this.children.length > 0 ? this.children[this.children.length - 1] : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(NodeWithChildren.prototype, \"childNodes\", {\n    get: function () {\n      return this.children;\n    },\n    set: function (children) {\n      this.children = children;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return NodeWithChildren;\n}(Node);\n\nexports.NodeWithChildren = NodeWithChildren;\n\nvar Element = function (_super) {\n  __extends(Element, _super);\n  /**\n   * @param name Name of the tag, eg. `div`, `span`.\n   * @param attribs Object mapping attribute names to attribute values.\n   * @param children Children of the node.\n   */\n\n\n  function Element(name, attribs, children) {\n    if (children === void 0) {\n      children = [];\n    }\n\n    var _this = _super.call(this, name === \"script\" ? \"script\"\n    /* Script */\n    : name === \"style\" ? \"style\"\n    /* Style */\n    : \"tag\"\n    /* Tag */\n    , children) || this;\n\n    _this.name = name;\n    _this.attribs = attribs;\n    _this.attribs = attribs;\n    return _this;\n  }\n\n  Object.defineProperty(Element.prototype, \"tagName\", {\n    // DOM Level 1 aliases\n    get: function () {\n      return this.name;\n    },\n    set: function (name) {\n      this.name = name;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Element.prototype, \"attributes\", {\n    get: function () {\n      var _this = this;\n\n      return Object.keys(this.attribs).map(function (name) {\n        return {\n          name: name,\n          value: _this.attribs[name]\n        };\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Element;\n}(NodeWithChildren);\n\nexports.Element = Element;\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\n\nfunction cloneNode(node, recursive) {\n  if (recursive === void 0) {\n    recursive = false;\n  }\n\n  switch (node.type) {\n    case \"text\"\n    /* Text */\n    :\n      return new Text(node.data);\n\n    case \"directive\"\n    /* Directive */\n    :\n      {\n        var instr = node;\n        return new ProcessingInstruction(instr.name, instr.data);\n      }\n\n    case \"comment\"\n    /* Comment */\n    :\n      return new Comment(node.data);\n\n    case \"tag\"\n    /* Tag */\n    :\n    case \"script\"\n    /* Script */\n    :\n    case \"style\"\n    /* Style */\n    :\n      {\n        var elem = node;\n        var children = recursive ? cloneChildren(elem.children) : [];\n        var clone_1 = new Element(elem.name, __assign({}, elem.attribs), children);\n        children.forEach(function (child) {\n          return child.parent = clone_1;\n        });\n        return clone_1;\n      }\n\n    case \"cdata\"\n    /* CDATA */\n    :\n      {\n        var cdata = node;\n        var children = recursive ? cloneChildren(cdata.children) : [];\n        var clone_2 = new NodeWithChildren(\"cdata\"\n        /* CDATA */\n        , children);\n        children.forEach(function (child) {\n          return child.parent = clone_2;\n        });\n        return clone_2;\n      }\n\n    case \"doctype\"\n    /* Doctype */\n    :\n      {\n        // This type isn't used yet.\n        throw new Error(\"Not implemented yet: ElementType.Doctype case\");\n      }\n  }\n}\n\nexports.cloneNode = cloneNode;\n\nfunction cloneChildren(childs) {\n  var children = childs.map(function (child) {\n    return cloneNode(child, true);\n  });\n\n  for (var i = 1; i < children.length; i++) {\n    children[i].prev = children[i - 1];\n    children[i - 1].next = children[i];\n  }\n\n  return children;\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/microdata-rdf-streaming-parser/node_modules/domhandler/lib/node.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","defineProperty","exports","value","cloneNode","Element","NodeWithChildren","ProcessingInstruction","Comment","Text","DataNode","Node","nodeTypes","Map","type","parent","prev","next","startIndex","endIndex","get","_a","enumerable","configurable","set","recursive","_super","data","_this","name","children","attribs","keys","map","node","instr","elem","cloneChildren","clone_1","forEach","child","cdata","clone_2","Error","childs"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cloneNode = exports.Element = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;\nvar nodeTypes = new Map([\n    [\"tag\" /* Tag */, 1],\n    [\"script\" /* Script */, 1],\n    [\"style\" /* Style */, 1],\n    [\"directive\" /* Directive */, 1],\n    [\"text\" /* Text */, 3],\n    [\"cdata\" /* CDATA */, 4],\n    [\"comment\" /* Comment */, 8],\n]);\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\nvar Node = /** @class */ (function () {\n    /**\n     *\n     * @param type The type of the node.\n     */\n    function Node(type) {\n        this.type = type;\n        /** Parent of the node */\n        this.parent = null;\n        /** Previous sibling */\n        this.prev = null;\n        /** Next sibling */\n        this.next = null;\n        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n        this.startIndex = null;\n        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n        this.endIndex = null;\n    }\n    Object.defineProperty(Node.prototype, \"nodeType\", {\n        // Read-only aliases\n        get: function () {\n            var _a;\n            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"parentNode\", {\n        // Read-write aliases for properties\n        get: function () {\n            return this.parent;\n        },\n        set: function (parent) {\n            this.parent = parent;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"previousSibling\", {\n        get: function () {\n            return this.prev;\n        },\n        set: function (prev) {\n            this.prev = prev;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"nextSibling\", {\n        get: function () {\n            return this.next;\n        },\n        set: function (next) {\n            this.next = next;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Clone this node, and optionally its children.\n     *\n     * @param recursive Clone child nodes as well.\n     * @returns A clone of the node.\n     */\n    Node.prototype.cloneNode = function (recursive) {\n        if (recursive === void 0) { recursive = false; }\n        return cloneNode(this, recursive);\n    };\n    return Node;\n}());\nexports.Node = Node;\nvar DataNode = /** @class */ (function (_super) {\n    __extends(DataNode, _super);\n    /**\n     * @param type The type of the node\n     * @param data The content of the data node\n     */\n    function DataNode(type, data) {\n        var _this = _super.call(this, type) || this;\n        _this.data = data;\n        return _this;\n    }\n    Object.defineProperty(DataNode.prototype, \"nodeValue\", {\n        get: function () {\n            return this.data;\n        },\n        set: function (data) {\n            this.data = data;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return DataNode;\n}(Node));\nexports.DataNode = DataNode;\nvar Text = /** @class */ (function (_super) {\n    __extends(Text, _super);\n    function Text(data) {\n        return _super.call(this, \"text\" /* Text */, data) || this;\n    }\n    return Text;\n}(DataNode));\nexports.Text = Text;\nvar Comment = /** @class */ (function (_super) {\n    __extends(Comment, _super);\n    function Comment(data) {\n        return _super.call(this, \"comment\" /* Comment */, data) || this;\n    }\n    return Comment;\n}(DataNode));\nexports.Comment = Comment;\nvar ProcessingInstruction = /** @class */ (function (_super) {\n    __extends(ProcessingInstruction, _super);\n    function ProcessingInstruction(name, data) {\n        var _this = _super.call(this, \"directive\" /* Directive */, data) || this;\n        _this.name = name;\n        return _this;\n    }\n    return ProcessingInstruction;\n}(DataNode));\nexports.ProcessingInstruction = ProcessingInstruction;\nvar NodeWithChildren = /** @class */ (function (_super) {\n    __extends(NodeWithChildren, _super);\n    /**\n     *\n     * @param type Type of the node.\n     * @param children Children of the node. Only certain node types can have children.\n     */\n    function NodeWithChildren(type, children) {\n        var _this = _super.call(this, type) || this;\n        _this.children = children;\n        return _this;\n    }\n    Object.defineProperty(NodeWithChildren.prototype, \"firstChild\", {\n        // Aliases\n        get: function () {\n            var _a;\n            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NodeWithChildren.prototype, \"lastChild\", {\n        get: function () {\n            return this.children.length > 0\n                ? this.children[this.children.length - 1]\n                : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NodeWithChildren.prototype, \"childNodes\", {\n        get: function () {\n            return this.children;\n        },\n        set: function (children) {\n            this.children = children;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return NodeWithChildren;\n}(Node));\nexports.NodeWithChildren = NodeWithChildren;\nvar Element = /** @class */ (function (_super) {\n    __extends(Element, _super);\n    /**\n     * @param name Name of the tag, eg. `div`, `span`.\n     * @param attribs Object mapping attribute names to attribute values.\n     * @param children Children of the node.\n     */\n    function Element(name, attribs, children) {\n        if (children === void 0) { children = []; }\n        var _this = _super.call(this, name === \"script\"\n            ? \"script\" /* Script */\n            : name === \"style\"\n                ? \"style\" /* Style */\n                : \"tag\" /* Tag */, children) || this;\n        _this.name = name;\n        _this.attribs = attribs;\n        _this.attribs = attribs;\n        return _this;\n    }\n    Object.defineProperty(Element.prototype, \"tagName\", {\n        // DOM Level 1 aliases\n        get: function () {\n            return this.name;\n        },\n        set: function (name) {\n            this.name = name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"attributes\", {\n        get: function () {\n            var _this = this;\n            return Object.keys(this.attribs).map(function (name) { return ({\n                name: name,\n                value: _this.attribs[name],\n            }); });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Element;\n}(NodeWithChildren));\nexports.Element = Element;\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\nfunction cloneNode(node, recursive) {\n    if (recursive === void 0) { recursive = false; }\n    switch (node.type) {\n        case \"text\" /* Text */:\n            return new Text(node.data);\n        case \"directive\" /* Directive */: {\n            var instr = node;\n            return new ProcessingInstruction(instr.name, instr.data);\n        }\n        case \"comment\" /* Comment */:\n            return new Comment(node.data);\n        case \"tag\" /* Tag */:\n        case \"script\" /* Script */:\n        case \"style\" /* Style */: {\n            var elem = node;\n            var children = recursive ? cloneChildren(elem.children) : [];\n            var clone_1 = new Element(elem.name, __assign({}, elem.attribs), children);\n            children.forEach(function (child) { return (child.parent = clone_1); });\n            return clone_1;\n        }\n        case \"cdata\" /* CDATA */: {\n            var cdata = node;\n            var children = recursive ? cloneChildren(cdata.children) : [];\n            var clone_2 = new NodeWithChildren(\"cdata\" /* CDATA */, children);\n            children.forEach(function (child) { return (child.parent = clone_2); });\n            return clone_2;\n        }\n        case \"doctype\" /* Doctype */: {\n            // This type isn't used yet.\n            throw new Error(\"Not implemented yet: ElementType.Doctype case\");\n        }\n    }\n}\nexports.cloneNode = cloneNode;\nfunction cloneChildren(childs) {\n    var children = childs.map(function (child) { return cloneNode(child, true); });\n    for (var i = 1; i < children.length; i++) {\n        children[i].prev = children[i - 1];\n        children[i - 1].next = children[i];\n    }\n    return children;\n}\n"]},"metadata":{},"sourceType":"script"}