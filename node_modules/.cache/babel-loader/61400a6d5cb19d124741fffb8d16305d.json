{"ast":null,"code":"import { lazyThenable } from './promiseUtils';\nimport { iterableToArray } from './iterableUtils';\nimport { ensureArray, joinArrays, valueToTerm, hasPlainObjectArgs, isAsyncIterable } from './valueUtils';\n/**\n * Returns a function that, when called with arguments,\n * extends the path with mutationExpressions.\n *\n * Mutation functions can be called in two equivalent ways:\n * - path.property.set(object, object)\n * - path.set({ property: [object, object] })\n * Objects can be strings, terms, or path expressions.\n * The second syntax allows setting multiple properties at once.\n * It also has `null` and `undefined` as shortcuts for the empty array,\n * and a direct value as shortcut for a single-valued array.\n *\n * Requires:\n * - a pathExpression property on the path proxy and all non-raw arguments.\n */\n\nexport default class MutationFunctionHandler {\n  constructor(mutationType, allowZeroArgs) {\n    this._mutationType = mutationType;\n    this._allowZeroArgs = allowZeroArgs;\n  } // Creates a function that performs a mutation\n\n\n  handle(pathData, path) {\n    return (...args) => {\n      // Check if the given arguments are valid\n      if (!this._allowZeroArgs && !args.length) throw new Error('Mutation cannot be invoked without arguments'); // Create a lazy Promise to the mutation expressions\n\n      const mutationExpressions = lazyThenable(() => this.createMutationExpressions(pathData, path, args));\n      return pathData.extendPath({\n        mutationExpressions\n      });\n    };\n  } // Creates expressions that represent the requested mutation\n\n\n  async createMutationExpressions(pathData, path, args) {\n    // The mutation targets a single property on the path by passing objects\n    if (!hasPlainObjectArgs(args)) return [await this.createMutationExpression(pathData, path, args)]; // The mutation targets multiple properties through a map of property-objects pairs\n\n    const pairs = Object.entries(args[0]);\n    const expressions = await Promise.all(pairs.map(([property, values]) => this.createMutationExpression(pathData, path[property], ensureArray(values)))); // Group expressions together to maintain the same structure as the singular case\n    // (All properties have the same parent path, and hence the same condition)\n\n    return [expressions.length === 0 ? {} : { ...expressions[0],\n      predicateObjects: joinArrays(expressions.map(e => e.predicateObjects))\n    }];\n  } // Creates an expression that represents a mutation with the given objects\n\n\n  async createMutationExpression(pathData, path, values) {\n    // Obtain the path segments, which are the selection conditions for the mutation\n    const conditions = await path.pathExpression;\n    if (!Array.isArray(conditions)) throw new Error(`${pathData} has no pathExpression property`);\n    if (conditions.length < 2) throw new Error(`${pathData} should at least contain a subject and a predicate`); // Obtain the predicate and target objects\n\n    const {\n      predicate,\n      reverse\n    } = conditions[conditions.length - 1];\n    if (!predicate) throw new Error(`Expected predicate in ${pathData}`);\n    const objects = await this.extractObjects(pathData, path, values); // Create a mutation, unless no objects are affected (`null` means all)\n\n    return objects !== null && objects.length === 0 ? {} : {\n      mutationType: this._mutationType,\n      conditions: conditions.slice(0, -1),\n      predicateObjects: [{\n        predicate,\n        reverse,\n        objects\n      }]\n    };\n  } // Extracts individual objects from a set of values passed to a mutation function\n\n\n  async extractObjects(pathData, path, values) {\n    // If no specific values are specified, match all (represented by `null`)\n    if (values.length === 0) return null; // Otherwise, expand singular values, promises, and paths\n\n    const objects = [];\n\n    for (const value of values) {\n      if (!isAsyncIterable(value)) // Add a (promise to) a single value\n        objects.push(await value); // Add multiple values from a path\n      else objects.push(...(await iterableToArray(value)));\n    }\n\n    return objects.map(valueToTerm);\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/MutationFunctionHandler.js"],"names":["lazyThenable","iterableToArray","ensureArray","joinArrays","valueToTerm","hasPlainObjectArgs","isAsyncIterable","MutationFunctionHandler","constructor","mutationType","allowZeroArgs","_mutationType","_allowZeroArgs","handle","pathData","path","args","length","Error","mutationExpressions","createMutationExpressions","extendPath","createMutationExpression","pairs","Object","entries","expressions","Promise","all","map","property","values","predicateObjects","e","conditions","pathExpression","Array","isArray","predicate","reverse","objects","extractObjects","slice","value","push"],"mappings":"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","sourcesContent":["import { lazyThenable } from './promiseUtils';\nimport { iterableToArray } from './iterableUtils';\nimport { ensureArray, joinArrays, valueToTerm, hasPlainObjectArgs, isAsyncIterable } from './valueUtils';\n/**\n * Returns a function that, when called with arguments,\n * extends the path with mutationExpressions.\n *\n * Mutation functions can be called in two equivalent ways:\n * - path.property.set(object, object)\n * - path.set({ property: [object, object] })\n * Objects can be strings, terms, or path expressions.\n * The second syntax allows setting multiple properties at once.\n * It also has `null` and `undefined` as shortcuts for the empty array,\n * and a direct value as shortcut for a single-valued array.\n *\n * Requires:\n * - a pathExpression property on the path proxy and all non-raw arguments.\n */\n\nexport default class MutationFunctionHandler {\n  constructor(mutationType, allowZeroArgs) {\n    this._mutationType = mutationType;\n    this._allowZeroArgs = allowZeroArgs;\n  } // Creates a function that performs a mutation\n\n\n  handle(pathData, path) {\n    return (...args) => {\n      // Check if the given arguments are valid\n      if (!this._allowZeroArgs && !args.length) throw new Error('Mutation cannot be invoked without arguments'); // Create a lazy Promise to the mutation expressions\n\n      const mutationExpressions = lazyThenable(() => this.createMutationExpressions(pathData, path, args));\n      return pathData.extendPath({\n        mutationExpressions\n      });\n    };\n  } // Creates expressions that represent the requested mutation\n\n\n  async createMutationExpressions(pathData, path, args) {\n    // The mutation targets a single property on the path by passing objects\n    if (!hasPlainObjectArgs(args)) return [await this.createMutationExpression(pathData, path, args)]; // The mutation targets multiple properties through a map of property-objects pairs\n\n    const pairs = Object.entries(args[0]);\n    const expressions = await Promise.all(pairs.map(([property, values]) => this.createMutationExpression(pathData, path[property], ensureArray(values)))); // Group expressions together to maintain the same structure as the singular case\n    // (All properties have the same parent path, and hence the same condition)\n\n    return [expressions.length === 0 ? {} : { ...expressions[0],\n      predicateObjects: joinArrays(expressions.map(e => e.predicateObjects))\n    }];\n  } // Creates an expression that represents a mutation with the given objects\n\n\n  async createMutationExpression(pathData, path, values) {\n    // Obtain the path segments, which are the selection conditions for the mutation\n    const conditions = await path.pathExpression;\n    if (!Array.isArray(conditions)) throw new Error(`${pathData} has no pathExpression property`);\n    if (conditions.length < 2) throw new Error(`${pathData} should at least contain a subject and a predicate`); // Obtain the predicate and target objects\n\n    const {\n      predicate,\n      reverse\n    } = conditions[conditions.length - 1];\n    if (!predicate) throw new Error(`Expected predicate in ${pathData}`);\n    const objects = await this.extractObjects(pathData, path, values); // Create a mutation, unless no objects are affected (`null` means all)\n\n    return objects !== null && objects.length === 0 ? {} : {\n      mutationType: this._mutationType,\n      conditions: conditions.slice(0, -1),\n      predicateObjects: [{\n        predicate,\n        reverse,\n        objects\n      }]\n    };\n  } // Extracts individual objects from a set of values passed to a mutation function\n\n\n  async extractObjects(pathData, path, values) {\n    // If no specific values are specified, match all (represented by `null`)\n    if (values.length === 0) return null; // Otherwise, expand singular values, promises, and paths\n\n    const objects = [];\n\n    for (const value of values) {\n      if (!isAsyncIterable(value)) // Add a (promise to) a single value\n        objects.push(await value); // Add multiple values from a path\n      else objects.push(...(await iterableToArray(value)));\n    }\n\n    return objects.map(valueToTerm);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}