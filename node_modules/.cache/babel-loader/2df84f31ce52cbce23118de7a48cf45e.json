{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NoExistenceHook = exports.NoAggregator = exports.UnknownNamedOperator = exports.UnknownOperator = exports.InvalidTermType = exports.InvalidExpressionType = exports.InvalidExpression = exports.InvalidArity = exports.UnimplementedError = exports.UnexpectedError = exports.EmptyAggregateError = exports.IncompatibleLanguageOperation = exports.InvalidTimezoneCall = exports.CastError = exports.InvalidArgumentTypes = exports.InError = exports.CoalesceError = exports.RDFEqualTypeError = exports.EBVCoercionError = exports.UnboundVariableError = exports.InvalidLexicalForm = exports.isExpressionError = exports.ExpressionError = void 0;\n/**\n * This class of error will be thrown when an expression errors.\n * Various reasons this could happen are:\n *   - invalid types for the given operator\n *   - unbound variables\n *   - invalid lexical forms\n *   - ...\n *\n * The distinction is made so that one can catch this specific type\n * and handle it accordingly to the SPARQL spec (relevant for e.g. FILTER, EXTEND),\n * while others (programming errors) can be re-thrown.\n *\n * @see isExpressionError\n */\n\nclass ExpressionError extends Error {}\n\nexports.ExpressionError = ExpressionError;\n/**\n * Checks whether a given error is an {@link ExpressionError}.\n * Also useful for mocking in tests for covering all branches.\n *\n * @see ExpressionError\n */\n\nfunction isExpressionError(error) {\n  return error instanceof ExpressionError;\n}\n\nexports.isExpressionError = isExpressionError;\n/**\n * A literal has an invalid lexical form for the datatype it is accompanied by.\n * This error is only thrown when the term is as function argument that requires\n * a valid lexical form.\n */\n\nclass InvalidLexicalForm extends ExpressionError {\n  constructor(arg) {\n    super(`Invalid lexical form '${pp(arg)}'`);\n    this.arg = arg;\n  }\n\n}\n\nexports.InvalidLexicalForm = InvalidLexicalForm;\n/**\n * A variable in the expression was not bound.\n */\n\nclass UnboundVariableError extends ExpressionError {\n  constructor(variable, bindings) {\n    super(`Unbound variable '${pp(variable)}'`);\n    this.variable = variable;\n    this.bindings = bindings;\n  }\n\n}\n\nexports.UnboundVariableError = UnboundVariableError;\n/**\n * An invalid term was being coerced to an Effective Boolean Value.\n *\n * See the {@link https://www.w3.org/TR/sparql11-query/#ebv | SPARQL docs}\n * on EBVs.\n */\n\nclass EBVCoercionError extends ExpressionError {\n  constructor(arg) {\n    super(`Cannot coerce term to EBV '${pp(arg)}'`);\n    this.arg = arg;\n  }\n\n}\n\nexports.EBVCoercionError = EBVCoercionError;\n/**\n * An equality test was done on literals with unsupported datatypes.\n *\n * See {@link https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal | term equality spec}.\n */\n\nclass RDFEqualTypeError extends ExpressionError {\n  constructor(args) {\n    super('Equality test for literals with unsupported datatypes');\n    this.args = args;\n  }\n\n}\n\nexports.RDFEqualTypeError = RDFEqualTypeError;\n/**\n * All the expressions in a COALESCE call threw errors.\n */\n\nclass CoalesceError extends ExpressionError {\n  constructor(errors) {\n    super('All COALESCE arguments threw errors');\n    this.errors = errors;\n  }\n\n}\n\nexports.CoalesceError = CoalesceError;\n/**\n * No arguments to an IN call where equal, and at least one threw an error.\n */\n\nclass InError extends ExpressionError {\n  constructor(errors) {\n    super('Some argument to IN errorred and none where equal. ' + errors.map(err => `(${err.toString()}) `).join('and '));\n    this.errors = errors;\n  }\n\n}\n\nexports.InError = InError;\n/**\n * Literals were passed to an operator that doesn't support their datatypes.\n */\n\nclass InvalidArgumentTypes extends ExpressionError {\n  constructor(args, op) {\n    super(`Argument types not valid for operator: '${pp(op)}' with '${pp(args)}`);\n    this.args = args;\n    this.op = op;\n  }\n\n}\n\nexports.InvalidArgumentTypes = InvalidArgumentTypes;\n/**\n * An invalid typecast happened.\n */\n\nclass CastError extends ExpressionError {\n  constructor(arg, cast) {\n    super(`Invalid cast: '${pp(arg)}' to '${pp(cast)}'`);\n    this.arg = arg;\n  }\n\n}\n\nexports.CastError = CastError;\n\nclass InvalidTimezoneCall extends ExpressionError {\n  constructor(dateString) {\n    super(`TIMEZONE call on ${dateString} which has no timezone`);\n    this.dateString = dateString;\n  }\n\n}\n\nexports.InvalidTimezoneCall = InvalidTimezoneCall;\n\nclass IncompatibleLanguageOperation extends ExpressionError {\n  constructor(arg1, arg2) {\n    super(`Operation on incompatible language literals '${pp(arg1)}' and '${pp(arg2)}'`);\n    this.arg1 = arg1;\n    this.arg2 = arg2;\n  }\n\n}\n\nexports.IncompatibleLanguageOperation = IncompatibleLanguageOperation;\n\nclass EmptyAggregateError extends ExpressionError {\n  constructor() {\n    super('Empty aggregate expression');\n  }\n\n}\n\nexports.EmptyAggregateError = EmptyAggregateError; // Non Expression Errors ------------------------------------------------------\n\n/**\n * An error that arises when we detect a 'should-be-impossible' state.\n * Given that this error is thrown, it clearly wasn't impossible, and some\n * mistake has been made.\n */\n\nclass UnexpectedError extends Error {\n  constructor(message, payload) {\n    super(`Programmer Error '${message}'`);\n    this.payload = payload;\n  }\n\n}\n\nexports.UnexpectedError = UnexpectedError;\n/**\n * An Error that signals a feature or function is yet unimplemented.\n */\n\nclass UnimplementedError extends Error {\n  constructor(feature) {\n    super(`Unimplemented feature '${feature}!'`);\n  }\n\n}\n\nexports.UnimplementedError = UnimplementedError;\n\nclass InvalidArity extends Error {\n  constructor(args, op) {\n    super(`The number of args does not match the arity of the operator '${pp(op)}'.`);\n    this.args = args;\n    this.op = op;\n  }\n\n}\n\nexports.InvalidArity = InvalidArity;\n\nclass InvalidExpression extends Error {\n  constructor(expr) {\n    super(`Invalid SPARQL Expression '${pp(expr)}'`);\n  }\n\n}\n\nexports.InvalidExpression = InvalidExpression;\n\nclass InvalidExpressionType extends Error {\n  constructor(expr) {\n    super(`Invalid expression type for SPARQL Expression '${pp(expr)}'`);\n    this.expr = expr;\n  }\n\n}\n\nexports.InvalidExpressionType = InvalidExpressionType;\n\nclass InvalidTermType extends Error {\n  constructor(term) {\n    super(`Invalid term type for term '${pp(term)}'`);\n    this.term = term;\n  }\n\n}\n\nexports.InvalidTermType = InvalidTermType;\n\nclass UnknownOperator extends Error {\n  constructor(name) {\n    super(`Unknown operator: '${pp(name)}`);\n  }\n\n}\n\nexports.UnknownOperator = UnknownOperator;\n\nclass UnknownNamedOperator extends Error {\n  constructor(name) {\n    super(`Unknown named operator: '${pp(name)}'`);\n  }\n\n}\n\nexports.UnknownNamedOperator = UnknownNamedOperator;\n\nclass NoAggregator extends Error {\n  constructor(name) {\n    super(`Aggregate expression ${pp(name)} found, but no aggregate hook provided.`);\n  }\n\n}\n\nexports.NoAggregator = NoAggregator;\n\nclass NoExistenceHook extends Error {\n  constructor() {\n    super('EXISTS found, but no existence hook provided.');\n  }\n\n}\n\nexports.NoExistenceHook = NoExistenceHook;\n\nfunction pp(o) {\n  return JSON.stringify(o);\n}","map":{"version":3,"sources":["../../../lib/util/Errors.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra } from 'sparqlalgebrajs';\n\nimport * as E from '../expressions';\nimport * as C from './Consts';\n\nimport { Bindings } from '../Types';\n\n/**\n * This class of error will be thrown when an expression errors.\n * Various reasons this could happen are:\n *   - invalid types for the given operator\n *   - unbound variables\n *   - invalid lexical forms\n *   - ...\n *\n * The distinction is made so that one can catch this specific type\n * and handle it accordingly to the SPARQL spec (relevant for e.g. FILTER, EXTEND),\n * while others (programming errors) can be re-thrown.\n *\n * @see isExpressionError\n */\nexport class ExpressionError extends Error { }\n\n/**\n * Checks whether a given error is an {@link ExpressionError}.\n * Also useful for mocking in tests for covering all branches.\n *\n * @see ExpressionError\n */\nexport function isExpressionError(error: Error): boolean {\n  return error instanceof ExpressionError;\n}\n\n/**\n * A literal has an invalid lexical form for the datatype it is accompanied by.\n * This error is only thrown when the term is as function argument that requires\n * a valid lexical form.\n */\nexport class InvalidLexicalForm extends ExpressionError {\n  constructor(public arg: RDF.Term) {\n    super(`Invalid lexical form '${pp(arg)}'`);\n  }\n}\n\n/**\n * A variable in the expression was not bound.\n */\nexport class UnboundVariableError extends ExpressionError {\n  constructor(public variable: string, public bindings: Bindings) {\n    super(`Unbound variable '${pp(variable)}'`);\n  }\n}\n\n/**\n * An invalid term was being coerced to an Effective Boolean Value.\n *\n * See the {@link https://www.w3.org/TR/sparql11-query/#ebv | SPARQL docs}\n * on EBVs.\n */\nexport class EBVCoercionError extends ExpressionError {\n  constructor(public arg: E.Term) {\n    super(`Cannot coerce term to EBV '${pp(arg)}'`);\n  }\n}\n\n/**\n * An equality test was done on literals with unsupported datatypes.\n *\n * See {@link https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal | term equality spec}.\n */\nexport class RDFEqualTypeError extends ExpressionError {\n  constructor(public args: E.Expression[]) {\n    super('Equality test for literals with unsupported datatypes');\n  }\n}\n\n/**\n * All the expressions in a COALESCE call threw errors.\n */\nexport class CoalesceError extends ExpressionError {\n  constructor(public errors: Error[]) {\n    super('All COALESCE arguments threw errors');\n  }\n}\n\n/**\n * No arguments to an IN call where equal, and at least one threw an error.\n */\nexport class InError extends ExpressionError {\n  constructor(public errors: Array<Error | false>) {\n    super(\n      'Some argument to IN errorred and none where equal. ' +\n      errors.map((err) => `(${err.toString()}) `).join('and '));\n  }\n}\n\n/**\n * Literals were passed to an operator that doesn't support their datatypes.\n */\nexport class InvalidArgumentTypes extends ExpressionError {\n  constructor(public args: E.Expression[], public op: C.Operator | C.NamedOperator) {\n    super(`Argument types not valid for operator: '${pp(op)}' with '${pp(args)}`);\n  }\n}\n\n/**\n * An invalid typecast happened.\n */\nexport class CastError<T> extends ExpressionError {\n  constructor(public arg: T, cast: C.TypeURL) {\n    super(`Invalid cast: '${pp(arg)}' to '${pp(cast)}'`);\n  }\n}\n\nexport class InvalidTimezoneCall extends ExpressionError {\n  constructor(public dateString: string) {\n    super(`TIMEZONE call on ${dateString} which has no timezone`);\n  }\n}\n\nexport class IncompatibleLanguageOperation extends ExpressionError {\n  constructor(public arg1: E.LangStringLiteral, public arg2: E.LangStringLiteral) {\n    super(`Operation on incompatible language literals '${pp(arg1)}' and '${pp(arg2)}'`);\n  }\n}\n\nexport class EmptyAggregateError extends ExpressionError {\n  constructor() {\n    super('Empty aggregate expression');\n  }\n}\n\n// Non Expression Errors ------------------------------------------------------\n\n/**\n * An error that arises when we detect a 'should-be-impossible' state.\n * Given that this error is thrown, it clearly wasn't impossible, and some\n * mistake has been made.\n */\nexport class UnexpectedError<T> extends Error {\n  constructor(message: string, public payload?: T) {\n    super(`Programmer Error '${message}'`);\n  }\n}\n\n/**\n * An Error that signals a feature or function is yet unimplemented.\n */\nexport class UnimplementedError extends Error {\n  constructor(feature: string) {\n    super(`Unimplemented feature '${feature}!'`);\n  }\n}\n\nexport class InvalidArity extends Error {\n  constructor(public args: E.Expression[], public op: C.Operator) {\n    super(`The number of args does not match the arity of the operator '${pp(op)}'.`);\n  }\n}\n\nexport class InvalidExpression<T> extends Error {\n  constructor(expr: T) {\n    super(`Invalid SPARQL Expression '${pp(expr)}'`);\n  }\n}\n\nexport class InvalidExpressionType<T> extends Error {\n  constructor(public expr: T) {\n    super(`Invalid expression type for SPARQL Expression '${pp(expr)}'`);\n  }\n}\n\nexport class InvalidTermType extends Error {\n  constructor(public term: Algebra.TermExpression) {\n    super(`Invalid term type for term '${pp(term)}'`);\n  }\n}\n\nexport class UnknownOperator extends Error {\n  constructor(name: string) {\n    super(`Unknown operator: '${pp(name)}`);\n  }\n}\n\nexport class UnknownNamedOperator extends Error {\n  constructor(name: string) {\n    super(`Unknown named operator: '${pp(name)}'`);\n  }\n}\n\nexport class NoAggregator extends Error {\n  constructor(name?: string) {\n    super(`Aggregate expression ${pp(name)} found, but no aggregate hook provided.`);\n  }\n}\n\nexport class NoExistenceHook extends Error {\n  constructor() {\n    super('EXISTS found, but no existence hook provided.');\n  }\n}\n\nfunction pp<T>(o: T) {\n  return JSON.stringify(o);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}