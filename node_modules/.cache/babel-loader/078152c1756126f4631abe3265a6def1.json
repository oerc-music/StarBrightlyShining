{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.materializeOperation = exports.materializeTerm = exports.ensureBindings = exports.isBindings = exports.Bindings = void 0;\n\nconst immutable_1 = require(\"immutable\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A convenience constructor for bindings based on a given hash.\n * @param {{[p: string]: RDF.Term}} hash A hash that maps variable names to terms.\n * @return {Bindings} The immutable bindings from the hash.\n * @constructor\n */\n// eslint-disable-next-line no-redeclare\n\n\nfunction Bindings(hash) {\n  return immutable_1.Map(hash);\n}\n\nexports.Bindings = Bindings;\n/**\n * Check if the given object is a bindings object.\n * @param maybeBindings Any object.\n * @return {boolean} If the object is a bindings object.\n */\n\nfunction isBindings(maybeBindings) {\n  return immutable_1.Map.isMap(maybeBindings);\n}\n\nexports.isBindings = isBindings;\n/**\n * Convert the given object to a bindings object if it is not a bindings object yet.\n * If it already is a bindings object, return the object as-is.\n * @param maybeBindings Any object.\n * @return {Bindings} A bindings object.\n */\n\nfunction ensureBindings(maybeBindings) {\n  return isBindings(maybeBindings) ? maybeBindings : Bindings(maybeBindings);\n}\n\nexports.ensureBindings = ensureBindings;\n/**\n * Materialize a term with the given binding.\n *\n * If the given term is a variable,\n * and that variable exist in the given bindings object,\n * the value of that binding is returned.\n * In all other cases, the term itself is returned.\n *\n * @param {RDF.Term} term A term.\n * @param {Bindings} bindings A bindings object.\n * @return {RDF.Term} The materialized term.\n */\n\nfunction materializeTerm(term, bindings) {\n  if (term.termType === 'Variable') {\n    const value = bindings.get(rdf_string_1.termToString(term));\n\n    if (value) {\n      return value;\n    }\n  }\n\n  return term;\n}\n\nexports.materializeTerm = materializeTerm;\n/**\n * Materialize the given operation (recursively) with the given bindings.\n * Essentially, all variables in the given operation will be replaced\n * by the terms bound to the variables in the given bindings.\n * @param {Operation} operation SPARQL algebra operation.\n * @param {Bindings} bindings A bindings object.\n * @param {boolean} strictTargetVariables If target variable bindings (such as on SELECT or BIND) should not be allowed.\n * @return Algebra.Operation A new operation materialized with the given bindings.\n */\n\nfunction materializeOperation(operation, bindings, strictTargetVariables = false) {\n  return sparqlalgebrajs_1.Util.mapOperation(operation, {\n    path(op, factory) {\n      // Materialize variables in a path expression.\n      // The predicate expression will be recursed.\n      return {\n        recurse: false,\n        result: factory.createPath(materializeTerm(op.subject, bindings), op.predicate, materializeTerm(op.object, bindings), materializeTerm(op.graph, bindings))\n      };\n    },\n\n    pattern(op, factory) {\n      // Materialize variables in the quad pattern.\n      return {\n        recurse: false,\n        result: factory.createPattern(materializeTerm(op.subject, bindings), materializeTerm(op.predicate, bindings), materializeTerm(op.object, bindings), materializeTerm(op.graph, bindings))\n      };\n    },\n\n    extend(op) {\n      // Materialize an extend operation.\n      // If strictTargetVariables is true, we throw if the extension target variable is attempted to be bound.\n      // Otherwise, we remove the extend operation.\n      if (bindings.has(rdf_string_1.termToString(op.variable))) {\n        if (strictTargetVariables) {\n          throw new Error(`Tried to bind variable ${rdf_string_1.termToString(op.variable)} in a BIND operator.`);\n        } else {\n          return {\n            recurse: true,\n            result: materializeOperation(op.input, bindings, strictTargetVariables)\n          };\n        }\n      }\n\n      return {\n        recurse: true,\n        result: op\n      };\n    },\n\n    group(op, factory) {\n      // Materialize a group operation.\n      // If strictTargetVariables is true, we throw if the group target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables.\n      if (strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(rdf_string_1.termToString(variable))) {\n            throw new Error(`Tried to bind variable ${rdf_string_1.termToString(variable)} in a GROUP BY operator.`);\n          }\n        }\n\n        return {\n          recurse: true,\n          result: op\n        };\n      }\n\n      const variables = op.variables.filter(variable => !bindings.has(rdf_string_1.termToString(variable)));\n      return {\n        recurse: true,\n        result: factory.createGroup(op.input, variables, op.aggregates)\n      };\n    },\n\n    project(op, factory) {\n      // Materialize a project operation.\n      // If strictTargetVariables is true, we throw if the project target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables.\n      if (strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(rdf_string_1.termToString(variable))) {\n            throw new Error(`Tried to bind variable ${rdf_string_1.termToString(variable)} in a SELECT operator.`);\n          }\n        }\n\n        return {\n          recurse: true,\n          result: op\n        };\n      }\n\n      const variables = op.variables.filter(variable => !bindings.has(rdf_string_1.termToString(variable)));\n      return {\n        recurse: true,\n        result: factory.createProject(op.input, variables)\n      };\n    },\n\n    values(op, factory) {\n      // Materialize a values operation.\n      // If strictTargetVariables is true, we throw if the values target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables and their bindings.\n      if (strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(rdf_string_1.termToString(variable))) {\n            throw new Error(`Tried to bind variable ${rdf_string_1.termToString(variable)} in a VALUES operator.`);\n          }\n        }\n      } else {\n        const variables = op.variables.filter(variable => !bindings.has(rdf_string_1.termToString(variable)));\n        const valueBindings = op.bindings.map(binding => {\n          const newBinding = Object.assign({}, binding);\n          bindings.forEach((value, key) => delete newBinding[key]);\n          return newBinding;\n        });\n        return {\n          recurse: true,\n          result: factory.createValues(variables, valueBindings)\n        };\n      }\n\n      return {\n        recurse: false,\n        result: op\n      };\n    },\n\n    expression(op, factory) {\n      if (op.expressionType === 'term') {\n        // Materialize a term expression\n        return {\n          recurse: false,\n          result: factory.createTermExpression(materializeTerm(op.term, bindings))\n        };\n      }\n\n      if (op.expressionType === 'aggregate' && 'variable' in op && bindings.has(rdf_string_1.termToString(op.variable))) {\n        // Materialize a bound aggregate operation.\n        // If strictTargetVariables is true, we throw if the expression target variable is attempted to be bound.\n        // Otherwise, we ignore this operation.\n        if (strictTargetVariables) {\n          throw new Error(`Tried to bind ${rdf_string_1.termToString(op.variable)} in a ${op.aggregator} aggregate.`);\n        } else {\n          return {\n            recurse: true,\n            result: op\n          };\n        }\n      }\n\n      return {\n        recurse: true,\n        result: op\n      };\n    }\n\n  });\n}\n\nexports.materializeOperation = materializeOperation;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/bus-query-operation/lib/Bindings.js"],"names":["Object","defineProperty","exports","value","materializeOperation","materializeTerm","ensureBindings","isBindings","Bindings","immutable_1","require","rdf_string_1","sparqlalgebrajs_1","hash","Map","maybeBindings","isMap","term","bindings","termType","get","termToString","operation","strictTargetVariables","Util","mapOperation","path","op","factory","recurse","result","createPath","subject","predicate","object","graph","pattern","createPattern","extend","has","variable","Error","input","group","variables","filter","createGroup","aggregates","project","createProject","values","valueBindings","map","binding","newBinding","assign","forEach","key","createValues","expression","expressionType","createTermExpression","aggregator"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.materializeOperation = exports.materializeTerm = exports.ensureBindings = exports.isBindings = exports.Bindings = void 0;\nconst immutable_1 = require(\"immutable\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A convenience constructor for bindings based on a given hash.\n * @param {{[p: string]: RDF.Term}} hash A hash that maps variable names to terms.\n * @return {Bindings} The immutable bindings from the hash.\n * @constructor\n */\n// eslint-disable-next-line no-redeclare\nfunction Bindings(hash) {\n    return immutable_1.Map(hash);\n}\nexports.Bindings = Bindings;\n/**\n * Check if the given object is a bindings object.\n * @param maybeBindings Any object.\n * @return {boolean} If the object is a bindings object.\n */\nfunction isBindings(maybeBindings) {\n    return immutable_1.Map.isMap(maybeBindings);\n}\nexports.isBindings = isBindings;\n/**\n * Convert the given object to a bindings object if it is not a bindings object yet.\n * If it already is a bindings object, return the object as-is.\n * @param maybeBindings Any object.\n * @return {Bindings} A bindings object.\n */\nfunction ensureBindings(maybeBindings) {\n    return isBindings(maybeBindings) ? maybeBindings : Bindings(maybeBindings);\n}\nexports.ensureBindings = ensureBindings;\n/**\n * Materialize a term with the given binding.\n *\n * If the given term is a variable,\n * and that variable exist in the given bindings object,\n * the value of that binding is returned.\n * In all other cases, the term itself is returned.\n *\n * @param {RDF.Term} term A term.\n * @param {Bindings} bindings A bindings object.\n * @return {RDF.Term} The materialized term.\n */\nfunction materializeTerm(term, bindings) {\n    if (term.termType === 'Variable') {\n        const value = bindings.get(rdf_string_1.termToString(term));\n        if (value) {\n            return value;\n        }\n    }\n    return term;\n}\nexports.materializeTerm = materializeTerm;\n/**\n * Materialize the given operation (recursively) with the given bindings.\n * Essentially, all variables in the given operation will be replaced\n * by the terms bound to the variables in the given bindings.\n * @param {Operation} operation SPARQL algebra operation.\n * @param {Bindings} bindings A bindings object.\n * @param {boolean} strictTargetVariables If target variable bindings (such as on SELECT or BIND) should not be allowed.\n * @return Algebra.Operation A new operation materialized with the given bindings.\n */\nfunction materializeOperation(operation, bindings, strictTargetVariables = false) {\n    return sparqlalgebrajs_1.Util.mapOperation(operation, {\n        path(op, factory) {\n            // Materialize variables in a path expression.\n            // The predicate expression will be recursed.\n            return {\n                recurse: false,\n                result: factory.createPath(materializeTerm(op.subject, bindings), op.predicate, materializeTerm(op.object, bindings), materializeTerm(op.graph, bindings)),\n            };\n        },\n        pattern(op, factory) {\n            // Materialize variables in the quad pattern.\n            return {\n                recurse: false,\n                result: factory.createPattern(materializeTerm(op.subject, bindings), materializeTerm(op.predicate, bindings), materializeTerm(op.object, bindings), materializeTerm(op.graph, bindings)),\n            };\n        },\n        extend(op) {\n            // Materialize an extend operation.\n            // If strictTargetVariables is true, we throw if the extension target variable is attempted to be bound.\n            // Otherwise, we remove the extend operation.\n            if (bindings.has(rdf_string_1.termToString(op.variable))) {\n                if (strictTargetVariables) {\n                    throw new Error(`Tried to bind variable ${rdf_string_1.termToString(op.variable)} in a BIND operator.`);\n                }\n                else {\n                    return {\n                        recurse: true,\n                        result: materializeOperation(op.input, bindings, strictTargetVariables),\n                    };\n                }\n            }\n            return {\n                recurse: true,\n                result: op,\n            };\n        },\n        group(op, factory) {\n            // Materialize a group operation.\n            // If strictTargetVariables is true, we throw if the group target variable is attempted to be bound.\n            // Otherwise, we just filter out the bound variables.\n            if (strictTargetVariables) {\n                for (const variable of op.variables) {\n                    if (bindings.has(rdf_string_1.termToString(variable))) {\n                        throw new Error(`Tried to bind variable ${rdf_string_1.termToString(variable)} in a GROUP BY operator.`);\n                    }\n                }\n                return {\n                    recurse: true,\n                    result: op,\n                };\n            }\n            const variables = op.variables.filter(variable => !bindings.has(rdf_string_1.termToString(variable)));\n            return {\n                recurse: true,\n                result: factory.createGroup(op.input, variables, op.aggregates),\n            };\n        },\n        project(op, factory) {\n            // Materialize a project operation.\n            // If strictTargetVariables is true, we throw if the project target variable is attempted to be bound.\n            // Otherwise, we just filter out the bound variables.\n            if (strictTargetVariables) {\n                for (const variable of op.variables) {\n                    if (bindings.has(rdf_string_1.termToString(variable))) {\n                        throw new Error(`Tried to bind variable ${rdf_string_1.termToString(variable)} in a SELECT operator.`);\n                    }\n                }\n                return {\n                    recurse: true,\n                    result: op,\n                };\n            }\n            const variables = op.variables.filter(variable => !bindings.has(rdf_string_1.termToString(variable)));\n            return {\n                recurse: true,\n                result: factory.createProject(op.input, variables),\n            };\n        },\n        values(op, factory) {\n            // Materialize a values operation.\n            // If strictTargetVariables is true, we throw if the values target variable is attempted to be bound.\n            // Otherwise, we just filter out the bound variables and their bindings.\n            if (strictTargetVariables) {\n                for (const variable of op.variables) {\n                    if (bindings.has(rdf_string_1.termToString(variable))) {\n                        throw new Error(`Tried to bind variable ${rdf_string_1.termToString(variable)} in a VALUES operator.`);\n                    }\n                }\n            }\n            else {\n                const variables = op.variables.filter(variable => !bindings.has(rdf_string_1.termToString(variable)));\n                const valueBindings = op.bindings.map(binding => {\n                    const newBinding = Object.assign({}, binding);\n                    bindings.forEach((value, key) => delete newBinding[key]);\n                    return newBinding;\n                });\n                return {\n                    recurse: true,\n                    result: factory.createValues(variables, valueBindings),\n                };\n            }\n            return {\n                recurse: false,\n                result: op,\n            };\n        },\n        expression(op, factory) {\n            if (op.expressionType === 'term') {\n                // Materialize a term expression\n                return {\n                    recurse: false,\n                    result: factory.createTermExpression(materializeTerm(op.term, bindings)),\n                };\n            }\n            if (op.expressionType === 'aggregate' &&\n                'variable' in op &&\n                bindings.has(rdf_string_1.termToString(op.variable))) {\n                // Materialize a bound aggregate operation.\n                // If strictTargetVariables is true, we throw if the expression target variable is attempted to be bound.\n                // Otherwise, we ignore this operation.\n                if (strictTargetVariables) {\n                    throw new Error(`Tried to bind ${rdf_string_1.termToString(op.variable)} in a ${op.aggregator} aggregate.`);\n                }\n                else {\n                    return {\n                        recurse: true,\n                        result: op,\n                    };\n                }\n            }\n            return {\n                recurse: true,\n                result: op,\n            };\n        },\n    });\n}\nexports.materializeOperation = materializeOperation;\n//# sourceMappingURL=Bindings.js.map"]},"metadata":{},"sourceType":"script"}