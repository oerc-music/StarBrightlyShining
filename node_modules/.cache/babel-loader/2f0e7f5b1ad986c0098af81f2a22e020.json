{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FederatedQuadSource = void 0;\n\nconst bus_rdf_resolve_quad_pattern_1 = require(\"@comunica/bus-rdf-resolve-quad-pattern\");\n\nconst context_entries_1 = require(\"@comunica/context-entries\");\n\nconst data_factory_1 = require(\"@comunica/data-factory\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst rdf_terms_1 = require(\"rdf-terms\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * A FederatedQuadSource can evaluate quad pattern queries over the union of different heterogeneous sources.\n * It will call the given mediator to evaluate each quad pattern query separately.\n */\n\nclass FederatedQuadSource {\n  constructor(mediatorResolveQuadPattern, context, emptyPatterns, skipEmptyPatterns) {\n    this.mediatorResolveQuadPattern = mediatorResolveQuadPattern;\n    this.sources = context.get(context_entries_1.KeysRdfResolveQuadPattern.sources);\n    this.contextDefault = context.delete(context_entries_1.KeysRdfResolveQuadPattern.sources);\n    this.emptyPatterns = emptyPatterns;\n    this.sourceIds = new Map();\n    this.skipEmptyPatterns = skipEmptyPatterns;\n    this.algebraFactory = new sparqlalgebrajs_1.Factory(); // Initialize sources in the emptyPatterns datastructure\n\n    if (this.skipEmptyPatterns) {\n      for (const source of this.sources) {\n        if (!this.emptyPatterns.has(source)) {\n          this.emptyPatterns.set(source, []);\n        }\n      }\n    }\n  }\n  /**\n   * Check if the given RDF term is not bound to an exact value.\n   * I.e., if it is not a Variable.\n   * @param {RDF.Term} term An RDF term.\n   * @return {boolean} If it is not bound.\n   */\n\n\n  static isTermBound(term) {\n    return term.termType !== 'Variable';\n  }\n  /**\n   * Checks if the given (child) pattern is a more bound version of the given (parent) pattern.\n   * This will also return true if the patterns are equal.\n   * @param {RDF.BaseQuad} child A child pattern.\n   * @param {RDF.BaseQuad} parent A parent pattern.\n   * @return {boolean} If child is a sub-pattern of parent\n   */\n\n\n  static isSubPatternOf(child, parent) {\n    return (!FederatedQuadSource.isTermBound(parent.subject) || parent.subject.equals(child.subject)) && (!FederatedQuadSource.isTermBound(parent.predicate) || parent.predicate.equals(child.predicate)) && (!FederatedQuadSource.isTermBound(parent.object) || parent.object.equals(child.object)) && (!FederatedQuadSource.isTermBound(parent.graph) || parent.graph.equals(child.graph));\n  }\n  /**\n   * If the given term is a blank node, return a deterministic named node for it\n   * based on the source id and the blank node value.\n   * @param term Any RDF term.\n   * @param sourceId A source identifier.\n   * @return If the given term was a blank node, this will return a skolemized named node, otherwise the original term.\n   */\n\n\n  static skolemizeTerm(term, sourceId) {\n    if (term.termType === 'BlankNode') {\n      return new data_factory_1.BlankNodeScoped(`bc_${sourceId}_${term.value}`, DF.namedNode(`${FederatedQuadSource.SKOLEM_PREFIX}${sourceId}:${term.value}`));\n    }\n\n    return term;\n  }\n  /**\n   * Skolemize all terms in the given quad.\n   * @param quad An RDF quad.\n   * @param sourceId A source identifier.\n   * @return The skolemized quad.\n   */\n\n\n  static skolemizeQuad(quad, sourceId) {\n    return rdf_terms_1.mapTerms(quad, term => FederatedQuadSource.skolemizeTerm(term, sourceId));\n  }\n  /**\n   * If a given term was a skolemized named node for the given source id,\n   * deskolemize it again to a blank node.\n   * If the given term was a skolemized named node for another source, return false.\n   * If the given term was not a skolemized named node, return the original term.\n   * @param term Any RDF term.\n   * @param sourceId A source identifier.\n   */\n\n\n  static deskolemizeTerm(term, sourceId) {\n    if (term.termType === 'BlankNode' && 'skolemized' in term) {\n      term = term.skolemized;\n    }\n\n    if (term.termType === 'NamedNode' && term.value.startsWith(FederatedQuadSource.SKOLEM_PREFIX)) {\n      const colonSeparator = term.value.indexOf(':', FederatedQuadSource.SKOLEM_PREFIX.length);\n      const termSourceId = term.value.slice(FederatedQuadSource.SKOLEM_PREFIX.length, colonSeparator); // We had a skolemized term\n\n      if (termSourceId === sourceId) {\n        // It came from the correct source\n        const termLabel = term.value.slice(colonSeparator + 1, term.value.length);\n        return DF.blankNode(termLabel);\n      } // It came from a different source\n\n\n      return null;\n    }\n\n    return term;\n  }\n  /**\n   * If the given source is guaranteed to produce an empty result for the given pattern.\n   *\n   * This prediction is done based on the 'emptyPatterns' datastructure that is stored within this actor.\n   * Every time an empty pattern is passed, this pattern is stored in this datastructure for this source.\n   * If this pattern (or a more bound pattern) is queried, we know for certain that it will be empty again.\n   * This is under the assumption that sources will remain static during query evaluation.\n   *\n   * @param {IQuerySource} source\n   * @param {RDF.BaseQuad} pattern\n   * @return {boolean}\n   */\n\n\n  isSourceEmpty(source, pattern) {\n    if (!this.skipEmptyPatterns) {\n      return false;\n    }\n\n    const emptyPatterns = this.emptyPatterns.get(source);\n\n    if (emptyPatterns) {\n      for (const emptyPattern of emptyPatterns) {\n        if (FederatedQuadSource.isSubPatternOf(pattern, emptyPattern)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Get the unique, deterministic id for the given source.\n   * @param source A data source.\n   * @return The id of the given source.\n   */\n\n\n  getSourceId(source) {\n    let sourceId = this.sourceIds.get(source);\n\n    if (sourceId === undefined) {\n      sourceId = `${this.sourceIds.size}`;\n      this.sourceIds.set(source, sourceId);\n    }\n\n    return sourceId;\n  }\n\n  match(subject, predicate, object, graph) {\n    // Counters for our metadata\n    const metadata = {\n      totalItems: 0\n    };\n    let remainingSources = this.sources.length; // Anonymous function to handle totalItems from metadata\n\n    const checkEmitMetadata = (currentTotalItems, source, pattern, lastMetadata) => {\n      if (this.skipEmptyPatterns && !currentTotalItems && pattern && !this.isSourceEmpty(source, pattern)) {\n        this.emptyPatterns.get(source).push(pattern);\n      }\n\n      if (!remainingSources) {\n        if (lastMetadata && this.sources.length === 1) {\n          // If we only had one source, emit the metadata as-is.\n          it.setProperty('metadata', lastMetadata);\n        } else {\n          it.setProperty('metadata', metadata);\n        }\n      }\n    };\n\n    const proxyIt = Promise.all(this.sources.map(async source => {\n      const sourceId = this.getSourceId(source); // Deskolemize terms, so we send the original blank nodes to each source.\n      // Note that some sources may not match bnodes by label. SPARQL endpoints for example consider them variables.\n\n      const patternS = FederatedQuadSource.deskolemizeTerm(subject, sourceId);\n      const patternP = FederatedQuadSource.deskolemizeTerm(predicate, sourceId);\n      const patternO = FederatedQuadSource.deskolemizeTerm(object, sourceId);\n      const patternG = FederatedQuadSource.deskolemizeTerm(graph, sourceId);\n      let pattern; // Prepare the context for this specific source\n\n      let context = bus_rdf_resolve_quad_pattern_1.getDataSourceContext(source, this.contextDefault);\n      context = context.set(context_entries_1.KeysRdfResolveQuadPattern.source, {\n        type: bus_rdf_resolve_quad_pattern_1.getDataSourceType(source),\n        value: bus_rdf_resolve_quad_pattern_1.getDataSourceValue(source)\n      });\n      let output; // If any of the deskolemized blank nodes originate from another source,\n      // or if we can predict that the given source will have no bindings for the given pattern,\n      // return an empty iterator.\n\n      if (!patternS || !patternP || !patternO || !patternG || // eslint-disable-next-line no-cond-assign\n      this.isSourceEmpty(source, pattern = this.algebraFactory.createPattern(patternS, patternP, patternO, patternG))) {\n        output = {\n          data: new asynciterator_1.ArrayIterator([], {\n            autoStart: false\n          })\n        };\n        output.data.setProperty('metadata', {\n          totalItems: 0\n        });\n      } else {\n        output = await this.mediatorResolveQuadPattern.mediate({\n          pattern,\n          context\n        });\n      } // Handle the metadata from this source\n\n\n      output.data.getProperty('metadata', subMetadata => {\n        if (!subMetadata.totalItems && subMetadata.totalItems !== 0 || !Number.isFinite(subMetadata.totalItems)) {\n          // We're already at infinite, so ignore any later metadata\n          metadata.totalItems = Number.POSITIVE_INFINITY;\n          remainingSources = 0;\n          checkEmitMetadata(Number.POSITIVE_INFINITY, source, pattern, subMetadata);\n        } else {\n          metadata.totalItems += subMetadata.totalItems;\n          remainingSources--;\n          checkEmitMetadata(subMetadata.totalItems, source, pattern, subMetadata);\n        }\n      }); // Determine the data stream from this source\n\n      let data = output.data.map(quad => FederatedQuadSource.skolemizeQuad(quad, sourceId)); // SPARQL query semantics allow graph variables to only match with named graphs, excluding the default graph\n\n      if (graph.termType === 'Variable') {\n        data = data.filter(quad => quad.graph.termType !== 'DefaultGraph');\n      } // Forward errors to our final iterator\n\n\n      data.on('error', error => it.emit('error', error));\n      return data;\n    })); // Take the union of all source streams\n\n    const it = new asynciterator_1.TransformIterator(async () => new asynciterator_1.UnionIterator(await proxyIt), {\n      autoStart: false\n    }); // If we have 0 sources, immediately emit metadata\n\n    if (this.sources.length === 0) {\n      it.setProperty('metadata', metadata);\n    }\n\n    return it;\n  }\n\n}\n\nexports.FederatedQuadSource = FederatedQuadSource;\nFederatedQuadSource.SKOLEM_PREFIX = 'urn:comunica_skolem:source_';","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-rdf-resolve-quad-pattern-federated/lib/FederatedQuadSource.js"],"names":["Object","defineProperty","exports","value","FederatedQuadSource","bus_rdf_resolve_quad_pattern_1","require","context_entries_1","data_factory_1","asynciterator_1","rdf_data_factory_1","rdf_terms_1","sparqlalgebrajs_1","DF","DataFactory","constructor","mediatorResolveQuadPattern","context","emptyPatterns","skipEmptyPatterns","sources","get","KeysRdfResolveQuadPattern","contextDefault","delete","sourceIds","Map","algebraFactory","Factory","source","has","set","isTermBound","term","termType","isSubPatternOf","child","parent","subject","equals","predicate","object","graph","skolemizeTerm","sourceId","BlankNodeScoped","namedNode","SKOLEM_PREFIX","skolemizeQuad","quad","mapTerms","deskolemizeTerm","skolemized","startsWith","colonSeparator","indexOf","length","termSourceId","slice","termLabel","blankNode","isSourceEmpty","pattern","emptyPattern","getSourceId","undefined","size","match","metadata","totalItems","remainingSources","checkEmitMetadata","currentTotalItems","lastMetadata","push","it","setProperty","proxyIt","Promise","all","map","patternS","patternP","patternO","patternG","getDataSourceContext","type","getDataSourceType","getDataSourceValue","output","createPattern","data","ArrayIterator","autoStart","mediate","getProperty","subMetadata","Number","isFinite","POSITIVE_INFINITY","filter","on","error","emit","TransformIterator","UnionIterator"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FederatedQuadSource = void 0;\nconst bus_rdf_resolve_quad_pattern_1 = require(\"@comunica/bus-rdf-resolve-quad-pattern\");\nconst context_entries_1 = require(\"@comunica/context-entries\");\nconst data_factory_1 = require(\"@comunica/data-factory\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst rdf_terms_1 = require(\"rdf-terms\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * A FederatedQuadSource can evaluate quad pattern queries over the union of different heterogeneous sources.\n * It will call the given mediator to evaluate each quad pattern query separately.\n */\nclass FederatedQuadSource {\n    constructor(mediatorResolveQuadPattern, context, emptyPatterns, skipEmptyPatterns) {\n        this.mediatorResolveQuadPattern = mediatorResolveQuadPattern;\n        this.sources = context.get(context_entries_1.KeysRdfResolveQuadPattern.sources);\n        this.contextDefault = context.delete(context_entries_1.KeysRdfResolveQuadPattern.sources);\n        this.emptyPatterns = emptyPatterns;\n        this.sourceIds = new Map();\n        this.skipEmptyPatterns = skipEmptyPatterns;\n        this.algebraFactory = new sparqlalgebrajs_1.Factory();\n        // Initialize sources in the emptyPatterns datastructure\n        if (this.skipEmptyPatterns) {\n            for (const source of this.sources) {\n                if (!this.emptyPatterns.has(source)) {\n                    this.emptyPatterns.set(source, []);\n                }\n            }\n        }\n    }\n    /**\n     * Check if the given RDF term is not bound to an exact value.\n     * I.e., if it is not a Variable.\n     * @param {RDF.Term} term An RDF term.\n     * @return {boolean} If it is not bound.\n     */\n    static isTermBound(term) {\n        return term.termType !== 'Variable';\n    }\n    /**\n     * Checks if the given (child) pattern is a more bound version of the given (parent) pattern.\n     * This will also return true if the patterns are equal.\n     * @param {RDF.BaseQuad} child A child pattern.\n     * @param {RDF.BaseQuad} parent A parent pattern.\n     * @return {boolean} If child is a sub-pattern of parent\n     */\n    static isSubPatternOf(child, parent) {\n        return (!FederatedQuadSource.isTermBound(parent.subject) || parent.subject.equals(child.subject)) &&\n            (!FederatedQuadSource.isTermBound(parent.predicate) || parent.predicate.equals(child.predicate)) &&\n            (!FederatedQuadSource.isTermBound(parent.object) || parent.object.equals(child.object)) &&\n            (!FederatedQuadSource.isTermBound(parent.graph) || parent.graph.equals(child.graph));\n    }\n    /**\n     * If the given term is a blank node, return a deterministic named node for it\n     * based on the source id and the blank node value.\n     * @param term Any RDF term.\n     * @param sourceId A source identifier.\n     * @return If the given term was a blank node, this will return a skolemized named node, otherwise the original term.\n     */\n    static skolemizeTerm(term, sourceId) {\n        if (term.termType === 'BlankNode') {\n            return new data_factory_1.BlankNodeScoped(`bc_${sourceId}_${term.value}`, DF.namedNode(`${FederatedQuadSource.SKOLEM_PREFIX}${sourceId}:${term.value}`));\n        }\n        return term;\n    }\n    /**\n     * Skolemize all terms in the given quad.\n     * @param quad An RDF quad.\n     * @param sourceId A source identifier.\n     * @return The skolemized quad.\n     */\n    static skolemizeQuad(quad, sourceId) {\n        return rdf_terms_1.mapTerms(quad, term => FederatedQuadSource.skolemizeTerm(term, sourceId));\n    }\n    /**\n     * If a given term was a skolemized named node for the given source id,\n     * deskolemize it again to a blank node.\n     * If the given term was a skolemized named node for another source, return false.\n     * If the given term was not a skolemized named node, return the original term.\n     * @param term Any RDF term.\n     * @param sourceId A source identifier.\n     */\n    static deskolemizeTerm(term, sourceId) {\n        if (term.termType === 'BlankNode' && 'skolemized' in term) {\n            term = term.skolemized;\n        }\n        if (term.termType === 'NamedNode' && term.value.startsWith(FederatedQuadSource.SKOLEM_PREFIX)) {\n            const colonSeparator = term.value.indexOf(':', FederatedQuadSource.SKOLEM_PREFIX.length);\n            const termSourceId = term.value.slice(FederatedQuadSource.SKOLEM_PREFIX.length, colonSeparator);\n            // We had a skolemized term\n            if (termSourceId === sourceId) {\n                // It came from the correct source\n                const termLabel = term.value.slice(colonSeparator + 1, term.value.length);\n                return DF.blankNode(termLabel);\n            }\n            // It came from a different source\n            return null;\n        }\n        return term;\n    }\n    /**\n     * If the given source is guaranteed to produce an empty result for the given pattern.\n     *\n     * This prediction is done based on the 'emptyPatterns' datastructure that is stored within this actor.\n     * Every time an empty pattern is passed, this pattern is stored in this datastructure for this source.\n     * If this pattern (or a more bound pattern) is queried, we know for certain that it will be empty again.\n     * This is under the assumption that sources will remain static during query evaluation.\n     *\n     * @param {IQuerySource} source\n     * @param {RDF.BaseQuad} pattern\n     * @return {boolean}\n     */\n    isSourceEmpty(source, pattern) {\n        if (!this.skipEmptyPatterns) {\n            return false;\n        }\n        const emptyPatterns = this.emptyPatterns.get(source);\n        if (emptyPatterns) {\n            for (const emptyPattern of emptyPatterns) {\n                if (FederatedQuadSource.isSubPatternOf(pattern, emptyPattern)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Get the unique, deterministic id for the given source.\n     * @param source A data source.\n     * @return The id of the given source.\n     */\n    getSourceId(source) {\n        let sourceId = this.sourceIds.get(source);\n        if (sourceId === undefined) {\n            sourceId = `${this.sourceIds.size}`;\n            this.sourceIds.set(source, sourceId);\n        }\n        return sourceId;\n    }\n    match(subject, predicate, object, graph) {\n        // Counters for our metadata\n        const metadata = { totalItems: 0 };\n        let remainingSources = this.sources.length;\n        // Anonymous function to handle totalItems from metadata\n        const checkEmitMetadata = (currentTotalItems, source, pattern, lastMetadata) => {\n            if (this.skipEmptyPatterns && !currentTotalItems && pattern && !this.isSourceEmpty(source, pattern)) {\n                this.emptyPatterns.get(source).push(pattern);\n            }\n            if (!remainingSources) {\n                if (lastMetadata && this.sources.length === 1) {\n                    // If we only had one source, emit the metadata as-is.\n                    it.setProperty('metadata', lastMetadata);\n                }\n                else {\n                    it.setProperty('metadata', metadata);\n                }\n            }\n        };\n        const proxyIt = Promise.all(this.sources.map(async (source) => {\n            const sourceId = this.getSourceId(source);\n            // Deskolemize terms, so we send the original blank nodes to each source.\n            // Note that some sources may not match bnodes by label. SPARQL endpoints for example consider them variables.\n            const patternS = FederatedQuadSource.deskolemizeTerm(subject, sourceId);\n            const patternP = FederatedQuadSource.deskolemizeTerm(predicate, sourceId);\n            const patternO = FederatedQuadSource.deskolemizeTerm(object, sourceId);\n            const patternG = FederatedQuadSource.deskolemizeTerm(graph, sourceId);\n            let pattern;\n            // Prepare the context for this specific source\n            let context = bus_rdf_resolve_quad_pattern_1.getDataSourceContext(source, this.contextDefault);\n            context = context.set(context_entries_1.KeysRdfResolveQuadPattern.source, { type: bus_rdf_resolve_quad_pattern_1.getDataSourceType(source), value: bus_rdf_resolve_quad_pattern_1.getDataSourceValue(source) });\n            let output;\n            // If any of the deskolemized blank nodes originate from another source,\n            // or if we can predict that the given source will have no bindings for the given pattern,\n            // return an empty iterator.\n            if (!patternS || !patternP || !patternO || !patternG ||\n                // eslint-disable-next-line no-cond-assign\n                this.isSourceEmpty(source, pattern = this.algebraFactory\n                    .createPattern(patternS, patternP, patternO, patternG))) {\n                output = { data: new asynciterator_1.ArrayIterator([], { autoStart: false }) };\n                output.data.setProperty('metadata', { totalItems: 0 });\n            }\n            else {\n                output = await this.mediatorResolveQuadPattern.mediate({ pattern, context });\n            }\n            // Handle the metadata from this source\n            output.data.getProperty('metadata', (subMetadata) => {\n                if ((!subMetadata.totalItems && subMetadata.totalItems !== 0) || !Number.isFinite(subMetadata.totalItems)) {\n                    // We're already at infinite, so ignore any later metadata\n                    metadata.totalItems = Number.POSITIVE_INFINITY;\n                    remainingSources = 0;\n                    checkEmitMetadata(Number.POSITIVE_INFINITY, source, pattern, subMetadata);\n                }\n                else {\n                    metadata.totalItems += subMetadata.totalItems;\n                    remainingSources--;\n                    checkEmitMetadata(subMetadata.totalItems, source, pattern, subMetadata);\n                }\n            });\n            // Determine the data stream from this source\n            let data = output.data.map(quad => FederatedQuadSource.skolemizeQuad(quad, sourceId));\n            // SPARQL query semantics allow graph variables to only match with named graphs, excluding the default graph\n            if (graph.termType === 'Variable') {\n                data = data.filter(quad => quad.graph.termType !== 'DefaultGraph');\n            }\n            // Forward errors to our final iterator\n            data.on('error', error => it.emit('error', error));\n            return data;\n        }));\n        // Take the union of all source streams\n        const it = new asynciterator_1.TransformIterator(async () => new asynciterator_1.UnionIterator(await proxyIt), { autoStart: false });\n        // If we have 0 sources, immediately emit metadata\n        if (this.sources.length === 0) {\n            it.setProperty('metadata', metadata);\n        }\n        return it;\n    }\n}\nexports.FederatedQuadSource = FederatedQuadSource;\nFederatedQuadSource.SKOLEM_PREFIX = 'urn:comunica_skolem:source_';\n//# sourceMappingURL=FederatedQuadSource.js.map"]},"metadata":{},"sourceType":"script"}