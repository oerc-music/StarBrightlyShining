{"ast":null,"code":"import update from 'immutability-helper';\nimport { parse } from 'querystring';\nimport { FETCH_GRAPH, PROCESS_ANNOTATION, TICK } from '../actions/index';\nconst REGISTER_CLOCK = \"REGISTER_CLOCK\";\nexport default function (state = {\n  mediaResources: {}\n}, action) {\n  let mediaResourcesToAdd = {};\n\n  switch (action.type) {\n    case FETCH_GRAPH:\n      // parse through graph looking for timed media resources\n      // to add to our state for potential timed annotation tracking\n      // n.b. will need fixing if we change our manifest structures\n      action.payload[\"@graph\"][0][\"ldp:contains\"].map(anno => {\n        anno[\"oa:hasTarget\"].map(target => {\n          if ((target[\"@type\"] === \"meldterm:AudioManifestation\" || target[\"@type\"] === \"meldterm:VideoManifestation\") && !(target[\"@id\"] in state[\"mediaResources\"])) {\n            mediaResourcesToAdd[target[\"@id\"]] = {\n              times: {},\n              currentTime: 0\n            };\n          }\n        });\n      });\n      return update(state, {\n        $merge: {\n          mediaResources: mediaResourcesToAdd\n        }\n      });\n\n    case REGISTER_CLOCK:\n      // alternative, more flexible means to accomplish the result of the FETCH_GRAPH\n      // action above (for use with generalised traversal)\n      if (!(action.payload in state[\"mediaResources\"])) {\n        mediaResourcesToAdd[action.payload] = {\n          times: {},\n          currentTime: 0\n        };\n      }\n\n      return update(state, {\n        $merge: {\n          mediaResources: mediaResourcesToAdd\n        }\n      });\n\n    case PROCESS_ANNOTATION:\n      mediaResourcesToAdd = state[\"mediaResources\"]; // ensure targets are an array\n\n      if (!Array.isArray(action.payload.targets)) {\n        action.payload.targets = [action.payload.targets];\n      }\n\n      action.payload.targets.map(t => {\n        // only interested if a) we have a timed media fragment and\n        // b) we know about the media resource that this is a fragment of\n        const targetUriComponents = t[\"@id\"].split('#');\n        const baseResource = targetUriComponents[0];\n\n        if (targetUriComponents.length > 1) {\n          const params = parse(targetUriComponents[1]);\n\n          if (\"t\" in params) {\n            // have a timed media fragment\n            if (baseResource in mediaResourcesToAdd) {\n              // we know about this media resource\n              // keep track of the annotation at this time\n              mediaResourcesToAdd[baseResource][\"times\"][params[\"t\"]] = action.payload.bodies;\n            }\n          }\n        }\n      });\n      return update(state, {\n        $set: {\n          \"mediaResources\": mediaResourcesToAdd\n        }\n      });\n\n    case TICK:\n      return update(state, {\n        \"mediaResources\": {\n          [action.payload.uri]: {\n            $merge: {\n              \"currentTime\": action.payload.time\n            }\n          }\n        }\n      });\n\n    default:\n      return state;\n  }\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/meld-clients-core/lib/reducers/reducer_timesync.js"],"names":["update","parse","FETCH_GRAPH","PROCESS_ANNOTATION","TICK","REGISTER_CLOCK","state","mediaResources","action","mediaResourcesToAdd","type","payload","map","anno","target","times","currentTime","$merge","Array","isArray","targets","t","targetUriComponents","split","baseResource","length","params","bodies","$set","uri","time"],"mappings":"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","sourcesContent":["import update from 'immutability-helper';\nimport { parse } from 'querystring';\nimport { FETCH_GRAPH, PROCESS_ANNOTATION, TICK } from '../actions/index';\nconst REGISTER_CLOCK = \"REGISTER_CLOCK\";\nexport default function (state = {\n  mediaResources: {}\n}, action) {\n  let mediaResourcesToAdd = {};\n\n  switch (action.type) {\n    case FETCH_GRAPH:\n      // parse through graph looking for timed media resources\n      // to add to our state for potential timed annotation tracking\n      // n.b. will need fixing if we change our manifest structures\n      action.payload[\"@graph\"][0][\"ldp:contains\"].map(anno => {\n        anno[\"oa:hasTarget\"].map(target => {\n          if ((target[\"@type\"] === \"meldterm:AudioManifestation\" || target[\"@type\"] === \"meldterm:VideoManifestation\") && !(target[\"@id\"] in state[\"mediaResources\"])) {\n            mediaResourcesToAdd[target[\"@id\"]] = {\n              times: {},\n              currentTime: 0\n            };\n          }\n        });\n      });\n      return update(state, {\n        $merge: {\n          mediaResources: mediaResourcesToAdd\n        }\n      });\n\n    case REGISTER_CLOCK:\n      // alternative, more flexible means to accomplish the result of the FETCH_GRAPH\n      // action above (for use with generalised traversal)\n      if (!(action.payload in state[\"mediaResources\"])) {\n        mediaResourcesToAdd[action.payload] = {\n          times: {},\n          currentTime: 0\n        };\n      }\n\n      return update(state, {\n        $merge: {\n          mediaResources: mediaResourcesToAdd\n        }\n      });\n\n    case PROCESS_ANNOTATION:\n      mediaResourcesToAdd = state[\"mediaResources\"]; // ensure targets are an array\n\n      if (!Array.isArray(action.payload.targets)) {\n        action.payload.targets = [action.payload.targets];\n      }\n\n      action.payload.targets.map(t => {\n        // only interested if a) we have a timed media fragment and\n        // b) we know about the media resource that this is a fragment of\n        const targetUriComponents = t[\"@id\"].split('#');\n        const baseResource = targetUriComponents[0];\n\n        if (targetUriComponents.length > 1) {\n          const params = parse(targetUriComponents[1]);\n\n          if (\"t\" in params) {\n            // have a timed media fragment\n            if (baseResource in mediaResourcesToAdd) {\n              // we know about this media resource\n              // keep track of the annotation at this time\n              mediaResourcesToAdd[baseResource][\"times\"][params[\"t\"]] = action.payload.bodies;\n            }\n          }\n        }\n      });\n      return update(state, {\n        $set: {\n          \"mediaResources\": mediaResourcesToAdd\n        }\n      });\n\n    case TICK:\n      return update(state, {\n        \"mediaResources\": {\n          [action.payload.uri]: {\n            $merge: {\n              \"currentTime\": action.payload.time\n            }\n          }\n        }\n      });\n\n    default:\n      return state;\n  }\n}"]},"metadata":{},"sourceType":"module"}