{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationSparqlEndpoint = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst bus_rdf_resolve_quad_pattern_1 = require(\"@comunica/bus-rdf-resolve-quad-pattern\");\n\nconst utils_datasource_1 = require(\"@comunica/utils-datasource\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst fetch_sparql_endpoint_1 = require(\"fetch-sparql-endpoint\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica SPARQL Endpoint Query Operation Actor.\n */\n\n\nclass ActorQueryOperationSparqlEndpoint extends bus_query_operation_1.ActorQueryOperation {\n  constructor(args) {\n    super(args);\n    this.endpointFetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({\n      method: args.forceHttpGet ? 'GET' : 'POST',\n      fetch: (input, init) => this.mediatorHttp.mediate({\n        input,\n        init,\n        context: this.lastContext\n      }),\n      prefixVariableQuestionMark: true\n    });\n  }\n\n  async test(action) {\n    if (!action.operation) {\n      throw new Error('Missing field \\'operation\\' in a query operation action.');\n    }\n\n    const source = await utils_datasource_1.DataSourceUtils.getSingleSource(action.context);\n\n    if (source && bus_rdf_resolve_quad_pattern_1.getDataSourceType(source) === 'sparql') {\n      return {\n        httpRequests: 1\n      };\n    }\n\n    throw new Error(`${this.name} requires a single source with a 'sparql' endpoint to be present in the context.`);\n  }\n\n  async run(action) {\n    const source = await utils_datasource_1.DataSourceUtils.getSingleSource(action.context);\n\n    if (!source) {\n      throw new Error('Illegal state: undefined sparql endpoint source.');\n    }\n\n    const endpoint = bus_rdf_resolve_quad_pattern_1.getDataSourceValue(source);\n    this.lastContext = action.context; // Determine the full SPARQL query that needs to be sent to the endpoint\n    // Also check the type of the query (SELECT, CONSTRUCT (includes DESCRIBE) or ASK)\n\n    let query;\n    let type;\n    let variables;\n\n    try {\n      query = sparqlalgebrajs_1.toSparql(action.operation); // This will throw an error in case the result is an invalid SPARQL query\n\n      type = this.endpointFetcher.getQueryType(query);\n    } catch (_a) {// Ignore errors\n    } // If the input is an sub-query, wrap this in a SELECT\n\n\n    if (!type || type === 'UNKNOWN') {\n      variables = sparqlalgebrajs_1.Util.inScopeVariables(action.operation);\n      query = sparqlalgebrajs_1.toSparql(ActorQueryOperationSparqlEndpoint.FACTORY.createProject(action.operation, variables));\n      type = 'SELECT';\n    } // Execute the query against the endpoint depending on the type\n\n\n    switch (type) {\n      case 'SELECT':\n        if (!variables) {\n          variables = sparqlalgebrajs_1.Util.inScopeVariables(action.operation);\n        }\n\n        return this.executeQuery(endpoint, query, false, variables);\n\n      case 'CONSTRUCT':\n        return this.executeQuery(endpoint, query, true);\n\n      case 'ASK':\n        return {\n          type: 'boolean',\n          booleanResult: this.endpointFetcher.fetchAsk(endpoint, query)\n        };\n    }\n  }\n  /**\n   * Execute the given SELECT or CONSTRUCT query against the given endpoint.\n   * @param endpoint A SPARQL endpoint URL.\n   * @param query A SELECT or CONSTRUCT query.\n   * @param quads If the query returns quads, i.e., if it is a CONSTRUCT query.\n   * @param variables Variables for SELECT queries.\n   */\n\n\n  executeQuery(endpoint, query, quads, variables) {\n    const inputStream = quads ? this.endpointFetcher.fetchTriples(endpoint, query) : this.endpointFetcher.fetchBindings(endpoint, query);\n    let totalItems = 0;\n    const stream = asynciterator_1.wrap(inputStream, {\n      autoStart: false,\n      maxBufferSize: Number.POSITIVE_INFINITY\n    }).map(rawData => {\n      totalItems++;\n      return quads ? rawData : bus_query_operation_1.Bindings(rawData);\n    });\n    inputStream.then(subStream => subStream.on('end', () => stream.emit('metadata', {\n      totalItems\n    })), () => {// Do nothing\n    });\n    const metadata = ActorQueryOperationSparqlEndpoint.cachifyMetadata(() => new Promise((resolve, reject) => {\n      stream._fillBuffer();\n\n      stream.on('error', reject);\n      stream.on('end', () => reject(new Error('No metadata was found')));\n      stream.on('metadata', resolve);\n    }));\n\n    if (quads) {\n      return {\n        type: 'quads',\n        quadStream: stream,\n        metadata\n      };\n    }\n\n    return {\n      type: 'bindings',\n      bindingsStream: stream,\n      metadata,\n      variables: variables.map(x => rdf_string_1.termToString(x)),\n      canContainUndefs: true\n    };\n  }\n\n}\n\nexports.ActorQueryOperationSparqlEndpoint = ActorQueryOperationSparqlEndpoint;\nActorQueryOperationSparqlEndpoint.FACTORY = new sparqlalgebrajs_1.Factory();","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-sparql-endpoint/lib/ActorQueryOperationSparqlEndpoint.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationSparqlEndpoint","bus_query_operation_1","require","bus_rdf_resolve_quad_pattern_1","utils_datasource_1","asynciterator_1","fetch_sparql_endpoint_1","rdf_string_1","sparqlalgebrajs_1","ActorQueryOperation","constructor","args","endpointFetcher","SparqlEndpointFetcher","method","forceHttpGet","fetch","input","init","mediatorHttp","mediate","context","lastContext","prefixVariableQuestionMark","test","action","operation","Error","source","DataSourceUtils","getSingleSource","getDataSourceType","httpRequests","name","run","endpoint","getDataSourceValue","query","type","variables","toSparql","getQueryType","_a","Util","inScopeVariables","FACTORY","createProject","executeQuery","booleanResult","fetchAsk","quads","inputStream","fetchTriples","fetchBindings","totalItems","stream","wrap","autoStart","maxBufferSize","Number","POSITIVE_INFINITY","map","rawData","Bindings","then","subStream","on","emit","metadata","cachifyMetadata","Promise","resolve","reject","_fillBuffer","quadStream","bindingsStream","x","termToString","canContainUndefs","Factory"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationSparqlEndpoint = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst bus_rdf_resolve_quad_pattern_1 = require(\"@comunica/bus-rdf-resolve-quad-pattern\");\nconst utils_datasource_1 = require(\"@comunica/utils-datasource\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst fetch_sparql_endpoint_1 = require(\"fetch-sparql-endpoint\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica SPARQL Endpoint Query Operation Actor.\n */\nclass ActorQueryOperationSparqlEndpoint extends bus_query_operation_1.ActorQueryOperation {\n    constructor(args) {\n        super(args);\n        this.endpointFetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({\n            method: args.forceHttpGet ? 'GET' : 'POST',\n            fetch: (input, init) => this.mediatorHttp.mediate({ input, init, context: this.lastContext }),\n            prefixVariableQuestionMark: true,\n        });\n    }\n    async test(action) {\n        if (!action.operation) {\n            throw new Error('Missing field \\'operation\\' in a query operation action.');\n        }\n        const source = await utils_datasource_1.DataSourceUtils.getSingleSource(action.context);\n        if (source && bus_rdf_resolve_quad_pattern_1.getDataSourceType(source) === 'sparql') {\n            return { httpRequests: 1 };\n        }\n        throw new Error(`${this.name} requires a single source with a 'sparql' endpoint to be present in the context.`);\n    }\n    async run(action) {\n        const source = await utils_datasource_1.DataSourceUtils.getSingleSource(action.context);\n        if (!source) {\n            throw new Error('Illegal state: undefined sparql endpoint source.');\n        }\n        const endpoint = bus_rdf_resolve_quad_pattern_1.getDataSourceValue(source);\n        this.lastContext = action.context;\n        // Determine the full SPARQL query that needs to be sent to the endpoint\n        // Also check the type of the query (SELECT, CONSTRUCT (includes DESCRIBE) or ASK)\n        let query;\n        let type;\n        let variables;\n        try {\n            query = sparqlalgebrajs_1.toSparql(action.operation);\n            // This will throw an error in case the result is an invalid SPARQL query\n            type = this.endpointFetcher.getQueryType(query);\n        }\n        catch (_a) {\n            // Ignore errors\n        }\n        // If the input is an sub-query, wrap this in a SELECT\n        if (!type || type === 'UNKNOWN') {\n            variables = sparqlalgebrajs_1.Util.inScopeVariables(action.operation);\n            query = sparqlalgebrajs_1.toSparql(ActorQueryOperationSparqlEndpoint.FACTORY.createProject(action.operation, variables));\n            type = 'SELECT';\n        }\n        // Execute the query against the endpoint depending on the type\n        switch (type) {\n            case 'SELECT':\n                if (!variables) {\n                    variables = sparqlalgebrajs_1.Util.inScopeVariables(action.operation);\n                }\n                return this.executeQuery(endpoint, query, false, variables);\n            case 'CONSTRUCT':\n                return this.executeQuery(endpoint, query, true);\n            case 'ASK':\n                return {\n                    type: 'boolean',\n                    booleanResult: this.endpointFetcher.fetchAsk(endpoint, query),\n                };\n        }\n    }\n    /**\n     * Execute the given SELECT or CONSTRUCT query against the given endpoint.\n     * @param endpoint A SPARQL endpoint URL.\n     * @param query A SELECT or CONSTRUCT query.\n     * @param quads If the query returns quads, i.e., if it is a CONSTRUCT query.\n     * @param variables Variables for SELECT queries.\n     */\n    executeQuery(endpoint, query, quads, variables) {\n        const inputStream = quads ?\n            this.endpointFetcher.fetchTriples(endpoint, query) :\n            this.endpointFetcher.fetchBindings(endpoint, query);\n        let totalItems = 0;\n        const stream = asynciterator_1.wrap(inputStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY })\n            .map(rawData => {\n            totalItems++;\n            return quads ? rawData : bus_query_operation_1.Bindings(rawData);\n        });\n        inputStream.then(subStream => subStream.on('end', () => stream.emit('metadata', { totalItems })), () => {\n            // Do nothing\n        });\n        const metadata = ActorQueryOperationSparqlEndpoint.cachifyMetadata(() => new Promise((resolve, reject) => {\n            stream._fillBuffer();\n            stream.on('error', reject);\n            stream.on('end', () => reject(new Error('No metadata was found')));\n            stream.on('metadata', resolve);\n        }));\n        if (quads) {\n            return {\n                type: 'quads',\n                quadStream: stream,\n                metadata,\n            };\n        }\n        return {\n            type: 'bindings',\n            bindingsStream: stream,\n            metadata,\n            variables: variables.map(x => rdf_string_1.termToString(x)),\n            canContainUndefs: true,\n        };\n    }\n}\nexports.ActorQueryOperationSparqlEndpoint = ActorQueryOperationSparqlEndpoint;\nActorQueryOperationSparqlEndpoint.FACTORY = new sparqlalgebrajs_1.Factory();\n//# sourceMappingURL=ActorQueryOperationSparqlEndpoint.js.map"]},"metadata":{},"sourceType":"script"}