{"ast":null,"code":"// **N3Util** provides N3 utility functions.\nimport N3DataFactory from './N3DataFactory'; // Tests whether the given term represents an IRI\n\nexport function isNamedNode(term) {\n  return !!term && term.termType === 'NamedNode';\n} // Tests whether the given term represents a blank node\n\nexport function isBlankNode(term) {\n  return !!term && term.termType === 'BlankNode';\n} // Tests whether the given term represents a literal\n\nexport function isLiteral(term) {\n  return !!term && term.termType === 'Literal';\n} // Tests whether the given term represents a variable\n\nexport function isVariable(term) {\n  return !!term && term.termType === 'Variable';\n} // Tests whether the given term represents the default graph\n\nexport function isDefaultGraph(term) {\n  return !!term && term.termType === 'DefaultGraph';\n} // Tests whether the given quad is in the default graph\n\nexport function inDefaultGraph(quad) {\n  return isDefaultGraph(quad.graph);\n} // Creates a function that prepends the given IRI to a local name\n\nexport function prefix(iri, factory) {\n  return prefixes({\n    '': iri\n  }, factory)('');\n} // Creates a function that allows registering and expanding prefixes\n\nexport function prefixes(defaultPrefixes, factory) {\n  // Add all of the default prefixes\n  const prefixes = Object.create(null);\n\n  for (const prefix in defaultPrefixes) processPrefix(prefix, defaultPrefixes[prefix]); // Set the default factory if none was specified\n\n\n  factory = factory || N3DataFactory; // Registers a new prefix (if an IRI was specified)\n  // or retrieves a function that expands an existing prefix (if no IRI was specified)\n\n  function processPrefix(prefix, iri) {\n    // Create a new prefix if an IRI is specified or the prefix doesn't exist\n    if (typeof iri === 'string') {\n      // Create a function that expands the prefix\n      const cache = Object.create(null);\n\n      prefixes[prefix] = local => {\n        return cache[local] || (cache[local] = factory.namedNode(iri + local));\n      };\n    } else if (!(prefix in prefixes)) {\n      throw new Error(`Unknown prefix: ${prefix}`);\n    }\n\n    return prefixes[prefix];\n  }\n\n  return processPrefix;\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/n3/src/N3Util.js"],"names":["N3DataFactory","isNamedNode","term","termType","isBlankNode","isLiteral","isVariable","isDefaultGraph","inDefaultGraph","quad","graph","prefix","iri","factory","prefixes","defaultPrefixes","Object","create","processPrefix","cache","local","namedNode","Error"],"mappings":"AAAA;AAEA,OAAOA,aAAP,MAA0B,iBAA1B,C,CAEA;;AACA,OAAO,SAASC,WAAT,CAAqBC,IAArB,EAA2B;AAChC,SAAO,CAAC,CAACA,IAAF,IAAUA,IAAI,CAACC,QAAL,KAAkB,WAAnC;AACD,C,CAED;;AACA,OAAO,SAASC,WAAT,CAAqBF,IAArB,EAA2B;AAChC,SAAO,CAAC,CAACA,IAAF,IAAUA,IAAI,CAACC,QAAL,KAAkB,WAAnC;AACD,C,CAED;;AACA,OAAO,SAASE,SAAT,CAAmBH,IAAnB,EAAyB;AAC9B,SAAO,CAAC,CAACA,IAAF,IAAUA,IAAI,CAACC,QAAL,KAAkB,SAAnC;AACD,C,CAED;;AACA,OAAO,SAASG,UAAT,CAAoBJ,IAApB,EAA0B;AAC/B,SAAO,CAAC,CAACA,IAAF,IAAUA,IAAI,CAACC,QAAL,KAAkB,UAAnC;AACD,C,CAED;;AACA,OAAO,SAASI,cAAT,CAAwBL,IAAxB,EAA8B;AACnC,SAAO,CAAC,CAACA,IAAF,IAAUA,IAAI,CAACC,QAAL,KAAkB,cAAnC;AACD,C,CAED;;AACA,OAAO,SAASK,cAAT,CAAwBC,IAAxB,EAA8B;AACnC,SAAOF,cAAc,CAACE,IAAI,CAACC,KAAN,CAArB;AACD,C,CAED;;AACA,OAAO,SAASC,MAAT,CAAgBC,GAAhB,EAAqBC,OAArB,EAA8B;AACnC,SAAOC,QAAQ,CAAC;AAAE,QAAIF;AAAN,GAAD,EAAcC,OAAd,CAAR,CAA+B,EAA/B,CAAP;AACD,C,CAED;;AACA,OAAO,SAASC,QAAT,CAAkBC,eAAlB,EAAmCF,OAAnC,EAA4C;AACjD;AACA,QAAMC,QAAQ,GAAGE,MAAM,CAACC,MAAP,CAAc,IAAd,CAAjB;;AACA,OAAK,MAAMN,MAAX,IAAqBI,eAArB,EACEG,aAAa,CAACP,MAAD,EAASI,eAAe,CAACJ,MAAD,CAAxB,CAAb,CAJ+C,CAKjD;;;AACAE,EAAAA,OAAO,GAAGA,OAAO,IAAIb,aAArB,CANiD,CAQjD;AACA;;AACA,WAASkB,aAAT,CAAuBP,MAAvB,EAA+BC,GAA/B,EAAoC;AAClC;AACA,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B;AACA,YAAMO,KAAK,GAAGH,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;;AACAH,MAAAA,QAAQ,CAACH,MAAD,CAAR,GAAmBS,KAAK,IAAI;AAC1B,eAAOD,KAAK,CAACC,KAAD,CAAL,KAAiBD,KAAK,CAACC,KAAD,CAAL,GAAeP,OAAO,CAACQ,SAAR,CAAkBT,GAAG,GAAGQ,KAAxB,CAAhC,CAAP;AACD,OAFD;AAGD,KAND,MAOK,IAAI,EAAET,MAAM,IAAIG,QAAZ,CAAJ,EAA2B;AAC9B,YAAM,IAAIQ,KAAJ,CAAW,mBAAkBX,MAAO,EAApC,CAAN;AACD;;AACD,WAAOG,QAAQ,CAACH,MAAD,CAAf;AACD;;AACD,SAAOO,aAAP;AACD","sourcesContent":["// **N3Util** provides N3 utility functions.\n\nimport N3DataFactory from './N3DataFactory';\n\n// Tests whether the given term represents an IRI\nexport function isNamedNode(term) {\n  return !!term && term.termType === 'NamedNode';\n}\n\n// Tests whether the given term represents a blank node\nexport function isBlankNode(term) {\n  return !!term && term.termType === 'BlankNode';\n}\n\n// Tests whether the given term represents a literal\nexport function isLiteral(term) {\n  return !!term && term.termType === 'Literal';\n}\n\n// Tests whether the given term represents a variable\nexport function isVariable(term) {\n  return !!term && term.termType === 'Variable';\n}\n\n// Tests whether the given term represents the default graph\nexport function isDefaultGraph(term) {\n  return !!term && term.termType === 'DefaultGraph';\n}\n\n// Tests whether the given quad is in the default graph\nexport function inDefaultGraph(quad) {\n  return isDefaultGraph(quad.graph);\n}\n\n// Creates a function that prepends the given IRI to a local name\nexport function prefix(iri, factory) {\n  return prefixes({ '': iri }, factory)('');\n}\n\n// Creates a function that allows registering and expanding prefixes\nexport function prefixes(defaultPrefixes, factory) {\n  // Add all of the default prefixes\n  const prefixes = Object.create(null);\n  for (const prefix in defaultPrefixes)\n    processPrefix(prefix, defaultPrefixes[prefix]);\n  // Set the default factory if none was specified\n  factory = factory || N3DataFactory;\n\n  // Registers a new prefix (if an IRI was specified)\n  // or retrieves a function that expands an existing prefix (if no IRI was specified)\n  function processPrefix(prefix, iri) {\n    // Create a new prefix if an IRI is specified or the prefix doesn't exist\n    if (typeof iri === 'string') {\n      // Create a function that expands the prefix\n      const cache = Object.create(null);\n      prefixes[prefix] = local => {\n        return cache[local] || (cache[local] = factory.namedNode(iri + local));\n      };\n    }\n    else if (!(prefix in prefixes)) {\n      throw new Error(`Unknown prefix: ${prefix}`);\n    }\n    return prefixes[prefix];\n  }\n  return processPrefix;\n}\n"]},"metadata":{},"sourceType":"module"}