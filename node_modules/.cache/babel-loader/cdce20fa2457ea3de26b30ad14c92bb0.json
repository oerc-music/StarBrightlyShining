{"ast":null,"code":"import DefaultEngine from '../lib/comunica-engine';\n/**\n * Asynchronous iterator wrapper for the Comunica SPARQL query engine.\n */\n\nexport default class ComunicaEngine {\n  /**\n   * Create a ComunicaEngine to query the given default source.\n   *\n   * The default source can be a single URL, an RDF/JS Datasource,\n   * or an array with any of these.\n   */\n  constructor(defaultSource, settings = {}) {\n    this._engine = settings.engine ? settings.engine : DefaultEngine; // Preload sources but silence errors; they will be thrown during execution\n\n    this._sources = this.parseSources(defaultSource);\n\n    this._sources.catch(() => null);\n\n    this._options = settings.options ? settings.options : {};\n  }\n  /**\n   * Creates an asynchronous iterable of results for the given SPARQL query.\n   */\n\n\n  async *execute(sparql, source) {\n    if (/^\\s*(?:INSERT|DELETE)/i.test(sparql)) yield* this.executeUpdate(sparql, source); // Load the sources if passed, the default sources otherwise\n\n    const sources = await (source ? this.parseSources(source) : this._sources);\n\n    if (sources.length !== 0) {\n      // Execute the query and yield the results\n      const queryResult = await this._engine.query(sparql, {\n        sources,\n        ...this._options\n      });\n      yield* this.streamToAsyncIterable(queryResult.bindingsStream);\n    }\n  }\n  /**\n   * Creates an asynchronous iterable with the results of the SPARQL UPDATE query.\n   */\n\n\n  async *executeUpdate(sparql, source) {\n    throw new Error(`SPARQL UPDATE queries are unsupported, received: ${sparql}`);\n  }\n  /**\n   * Parses the source(s) into an array of Comunica sources.\n   */\n\n\n  async parseSources(source) {\n    let sources = await source;\n    if (!sources) return []; // Transform URLs or terms into strings\n\n    if (sources instanceof URL) sources = sources.href;else if (sources.termType === 'NamedNode') sources = sources.value; // Strip the fragment off a URI\n\n    if (typeof sources === 'string') sources = [sources.replace(/#.*/, '')]; // Flatten recursive calls to this function\n    else if (Array.isArray(sources)) sources = await flattenAsync(sources.map(s => this.parseSources(s))); // Needs to be after the string check since those also have a match functions\n    else if (typeof sources.match === 'function') sources = [assign({\n      type: 'rdfjsSource'\n    }, sources)]; // Wrap a single source in an array\n    else if (typeof source.value === 'string') sources = [sources]; // Error on unsupported sources\n    else throw new Error(`Unsupported source: ${source}`); // Add Comunica source details\n\n    return sources.map(src => ({\n      value: src.value || src,\n      type: src.type\n    }));\n  }\n  /**\n   * Transforms the readable into an asynchronously iterable object\n   */\n\n\n  streamToAsyncIterable(readable) {\n    let done = false;\n    let pendingError;\n    let pendingPromise;\n    readable.on('readable', settlePromise);\n    readable.on('error', finish);\n    readable.on('end', finish);\n    return {\n      next: () => new Promise(trackPromise),\n\n      [Symbol.asyncIterator]() {\n        return this;\n      }\n\n    };\n\n    function trackPromise(resolve, reject) {\n      pendingPromise = {\n        resolve,\n        reject\n      };\n      settlePromise();\n    }\n\n    function settlePromise() {\n      // Finish if the stream errored or ended\n      if (done || pendingError) {\n        finish();\n      } // Try to resolve the promise with a value\n      else if (pendingPromise) {\n        const value = readable.read();\n\n        if (value !== null) {\n          pendingPromise.resolve({\n            value\n          });\n          pendingPromise = null;\n        }\n      }\n    }\n\n    function finish(error) {\n      // Finish with or without an error\n      if (!pendingError) {\n        done = true;\n        pendingError = error;\n      } // Try to emit the result\n\n\n      if (pendingPromise) {\n        if (!pendingError) pendingPromise.resolve({\n          done\n        });else pendingPromise.reject(pendingError);\n        pendingPromise = null;\n      } // Detach listeners\n\n\n      readable.on('readable', settlePromise);\n      readable.on('error', finish);\n      readable.on('end', finish);\n    }\n  }\n  /**\n   * Removes the given document (or all, if not specified) from the cache,\n   * such that fresh results are obtained next time.\n   */\n\n\n  async clearCache(document) {\n    await this._engine.invalidateHttpCache(document);\n  }\n\n}\n/**\n * Extends Object.assign by also copying prototype methods\n * @param {Object} props To add to the object\n * @param {Object} orig Original Object\n * @returns Copy of original object with added props\n */\n\nfunction assign(props, orig) {\n  // https://stackoverflow.com/questions/41474986/how-to-clone-a-javascript-es6-class-instance\n  return Object.assign(Object.create(orig), { ...orig,\n    ...props\n  });\n} // Flattens the given array one level deep\n\n\nasync function flattenAsync(array) {\n  return [].concat(...(await Promise.all(array)));\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@ldflex/comunica/src/ComunicaEngine.js"],"names":["DefaultEngine","ComunicaEngine","constructor","defaultSource","settings","_engine","engine","_sources","parseSources","catch","_options","options","execute","sparql","source","test","executeUpdate","sources","length","queryResult","query","streamToAsyncIterable","bindingsStream","Error","URL","href","termType","value","replace","Array","isArray","flattenAsync","map","s","match","assign","type","src","readable","done","pendingError","pendingPromise","on","settlePromise","finish","next","Promise","trackPromise","Symbol","asyncIterator","resolve","reject","read","error","clearCache","document","invalidateHttpCache","props","orig","Object","create","array","concat","all"],"mappings":"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","sourcesContent":["import DefaultEngine from '../lib/comunica-engine';\n\n/**\n * Asynchronous iterator wrapper for the Comunica SPARQL query engine.\n */\nexport default class ComunicaEngine {\n  /**\n   * Create a ComunicaEngine to query the given default source.\n   *\n   * The default source can be a single URL, an RDF/JS Datasource,\n   * or an array with any of these.\n   */\n  constructor(defaultSource, settings = {}) {\n    this._engine = settings.engine ? settings.engine : DefaultEngine;\n    // Preload sources but silence errors; they will be thrown during execution\n    this._sources = this.parseSources(defaultSource);\n    this._sources.catch(() => null);\n    this._options = settings.options ? settings.options : {};\n  }\n\n  /**\n   * Creates an asynchronous iterable of results for the given SPARQL query.\n   */\n  async* execute(sparql, source) {\n    if ((/^\\s*(?:INSERT|DELETE)/i).test(sparql))\n      yield* this.executeUpdate(sparql, source);\n\n    // Load the sources if passed, the default sources otherwise\n    const sources = await (source ? this.parseSources(source) : this._sources);\n    if (sources.length !== 0) {\n      // Execute the query and yield the results\n      const queryResult = await this._engine.query(sparql, { sources, ...this._options });\n      yield* this.streamToAsyncIterable(queryResult.bindingsStream);\n    }\n  }\n\n  /**\n   * Creates an asynchronous iterable with the results of the SPARQL UPDATE query.\n   */\n  async* executeUpdate(sparql, source) {\n    throw new Error(`SPARQL UPDATE queries are unsupported, received: ${sparql}`);\n  }\n\n  /**\n   * Parses the source(s) into an array of Comunica sources.\n   */\n  async parseSources(source) {\n    let sources = await source;\n    if (!sources)\n      return [];\n\n    // Transform URLs or terms into strings\n    if (sources instanceof URL)\n      sources = sources.href;\n    else if (sources.termType === 'NamedNode')\n      sources = sources.value;\n\n    // Strip the fragment off a URI\n    if (typeof sources === 'string')\n      sources = [sources.replace(/#.*/, '')];\n    // Flatten recursive calls to this function\n    else if (Array.isArray(sources))\n      sources = await flattenAsync(sources.map(s => this.parseSources(s)));\n    // Needs to be after the string check since those also have a match functions\n    else if (typeof sources.match === 'function')\n      sources = [assign({ type: 'rdfjsSource' }, sources)];\n    // Wrap a single source in an array\n    else if (typeof source.value === 'string')\n      sources = [sources];\n    // Error on unsupported sources\n    else\n      throw new Error(`Unsupported source: ${source}`);\n\n    // Add Comunica source details\n    return sources.map(src => ({\n      value: src.value || src,\n      type: src.type,\n    }));\n  }\n\n  /**\n   * Transforms the readable into an asynchronously iterable object\n   */\n  streamToAsyncIterable(readable) {\n    let done = false;\n    let pendingError;\n    let pendingPromise;\n\n    readable.on('readable', settlePromise);\n    readable.on('error', finish);\n    readable.on('end', finish);\n\n    return {\n      next: () => new Promise(trackPromise),\n      [Symbol.asyncIterator]() { return this; },\n    };\n\n    function trackPromise(resolve, reject) {\n      pendingPromise = { resolve, reject };\n      settlePromise();\n    }\n\n    function settlePromise() {\n      // Finish if the stream errored or ended\n      if (done || pendingError) {\n        finish();\n      }\n      // Try to resolve the promise with a value\n      else if (pendingPromise) {\n        const value = readable.read();\n        if (value !== null) {\n          pendingPromise.resolve({ value });\n          pendingPromise = null;\n        }\n      }\n    }\n\n    function finish(error) {\n      // Finish with or without an error\n      if (!pendingError) {\n        done = true;\n        pendingError = error;\n      }\n      // Try to emit the result\n      if (pendingPromise) {\n        if (!pendingError)\n          pendingPromise.resolve({ done });\n        else\n          pendingPromise.reject(pendingError);\n        pendingPromise = null;\n      }\n      // Detach listeners\n      readable.on('readable', settlePromise);\n      readable.on('error', finish);\n      readable.on('end', finish);\n    }\n  }\n\n  /**\n   * Removes the given document (or all, if not specified) from the cache,\n   * such that fresh results are obtained next time.\n   */\n  async clearCache(document) {\n    await this._engine.invalidateHttpCache(document);\n  }\n}\n\n/**\n * Extends Object.assign by also copying prototype methods\n * @param {Object} props To add to the object\n * @param {Object} orig Original Object\n * @returns Copy of original object with added props\n */\nfunction assign(props, orig) {\n  // https://stackoverflow.com/questions/41474986/how-to-clone-a-javascript-es6-class-instance\n  return Object.assign(Object.create(orig), { ...orig, ...props });\n}\n\n// Flattens the given array one level deep\nasync function flattenAsync(array) {\n  return [].concat(...(await Promise.all(array)));\n}\n"]},"metadata":{},"sourceType":"module"}