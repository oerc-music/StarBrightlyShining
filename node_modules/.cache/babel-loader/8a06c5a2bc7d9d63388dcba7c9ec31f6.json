{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Util = void 0;\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * Utilities for conversion.\n */\n\n\nclass Util {\n  constructor(settings) {\n    this.nodeHandlers = {};\n    this.nodeValueHandlers = {};\n    this.directiveNodeHandlers = {};\n    this.settings = settings;\n    this.dataFactory = settings.dataFactory || new rdf_data_factory_1.DataFactory();\n    this.operationFactory = new sparqlalgebrajs_1.Factory(this.dataFactory);\n    this.contextParser = new jsonld_context_parser_1.ContextParser();\n  }\n  /**\n   * Register a new {@link NodeHandlerAdapter}.\n   * @param {NodeHandlerAdapter<any>} nodeHandler A handler for converting GraphQL nodes to operations.\n   */\n\n\n  registerNodeHandler(nodeHandler) {\n    this.nodeHandlers[nodeHandler.targetKind] = nodeHandler;\n  }\n  /**\n   * Register a new {@link NodeValueHandlerAdapter}\n   * @param {NodeValueHandlerAdapter<any>} nodeValueHandler A handler for converting GraphQL value nodes\n   *                                                        to terms and patterns.\n   */\n\n\n  registerNodeValueHandler(nodeValueHandler) {\n    this.nodeValueHandlers[nodeValueHandler.targetKind] = nodeValueHandler;\n  }\n  /**\n   * Register a new {@link DirectiveNodeHandlerAdapter}\n   * @param {DirectiveNodeHandlerAdapter} directiveNodeHandler A handler for handling GraphQL directives.\n   */\n\n\n  registerDirectiveNodeHandler(directiveNodeHandler) {\n    this.directiveNodeHandlers[directiveNodeHandler.targetKind] = directiveNodeHandler;\n  }\n  /**\n   * Get the operation for the given GraphQL node.\n   * @param {T} node A GraphQL node.\n   * @param {IConvertContext} convertContext A conversion context.\n   * @return {Operation} A SPARQL algebra operation.\n   */\n\n\n  handleNode(node, convertContext) {\n    const nodeHandler = this.nodeHandlers[node.kind];\n\n    if (!nodeHandler) {\n      throw new Error(`Unsupported GraphQL node '${node.kind}'`);\n    }\n\n    return nodeHandler.handle(node, convertContext);\n  }\n  /**\n   * Get the terms and patterns for the given value node.\n   * @param {T} node A GraphQL node.\n   * @param {string} fieldName The name of the field or argument in which the value was encapsulated.\n   * @param {IConvertContext} convertContext A conversion context.\n   * @return {IValueNodeHandlerOutput} The RDF terms and patterns.\n   */\n\n\n  handleNodeValue(node, fieldName, convertContext) {\n    const nodeValueHandler = this.nodeValueHandlers[node.kind];\n\n    if (!nodeValueHandler) {\n      throw new Error(`Unsupported GraphQL value node '${node.kind}'`);\n    }\n\n    return nodeValueHandler.handle(node, fieldName, convertContext);\n  }\n  /**\n   * Get the handler output for the given directive.\n   * @param {IDirectiveContext} directiveContext The current directive context.\n   * @param {IConvertContext} convertContext A conversion context.\n   * @return {IDirectiveNodeHandlerOutput} The directive node handler output or null.\n   */\n\n\n  handleDirectiveNode(directiveContext, convertContext) {\n    const directiveNodeHandler = this.directiveNodeHandlers[directiveContext.directive.name.value];\n\n    if (!directiveNodeHandler) {\n      return null;\n    }\n\n    return directiveNodeHandler.handle(directiveContext, convertContext);\n  }\n  /**\n   * Join the given array of operations.\n   * If all operations are BGPs, then a single big BGP with all patterns from the given BGPs will be created.\n   * @param {Operation[]} operations An array of operations.\n   * @return {Operation} A single joined operation.\n   */\n\n\n  joinOperations(operations) {\n    if (operations.length === 1) {\n      return operations[0];\n    } // Check if which operations are BGPs\n\n\n    const bgps = [];\n    const nonBgps = [];\n\n    for (const operation of operations) {\n      if (operation.type === 'bgp') {\n        bgps.push(operation);\n      } else {\n        nonBgps.push(operation);\n      }\n    }\n\n    if (bgps.length === operations.length) {\n      // Create a big BGP from all BGPs\n      return this.joinOperationsAsBgp(bgps);\n    } else if (bgps.length === operations.length - 1 && nonBgps[0].type === 'leftjoin' && nonBgps[0].left.type === 'bgp') {\n      // Check if we have one left-join (with a BGP on the left), and the rest are BGPs.\n      // If so, merge the BGPS within the left-hand-side of the left-join.\n      const originalLeftJoin = nonBgps[0];\n      bgps.push(originalLeftJoin.left);\n      return this.operationFactory.createLeftJoin(this.joinOperationsAsBgp(bgps), originalLeftJoin.right);\n    } else if (nonBgps.length === operations.length) {\n      // Create nested joins\n      return this.joinOperationsAsNestedJoin(nonBgps);\n    } else {\n      // Join as much BGPs together as possible, and join with the other operations\n      return this.joinOperationsAsNestedJoin([this.joinOperationsAsBgp(bgps), this.joinOperationsAsNestedJoin(nonBgps)]);\n    }\n  }\n\n  joinOperationsAsBgp(operations) {\n    return this.operationFactory.createBgp([].concat.apply([], operations.map(op => op.patterns)));\n  }\n\n  joinOperationsAsNestedJoin(operations) {\n    return operations.reverse().reduce((prev, cur) => prev ? this.operationFactory.createJoin(cur, prev) : cur, null);\n  }\n  /**\n   * Append a field's label to a path.\n   * @param {string[]} path A path.\n   * @param {string} fieldLabel A field label.\n   * @return {string[]} A new path array.\n   */\n\n\n  appendFieldToPath(path, fieldLabel) {\n    return path.concat([fieldLabel]);\n  }\n  /**\n   * Get the label of a field by taking into account the alias.\n   * @param {FieldNode} field A field node.\n   * @return {string} The field name or alias.\n   */\n\n\n  getFieldLabel(field) {\n    return (field.alias ? field.alias : field.name).value;\n  }\n  /**\n   * Convert a field node to a variable built from the node name and the current path inside the context.\n   * @param {string} fieldLabel A field label.\n   * @param {IConvertContext} convertContext A convert context.\n   * @param {string} variableDelimiter A variable delimiter.\n   * @return {Variable} A variable.\n   */\n\n\n  nameToVariable(fieldLabel, convertContext) {\n    return this.dataFactory.variable((convertContext.path.length ? convertContext.path.join(this.settings.variableDelimiter) + this.settings.variableDelimiter : '') + fieldLabel);\n  }\n  /**\n   * Convert a GraphQL term into a URI using the given context.\n   * @param {string} value A GraphQL term.\n   * @param {IContext} context A JSON-LD context.\n   * @return {NamedNode} A named node.\n   */\n\n\n  valueToNamedNode(value, context) {\n    const contextValue = context.expandTerm(value, true);\n\n    if (this.settings.requireContext && !contextValue) {\n      throw new Error('No context entry was found for ' + value);\n    }\n\n    return this.dataFactory.namedNode(contextValue || value);\n  }\n  /**\n   * Get an argument by name.\n   * This will return null if the argument could not be found.\n   * @param {ReadonlyArray<ArgumentNode>} args Arguments or null.\n   * @param {string} name The name of an argument.\n   * @return {ArgumentNode} The named argument.\n   */\n\n\n  getArgument(args, name) {\n    if (args) {\n      for (const argument of args) {\n        if (argument.name.value === name) {\n          return argument;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Create a pattern with an rdf:type predicate.\n   * @param {Term} subject The subject.\n   * @param {NamedTypeNode} typeCondition The object name.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {Pattern} A pattern.\n   */\n\n\n  newTypePattern(subject, typeCondition, convertContext) {\n    return this.operationFactory.createPattern(subject, this.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), this.valueToNamedNode(typeCondition.name.value, convertContext.context), convertContext.graph);\n  }\n  /**\n   * Create a quad pattern when the predicate is a name node that needs to be translated using the context.\n   * @param {Term} subject The subject.\n   * @param {NameNode} predicateName The name node for the predicate.\n   * @param {Term} object The object.\n   * @param {Term} graph The graph.\n   * @param {IContext} context A context.\n   * @return {Pattern} A quad pattern.\n   */\n\n\n  createQuadPattern(subject, predicateName, object, graph, context) {\n    const predicate = this.valueToNamedNode(predicateName.value, context);\n\n    if (context && context.getContextRaw()[predicateName.value] && context.getContextRaw()[predicateName.value]['@reverse']) {\n      return this.operationFactory.createPattern(object, predicate, subject, graph);\n    }\n\n    return this.operationFactory.createPattern(subject, predicate, object, graph);\n  }\n  /**\n   * Create a quad path when the predicate is a list node with field alternatives\n   * that need to be translated using the context.\n   * @param {Term} subject The subject.\n   * @param {NameNode} predicateName The name node for the predicate.\n   * @param {Term} object The object.\n   * @param {Term} graph The graph.\n   * @param {IContext} context A context.\n   * @return {Path} A quad property path.\n   */\n\n\n  createQuadPath(subject, predicateName, predicateAlternatives, object, graph, context) {\n    const predicateInitial = this.valueToNamedNode(predicateName.value, context);\n    let pathSymbol = this.operationFactory.createLink(predicateInitial); // Add all fields in the list as predicate alternatives\n\n    for (const predicateAlternative of predicateAlternatives.values) {\n      if (predicateAlternative.kind !== 'EnumValue') {\n        throw new Error('Invalid value type for \\'alt\\' argument, must be EnumValue, but got ' + predicateAlternative.kind);\n      }\n\n      pathSymbol = this.operationFactory.createAlt(pathSymbol, this.operationFactory.createLink(this.valueToNamedNode(predicateAlternative.value, context)));\n    } // Reverse the path based on the initial predicate\n\n\n    if (context && context.getContextRaw()[predicateName.value] && context.getContextRaw()[predicateName.value]['@reverse']) {\n      return this.operationFactory.createPath(object, pathSymbol, subject, graph);\n    }\n\n    return this.operationFactory.createPath(subject, pathSymbol, object, graph);\n  }\n\n}\n\nexports.Util = Util;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/graphql-to-sparql/lib/Util.js"],"names":["Object","defineProperty","exports","value","Util","rdf_data_factory_1","require","jsonld_context_parser_1","sparqlalgebrajs_1","constructor","settings","nodeHandlers","nodeValueHandlers","directiveNodeHandlers","dataFactory","DataFactory","operationFactory","Factory","contextParser","ContextParser","registerNodeHandler","nodeHandler","targetKind","registerNodeValueHandler","nodeValueHandler","registerDirectiveNodeHandler","directiveNodeHandler","handleNode","node","convertContext","kind","Error","handle","handleNodeValue","fieldName","handleDirectiveNode","directiveContext","directive","name","joinOperations","operations","length","bgps","nonBgps","operation","type","push","joinOperationsAsBgp","left","originalLeftJoin","createLeftJoin","right","joinOperationsAsNestedJoin","createBgp","concat","apply","map","op","patterns","reverse","reduce","prev","cur","createJoin","appendFieldToPath","path","fieldLabel","getFieldLabel","field","alias","nameToVariable","variable","join","variableDelimiter","valueToNamedNode","context","contextValue","expandTerm","requireContext","namedNode","getArgument","args","argument","newTypePattern","subject","typeCondition","createPattern","graph","createQuadPattern","predicateName","object","predicate","getContextRaw","createQuadPath","predicateAlternatives","predicateInitial","pathSymbol","createLink","predicateAlternative","values","createAlt","createPath"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * Utilities for conversion.\n */\nclass Util {\n    constructor(settings) {\n        this.nodeHandlers = {};\n        this.nodeValueHandlers = {};\n        this.directiveNodeHandlers = {};\n        this.settings = settings;\n        this.dataFactory = settings.dataFactory || new rdf_data_factory_1.DataFactory();\n        this.operationFactory = new sparqlalgebrajs_1.Factory(this.dataFactory);\n        this.contextParser = new jsonld_context_parser_1.ContextParser();\n    }\n    /**\n     * Register a new {@link NodeHandlerAdapter}.\n     * @param {NodeHandlerAdapter<any>} nodeHandler A handler for converting GraphQL nodes to operations.\n     */\n    registerNodeHandler(nodeHandler) {\n        this.nodeHandlers[nodeHandler.targetKind] = nodeHandler;\n    }\n    /**\n     * Register a new {@link NodeValueHandlerAdapter}\n     * @param {NodeValueHandlerAdapter<any>} nodeValueHandler A handler for converting GraphQL value nodes\n     *                                                        to terms and patterns.\n     */\n    registerNodeValueHandler(nodeValueHandler) {\n        this.nodeValueHandlers[nodeValueHandler.targetKind] = nodeValueHandler;\n    }\n    /**\n     * Register a new {@link DirectiveNodeHandlerAdapter}\n     * @param {DirectiveNodeHandlerAdapter} directiveNodeHandler A handler for handling GraphQL directives.\n     */\n    registerDirectiveNodeHandler(directiveNodeHandler) {\n        this.directiveNodeHandlers[directiveNodeHandler.targetKind] = directiveNodeHandler;\n    }\n    /**\n     * Get the operation for the given GraphQL node.\n     * @param {T} node A GraphQL node.\n     * @param {IConvertContext} convertContext A conversion context.\n     * @return {Operation} A SPARQL algebra operation.\n     */\n    handleNode(node, convertContext) {\n        const nodeHandler = this.nodeHandlers[node.kind];\n        if (!nodeHandler) {\n            throw new Error(`Unsupported GraphQL node '${node.kind}'`);\n        }\n        return nodeHandler.handle(node, convertContext);\n    }\n    /**\n     * Get the terms and patterns for the given value node.\n     * @param {T} node A GraphQL node.\n     * @param {string} fieldName The name of the field or argument in which the value was encapsulated.\n     * @param {IConvertContext} convertContext A conversion context.\n     * @return {IValueNodeHandlerOutput} The RDF terms and patterns.\n     */\n    handleNodeValue(node, fieldName, convertContext) {\n        const nodeValueHandler = this.nodeValueHandlers[node.kind];\n        if (!nodeValueHandler) {\n            throw new Error(`Unsupported GraphQL value node '${node.kind}'`);\n        }\n        return nodeValueHandler.handle(node, fieldName, convertContext);\n    }\n    /**\n     * Get the handler output for the given directive.\n     * @param {IDirectiveContext} directiveContext The current directive context.\n     * @param {IConvertContext} convertContext A conversion context.\n     * @return {IDirectiveNodeHandlerOutput} The directive node handler output or null.\n     */\n    handleDirectiveNode(directiveContext, convertContext) {\n        const directiveNodeHandler = this.directiveNodeHandlers[directiveContext.directive.name.value];\n        if (!directiveNodeHandler) {\n            return null;\n        }\n        return directiveNodeHandler.handle(directiveContext, convertContext);\n    }\n    /**\n     * Join the given array of operations.\n     * If all operations are BGPs, then a single big BGP with all patterns from the given BGPs will be created.\n     * @param {Operation[]} operations An array of operations.\n     * @return {Operation} A single joined operation.\n     */\n    joinOperations(operations) {\n        if (operations.length === 1) {\n            return operations[0];\n        }\n        // Check if which operations are BGPs\n        const bgps = [];\n        const nonBgps = [];\n        for (const operation of operations) {\n            if (operation.type === 'bgp') {\n                bgps.push(operation);\n            }\n            else {\n                nonBgps.push(operation);\n            }\n        }\n        if (bgps.length === operations.length) {\n            // Create a big BGP from all BGPs\n            return this.joinOperationsAsBgp(bgps);\n        }\n        else if (bgps.length === operations.length - 1\n            && nonBgps[0].type === 'leftjoin'\n            && nonBgps[0].left.type === 'bgp') {\n            // Check if we have one left-join (with a BGP on the left), and the rest are BGPs.\n            // If so, merge the BGPS within the left-hand-side of the left-join.\n            const originalLeftJoin = nonBgps[0];\n            bgps.push(originalLeftJoin.left);\n            return this.operationFactory.createLeftJoin(this.joinOperationsAsBgp(bgps), originalLeftJoin.right);\n        }\n        else if (nonBgps.length === operations.length) {\n            // Create nested joins\n            return this.joinOperationsAsNestedJoin(nonBgps);\n        }\n        else {\n            // Join as much BGPs together as possible, and join with the other operations\n            return this.joinOperationsAsNestedJoin([\n                this.joinOperationsAsBgp(bgps),\n                this.joinOperationsAsNestedJoin(nonBgps),\n            ]);\n        }\n    }\n    joinOperationsAsBgp(operations) {\n        return this.operationFactory.createBgp([].concat.apply([], operations\n            .map((op) => op.patterns)));\n    }\n    joinOperationsAsNestedJoin(operations) {\n        return operations.reverse().reduce((prev, cur) => prev ? this.operationFactory.createJoin(cur, prev) : cur, null);\n    }\n    /**\n     * Append a field's label to a path.\n     * @param {string[]} path A path.\n     * @param {string} fieldLabel A field label.\n     * @return {string[]} A new path array.\n     */\n    appendFieldToPath(path, fieldLabel) {\n        return path.concat([fieldLabel]);\n    }\n    /**\n     * Get the label of a field by taking into account the alias.\n     * @param {FieldNode} field A field node.\n     * @return {string} The field name or alias.\n     */\n    getFieldLabel(field) {\n        return (field.alias ? field.alias : field.name).value;\n    }\n    /**\n     * Convert a field node to a variable built from the node name and the current path inside the context.\n     * @param {string} fieldLabel A field label.\n     * @param {IConvertContext} convertContext A convert context.\n     * @param {string} variableDelimiter A variable delimiter.\n     * @return {Variable} A variable.\n     */\n    nameToVariable(fieldLabel, convertContext) {\n        return this.dataFactory.variable((convertContext.path.length\n            ? convertContext.path.join(this.settings.variableDelimiter) + this.settings.variableDelimiter : '') + fieldLabel);\n    }\n    /**\n     * Convert a GraphQL term into a URI using the given context.\n     * @param {string} value A GraphQL term.\n     * @param {IContext} context A JSON-LD context.\n     * @return {NamedNode} A named node.\n     */\n    valueToNamedNode(value, context) {\n        const contextValue = context.expandTerm(value, true);\n        if (this.settings.requireContext && !contextValue) {\n            throw new Error('No context entry was found for ' + value);\n        }\n        return this.dataFactory.namedNode(contextValue || value);\n    }\n    /**\n     * Get an argument by name.\n     * This will return null if the argument could not be found.\n     * @param {ReadonlyArray<ArgumentNode>} args Arguments or null.\n     * @param {string} name The name of an argument.\n     * @return {ArgumentNode} The named argument.\n     */\n    getArgument(args, name) {\n        if (args) {\n            for (const argument of args) {\n                if (argument.name.value === name) {\n                    return argument;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Create a pattern with an rdf:type predicate.\n     * @param {Term} subject The subject.\n     * @param {NamedTypeNode} typeCondition The object name.\n     * @param {IConvertContext} convertContext A convert context.\n     * @return {Pattern} A pattern.\n     */\n    newTypePattern(subject, typeCondition, convertContext) {\n        return this.operationFactory.createPattern(subject, this.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), this.valueToNamedNode(typeCondition.name.value, convertContext.context), convertContext.graph);\n    }\n    /**\n     * Create a quad pattern when the predicate is a name node that needs to be translated using the context.\n     * @param {Term} subject The subject.\n     * @param {NameNode} predicateName The name node for the predicate.\n     * @param {Term} object The object.\n     * @param {Term} graph The graph.\n     * @param {IContext} context A context.\n     * @return {Pattern} A quad pattern.\n     */\n    createQuadPattern(subject, predicateName, object, graph, context) {\n        const predicate = this.valueToNamedNode(predicateName.value, context);\n        if (context && context.getContextRaw()[predicateName.value]\n            && context.getContextRaw()[predicateName.value]['@reverse']) {\n            return this.operationFactory.createPattern(object, predicate, subject, graph);\n        }\n        return this.operationFactory.createPattern(subject, predicate, object, graph);\n    }\n    /**\n     * Create a quad path when the predicate is a list node with field alternatives\n     * that need to be translated using the context.\n     * @param {Term} subject The subject.\n     * @param {NameNode} predicateName The name node for the predicate.\n     * @param {Term} object The object.\n     * @param {Term} graph The graph.\n     * @param {IContext} context A context.\n     * @return {Path} A quad property path.\n     */\n    createQuadPath(subject, predicateName, predicateAlternatives, object, graph, context) {\n        const predicateInitial = this.valueToNamedNode(predicateName.value, context);\n        let pathSymbol = this.operationFactory.createLink(predicateInitial);\n        // Add all fields in the list as predicate alternatives\n        for (const predicateAlternative of predicateAlternatives.values) {\n            if (predicateAlternative.kind !== 'EnumValue') {\n                throw new Error('Invalid value type for \\'alt\\' argument, must be EnumValue, but got '\n                    + predicateAlternative.kind);\n            }\n            pathSymbol = this.operationFactory.createAlt(pathSymbol, this.operationFactory.createLink(this.valueToNamedNode(predicateAlternative.value, context)));\n        }\n        // Reverse the path based on the initial predicate\n        if (context && context.getContextRaw()[predicateName.value]\n            && context.getContextRaw()[predicateName.value]['@reverse']) {\n            return this.operationFactory.createPath(object, pathSymbol, subject, graph);\n        }\n        return this.operationFactory.createPath(subject, pathSymbol, object, graph);\n    }\n}\nexports.Util = Util;\n//# sourceMappingURL=Util.js.map"]},"metadata":{},"sourceType":"script"}