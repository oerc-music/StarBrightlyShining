{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorSparqlSerializeSparqlJson = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst bus_sparql_serialize_1 = require(\"@comunica/bus-sparql-serialize\");\n/**\n * A comunica sparql-results+xml Serialize Actor.\n */\n\n\nclass ActorSparqlSerializeSparqlJson extends bus_sparql_serialize_1.ActorSparqlSerializeFixedMediaTypes {\n  constructor(args) {\n    super(args);\n  }\n  /**\n   * Converts an RDF term to its JSON representation.\n   * @param {RDF.Term} value An RDF term.\n   * @return {any} A JSON object.\n   */\n\n\n  static bindingToJsonBindings(value) {\n    if (value.termType === 'Literal') {\n      const literal = value;\n      const jsonValue = {\n        value: literal.value,\n        type: 'literal'\n      };\n      const {\n        language\n      } = literal;\n      const {\n        datatype\n      } = literal;\n\n      if (language) {\n        jsonValue['xml:lang'] = language;\n      } else if (datatype && datatype.value !== 'http://www.w3.org/2001/XMLSchema#string') {\n        jsonValue.datatype = datatype.value;\n      }\n\n      return jsonValue;\n    }\n\n    if (value.termType === 'BlankNode') {\n      return {\n        value: value.value,\n        type: 'bnode'\n      };\n    }\n\n    return {\n      value: value.value,\n      type: 'uri'\n    };\n  }\n\n  async testHandleChecked(action, context) {\n    if (!['bindings', 'boolean'].includes(action.type)) {\n      throw new Error('This actor can only handle bindings streams or booleans.');\n    }\n\n    return true;\n  }\n\n  async runHandle(action, mediaType, context) {\n    const data = new stream_1.Readable();\n\n    data._read = () => {// Do nothing\n    }; // Write head\n\n\n    const head = {};\n\n    if (action.type === 'bindings' && action.variables.length > 0) {\n      head.vars = action.variables.map(variable => variable.slice(1));\n    }\n\n    data.push(`{\"head\": ${JSON.stringify(head)},\\n`);\n    let empty = true;\n\n    if (action.type === 'bindings') {\n      const resultStream = action.bindingsStream; // Write bindings\n\n      resultStream.on('error', error => {\n        data.emit('error', error);\n      });\n      resultStream.on('data', bindings => {\n        if (empty) {\n          data.push('\"results\": { \"bindings\": [\\n');\n        } else {\n          data.push(',\\n');\n        } // JSON SPARQL results spec does not allow unbound variables and blank node bindings\n\n\n        const realBindings = bindings.filter((value, key) => Boolean(value) && key.startsWith('?'));\n        data.push(JSON.stringify(realBindings.mapEntries(([key, value]) => [key.slice(1), ActorSparqlSerializeSparqlJson.bindingToJsonBindings(value)]).toJSON()));\n        empty = false;\n      }); // Close streams\n\n      resultStream.on('end', () => {\n        if (empty) {\n          data.push('\"results\": { \"bindings\": [] }}\\n');\n        } else {\n          data.push('\\n]}}\\n');\n        }\n\n        data.push(null);\n      });\n    } else {\n      try {\n        data.push(`\"boolean\":${await action.booleanResult}\\n}\\n`);\n        data.push(null);\n      } catch (error) {\n        data.once('newListener', () => data.emit('error', error));\n      }\n    }\n\n    return {\n      data\n    };\n  }\n\n}\n\nexports.ActorSparqlSerializeSparqlJson = ActorSparqlSerializeSparqlJson;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-sparql-serialize-sparql-json/lib/ActorSparqlSerializeSparqlJson.js"],"names":["Object","defineProperty","exports","value","ActorSparqlSerializeSparqlJson","stream_1","require","bus_sparql_serialize_1","ActorSparqlSerializeFixedMediaTypes","constructor","args","bindingToJsonBindings","termType","literal","jsonValue","type","language","datatype","testHandleChecked","action","context","includes","Error","runHandle","mediaType","data","Readable","_read","head","variables","length","vars","map","variable","slice","push","JSON","stringify","empty","resultStream","bindingsStream","on","error","emit","bindings","realBindings","filter","key","Boolean","startsWith","mapEntries","toJSON","booleanResult","once"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorSparqlSerializeSparqlJson = void 0;\nconst stream_1 = require(\"stream\");\nconst bus_sparql_serialize_1 = require(\"@comunica/bus-sparql-serialize\");\n/**\n * A comunica sparql-results+xml Serialize Actor.\n */\nclass ActorSparqlSerializeSparqlJson extends bus_sparql_serialize_1.ActorSparqlSerializeFixedMediaTypes {\n    constructor(args) {\n        super(args);\n    }\n    /**\n     * Converts an RDF term to its JSON representation.\n     * @param {RDF.Term} value An RDF term.\n     * @return {any} A JSON object.\n     */\n    static bindingToJsonBindings(value) {\n        if (value.termType === 'Literal') {\n            const literal = value;\n            const jsonValue = { value: literal.value, type: 'literal' };\n            const { language } = literal;\n            const { datatype } = literal;\n            if (language) {\n                jsonValue['xml:lang'] = language;\n            }\n            else if (datatype && datatype.value !== 'http://www.w3.org/2001/XMLSchema#string') {\n                jsonValue.datatype = datatype.value;\n            }\n            return jsonValue;\n        }\n        if (value.termType === 'BlankNode') {\n            return { value: value.value, type: 'bnode' };\n        }\n        return { value: value.value, type: 'uri' };\n    }\n    async testHandleChecked(action, context) {\n        if (!['bindings', 'boolean'].includes(action.type)) {\n            throw new Error('This actor can only handle bindings streams or booleans.');\n        }\n        return true;\n    }\n    async runHandle(action, mediaType, context) {\n        const data = new stream_1.Readable();\n        data._read = () => {\n            // Do nothing\n        };\n        // Write head\n        const head = {};\n        if (action.type === 'bindings' && action.variables.length > 0) {\n            head.vars = action.variables.map((variable) => variable.slice(1));\n        }\n        data.push(`{\"head\": ${JSON.stringify(head)},\\n`);\n        let empty = true;\n        if (action.type === 'bindings') {\n            const resultStream = action.bindingsStream;\n            // Write bindings\n            resultStream.on('error', (error) => {\n                data.emit('error', error);\n            });\n            resultStream.on('data', (bindings) => {\n                if (empty) {\n                    data.push('\"results\": { \"bindings\": [\\n');\n                }\n                else {\n                    data.push(',\\n');\n                }\n                // JSON SPARQL results spec does not allow unbound variables and blank node bindings\n                const realBindings = bindings\n                    .filter((value, key) => Boolean(value) && key.startsWith('?'));\n                data.push(JSON.stringify(realBindings.mapEntries(([key, value]) => [key.slice(1), ActorSparqlSerializeSparqlJson.bindingToJsonBindings(value)])\n                    .toJSON()));\n                empty = false;\n            });\n            // Close streams\n            resultStream.on('end', () => {\n                if (empty) {\n                    data.push('\"results\": { \"bindings\": [] }}\\n');\n                }\n                else {\n                    data.push('\\n]}}\\n');\n                }\n                data.push(null);\n            });\n        }\n        else {\n            try {\n                data.push(`\"boolean\":${await action.booleanResult}\\n}\\n`);\n                data.push(null);\n            }\n            catch (error) {\n                data.once('newListener', () => data.emit('error', error));\n            }\n        }\n        return { data };\n    }\n}\nexports.ActorSparqlSerializeSparqlJson = ActorSparqlSerializeSparqlJson;\n//# sourceMappingURL=ActorSparqlSerializeSparqlJson.js.map"]},"metadata":{},"sourceType":"script"}