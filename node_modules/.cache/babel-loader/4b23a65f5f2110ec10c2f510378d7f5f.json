{"ast":null,"code":"const EMPTY = Object.create(null);\n/**\n * A PathProxy creates path expressions,\n * to which functionality can be attached.\n *\n * To users, these paths act as regular JavaScript objects\n * (such as `path.foo.bar.prop`) thanks to Proxy.\n * Behind the scenes, they carry around internal data\n * that can be used to influence their functionality.\n *\n * A path's functionality is realized by:\n * - handlers, which handle a specific named property\n * - resolvers, which can handle arbitrary properties\n * Only handlers and resolvers see the internal data.\n *\n * A path can have arbitrary internal data fields, but these are reserved:\n * - settings, an object that is passed on as-is to child paths\n * - proxy, a reference to the proxied object the user sees\n * - parent, a reference to the parent path\n * - apply, a function the will be invoked when the path is called as a function\n * - extendPath, a method to create a child path with this path as parent\n */\n\nexport default class PathProxy {\n  constructor({\n    handlers = EMPTY,\n    resolvers = []\n  } = {}) {\n    this._handlers = handlers;\n    this._resolvers = resolvers;\n  }\n  /**\n   * Creates a path Proxy with the given settings and internal data fields.\n   */\n\n\n  createPath(settings = {}, data) {\n    // The settings parameter is optional\n    if (data === undefined) [data, settings] = [settings, {}]; // Create the path's internal data object and the proxy that wraps it\n\n    const {\n      apply,\n      ...rawData\n    } = data;\n    const path = apply ? Object.assign(callPathFunction, rawData) : rawData;\n    const proxy = new Proxy(path, this);\n    path.proxy = proxy;\n    path.settings = settings;\n\n    function callPathFunction(...args) {\n      return apply(args, path, proxy);\n    } // Add an extendPath method to create child paths\n\n\n    if (!path.extendPath) {\n      const pathProxy = this;\n\n      path.extendPath = function extendPath(newData, parent = this) {\n        return pathProxy.createPath(settings, {\n          parent,\n          extendPath,\n          ...newData\n        });\n      };\n    } // Return the proxied path\n\n\n    return proxy;\n  }\n  /**\n   * Handles access to a property\n   */\n\n\n  get(pathData, property) {\n    // Handlers provide functionality for a specific property,\n    // so check if we find a handler first\n    const handler = this._handlers[property];\n    if (handler && typeof handler.handle === 'function') return handler.handle(pathData, pathData.proxy); // Resolvers provide functionality for arbitrary properties,\n    // so find a resolver that can handle this property\n\n    for (const resolver of this._resolvers) {\n      if (resolver.supports(property)) return resolver.resolve(property, pathData, pathData.proxy);\n    } // Otherwise, the property does not exist\n\n\n    return undefined;\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/PathProxy.js"],"names":["EMPTY","Object","create","PathProxy","constructor","handlers","resolvers","_handlers","_resolvers","createPath","settings","data","undefined","apply","rawData","path","assign","callPathFunction","proxy","Proxy","args","extendPath","pathProxy","newData","parent","get","pathData","property","handler","handle","resolver","supports","resolve"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,MAAMC,SAAN,CAAgB;AAC7BC,EAAAA,WAAW,CAAC;AACVC,IAAAA,QAAQ,GAAGL,KADD;AAEVM,IAAAA,SAAS,GAAG;AAFF,MAGR,EAHO,EAGH;AACN,SAAKC,SAAL,GAAiBF,QAAjB;AACA,SAAKG,UAAL,GAAkBF,SAAlB;AACD;AACD;AACF;AACA;;;AAGEG,EAAAA,UAAU,CAACC,QAAQ,GAAG,EAAZ,EAAgBC,IAAhB,EAAsB;AAC9B;AACA,QAAIA,IAAI,KAAKC,SAAb,EAAwB,CAACD,IAAD,EAAOD,QAAP,IAAmB,CAACA,QAAD,EAAW,EAAX,CAAnB,CAFM,CAE6B;;AAE3D,UAAM;AACJG,MAAAA,KADI;AAEJ,SAAGC;AAFC,QAGFH,IAHJ;AAIA,UAAMI,IAAI,GAAGF,KAAK,GAAGZ,MAAM,CAACe,MAAP,CAAcC,gBAAd,EAAgCH,OAAhC,CAAH,GAA8CA,OAAhE;AACA,UAAMI,KAAK,GAAG,IAAIC,KAAJ,CAAUJ,IAAV,EAAgB,IAAhB,CAAd;AACAA,IAAAA,IAAI,CAACG,KAAL,GAAaA,KAAb;AACAH,IAAAA,IAAI,CAACL,QAAL,GAAgBA,QAAhB;;AAEA,aAASO,gBAAT,CAA0B,GAAGG,IAA7B,EAAmC;AACjC,aAAOP,KAAK,CAACO,IAAD,EAAOL,IAAP,EAAaG,KAAb,CAAZ;AACD,KAf6B,CAe5B;;;AAGF,QAAI,CAACH,IAAI,CAACM,UAAV,EAAsB;AACpB,YAAMC,SAAS,GAAG,IAAlB;;AAEAP,MAAAA,IAAI,CAACM,UAAL,GAAkB,SAASA,UAAT,CAAoBE,OAApB,EAA6BC,MAAM,GAAG,IAAtC,EAA4C;AAC5D,eAAOF,SAAS,CAACb,UAAV,CAAqBC,QAArB,EAA+B;AACpCc,UAAAA,MADoC;AAEpCH,UAAAA,UAFoC;AAGpC,aAAGE;AAHiC,SAA/B,CAAP;AAKD,OAND;AAOD,KA5B6B,CA4B5B;;;AAGF,WAAOL,KAAP;AACD;AACD;AACF;AACA;;;AAGEO,EAAAA,GAAG,CAACC,QAAD,EAAWC,QAAX,EAAqB;AACtB;AACA;AACA,UAAMC,OAAO,GAAG,KAAKrB,SAAL,CAAeoB,QAAf,CAAhB;AACA,QAAIC,OAAO,IAAI,OAAOA,OAAO,CAACC,MAAf,KAA0B,UAAzC,EAAqD,OAAOD,OAAO,CAACC,MAAR,CAAeH,QAAf,EAAyBA,QAAQ,CAACR,KAAlC,CAAP,CAJ/B,CAIgF;AACtG;;AAEA,SAAK,MAAMY,QAAX,IAAuB,KAAKtB,UAA5B,EAAwC;AACtC,UAAIsB,QAAQ,CAACC,QAAT,CAAkBJ,QAAlB,CAAJ,EAAiC,OAAOG,QAAQ,CAACE,OAAT,CAAiBL,QAAjB,EAA2BD,QAA3B,EAAqCA,QAAQ,CAACR,KAA9C,CAAP;AAClC,KATqB,CASpB;;;AAGF,WAAON,SAAP;AACD;;AAhE4B","sourcesContent":["const EMPTY = Object.create(null);\n/**\n * A PathProxy creates path expressions,\n * to which functionality can be attached.\n *\n * To users, these paths act as regular JavaScript objects\n * (such as `path.foo.bar.prop`) thanks to Proxy.\n * Behind the scenes, they carry around internal data\n * that can be used to influence their functionality.\n *\n * A path's functionality is realized by:\n * - handlers, which handle a specific named property\n * - resolvers, which can handle arbitrary properties\n * Only handlers and resolvers see the internal data.\n *\n * A path can have arbitrary internal data fields, but these are reserved:\n * - settings, an object that is passed on as-is to child paths\n * - proxy, a reference to the proxied object the user sees\n * - parent, a reference to the parent path\n * - apply, a function the will be invoked when the path is called as a function\n * - extendPath, a method to create a child path with this path as parent\n */\n\nexport default class PathProxy {\n  constructor({\n    handlers = EMPTY,\n    resolvers = []\n  } = {}) {\n    this._handlers = handlers;\n    this._resolvers = resolvers;\n  }\n  /**\n   * Creates a path Proxy with the given settings and internal data fields.\n   */\n\n\n  createPath(settings = {}, data) {\n    // The settings parameter is optional\n    if (data === undefined) [data, settings] = [settings, {}]; // Create the path's internal data object and the proxy that wraps it\n\n    const {\n      apply,\n      ...rawData\n    } = data;\n    const path = apply ? Object.assign(callPathFunction, rawData) : rawData;\n    const proxy = new Proxy(path, this);\n    path.proxy = proxy;\n    path.settings = settings;\n\n    function callPathFunction(...args) {\n      return apply(args, path, proxy);\n    } // Add an extendPath method to create child paths\n\n\n    if (!path.extendPath) {\n      const pathProxy = this;\n\n      path.extendPath = function extendPath(newData, parent = this) {\n        return pathProxy.createPath(settings, {\n          parent,\n          extendPath,\n          ...newData\n        });\n      };\n    } // Return the proxied path\n\n\n    return proxy;\n  }\n  /**\n   * Handles access to a property\n   */\n\n\n  get(pathData, property) {\n    // Handlers provide functionality for a specific property,\n    // so check if we find a handler first\n    const handler = this._handlers[property];\n    if (handler && typeof handler.handle === 'function') return handler.handle(pathData, pathData.proxy); // Resolvers provide functionality for arbitrary properties,\n    // so find a resolver that can handle this property\n\n    for (const resolver of this._resolvers) {\n      if (resolver.supports(property)) return resolver.resolve(property, pathData, pathData.proxy);\n    } // Otherwise, the property does not exist\n\n\n    return undefined;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}