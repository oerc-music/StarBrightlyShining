{"ast":null,"code":"\"use strict\";\n/**\n * These helpers provide a (albeit inflexible) DSL for writing function\n * definitions for the SPARQL functions.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeCheckLit = exports.log = exports.dateTime = exports.langString = exports.string = exports.numberFromString = exports.number = exports.bool = exports.map = exports.Impl = exports.Builder = exports.declare = void 0;\n\nconst immutable_1 = require(\"immutable\");\n\nconst E = require(\"../expressions\");\n\nconst C = require(\"../util/Consts\");\n\nconst Err = require(\"../util/Errors\");\n\nconst Consts_1 = require(\"../util/Consts\");\n\nconst Core_1 = require(\"./Core\");\n\nfunction declare() {\n  return new Builder();\n}\n\nexports.declare = declare;\n\nclass Builder {\n  constructor() {\n    this.implementations = [];\n  }\n\n  collect() {\n    return map(this.implementations);\n  }\n\n  log() {\n    // tslint:disable-next-line:no-console\n    console.log(this.implementations);\n    return this;\n  }\n\n  add(impl) {\n    this.implementations.push(impl);\n    return this;\n  }\n\n  set(argTypes, func) {\n    const types = immutable_1.List(argTypes);\n    return this.add(new Impl({\n      types,\n      func\n    }));\n  }\n\n  copy({\n    from,\n    to\n  }) {\n    const last = this.implementations.length - 1;\n\n    const _from = immutable_1.List(from);\n\n    for (let i = last; i >= 0; i--) {\n      const impl = this.implementations[i];\n\n      if (impl.get('types').equals(_from)) {\n        return this.set(to, impl.get('func'));\n      }\n    }\n\n    throw new Err.UnexpectedError('Tried to copy implementation, but types not found', {\n      from,\n      to\n    });\n  }\n\n  onUnary(type, op) {\n    return this.set([type], ([val]) => {\n      return op(val);\n    });\n  }\n\n  onUnaryTyped(type, op) {\n    return this.set([type], ([val]) => {\n      return op(val.typedValue);\n    });\n  }\n\n  onBinary(types, op) {\n    return this.set(types, ([left, right]) => {\n      return op(left, right);\n    });\n  }\n\n  onBinaryTyped(types, op) {\n    return this.set(types, ([left, right]) => {\n      return op(left.typedValue, right.typedValue);\n    });\n  }\n\n  onTernaryTyped(types, op) {\n    return this.set(types, ([a1, a2, a3]) => {\n      return op(a1.typedValue, a2.typedValue, a3.typedValue);\n    });\n  }\n\n  onTernary(types, op) {\n    return this.set(types, ([a1, a2, a3]) => {\n      return op(a1, a2, a3);\n    });\n  }\n\n  onQuaternaryTyped(types, op) {\n    return this.set(types, ([a1, a2, a3, a4]) => {\n      return op(a1.typedValue, a2.typedValue, a3.typedValue, a4.typedValue);\n    });\n  }\n\n  unimplemented(msg) {\n    for (let arity = 0; arity <= 5; arity++) {\n      const types = Array(arity).fill('term');\n\n      const func = _args => {\n        throw new Err.UnimplementedError(msg);\n      };\n\n      this.set(types, func);\n    }\n\n    return this;\n  }\n\n  onTerm1(op) {\n    return this.set(['term'], ([term]) => op(term));\n  }\n\n  onLiteral1(op) {\n    return this.set(['literal'], ([term]) => op(term));\n  }\n\n  onBoolean1(op) {\n    return this.set(['boolean'], ([lit]) => op(lit));\n  }\n\n  onBoolean1Typed(op) {\n    return this.set(['boolean'], ([lit]) => op(lit.typedValue));\n  }\n\n  onString1(op) {\n    return this.set(['string'], ([lit]) => op(lit));\n  }\n\n  onString1Typed(op) {\n    return this.set(['string'], ([lit]) => op(lit.typedValue));\n  }\n\n  onLangString1(op) {\n    return this.set(['langString'], ([lit]) => op(lit));\n  }\n\n  onStringly1(op) {\n    return this.set(['string'], ([lit]) => op(lit)).set(['langString'], ([lit]) => op(lit));\n  }\n\n  onStringly1Typed(op) {\n    return this.set(['string'], ([lit]) => op(lit.typedValue)).set(['langString'], ([lit]) => op(lit.typedValue));\n  }\n\n  onNumeric1(op) {\n    return this.set(['integer'], ([val]) => op(val)).set(['decimal'], ([val]) => op(val)).set(['float'], ([val]) => op(val)).set(['double'], ([val]) => op(val)).invalidLexicalForm(['nonlexical'], 1);\n  }\n\n  onDateTime1(op) {\n    return this.set(['date'], ([val]) => op(val)).invalidLexicalForm(['nonlexical'], 1);\n  }\n  /**\n   * Arithmetic operators take 2 numeric arguments, and return a single numerical\n   * value. The type of the return value is heavily dependant on the types of the\n   * input arguments. In JS everything is a double, but in SPARQL it is not.\n   *\n   * {@link https://www.w3.org/TR/sparql11-query/#OperatorMapping}\n   * {@link https://www.w3.org/TR/xpath-functions/#op.numeric}\n   *\n   * @param op the (simple) binary mathematical operator that\n   */\n\n\n  arithmetic(op) {\n    return this.numeric(([left, right]) => {\n      const promotionType = Core_1.promote(left.type, right.type);\n      const resultType = C.decategorize(promotionType);\n      return number(op(left.typedValue, right.typedValue), resultType);\n    });\n  }\n\n  numberTest(test) {\n    return this.numeric(([left, right]) => {\n      const result = test(left.typedValue, right.typedValue);\n      return bool(result);\n    });\n  }\n\n  stringTest(test) {\n    return this.set(['string', 'string'], ([left, right]) => {\n      const result = test(left.typedValue, right.typedValue);\n      return bool(result);\n    }).invalidLexicalForm(['nonlexical', 'string'], 1).invalidLexicalForm(['string', 'nonlexical'], 2);\n  }\n\n  booleanTest(test) {\n    return this.set(['boolean', 'boolean'], ([left, right]) => {\n      const result = test(left.typedValue, right.typedValue);\n      return bool(result);\n    }).invalidLexicalForm(['nonlexical', 'boolean'], 1).invalidLexicalForm(['boolean', 'nonlexical'], 2);\n  }\n\n  dateTimeTest(test) {\n    return this.set(['date', 'date'], ([left, right]) => {\n      const result = test(left.typedValue, right.typedValue);\n      return bool(result);\n    }).invalidLexicalForm(['nonlexical', 'date'], 1).invalidLexicalForm(['date', 'nonlexical'], 2);\n  }\n\n  numeric(op) {\n    return this.set(['integer', 'integer'], op).set(['integer', 'decimal'], op).set(['integer', 'float'], op).set(['integer', 'double'], op).invalidLexicalForm(['integer', 'nonlexical'], 2).set(['decimal', 'integer'], op).set(['decimal', 'decimal'], op).set(['decimal', 'float'], op).set(['decimal', 'double'], op).invalidLexicalForm(['decimal', 'nonlexical'], 2).set(['float', 'integer'], op).set(['float', 'decimal'], op).set(['float', 'float'], op).set(['float', 'double'], op).invalidLexicalForm(['float', 'nonlexical'], 2).set(['double', 'integer'], op).set(['double', 'decimal'], op).set(['double', 'float'], op).set(['double', 'double'], op).invalidLexicalForm(['double', 'nonlexical'], 2).invalidLexicalForm(['nonlexical', 'integer'], 1).invalidLexicalForm(['nonlexical', 'decimal'], 1).invalidLexicalForm(['nonlexical', 'float'], 1).invalidLexicalForm(['nonlexical', 'double'], 1);\n  }\n\n  invalidLexicalForm(types, index) {\n    return this.set(types, args => {\n      throw new Err.InvalidLexicalForm(args[index - 1].toRDF());\n    });\n  }\n\n  chain(impls) {\n    this.implementations = this.implementations.concat(impls);\n    return this;\n  }\n\n}\n\nexports.Builder = Builder;\nconst implDefaults = {\n  types: [],\n\n  func() {\n    const msg = 'Implementation not set yet declared as implemented';\n    throw new Err.UnexpectedError(msg);\n  }\n\n};\n\nclass Impl extends immutable_1.Record(implDefaults) {\n  constructor(params) {\n    super(params);\n  }\n\n  get(value) {\n    return super.get(value);\n  }\n\n  toPair() {\n    return [this.get('types'), this.get('func')];\n  }\n\n}\n\nexports.Impl = Impl;\n\nfunction map(implementations) {\n  const typeImplPair = implementations.map(i => i.toPair());\n  return immutable_1.Map(typeImplPair);\n}\n\nexports.map = map; // ----------------------------------------------------------------------------\n// Literal Construction helpers\n// ----------------------------------------------------------------------------\n\nfunction bool(val) {\n  return new E.BooleanLiteral(val);\n}\n\nexports.bool = bool;\n\nfunction number(num, dt) {\n  return new E.NumericLiteral(num, C.make(dt || Consts_1.TypeURL.XSD_FLOAT), undefined);\n}\n\nexports.number = number;\n\nfunction numberFromString(str, dt) {\n  const num = Number(str);\n  return new E.NumericLiteral(num, C.make(dt || Consts_1.TypeURL.XSD_FLOAT), undefined);\n}\n\nexports.numberFromString = numberFromString;\n\nfunction string(s) {\n  return new E.StringLiteral(s);\n}\n\nexports.string = string;\n\nfunction langString(s, lang) {\n  return new E.LangStringLiteral(s, lang);\n}\n\nexports.langString = langString;\n\nfunction dateTime(date, str) {\n  return new E.DateTimeLiteral(date, str);\n}\n\nexports.dateTime = dateTime; // ----------------------------------------------------------------------------\n// Util\n// ----------------------------------------------------------------------------\n// tslint:disable-next-line:no-any\n\nfunction log(val, ...args) {\n  // tslint:disable-next-line:no-console\n  console.log(val, args);\n  return val;\n}\n\nexports.log = log;\n\nfunction typeCheckLit(term, allowed, args, op) {\n  if (term.termType !== 'literal') {\n    throw new Err.InvalidArgumentTypes(args, op);\n  } // tslint:disable-next-line:no-any\n\n\n  const lit = term;\n\n  if (!allowed.includes(lit.type)) {\n    throw new Err.InvalidArgumentTypes(args, op);\n  }\n\n  return lit;\n}\n\nexports.typeCheckLit = typeCheckLit;","map":{"version":3,"sources":["../../../lib/functions/Helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * These helpers provide a (albeit inflexible) DSL for writing function\n * definitions for the SPARQL functions.\n */\n\nimport { List, Map, Record } from 'immutable';\n\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport { TypeURL } from '../util/Consts';\nimport { ArgumentType, OverloadMap, promote } from './Core';\n\ntype Term = E.TermExpression;\n\nexport function declare(): Builder {\n  return new Builder();\n}\n\nexport class Builder {\n  private implementations: Impl[] = [];\n\n  collect(): OverloadMap {\n    return map(this.implementations);\n  }\n\n  log(): Builder {\n    // tslint:disable-next-line:no-console\n    console.log(this.implementations);\n    return this;\n  }\n\n  add(impl: Impl): Builder {\n    this.implementations.push(impl);\n    return this;\n  }\n\n  set(argTypes: ArgumentType[], func: E.SimpleApplication): Builder {\n    const types = List(argTypes);\n    return this.add(new Impl({ types, func }));\n  }\n\n  copy({ from, to }: { from: ArgumentType[], to: ArgumentType[] }): Builder {\n    const last = this.implementations.length - 1;\n    const _from = List(from);\n    for (let i = last; i >= 0; i--) {\n      const impl = this.implementations[i];\n      if (impl.get('types').equals(_from)) {\n        return this.set(to, impl.get('func'));\n      }\n    }\n    throw new Err.UnexpectedError(\n      'Tried to copy implementation, but types not found',\n      { from, to });\n  }\n\n  onUnary<T extends Term>(type: ArgumentType, op: (val: T) => Term) {\n    return this.set([type], ([val]: [T]) => {\n      return op(val);\n    });\n  }\n\n  onUnaryTyped<T>(type: ArgumentType, op: (val: T) => Term) {\n    return this.set([type], ([val]: [E.Literal<T>]) => {\n      return op(val.typedValue);\n    });\n  }\n\n  onBinary<L extends Term, R extends Term>(types: ArgumentType[], op: (left: L, right: R) => Term) {\n    return this.set(types, ([left, right]: [L, R]) => {\n      return op(left, right);\n    });\n  }\n\n  onBinaryTyped<L, R>(types: ArgumentType[], op: (left: L, right: R) => Term) {\n    return this.set(types, ([left, right]: [E.Literal<L>, E.Literal<R>]) => {\n      return op(left.typedValue, right.typedValue);\n    });\n  }\n\n  onTernaryTyped<A1, A2, A3>(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3) => Term) {\n    return this.set(types, ([a1, a2, a3]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>]) => {\n      return op(a1.typedValue, a2.typedValue, a3.typedValue);\n    });\n  }\n\n  onTernary<\n    A1 extends Term,\n    A2 extends Term,\n    A3 extends Term\n  >(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3) => Term) {\n    return this.set(types, ([a1, a2, a3]: [A1, A2, A3]) => {\n      return op(a1, a2, a3);\n    });\n  }\n\n  onQuaternaryTyped<A1, A2, A3, A4>(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3, a4: A4) => Term) {\n    return this.set(types, ([a1, a2, a3, a4]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>, E.Literal<A4>]) => {\n      return op(a1.typedValue, a2.typedValue, a3.typedValue, a4.typedValue);\n    });\n  }\n\n  unimplemented(msg: string): Builder {\n    for (let arity = 0; arity <= 5; arity++) {\n      const types = Array(arity).fill('term');\n      const func = (_args: Term[]) => { throw new Err.UnimplementedError(msg); };\n      this.set(types, func);\n    }\n    return this;\n  }\n\n  onTerm1(op: (term: Term) => Term): Builder {\n    return this.set(['term'], ([term]: [Term]) => op(term));\n  }\n\n  onLiteral1<T>(op: (lit: E.Literal<T>) => Term): Builder {\n    return this.set(['literal'], ([term]: [E.Literal<T>]) => op(term));\n  }\n\n  onBoolean1(op: (lit: E.BooleanLiteral) => Term): Builder {\n    return this\n      .set(['boolean'], ([lit]: [E.BooleanLiteral]) => op(lit));\n  }\n\n  onBoolean1Typed(op: (lit: boolean) => Term): Builder {\n    return this\n      .set(['boolean'], ([lit]: [E.BooleanLiteral]) => op(lit.typedValue));\n  }\n\n  onString1(op: (lit: E.Literal<string>) => Term): Builder {\n    return this\n      .set(['string'], ([lit]: [E.Literal<string>]) => op(lit));\n  }\n\n  onString1Typed(op: (lit: string) => Term): Builder {\n    return this\n      .set(['string'], ([lit]: [E.Literal<string>]) => op(lit.typedValue));\n  }\n\n  onLangString1(op: (lit: E.LangStringLiteral) => Term): Builder {\n    return this\n      .set(['langString'], ([lit]: [E.LangStringLiteral]) => op(lit));\n  }\n\n  onStringly1(op: (lit: E.Literal<string>) => Term): Builder {\n    return this\n      .set(['string'], ([lit]: [E.Literal<string>]) => op(lit))\n      .set(['langString'], ([lit]: [E.Literal<string>]) => op(lit));\n  }\n\n  onStringly1Typed(op: (lit: string) => Term): Builder {\n    return this\n      .set(['string'], ([lit]: [E.Literal<string>]) => op(lit.typedValue))\n      .set(['langString'], ([lit]: [E.Literal<string>]) => op(lit.typedValue));\n  }\n\n  onNumeric1(op: (val: E.NumericLiteral) => Term): Builder {\n    return this\n      .set(['integer'], ([val]: [E.NumericLiteral]) => op(val))\n      .set(['decimal'], ([val]: [E.NumericLiteral]) => op(val))\n      .set(['float'], ([val]: [E.NumericLiteral]) => op(val))\n      .set(['double'], ([val]: [E.NumericLiteral]) => op(val))\n      .invalidLexicalForm(['nonlexical'], 1);\n  }\n\n  onDateTime1(op: (date: E.DateTimeLiteral) => Term): Builder {\n    return this\n      .set(['date'], ([val]: [E.DateTimeLiteral]) => op(val))\n      .invalidLexicalForm(['nonlexical'], 1);\n  }\n\n  /**\n   * Arithmetic operators take 2 numeric arguments, and return a single numerical\n   * value. The type of the return value is heavily dependant on the types of the\n   * input arguments. In JS everything is a double, but in SPARQL it is not.\n   *\n   * {@link https://www.w3.org/TR/sparql11-query/#OperatorMapping}\n   * {@link https://www.w3.org/TR/xpath-functions/#op.numeric}\n   *\n   * @param op the (simple) binary mathematical operator that\n   */\n  arithmetic(op: (left: number, right: number) => number): Builder {\n    return this.numeric(([left, right]: E.NumericLiteral[]) => {\n      const promotionType = promote(left.type, right.type);\n      const resultType = C.decategorize(promotionType);\n      return number(op(left.typedValue, right.typedValue), resultType);\n    });\n  }\n\n  numberTest(test: (left: number, right: number) => boolean): Builder {\n    return this.numeric(([left, right]: E.NumericLiteral[]) => {\n      const result = test(left.typedValue, right.typedValue);\n      return bool(result);\n    });\n  }\n\n  stringTest(test: (left: string, right: string) => boolean): Builder {\n    return this\n      .set(\n        ['string', 'string'],\n        ([left, right]: E.StringLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['nonlexical', 'string'], 1)\n      .invalidLexicalForm(['string', 'nonlexical'], 2);\n  }\n\n  booleanTest(test: (left: boolean, right: boolean) => boolean): Builder {\n    return this\n      .set(\n        ['boolean', 'boolean'],\n        ([left, right]: E.BooleanLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['nonlexical', 'boolean'], 1)\n      .invalidLexicalForm(['boolean', 'nonlexical'], 2);\n  }\n\n  dateTimeTest(test: (left: Date, right: Date) => boolean): Builder {\n    return this\n      .set(\n        ['date', 'date'],\n        ([left, right]: E.DateTimeLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['nonlexical', 'date'], 1)\n      .invalidLexicalForm(['date', 'nonlexical'], 2);\n  }\n\n  numeric(op: E.SimpleApplication): Builder {\n    return this\n      .set(['integer', 'integer'], op)\n      .set(['integer', 'decimal'], op)\n      .set(['integer', 'float'], op)\n      .set(['integer', 'double'], op)\n      .invalidLexicalForm(['integer', 'nonlexical'], 2)\n\n      .set(['decimal', 'integer'], op)\n      .set(['decimal', 'decimal'], op)\n      .set(['decimal', 'float'], op)\n      .set(['decimal', 'double'], op)\n      .invalidLexicalForm(['decimal', 'nonlexical'], 2)\n\n      .set(['float', 'integer'], op)\n      .set(['float', 'decimal'], op)\n      .set(['float', 'float'], op)\n      .set(['float', 'double'], op)\n      .invalidLexicalForm(['float', 'nonlexical'], 2)\n\n      .set(['double', 'integer'], op)\n      .set(['double', 'decimal'], op)\n      .set(['double', 'float'], op)\n      .set(['double', 'double'], op)\n      .invalidLexicalForm(['double', 'nonlexical'], 2)\n\n      .invalidLexicalForm(['nonlexical', 'integer'], 1)\n      .invalidLexicalForm(['nonlexical', 'decimal'], 1)\n      .invalidLexicalForm(['nonlexical', 'float'], 1)\n      .invalidLexicalForm(['nonlexical', 'double'], 1);\n\n  }\n\n  invalidLexicalForm(types: ArgumentType[], index: number): Builder {\n    return this.set(types, (args: Term[]): E.TermExpression => {\n      throw new Err.InvalidLexicalForm(args[index - 1].toRDF());\n    });\n  }\n\n  private chain(impls: Impl[]): Builder {\n    this.implementations = this.implementations.concat(impls);\n    return this;\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Type Safety Helpers\n// ----------------------------------------------------------------------------\n\n/**\n * Immutable.js type definitions are pretty unsafe, and this is typo-prone work.\n * These helpers allow use to create OverloadMaps with more type-safety.\n * One entry in the OverloadMap is described by the record Impl;\n *\n * A list of Impl's then gets constructed into an Immutable.js Map.\n *\n * See:\n * https://medium.com/@alexxgent/enforcing-types-with-immutablejs-and-typescript-6ab980819b6a\n */\n\nexport type ImplType = {\n  types: List<ArgumentType>;\n  func: E.SimpleApplication;\n};\n\nconst implDefaults = {\n  types: [] as ArgumentType[],\n  func() {\n    const msg = 'Implementation not set yet declared as implemented';\n    throw new Err.UnexpectedError(msg);\n  },\n};\n\nexport class Impl extends Record(implDefaults) {\n\n  constructor(params: ImplType) { super(params); }\n\n  get<T extends keyof ImplType>(value: T): ImplType[T] {\n    return super.get(value);\n  }\n\n  toPair(): [List<ArgumentType>, E.SimpleApplication] {\n    return [this.get('types'), this.get('func')];\n  }\n}\n\nexport function map(implementations: Impl[]): OverloadMap {\n  const typeImplPair = implementations.map((i) => i.toPair());\n  return Map<List<ArgumentType>, E.SimpleApplication>(typeImplPair);\n}\n\n// ----------------------------------------------------------------------------\n// Literal Construction helpers\n// ----------------------------------------------------------------------------\n\nexport function bool(val: boolean): E.BooleanLiteral {\n  return new E.BooleanLiteral(val);\n}\n\nexport function number(num: number, dt?: C.TypeURL): E.NumericLiteral {\n  return new E.NumericLiteral(num, C.make(dt || TypeURL.XSD_FLOAT), undefined);\n}\n\nexport function numberFromString(str: string, dt?: C.TypeURL): E.NumericLiteral {\n  const num = Number(str);\n  return new E.NumericLiteral(num, C.make(dt || TypeURL.XSD_FLOAT), undefined);\n}\n\nexport function string(s: string): E.StringLiteral {\n  return new E.StringLiteral(s);\n}\n\nexport function langString(s: string, lang: string) {\n  return new E.LangStringLiteral(s, lang);\n}\n\nexport function dateTime(date: Date, str: string): E.DateTimeLiteral {\n  return new E.DateTimeLiteral(date, str);\n}\n\n// ----------------------------------------------------------------------------\n// Util\n// ----------------------------------------------------------------------------\n\n// tslint:disable-next-line:no-any\nexport function log<T>(val: T, ...args: any[]): T {\n  // tslint:disable-next-line:no-console\n  console.log(val, args);\n  return val;\n}\n\nexport function typeCheckLit<T>(\n  term: E.TermExpression,\n  allowed: ArgumentType[],\n  args: E.Expression[],\n  op: C.Operator,\n): E.Literal<T> {\n\n  if (term.termType !== 'literal') {\n    throw new Err.InvalidArgumentTypes(args, op);\n  }\n\n  // tslint:disable-next-line:no-any\n  const lit = term as E.Literal<any>;\n\n  if (!allowed.includes(lit.type)) {\n    throw new Err.InvalidArgumentTypes(args, op);\n  }\n\n  return lit;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}