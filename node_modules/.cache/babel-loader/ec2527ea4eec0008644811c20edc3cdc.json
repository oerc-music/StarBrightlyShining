{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncEvaluator = void 0;\n\nconst Transformation_1 = require(\"../Transformation\");\n\nconst RecursiveExpressionEvaluator_1 = require(\"./RecursiveExpressionEvaluator\");\n\nclass SyncEvaluator {\n  constructor(algExpr, config = {}) {\n    this.algExpr = algExpr;\n    this.config = config;\n    this.expr = Transformation_1.transformAlgebra(algExpr);\n    const context = {\n      now: config.now || new Date(Date.now()),\n      bnode: config.bnode || undefined,\n      baseIRI: config.baseIRI || undefined,\n      exists: config.exists,\n      aggregate: config.aggregate\n    };\n    this.evaluator = new RecursiveExpressionEvaluator_1.SyncRecursiveEvaluator(context);\n  }\n\n  evaluate(mapping) {\n    const result = this.evaluator.evaluate(this.expr, mapping);\n    return log(result).toRDF();\n  }\n\n  evaluateAsEBV(mapping) {\n    const result = this.evaluator.evaluate(this.expr, mapping);\n    return log(result).coerceEBV();\n  }\n\n  evaluateAsInternal(mapping) {\n    const result = this.evaluator.evaluate(this.expr, mapping);\n    return log(result);\n  }\n\n}\n\nexports.SyncEvaluator = SyncEvaluator;\n\nfunction log(val) {\n  // console.log(val);\n  return val;\n}","map":{"version":3,"sources":["../../../lib/evaluators/SyncEvaluator.ts"],"names":[],"mappings":";;;;;;;AAKA,MAAA,gBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAGA,MAAA,8BAAA,GAAA,OAAA,CAAA,gCAAA,CAAA;;AAkBA,MAAa,aAAb,CAA0B;AAIxB,EAAA,WAAA,CAAmB,OAAnB,EAAmD,MAAA,GAA8B,EAAjF,EAAmF;AAAhE,SAAA,OAAA,GAAA,OAAA;AAAgC,SAAA,MAAA,GAAA,MAAA;AACjD,SAAK,IAAL,GAAY,gBAAA,CAAA,gBAAA,CAAiB,OAAjB,CAAZ;AAEA,UAAM,OAAO,GAAyB;AACpC,MAAA,GAAG,EAAE,MAAM,CAAC,GAAP,IAAc,IAAI,IAAJ,CAAS,IAAI,CAAC,GAAL,EAAT,CADiB;AAEpC,MAAA,KAAK,EAAE,MAAM,CAAC,KAAP,IAAgB,SAFa;AAGpC,MAAA,OAAO,EAAE,MAAM,CAAC,OAAP,IAAkB,SAHS;AAIpC,MAAA,MAAM,EAAE,MAAM,CAAC,MAJqB;AAKpC,MAAA,SAAS,EAAE,MAAM,CAAC;AALkB,KAAtC;AAQA,SAAK,SAAL,GAAiB,IAAI,8BAAA,CAAA,sBAAJ,CAA2B,OAA3B,CAAjB;AACD;;AAED,EAAA,QAAQ,CAAC,OAAD,EAAkB;AACxB,UAAM,MAAM,GAAG,KAAK,SAAL,CAAe,QAAf,CAAwB,KAAK,IAA7B,EAAmC,OAAnC,CAAf;AACA,WAAO,GAAG,CAAC,MAAD,CAAH,CAAY,KAAZ,EAAP;AACD;;AAED,EAAA,aAAa,CAAC,OAAD,EAAkB;AAC7B,UAAM,MAAM,GAAG,KAAK,SAAL,CAAe,QAAf,CAAwB,KAAK,IAA7B,EAAmC,OAAnC,CAAf;AACA,WAAO,GAAG,CAAC,MAAD,CAAH,CAAY,SAAZ,EAAP;AACD;;AAED,EAAA,kBAAkB,CAAC,OAAD,EAAkB;AAClC,UAAM,MAAM,GAAG,KAAK,SAAL,CAAe,QAAf,CAAwB,KAAK,IAA7B,EAAmC,OAAnC,CAAf;AACA,WAAO,GAAG,CAAC,MAAD,CAAV;AACD;;AA/BuB;;AAA1B,OAAA,CAAA,aAAA,GAAA,aAAA;;AAkCA,SAAS,GAAT,CAAgB,GAAhB,EAAsB;AACpB;AACA,SAAO,GAAP;AACD","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as E from '../expressions/Expressions';\n\nimport { transformAlgebra } from '../Transformation';\nimport { Bindings, ExpressionEvaluator } from '../Types';\n\nimport { SyncRecursiveEvaluator } from './RecursiveExpressionEvaluator';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\n\nexport interface SyncEvaluatorConfig {\n  now?: Date;\n  baseIRI?: string;\n\n  exists?: (expression: Alg.ExistenceExpression, mapping: Bindings) => boolean;\n  aggregate?: (expression: Alg.AggregateExpression) => RDF.Term;\n  bnode?: (input?: string) => RDF.BlankNode;\n}\n\nexport type SyncEvaluatorContext = SyncEvaluatorConfig & {\n  now: Date;\n};\n\nexport class SyncEvaluator {\n  private expr: Expression;\n  private evaluator: ExpressionEvaluator<Expression, Term>;\n\n  constructor(public algExpr: Alg.Expression, public config: SyncEvaluatorConfig = {}) {\n    this.expr = transformAlgebra(algExpr);\n\n    const context: SyncEvaluatorContext = {\n      now: config.now || new Date(Date.now()),\n      bnode: config.bnode || undefined,\n      baseIRI: config.baseIRI || undefined,\n      exists: config.exists,\n      aggregate: config.aggregate,\n    };\n\n    this.evaluator = new SyncRecursiveEvaluator(context);\n  }\n\n  evaluate(mapping: Bindings): RDF.Term {\n    const result = this.evaluator.evaluate(this.expr, mapping);\n    return log(result).toRDF();\n  }\n\n  evaluateAsEBV(mapping: Bindings): boolean {\n    const result = this.evaluator.evaluate(this.expr, mapping);\n    return log(result).coerceEBV();\n  }\n\n  evaluateAsInternal(mapping: Bindings): Term {\n    const result = this.evaluator.evaluate(this.expr, mapping);\n    return log(result);\n  }\n}\n\nfunction log<T>(val: T): T {\n  // console.log(val);\n  return val;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}