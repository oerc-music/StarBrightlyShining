{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Util = void 0;\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * A collection of utility functions.\n */\n\n\nclass Util {\n  constructor(dataFactory, baseIRI) {\n    this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();\n    this.baseIRI = baseIRI || '';\n  }\n  /**\n   * Check if the given IRI is valid.\n   * @param {string} iri A potential IRI.\n   * @return {boolean} If the given IRI is valid.\n   */\n\n\n  static isValidIri(iri) {\n    return Util.IRI_REGEX.test(iri);\n  }\n  /**\n   * Create vocab terms for the given terms attribute.\n   *\n   * Relative IRIs will be based on the active vocab or baseIRI if `allowRelativeIris` is true.\n   *\n   * @param {string} terms An attribute value.\n   * @param {IItemScope} itemScope The active item scope.\n   * @param {boolean} allowRelativeIris If relative IRIs are allowed.\n   * @return {Term[]} The IRI terms.\n   */\n\n\n  createVocabIris(terms, itemScope, allowRelativeIris) {\n    return terms.split(/\\s+/u).filter(term => !!term).map(property => {\n      if (!Util.isValidIri(property)) {\n        if (!allowRelativeIris) {\n          return;\n        }\n\n        property = `${itemScope.vocab || `${this.baseIRI}#`}${property}`;\n      }\n\n      return this.dataFactory.namedNode(property);\n    }).filter(term => !!term);\n  }\n  /**\n   * Get the predicates for which the given itemprop value should cause vocabulary expansion.\n   * @param terms An attribute value.\n   * @param itemScope The active item scope.\n   * @param vocabRegistry The active vocabulary registry.\n   */\n\n\n  getVocabularyExpansionType(terms, itemScope, vocabRegistry) {\n    // Check the presence of subPropertyOf or equivalentProperty\n    const parts = terms.split(/\\s+/u);\n\n    if (parts.includes('subPropertyOf') || parts.includes('equivalentProperty')) {\n      return [this.dataFactory.namedNode(`${Util.RDF}type`)];\n    } // Check in the item scope's vocab\n\n\n    if (itemScope.vocab && itemScope.vocab in vocabRegistry && vocabRegistry[itemScope.vocab].properties) {\n      let predicates = [];\n\n      for (const [property, expansions] of Object.entries(vocabRegistry[itemScope.vocab].properties)) {\n        if (parts.includes(property)) {\n          predicates = predicates.concat(Object.values(expansions).map(iri => this.dataFactory.namedNode(iri)));\n        }\n      }\n\n      return predicates;\n    }\n\n    return [];\n  }\n  /**\n   * Create a named node for the given term, which can be relative to the document base.\n   * @param {string} iri A term string.\n   * @return {Term} An RDF term, or undefined if invalid.\n   */\n\n\n  createSubject(iri) {\n    if (!Util.isValidIri(iri)) {\n      try {\n        iri = relative_to_absolute_iri_1.resolve(iri, this.baseIRI);\n      } catch (_a) {\n        return;\n      }\n    }\n\n    return this.dataFactory.namedNode(iri);\n  }\n  /**\n   * Create a new literal node.\n   * @param {string} literal The literal value.\n   * @param {IActiveTag} activeTag The current active tag.\n   * @return {Literal} A new literal node.\n   */\n\n\n  createLiteral(literal, activeTag) {\n    return this.dataFactory.literal(literal, activeTag.language);\n  }\n  /**\n   * Determine the vocab IRI from a given type IRI.\n   * @link https://w3c.github.io/microdata-rdf/#property-uri-generation\n   * @param typeIri A type IRI.\n   * @param vocabRegistry The active vocabulary registry.\n   */\n\n\n  deriveVocab(typeIri, vocabRegistry) {\n    let vocab; // First check if we find a prefix in the vocab registry\n\n    for (const uriPrefix in vocabRegistry) {\n      if (typeIri.startsWith(uriPrefix)) {\n        vocab = uriPrefix; // Append fragment if prefix does not end with a slash\n\n        if (!vocab.endsWith('/')) {\n          vocab += '#';\n        }\n\n        break;\n      }\n    } // If no match was found, remove the last path segment from the URI\n\n\n    if (!vocab) {\n      const hashPos = typeIri.indexOf('#');\n\n      if (hashPos > 0) {\n        vocab = typeIri.slice(0, hashPos + 1);\n      } else {\n        vocab = relative_to_absolute_iri_1.resolve('.', typeIri);\n      }\n    }\n\n    return vocab;\n  }\n\n}\n\nexports.Util = Util;\nUtil.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nUtil.XSD = 'http://www.w3.org/2001/XMLSchema#';\nUtil.RDFA = 'http://www.w3.org/ns/rdfa#';\nUtil.IRI_REGEX = /^([A-Za-z][\\d+-.A-Za-z]*|_):[^ \"<>[\\\\\\]`{|}]*$/u;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/microdata-rdf-streaming-parser/lib/Util.js"],"names":["Object","defineProperty","exports","value","Util","rdf_data_factory_1","require","relative_to_absolute_iri_1","constructor","dataFactory","baseIRI","DataFactory","isValidIri","iri","IRI_REGEX","test","createVocabIris","terms","itemScope","allowRelativeIris","split","filter","term","map","property","vocab","namedNode","getVocabularyExpansionType","vocabRegistry","parts","includes","RDF","properties","predicates","expansions","entries","concat","values","createSubject","resolve","_a","createLiteral","literal","activeTag","language","deriveVocab","typeIri","uriPrefix","startsWith","endsWith","hashPos","indexOf","slice","XSD","RDFA"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * A collection of utility functions.\n */\nclass Util {\n    constructor(dataFactory, baseIRI) {\n        this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();\n        this.baseIRI = baseIRI || '';\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return Util.IRI_REGEX.test(iri);\n    }\n    /**\n     * Create vocab terms for the given terms attribute.\n     *\n     * Relative IRIs will be based on the active vocab or baseIRI if `allowRelativeIris` is true.\n     *\n     * @param {string} terms An attribute value.\n     * @param {IItemScope} itemScope The active item scope.\n     * @param {boolean} allowRelativeIris If relative IRIs are allowed.\n     * @return {Term[]} The IRI terms.\n     */\n    createVocabIris(terms, itemScope, allowRelativeIris) {\n        return terms.split(/\\s+/u)\n            .filter(term => !!term)\n            .map(property => {\n            if (!Util.isValidIri(property)) {\n                if (!allowRelativeIris) {\n                    return;\n                }\n                property = `${itemScope.vocab || `${this.baseIRI}#`}${property}`;\n            }\n            return this.dataFactory.namedNode(property);\n        })\n            .filter(term => !!term);\n    }\n    /**\n     * Get the predicates for which the given itemprop value should cause vocabulary expansion.\n     * @param terms An attribute value.\n     * @param itemScope The active item scope.\n     * @param vocabRegistry The active vocabulary registry.\n     */\n    getVocabularyExpansionType(terms, itemScope, vocabRegistry) {\n        // Check the presence of subPropertyOf or equivalentProperty\n        const parts = terms.split(/\\s+/u);\n        if (parts.includes('subPropertyOf') || parts.includes('equivalentProperty')) {\n            return [this.dataFactory.namedNode(`${Util.RDF}type`)];\n        }\n        // Check in the item scope's vocab\n        if (itemScope.vocab && itemScope.vocab in vocabRegistry && vocabRegistry[itemScope.vocab].properties) {\n            let predicates = [];\n            for (const [property, expansions] of Object\n                .entries(vocabRegistry[itemScope.vocab].properties)) {\n                if (parts.includes(property)) {\n                    predicates = predicates.concat(Object.values(expansions).map(iri => this.dataFactory.namedNode(iri)));\n                }\n            }\n            return predicates;\n        }\n        return [];\n    }\n    /**\n     * Create a named node for the given term, which can be relative to the document base.\n     * @param {string} iri A term string.\n     * @return {Term} An RDF term, or undefined if invalid.\n     */\n    createSubject(iri) {\n        if (!Util.isValidIri(iri)) {\n            try {\n                iri = relative_to_absolute_iri_1.resolve(iri, this.baseIRI);\n            }\n            catch (_a) {\n                return;\n            }\n        }\n        return this.dataFactory.namedNode(iri);\n    }\n    /**\n     * Create a new literal node.\n     * @param {string} literal The literal value.\n     * @param {IActiveTag} activeTag The current active tag.\n     * @return {Literal} A new literal node.\n     */\n    createLiteral(literal, activeTag) {\n        return this.dataFactory.literal(literal, activeTag.language);\n    }\n    /**\n     * Determine the vocab IRI from a given type IRI.\n     * @link https://w3c.github.io/microdata-rdf/#property-uri-generation\n     * @param typeIri A type IRI.\n     * @param vocabRegistry The active vocabulary registry.\n     */\n    deriveVocab(typeIri, vocabRegistry) {\n        let vocab;\n        // First check if we find a prefix in the vocab registry\n        for (const uriPrefix in vocabRegistry) {\n            if (typeIri.startsWith(uriPrefix)) {\n                vocab = uriPrefix;\n                // Append fragment if prefix does not end with a slash\n                if (!vocab.endsWith('/')) {\n                    vocab += '#';\n                }\n                break;\n            }\n        }\n        // If no match was found, remove the last path segment from the URI\n        if (!vocab) {\n            const hashPos = typeIri.indexOf('#');\n            if (hashPos > 0) {\n                vocab = typeIri.slice(0, hashPos + 1);\n            }\n            else {\n                vocab = relative_to_absolute_iri_1.resolve('.', typeIri);\n            }\n        }\n        return vocab;\n    }\n}\nexports.Util = Util;\nUtil.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nUtil.XSD = 'http://www.w3.org/2001/XMLSchema#';\nUtil.RDFA = 'http://www.w3.org/ns/rdfa#';\nUtil.IRI_REGEX = /^([A-Za-z][\\d+-.A-Za-z]*|_):[^ \"<>[\\\\\\]`{|}]*$/u;\n//# sourceMappingURL=Util.js.map"]},"metadata":{},"sourceType":"script"}