{"ast":null,"code":"import ContextProvider from './ContextProvider';\nimport { lazyThenable } from './promiseUtils';\nimport { valueToTerm } from './valueUtils';\n/**\n * Resolves property names of a path\n * to their corresponding IRIs through a JSON-LD context.\n * @abstract\n */\n\nexport default class AbstractPathResolver {\n  get _context() {\n    return this._contextProvider._context;\n  }\n\n  async extendContext(...contexts) {\n    await this._contextProvider.extendContext(...contexts);\n  }\n  /**\n   * Creates a new resolver for the given context(s).\n   * @param arg Either a context provider *or* a context\n   */\n\n\n  constructor(arg, ...contexts) {\n    this._contextProvider = new ContextProvider();\n\n    if (arg instanceof ContextProvider) {\n      this._contextProvider = arg;\n      this.extendContext(...contexts);\n    } else {\n      this.extendContext(arg, ...contexts);\n    }\n  }\n  /**\n   * The JSON-LD resolver supports all string properties.\n   */\n\n\n  supports(property) {\n    return typeof property === 'string';\n  }\n  /**\n   * When resolving a JSON-LD or complex path property,\n   * we create a new chainable path segment corresponding to the predicate.\n   *\n   * Example usage: person.friends.firstName\n   */\n\n\n  resolve(property, pathData) {\n    const predicate = lazyThenable(() => this.expandProperty(property));\n    const reverse = lazyThenable(() => this._context.then(({\n      contextRaw\n    }) => contextRaw[property] && contextRaw[property]['@reverse']));\n    const resultsCache = this.getResultsCache(pathData, predicate, reverse);\n    const newData = {\n      property,\n      predicate,\n      resultsCache,\n      reverse,\n      apply: this.apply\n    };\n    return pathData.extendPath(newData);\n  }\n  /**\n   * When the property is called as a function,\n   * it adds property-object constraints to the path.\n   *\n   * Example usage: person.friends.location(place).firstName\n   */\n\n\n  apply(args, pathData, path) {\n    if (args.length === 0) {\n      const {\n        property\n      } = pathData;\n      throw new Error(`Specify at least one term when calling .${property}() on a path`);\n    } // With the property constraint added, continue from the previous path\n\n\n    pathData.values = args.map(valueToTerm);\n    return path;\n  }\n\n  async expandProperty(property) {\n    // JavaScript requires keys containing colons to be quoted,\n    // so prefixed names would need to written as path['foaf:knows'].\n    // We thus allow writing path.foaf_knows or path.foaf$knows instead.\n    return this.lookupProperty(property.replace(/^([a-z][a-z0-9]*)[_$]/i, '$1:'));\n  }\n  /**\n   * Gets the results cache for the given predicate.\n   */\n\n\n  getResultsCache(pathData, predicate, reverse) {\n    let {\n      propertyCache\n    } = pathData;\n    return propertyCache && lazyThenable(async () => {\n      // Preloading does not work with reversed predicates\n      propertyCache = !(await reverse) && (await propertyCache);\n      return propertyCache && propertyCache[(await predicate).value];\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/AbstractPathResolver.js"],"names":["ContextProvider","lazyThenable","valueToTerm","AbstractPathResolver","_context","_contextProvider","extendContext","contexts","constructor","arg","supports","property","resolve","pathData","predicate","expandProperty","reverse","then","contextRaw","resultsCache","getResultsCache","newData","apply","extendPath","args","path","length","Error","values","map","lookupProperty","replace","propertyCache","value"],"mappings":"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","sourcesContent":["import ContextProvider from './ContextProvider';\nimport { lazyThenable } from './promiseUtils';\nimport { valueToTerm } from './valueUtils';\n/**\n * Resolves property names of a path\n * to their corresponding IRIs through a JSON-LD context.\n * @abstract\n */\n\nexport default class AbstractPathResolver {\n  get _context() {\n    return this._contextProvider._context;\n  }\n\n  async extendContext(...contexts) {\n    await this._contextProvider.extendContext(...contexts);\n  }\n  /**\n   * Creates a new resolver for the given context(s).\n   * @param arg Either a context provider *or* a context\n   */\n\n\n  constructor(arg, ...contexts) {\n    this._contextProvider = new ContextProvider();\n\n    if (arg instanceof ContextProvider) {\n      this._contextProvider = arg;\n      this.extendContext(...contexts);\n    } else {\n      this.extendContext(arg, ...contexts);\n    }\n  }\n  /**\n   * The JSON-LD resolver supports all string properties.\n   */\n\n\n  supports(property) {\n    return typeof property === 'string';\n  }\n  /**\n   * When resolving a JSON-LD or complex path property,\n   * we create a new chainable path segment corresponding to the predicate.\n   *\n   * Example usage: person.friends.firstName\n   */\n\n\n  resolve(property, pathData) {\n    const predicate = lazyThenable(() => this.expandProperty(property));\n    const reverse = lazyThenable(() => this._context.then(({\n      contextRaw\n    }) => contextRaw[property] && contextRaw[property]['@reverse']));\n    const resultsCache = this.getResultsCache(pathData, predicate, reverse);\n    const newData = {\n      property,\n      predicate,\n      resultsCache,\n      reverse,\n      apply: this.apply\n    };\n    return pathData.extendPath(newData);\n  }\n  /**\n   * When the property is called as a function,\n   * it adds property-object constraints to the path.\n   *\n   * Example usage: person.friends.location(place).firstName\n   */\n\n\n  apply(args, pathData, path) {\n    if (args.length === 0) {\n      const {\n        property\n      } = pathData;\n      throw new Error(`Specify at least one term when calling .${property}() on a path`);\n    } // With the property constraint added, continue from the previous path\n\n\n    pathData.values = args.map(valueToTerm);\n    return path;\n  }\n\n  async expandProperty(property) {\n    // JavaScript requires keys containing colons to be quoted,\n    // so prefixed names would need to written as path['foaf:knows'].\n    // We thus allow writing path.foaf_knows or path.foaf$knows instead.\n    return this.lookupProperty(property.replace(/^([a-z][a-z0-9]*)[_$]/i, '$1:'));\n  }\n  /**\n   * Gets the results cache for the given predicate.\n   */\n\n\n  getResultsCache(pathData, predicate, reverse) {\n    let {\n      propertyCache\n    } = pathData;\n    return propertyCache && lazyThenable(async () => {\n      // Preloading does not work with reversed predicates\n      propertyCache = !(await reverse) && (await propertyCache);\n      return propertyCache && propertyCache[(await predicate).value];\n    });\n  }\n\n}"]},"metadata":{},"sourceType":"module"}