{"ast":null,"code":"import { getFirstItem } from './iterableUtils';\n/**\n * Returns a lazy thenable to the created promise.\n */\n\nexport function lazyThenable(createPromise) {\n  return {\n    then: getThen(createPromise)\n  };\n}\n/**\n * Lazily returns the `then` function of the created promise.\n */\n\nexport function getThen(createPromise) {\n  return (onResolved, onRejected) => createPromise().then(onResolved, onRejected);\n}\n/**\n * Returns an iterable that is also a promise to the first element.\n */\n\nexport function toIterablePromise(iterable) {\n  // If called with a generator function,\n  // memoize it to enable multiple iterations\n  if (typeof iterable === 'function') iterable = memoizeIterable(iterable()); // Return an object that is iterable and a promise\n\n  return {\n    [Symbol.asyncIterator]() {\n      return iterable[Symbol.asyncIterator]();\n    },\n\n    get then() {\n      return getThen(() => getFirstItem(this));\n    },\n\n    catch(onRejected) {\n      return this.then(null, onRejected);\n    },\n\n    finally(callback) {\n      return this.then().finally(callback);\n    }\n\n  };\n}\n/**\n * Returns a memoized version of the iterable\n * that can be iterated over as many times as needed.\n */\n\nexport function memoizeIterable(iterable) {\n  const cache = [];\n  let iterator = iterable[Symbol.asyncIterator]();\n  return {\n    [Symbol.asyncIterator]() {\n      let i = 0;\n      return {\n        async next() {\n          // Return the item if it has been read already\n          if (i < cache.length) return cache[i++]; // Stop if there are no more items\n\n          if (!iterator) return {\n            done: true\n          }; // Read and cache an item from the iterable otherwise\n\n          const item = cache[i++] = iterator.next();\n          if ((await item).done) iterator = null;\n          return item;\n        }\n\n      };\n    }\n\n  };\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/promiseUtils.js"],"names":["getFirstItem","lazyThenable","createPromise","then","getThen","onResolved","onRejected","toIterablePromise","iterable","memoizeIterable","Symbol","asyncIterator","catch","finally","callback","cache","iterator","i","next","length","done","item"],"mappings":"AAAA,SAASA,YAAT,QAA6B,iBAA7B;AACA;AACA;AACA;;AAEA,OAAO,SAASC,YAAT,CAAsBC,aAAtB,EAAqC;AAC1C,SAAO;AACLC,IAAAA,IAAI,EAAEC,OAAO,CAACF,aAAD;AADR,GAAP;AAGD;AACD;AACA;AACA;;AAEA,OAAO,SAASE,OAAT,CAAiBF,aAAjB,EAAgC;AACrC,SAAO,CAACG,UAAD,EAAaC,UAAb,KAA4BJ,aAAa,GAAGC,IAAhB,CAAqBE,UAArB,EAAiCC,UAAjC,CAAnC;AACD;AACD;AACA;AACA;;AAEA,OAAO,SAASC,iBAAT,CAA2BC,QAA3B,EAAqC;AAC1C;AACA;AACA,MAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoCA,QAAQ,GAAGC,eAAe,CAACD,QAAQ,EAAT,CAA1B,CAHM,CAGkC;;AAE5E,SAAO;AACL,KAACE,MAAM,CAACC,aAAR,IAAyB;AACvB,aAAOH,QAAQ,CAACE,MAAM,CAACC,aAAR,CAAR,EAAP;AACD,KAHI;;AAKL,QAAIR,IAAJ,GAAW;AACT,aAAOC,OAAO,CAAC,MAAMJ,YAAY,CAAC,IAAD,CAAnB,CAAd;AACD,KAPI;;AASLY,IAAAA,KAAK,CAACN,UAAD,EAAa;AAChB,aAAO,KAAKH,IAAL,CAAU,IAAV,EAAgBG,UAAhB,CAAP;AACD,KAXI;;AAaLO,IAAAA,OAAO,CAACC,QAAD,EAAW;AAChB,aAAO,KAAKX,IAAL,GAAYU,OAAZ,CAAoBC,QAApB,CAAP;AACD;;AAfI,GAAP;AAkBD;AACD;AACA;AACA;AACA;;AAEA,OAAO,SAASL,eAAT,CAAyBD,QAAzB,EAAmC;AACxC,QAAMO,KAAK,GAAG,EAAd;AACA,MAAIC,QAAQ,GAAGR,QAAQ,CAACE,MAAM,CAACC,aAAR,CAAR,EAAf;AACA,SAAO;AACL,KAACD,MAAM,CAACC,aAAR,IAAyB;AACvB,UAAIM,CAAC,GAAG,CAAR;AACA,aAAO;AACL,cAAMC,IAAN,GAAa;AACX;AACA,cAAID,CAAC,GAAGF,KAAK,CAACI,MAAd,EAAsB,OAAOJ,KAAK,CAACE,CAAC,EAAF,CAAZ,CAFX,CAE8B;;AAEzC,cAAI,CAACD,QAAL,EAAe,OAAO;AACpBI,YAAAA,IAAI,EAAE;AADc,WAAP,CAJJ,CAMR;;AAEH,gBAAMC,IAAI,GAAGN,KAAK,CAACE,CAAC,EAAF,CAAL,GAAaD,QAAQ,CAACE,IAAT,EAA1B;AACA,cAAI,CAAC,MAAMG,IAAP,EAAaD,IAAjB,EAAuBJ,QAAQ,GAAG,IAAX;AACvB,iBAAOK,IAAP;AACD;;AAZI,OAAP;AAeD;;AAlBI,GAAP;AAqBD","sourcesContent":["import { getFirstItem } from './iterableUtils';\n/**\n * Returns a lazy thenable to the created promise.\n */\n\nexport function lazyThenable(createPromise) {\n  return {\n    then: getThen(createPromise)\n  };\n}\n/**\n * Lazily returns the `then` function of the created promise.\n */\n\nexport function getThen(createPromise) {\n  return (onResolved, onRejected) => createPromise().then(onResolved, onRejected);\n}\n/**\n * Returns an iterable that is also a promise to the first element.\n */\n\nexport function toIterablePromise(iterable) {\n  // If called with a generator function,\n  // memoize it to enable multiple iterations\n  if (typeof iterable === 'function') iterable = memoizeIterable(iterable()); // Return an object that is iterable and a promise\n\n  return {\n    [Symbol.asyncIterator]() {\n      return iterable[Symbol.asyncIterator]();\n    },\n\n    get then() {\n      return getThen(() => getFirstItem(this));\n    },\n\n    catch(onRejected) {\n      return this.then(null, onRejected);\n    },\n\n    finally(callback) {\n      return this.then().finally(callback);\n    }\n\n  };\n}\n/**\n * Returns a memoized version of the iterable\n * that can be iterated over as many times as needed.\n */\n\nexport function memoizeIterable(iterable) {\n  const cache = [];\n  let iterator = iterable[Symbol.asyncIterator]();\n  return {\n    [Symbol.asyncIterator]() {\n      let i = 0;\n      return {\n        async next() {\n          // Return the item if it has been read already\n          if (i < cache.length) return cache[i++]; // Stop if there are no more items\n\n          if (!iterator) return {\n            done: true\n          }; // Read and cache an item from the iterable otherwise\n\n          const item = cache[i++] = iterator.next();\n          if ((await item).done) iterator = null;\n          return item;\n        }\n\n      };\n    }\n\n  };\n}"]},"metadata":{},"sourceType":"module"}