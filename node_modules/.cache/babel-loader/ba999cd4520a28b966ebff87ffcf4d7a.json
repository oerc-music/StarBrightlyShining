{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Converter = void 0;\n\nconst rdf_literal_1 = require(\"rdf-literal\");\n\nconst sparqljson_parse_1 = require(\"sparqljson-parse\");\n/**\n * Converts SPARQL JSON results to a tree-based structure by splitting variables on a certain delimiter.\n */\n\n\nclass Converter {\n  constructor(settings) {\n    settings = settings || {\n      delimiter: '_'\n    };\n    settings.prefixVariableQuestionMark = false;\n    this.delimiter = settings.delimiter || '_';\n    this.parser = new sparqljson_parse_1.SparqlJsonParser(settings);\n    this.materializeRdfJsTerms = settings.materializeRdfJsTerms;\n  }\n  /**\n   * Adds a value to a tree.\n   * @param tree A tree datastructure.\n   * @param {string[]} path The path of keys in the tree.\n   * @param {Term} value A value to add.\n   * @param {string} lastKeyPath The accumulated key path (separated by the given delimiter)\n   *                             through recursive calls, can be empty.\n   * @param {ISchema} schema A schema.\n   * @param {string} delimiter The string to join key paths by.\n   */\n\n\n  static addValueToTree(tree, path, value, lastKeyPath, schema, delimiter) {\n    const key = path[0];\n    const keyPath = lastKeyPath ? lastKeyPath + delimiter + key : key;\n    const singularize = schema.singularizeVariables[keyPath];\n\n    if (path.length === 1) {\n      // Leaf nodes\n      if (singularize) {\n        if (!tree[key]) {\n          tree[key] = value;\n        }\n      } else {\n        if (!tree[key]) {\n          tree[key] = [];\n        }\n\n        tree[key].push(value);\n      }\n    } else {\n      // Inner nodes\n      let nextNode;\n\n      if (singularize) {\n        if (!tree[key]) {\n          tree[key] = {};\n        }\n\n        nextNode = tree[key];\n      } else {\n        if (!tree[key]) {\n          tree[key] = [{}];\n        }\n\n        nextNode = tree[key][0];\n      }\n\n      Converter.addValueToTree(nextNode, path.slice(1), value, keyPath, schema, delimiter);\n    }\n  }\n  /**\n   * Recursively merge the two given trees.\n   * @param tree1 A first tree (has key priority on literals).\n   * @param tree2 A second tree. All arrays will/should only have a single element.\n   * @return {any} The merged tree.\n   */\n\n\n  static mergeTrees(tree1, tree2) {\n    if (typeof tree1 !== typeof tree2) {\n      throw new Error(`Two incompatible tree nodes were found: ${typeof tree1} and ${typeof tree2}`);\n    }\n\n    if (Array.isArray(tree1) !== Array.isArray(tree2)) {\n      throw new Error(`Two incompatible tree nodes were found: Array?${Array.isArray(tree1)} and Array?${Array.isArray(tree2)}`);\n    }\n\n    if (typeof tree1 === 'object' && typeof tree2 === 'object') {\n      if (tree1.termType && tree2.termType) {\n        if (tree1.equals(tree2)) {\n          return {\n            valid: true,\n            result: tree1\n          };\n        } else {\n          return {\n            valid: false,\n            result: tree1\n          };\n        }\n      }\n\n      if (Array.isArray(tree1) && Array.isArray(tree2)) {\n        if (tree1.length > 0) {\n          const merged = [];\n          let valid = false;\n\n          for (const tree1Element of tree1) {\n            const mergedElement = Converter.mergeTrees(tree1Element, tree2[0]);\n\n            if (mergedElement.valid) {\n              valid = true;\n              merged.push(mergedElement.result);\n            } else {\n              merged.push(tree1Element);\n            }\n          }\n\n          if (valid) {\n            return {\n              valid: true,\n              result: merged\n            };\n          }\n        }\n\n        return {\n          valid: true,\n          result: tree1.concat(tree2)\n        };\n      } else {\n        const merged = {};\n\n        for (const key2 in tree2) {\n          merged[key2] = tree2[key2];\n        }\n\n        for (const key1 in tree1) {\n          if (merged[key1]) {\n            const mergedElement = Converter.mergeTrees(tree1[key1], merged[key1]);\n\n            if (mergedElement.valid) {\n              merged[key1] = mergedElement.result;\n            } else {\n              return {\n                valid: false,\n                result: tree1\n              };\n            }\n          } else {\n            merged[key1] = tree1[key1];\n          }\n        }\n\n        return {\n          valid: true,\n          result: merged\n        };\n      }\n    } else {\n      throw new Error(`Unmergable tree types: ${typeof tree1} and ${typeof tree2}`);\n    }\n  }\n  /**\n   * Materialize all RDF terms in the given tree to raw values.\n   * This does not mutate the original tree.\n   * @param tree A tree.\n   * @return {any} A materialized tree.\n   */\n\n\n  static materializeTree(tree) {\n    if (tree.termType) {\n      return rdf_literal_1.getTermRaw(tree);\n    } else if (Array.isArray(tree)) {\n      return tree.map(Converter.materializeTree);\n    } else {\n      const materialized = {};\n\n      for (const key in tree) {\n        materialized[key] = Converter.materializeTree(tree[key]);\n      }\n\n      return materialized;\n    }\n  }\n  /**\n   * Convert a complete SPARQL JSON response to a GraphQL results tree.\n   * @param sparqlResponse A SPARQL JSON response.\n   * @param {ISchema} schema A schema.\n   * @return {any} A GraphQL results tree.\n   */\n\n\n  sparqlJsonResultsToTree(sparqlResponse, schema) {\n    return this.bindingsToTree(this.parser.parseJsonResults(sparqlResponse), schema || {\n      singularizeVariables: {}\n    });\n  }\n  /**\n   * Convert an array of bindings to a GraphQL results tree.\n   * @param {IBindings[]} bindingsArray An array of bindings.\n   * @param {ISchema} schema A schema.\n   * @return {any} A GraphQL results tree.\n   */\n\n\n  bindingsToTree(bindingsArray, schema) {\n    const singularRoot = schema && schema.singularizeVariables[''];\n    let tree = singularRoot ? {} : [];\n\n    for (const bindings of bindingsArray) {\n      const subTree = singularRoot ? {} : [{}];\n\n      for (const key in bindings) {\n        const path = key.split(this.delimiter);\n        const value = bindings[key];\n        Converter.addValueToTree(singularRoot ? subTree : subTree[0], path, value, '', schema, this.delimiter);\n      }\n\n      tree = Converter.mergeTrees(tree, subTree).result;\n    }\n\n    if (this.materializeRdfJsTerms) {\n      tree = Converter.materializeTree(tree);\n    }\n\n    return tree;\n  }\n\n}\n\nexports.Converter = Converter;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/sparqljson-to-tree/lib/Converter.js"],"names":["Object","defineProperty","exports","value","Converter","rdf_literal_1","require","sparqljson_parse_1","constructor","settings","delimiter","prefixVariableQuestionMark","parser","SparqlJsonParser","materializeRdfJsTerms","addValueToTree","tree","path","lastKeyPath","schema","key","keyPath","singularize","singularizeVariables","length","push","nextNode","slice","mergeTrees","tree1","tree2","Error","Array","isArray","termType","equals","valid","result","merged","tree1Element","mergedElement","concat","key2","key1","materializeTree","getTermRaw","map","materialized","sparqlJsonResultsToTree","sparqlResponse","bindingsToTree","parseJsonResults","bindingsArray","singularRoot","bindings","subTree","split"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Converter = void 0;\nconst rdf_literal_1 = require(\"rdf-literal\");\nconst sparqljson_parse_1 = require(\"sparqljson-parse\");\n/**\n * Converts SPARQL JSON results to a tree-based structure by splitting variables on a certain delimiter.\n */\nclass Converter {\n    constructor(settings) {\n        settings = settings || { delimiter: '_' };\n        settings.prefixVariableQuestionMark = false;\n        this.delimiter = settings.delimiter || '_';\n        this.parser = new sparqljson_parse_1.SparqlJsonParser(settings);\n        this.materializeRdfJsTerms = settings.materializeRdfJsTerms;\n    }\n    /**\n     * Adds a value to a tree.\n     * @param tree A tree datastructure.\n     * @param {string[]} path The path of keys in the tree.\n     * @param {Term} value A value to add.\n     * @param {string} lastKeyPath The accumulated key path (separated by the given delimiter)\n     *                             through recursive calls, can be empty.\n     * @param {ISchema} schema A schema.\n     * @param {string} delimiter The string to join key paths by.\n     */\n    static addValueToTree(tree, path, value, lastKeyPath, schema, delimiter) {\n        const key = path[0];\n        const keyPath = lastKeyPath ? (lastKeyPath + delimiter + key) : key;\n        const singularize = schema.singularizeVariables[keyPath];\n        if (path.length === 1) {\n            // Leaf nodes\n            if (singularize) {\n                if (!tree[key]) {\n                    tree[key] = value;\n                }\n            }\n            else {\n                if (!tree[key]) {\n                    tree[key] = [];\n                }\n                tree[key].push(value);\n            }\n        }\n        else {\n            // Inner nodes\n            let nextNode;\n            if (singularize) {\n                if (!tree[key]) {\n                    tree[key] = {};\n                }\n                nextNode = tree[key];\n            }\n            else {\n                if (!tree[key]) {\n                    tree[key] = [{}];\n                }\n                nextNode = tree[key][0];\n            }\n            Converter.addValueToTree(nextNode, path.slice(1), value, keyPath, schema, delimiter);\n        }\n    }\n    /**\n     * Recursively merge the two given trees.\n     * @param tree1 A first tree (has key priority on literals).\n     * @param tree2 A second tree. All arrays will/should only have a single element.\n     * @return {any} The merged tree.\n     */\n    static mergeTrees(tree1, tree2) {\n        if (typeof tree1 !== typeof tree2) {\n            throw new Error(`Two incompatible tree nodes were found: ${typeof tree1} and ${typeof tree2}`);\n        }\n        if (Array.isArray(tree1) !== Array.isArray(tree2)) {\n            throw new Error(`Two incompatible tree nodes were found: Array?${Array.isArray(tree1)} and Array?${Array.isArray(tree2)}`);\n        }\n        if (typeof tree1 === 'object' && typeof tree2 === 'object') {\n            if (tree1.termType && tree2.termType) {\n                if (tree1.equals(tree2)) {\n                    return { valid: true, result: tree1 };\n                }\n                else {\n                    return { valid: false, result: tree1 };\n                }\n            }\n            if (Array.isArray(tree1) && Array.isArray(tree2)) {\n                if (tree1.length > 0) {\n                    const merged = [];\n                    let valid = false;\n                    for (const tree1Element of tree1) {\n                        const mergedElement = Converter.mergeTrees(tree1Element, tree2[0]);\n                        if (mergedElement.valid) {\n                            valid = true;\n                            merged.push(mergedElement.result);\n                        }\n                        else {\n                            merged.push(tree1Element);\n                        }\n                    }\n                    if (valid) {\n                        return { valid: true, result: merged };\n                    }\n                }\n                return { valid: true, result: tree1.concat(tree2) };\n            }\n            else {\n                const merged = {};\n                for (const key2 in tree2) {\n                    merged[key2] = tree2[key2];\n                }\n                for (const key1 in tree1) {\n                    if (merged[key1]) {\n                        const mergedElement = Converter.mergeTrees(tree1[key1], merged[key1]);\n                        if (mergedElement.valid) {\n                            merged[key1] = mergedElement.result;\n                        }\n                        else {\n                            return { valid: false, result: tree1 };\n                        }\n                    }\n                    else {\n                        merged[key1] = tree1[key1];\n                    }\n                }\n                return { valid: true, result: merged };\n            }\n        }\n        else {\n            throw new Error(`Unmergable tree types: ${typeof tree1} and ${typeof tree2}`);\n        }\n    }\n    /**\n     * Materialize all RDF terms in the given tree to raw values.\n     * This does not mutate the original tree.\n     * @param tree A tree.\n     * @return {any} A materialized tree.\n     */\n    static materializeTree(tree) {\n        if (tree.termType) {\n            return rdf_literal_1.getTermRaw(tree);\n        }\n        else if (Array.isArray(tree)) {\n            return tree.map(Converter.materializeTree);\n        }\n        else {\n            const materialized = {};\n            for (const key in tree) {\n                materialized[key] = Converter.materializeTree(tree[key]);\n            }\n            return materialized;\n        }\n    }\n    /**\n     * Convert a complete SPARQL JSON response to a GraphQL results tree.\n     * @param sparqlResponse A SPARQL JSON response.\n     * @param {ISchema} schema A schema.\n     * @return {any} A GraphQL results tree.\n     */\n    sparqlJsonResultsToTree(sparqlResponse, schema) {\n        return this.bindingsToTree(this.parser.parseJsonResults(sparqlResponse), schema || { singularizeVariables: {} });\n    }\n    /**\n     * Convert an array of bindings to a GraphQL results tree.\n     * @param {IBindings[]} bindingsArray An array of bindings.\n     * @param {ISchema} schema A schema.\n     * @return {any} A GraphQL results tree.\n     */\n    bindingsToTree(bindingsArray, schema) {\n        const singularRoot = schema && schema.singularizeVariables[''];\n        let tree = singularRoot ? {} : [];\n        for (const bindings of bindingsArray) {\n            const subTree = singularRoot ? {} : [{}];\n            for (const key in bindings) {\n                const path = key.split(this.delimiter);\n                const value = bindings[key];\n                Converter.addValueToTree(singularRoot ? subTree : subTree[0], path, value, '', schema, this.delimiter);\n            }\n            tree = Converter.mergeTrees(tree, subTree).result;\n        }\n        if (this.materializeRdfJsTerms) {\n            tree = Converter.materializeTree(tree);\n        }\n        return tree;\n    }\n}\nexports.Converter = Converter;\n//# sourceMappingURL=Converter.js.map"]},"metadata":{},"sourceType":"script"}