{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RdfSourceQpf = void 0;\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst rdf_terms_1 = require(\"rdf-terms\");\n\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * An RDF source that executes a quad pattern over a QPF interface and fetches its first page.\n */\n\nclass RdfSourceQpf {\n  constructor(mediatorMetadata, mediatorMetadataExtract, mediatorRdfDereference, subjectUri, predicateUri, objectUri, graphUri, metadata, context, initialQuads) {\n    this.mediatorMetadata = mediatorMetadata;\n    this.mediatorMetadataExtract = mediatorMetadataExtract;\n    this.mediatorRdfDereference = mediatorRdfDereference;\n    this.subjectUri = subjectUri;\n    this.predicateUri = predicateUri;\n    this.objectUri = objectUri;\n    this.graphUri = graphUri;\n    this.context = context;\n    this.cachedQuads = {};\n    const searchForm = this.getSearchForm(metadata);\n\n    if (!searchForm) {\n      throw new Error('Illegal state: found no TPF/QPF search form anymore in metadata.');\n    }\n\n    this.searchForm = searchForm;\n    this.defaultGraph = metadata.defaultGraph ? DF.namedNode(metadata.defaultGraph) : undefined;\n\n    if (initialQuads) {\n      let wrappedQuads = asynciterator_1.wrap(initialQuads);\n\n      if (this.defaultGraph) {\n        wrappedQuads = this.reverseMapQuadsToDefaultGraph(wrappedQuads);\n      }\n\n      wrappedQuads.setProperty('metadata', metadata);\n      this.cacheQuads(wrappedQuads, DF.variable(''), DF.variable(''), DF.variable(''), DF.variable(''));\n    }\n  }\n  /**\n   * Get a first QPF search form.\n   * @param {{[p: string]: any}} metadata A metadata object.\n   * @return {ISearchForm} A search form, or null if none could be found.\n   */\n\n\n  getSearchForm(metadata) {\n    if (!metadata.searchForms || !metadata.searchForms.values) {\n      return;\n    } // Find a quad pattern or triple pattern search form\n\n\n    const {\n      searchForms\n    } = metadata; // TODO: in the future, a query-based search form getter should be used.\n\n    for (const searchForm of searchForms.values) {\n      if (this.graphUri && this.subjectUri in searchForm.mappings && this.predicateUri in searchForm.mappings && this.objectUri in searchForm.mappings && this.graphUri in searchForm.mappings && Object.keys(searchForm.mappings).length === 4) {\n        return searchForm;\n      }\n\n      if (this.subjectUri in searchForm.mappings && this.predicateUri in searchForm.mappings && this.objectUri in searchForm.mappings && Object.keys(searchForm.mappings).length === 3) {\n        return searchForm;\n      }\n    }\n  }\n  /**\n   * Create a QPF fragment IRI for the given quad pattern.\n   * @param {ISearchForm} searchForm A search form.\n   * @param {Term} subject A term.\n   * @param {Term} predicate A term.\n   * @param {Term} object A term.\n   * @param {Term} graph A term.\n   * @return {string} A URI.\n   */\n\n\n  createFragmentUri(searchForm, subject, predicate, object, graph) {\n    const entries = {};\n    const input = [{\n      uri: this.subjectUri,\n      term: subject\n    }, {\n      uri: this.predicateUri,\n      term: predicate\n    }, {\n      uri: this.objectUri,\n      term: object\n    }, {\n      uri: this.graphUri,\n      term: graph\n    }];\n\n    for (const entry of input) {\n      if (entry.uri && entry.term.termType !== 'Variable') {\n        entries[entry.uri] = rdf_string_1.termToString(entry.term);\n      }\n    }\n\n    return searchForm.getUri(entries);\n  }\n\n  match(subject, predicate, object, graph) {\n    // If we are querying the default graph,\n    // and the source has an overridden value for the default graph (such as QPF can provide),\n    // we override the graph parameter with that value.\n    let modifiedGraph = false;\n\n    if (this.defaultGraph && graph.termType === 'DefaultGraph') {\n      modifiedGraph = true;\n      graph = this.defaultGraph;\n    } // Try to emit from cache\n\n\n    const cached = this.getCachedQuads(subject, predicate, object, graph);\n\n    if (cached) {\n      return cached;\n    }\n\n    const quads = new asynciterator_1.TransformIterator(async () => {\n      let url = this.createFragmentUri(this.searchForm, subject, predicate, object, graph);\n      const rdfDereferenceOutput = await this.mediatorRdfDereference.mediate({\n        context: this.context,\n        url\n      });\n      url = rdfDereferenceOutput.url; // Determine the metadata and emit it\n\n      const rdfMetadataOuput = await this.mediatorMetadata.mediate({\n        context: this.context,\n        url,\n        quads: rdfDereferenceOutput.quads,\n        triples: rdfDereferenceOutput.triples\n      });\n      const metadataExtractPromise = this.mediatorMetadataExtract.mediate({\n        context: this.context,\n        url,\n        metadata: rdfMetadataOuput.metadata\n      }).then(({\n        metadata\n      }) => quads.setProperty('metadata', metadata)); // The server is free to send any data in its response (such as metadata),\n      // including quads that do not match the given matter.\n      // Therefore, we have to filter away all non-matching quads here.\n\n      const actualDefaultGraph = DF.defaultGraph();\n      let filteredOutput = asynciterator_1.wrap(rdfMetadataOuput.data).transform({\n        filter(quad) {\n          if (rdf_terms_1.matchPattern(quad, subject, predicate, object, graph)) {\n            return true;\n          } // Special case: if we are querying in the default graph, and we had an overridden default graph,\n          // also accept that incoming triples may be defined in the actual default graph\n\n\n          return modifiedGraph && rdf_terms_1.matchPattern(quad, subject, predicate, object, actualDefaultGraph);\n        }\n\n      });\n\n      if (modifiedGraph || graph.termType === 'Variable') {\n        // Reverse-map the overridden default graph back to the actual default graph\n        filteredOutput = this.reverseMapQuadsToDefaultGraph(filteredOutput);\n      } // Swallow error events, as they will be emitted in the metadata stream as well,\n      // and therefore thrown async next.\n\n\n      filteredOutput.on('error', () => {// Do nothing\n      }); // Ensures metadata event is emitted before end-event\n\n      await metadataExtractPromise;\n      return filteredOutput;\n    }, {\n      autoStart: false\n    });\n    this.cacheQuads(quads, subject, predicate, object, graph);\n    return this.getCachedQuads(subject, predicate, object, graph);\n  }\n\n  reverseMapQuadsToDefaultGraph(quads) {\n    const actualDefaultGraph = DF.defaultGraph();\n    return quads.map(quad => rdf_terms_1.mapTerms(quad, (term, key) => key === 'graph' && term.equals(this.defaultGraph) ? actualDefaultGraph : term));\n  }\n\n  getPatternId(subject, predicate, object, graph) {\n    return JSON.stringify({\n      s: subject.termType === 'Variable' ? '' : rdf_string_1.termToString(subject),\n      p: predicate.termType === 'Variable' ? '' : rdf_string_1.termToString(predicate),\n      o: object.termType === 'Variable' ? '' : rdf_string_1.termToString(object),\n      g: graph.termType === 'Variable' ? '' : rdf_string_1.termToString(graph)\n    });\n  }\n\n  cacheQuads(quads, subject, predicate, object, graph) {\n    const patternId = this.getPatternId(subject, predicate, object, graph);\n    this.cachedQuads[patternId] = quads.clone();\n  }\n\n  getCachedQuads(subject, predicate, object, graph) {\n    const patternId = this.getPatternId(subject, predicate, object, graph);\n    const quads = this.cachedQuads[patternId];\n\n    if (quads) {\n      return quads.clone();\n    }\n  }\n\n}\n\nexports.RdfSourceQpf = RdfSourceQpf;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-rdf-resolve-hypermedia-qpf/lib/RdfSourceQpf.js"],"names":["Object","defineProperty","exports","value","RdfSourceQpf","asynciterator_1","require","rdf_data_factory_1","rdf_string_1","rdf_terms_1","DF","DataFactory","constructor","mediatorMetadata","mediatorMetadataExtract","mediatorRdfDereference","subjectUri","predicateUri","objectUri","graphUri","metadata","context","initialQuads","cachedQuads","searchForm","getSearchForm","Error","defaultGraph","namedNode","undefined","wrappedQuads","wrap","reverseMapQuadsToDefaultGraph","setProperty","cacheQuads","variable","searchForms","values","mappings","keys","length","createFragmentUri","subject","predicate","object","graph","entries","input","uri","term","entry","termType","termToString","getUri","match","modifiedGraph","cached","getCachedQuads","quads","TransformIterator","url","rdfDereferenceOutput","mediate","rdfMetadataOuput","triples","metadataExtractPromise","then","actualDefaultGraph","filteredOutput","data","transform","filter","quad","matchPattern","on","autoStart","map","mapTerms","key","equals","getPatternId","JSON","stringify","s","p","o","g","patternId","clone"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RdfSourceQpf = void 0;\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst rdf_terms_1 = require(\"rdf-terms\");\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * An RDF source that executes a quad pattern over a QPF interface and fetches its first page.\n */\nclass RdfSourceQpf {\n    constructor(mediatorMetadata, mediatorMetadataExtract, mediatorRdfDereference, subjectUri, predicateUri, objectUri, graphUri, metadata, context, initialQuads) {\n        this.mediatorMetadata = mediatorMetadata;\n        this.mediatorMetadataExtract = mediatorMetadataExtract;\n        this.mediatorRdfDereference = mediatorRdfDereference;\n        this.subjectUri = subjectUri;\n        this.predicateUri = predicateUri;\n        this.objectUri = objectUri;\n        this.graphUri = graphUri;\n        this.context = context;\n        this.cachedQuads = {};\n        const searchForm = this.getSearchForm(metadata);\n        if (!searchForm) {\n            throw new Error('Illegal state: found no TPF/QPF search form anymore in metadata.');\n        }\n        this.searchForm = searchForm;\n        this.defaultGraph = metadata.defaultGraph ? DF.namedNode(metadata.defaultGraph) : undefined;\n        if (initialQuads) {\n            let wrappedQuads = asynciterator_1.wrap(initialQuads);\n            if (this.defaultGraph) {\n                wrappedQuads = this.reverseMapQuadsToDefaultGraph(wrappedQuads);\n            }\n            wrappedQuads.setProperty('metadata', metadata);\n            this.cacheQuads(wrappedQuads, DF.variable(''), DF.variable(''), DF.variable(''), DF.variable(''));\n        }\n    }\n    /**\n     * Get a first QPF search form.\n     * @param {{[p: string]: any}} metadata A metadata object.\n     * @return {ISearchForm} A search form, or null if none could be found.\n     */\n    getSearchForm(metadata) {\n        if (!metadata.searchForms || !metadata.searchForms.values) {\n            return;\n        }\n        // Find a quad pattern or triple pattern search form\n        const { searchForms } = metadata;\n        // TODO: in the future, a query-based search form getter should be used.\n        for (const searchForm of searchForms.values) {\n            if (this.graphUri &&\n                this.subjectUri in searchForm.mappings &&\n                this.predicateUri in searchForm.mappings &&\n                this.objectUri in searchForm.mappings &&\n                this.graphUri in searchForm.mappings &&\n                Object.keys(searchForm.mappings).length === 4) {\n                return searchForm;\n            }\n            if (this.subjectUri in searchForm.mappings &&\n                this.predicateUri in searchForm.mappings &&\n                this.objectUri in searchForm.mappings &&\n                Object.keys(searchForm.mappings).length === 3) {\n                return searchForm;\n            }\n        }\n    }\n    /**\n     * Create a QPF fragment IRI for the given quad pattern.\n     * @param {ISearchForm} searchForm A search form.\n     * @param {Term} subject A term.\n     * @param {Term} predicate A term.\n     * @param {Term} object A term.\n     * @param {Term} graph A term.\n     * @return {string} A URI.\n     */\n    createFragmentUri(searchForm, subject, predicate, object, graph) {\n        const entries = {};\n        const input = [\n            { uri: this.subjectUri, term: subject },\n            { uri: this.predicateUri, term: predicate },\n            { uri: this.objectUri, term: object },\n            { uri: this.graphUri, term: graph },\n        ];\n        for (const entry of input) {\n            if (entry.uri && entry.term.termType !== 'Variable') {\n                entries[entry.uri] = rdf_string_1.termToString(entry.term);\n            }\n        }\n        return searchForm.getUri(entries);\n    }\n    match(subject, predicate, object, graph) {\n        // If we are querying the default graph,\n        // and the source has an overridden value for the default graph (such as QPF can provide),\n        // we override the graph parameter with that value.\n        let modifiedGraph = false;\n        if (this.defaultGraph && graph.termType === 'DefaultGraph') {\n            modifiedGraph = true;\n            graph = this.defaultGraph;\n        }\n        // Try to emit from cache\n        const cached = this.getCachedQuads(subject, predicate, object, graph);\n        if (cached) {\n            return cached;\n        }\n        const quads = new asynciterator_1.TransformIterator(async () => {\n            let url = this.createFragmentUri(this.searchForm, subject, predicate, object, graph);\n            const rdfDereferenceOutput = await this.mediatorRdfDereference.mediate({ context: this.context, url });\n            url = rdfDereferenceOutput.url;\n            // Determine the metadata and emit it\n            const rdfMetadataOuput = await this.mediatorMetadata.mediate({ context: this.context, url, quads: rdfDereferenceOutput.quads, triples: rdfDereferenceOutput.triples });\n            const metadataExtractPromise = this.mediatorMetadataExtract\n                .mediate({ context: this.context, url, metadata: rdfMetadataOuput.metadata })\n                .then(({ metadata }) => quads.setProperty('metadata', metadata));\n            // The server is free to send any data in its response (such as metadata),\n            // including quads that do not match the given matter.\n            // Therefore, we have to filter away all non-matching quads here.\n            const actualDefaultGraph = DF.defaultGraph();\n            let filteredOutput = asynciterator_1.wrap(rdfMetadataOuput.data)\n                .transform({\n                filter(quad) {\n                    if (rdf_terms_1.matchPattern(quad, subject, predicate, object, graph)) {\n                        return true;\n                    }\n                    // Special case: if we are querying in the default graph, and we had an overridden default graph,\n                    // also accept that incoming triples may be defined in the actual default graph\n                    return modifiedGraph && rdf_terms_1.matchPattern(quad, subject, predicate, object, actualDefaultGraph);\n                },\n            });\n            if (modifiedGraph || graph.termType === 'Variable') {\n                // Reverse-map the overridden default graph back to the actual default graph\n                filteredOutput = this.reverseMapQuadsToDefaultGraph(filteredOutput);\n            }\n            // Swallow error events, as they will be emitted in the metadata stream as well,\n            // and therefore thrown async next.\n            filteredOutput.on('error', () => {\n                // Do nothing\n            });\n            // Ensures metadata event is emitted before end-event\n            await metadataExtractPromise;\n            return filteredOutput;\n        }, { autoStart: false });\n        this.cacheQuads(quads, subject, predicate, object, graph);\n        return this.getCachedQuads(subject, predicate, object, graph);\n    }\n    reverseMapQuadsToDefaultGraph(quads) {\n        const actualDefaultGraph = DF.defaultGraph();\n        return quads.map(quad => rdf_terms_1.mapTerms(quad, (term, key) => key === 'graph' && term.equals(this.defaultGraph) ? actualDefaultGraph : term));\n    }\n    getPatternId(subject, predicate, object, graph) {\n        return JSON.stringify({\n            s: subject.termType === 'Variable' ? '' : rdf_string_1.termToString(subject),\n            p: predicate.termType === 'Variable' ? '' : rdf_string_1.termToString(predicate),\n            o: object.termType === 'Variable' ? '' : rdf_string_1.termToString(object),\n            g: graph.termType === 'Variable' ? '' : rdf_string_1.termToString(graph),\n        });\n    }\n    cacheQuads(quads, subject, predicate, object, graph) {\n        const patternId = this.getPatternId(subject, predicate, object, graph);\n        this.cachedQuads[patternId] = quads.clone();\n    }\n    getCachedQuads(subject, predicate, object, graph) {\n        const patternId = this.getPatternId(subject, predicate, object, graph);\n        const quads = this.cachedQuads[patternId];\n        if (quads) {\n            return quads.clone();\n        }\n    }\n}\nexports.RdfSourceQpf = RdfSourceQpf;\n//# sourceMappingURL=RdfSourceQpf.js.map"]},"metadata":{},"sourceType":"script"}