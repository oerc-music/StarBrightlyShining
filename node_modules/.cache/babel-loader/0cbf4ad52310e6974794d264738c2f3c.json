{"ast":null,"code":"import auth from 'solid-auth-client';\nimport ldflex from '@solid/query-ldflex'; // Wildcard for tracking all resources\n\nconst ALL = '*'; // Subscribers per resource URL\n\nconst subscribers = {}; // WebSockets per host\n\nconst webSockets = {}; // All fetched URLs\n\nconst fetchedUrls = new Set();\n/**\n * Notifies a subscriber of updates to resources on a Solid server,\n * by listening to its WebSockets.\n */\n\nexport default class UpdateTracker {\n  /** Create a tracker that sends updates to the given subscriber function. */\n  constructor(subscriber) {\n    this.subscriber = subscriber;\n  }\n  /** Subscribes to changes in the given resources */\n\n\n  async subscribe(...urls) {\n    for (let url of urls) {\n      // Create a new subscription to the resource if none existed\n      url = url.replace(/#.*/, '');\n\n      if (!(url in subscribers)) {\n        subscribers[url] = new Set();\n        const tracked = url !== ALL ? [url] : [...fetchedUrls];\n        await Promise.all(tracked.map(trackResource));\n      } // Add the new subscriber\n\n\n      subscribers[url].add(this.subscriber);\n    }\n  }\n  /** Unsubscribes to changes in the given resources */\n\n\n  async unsubscribe(...urls) {\n    for (let url of urls) {\n      url = url.replace(/#.*/, '');\n      if (url in subscribers) subscribers[url].delete(this.subscriber);\n    }\n  }\n\n}\n/** Tracks updates to the given resource */\n\nasync function trackResource(url, options) {\n  // Obtain a WebSocket for the given host\n  const {\n    host\n  } = new URL(url);\n\n  if (!(host in webSockets)) {\n    webSockets[host] = Promise.resolve(null).then(() => createWebSocket(url, {\n      host,\n      ...options\n    }));\n  }\n\n  const webSocket = await webSockets[host]; // Track subscribed resources to resubscribe later if needed\n\n  webSocket.resources.add(url); // Subscribe to updates on the resource\n\n  webSocket.enqueue(`sub ${url}`);\n}\n/** Creates a WebSocket for the given URL. */\n\n\nasync function createWebSocket(resourceUrl, options = {}) {\n  const webSocketUrl = await getWebSocketUrl(resourceUrl);\n  const webSocket = new WebSocket(webSocketUrl);\n  return Object.assign(webSocket, {\n    resources: new Set(),\n    reconnectionAttempts: 0,\n    reconnectionDelay: 1000,\n    enqueue,\n    onmessage: processMessage,\n    onclose: reconnect,\n    ready: new Promise(resolve => {\n      webSocket.onopen = () => {\n        webSocket.reconnectionAttempts = 0;\n        webSocket.reconnectionDelay = 1000;\n        resolve();\n      };\n    })\n  }, options);\n}\n/** Retrieves the WebSocket URL for the given resource. */\n\n\nasync function getWebSocketUrl(resourceUrl) {\n  const response = await auth.fetch(resourceUrl);\n  const webSocketUrl = response.headers.get('Updates-Via');\n  if (!webSocketUrl) throw new Error(`No WebSocket found for ${resourceUrl}`);\n  return webSocketUrl;\n}\n/** Enqueues data on the WebSocket */\n\n\nasync function enqueue(data) {\n  await this.ready;\n  this.send(data);\n}\n/** Processes an update message from the WebSocket */\n\n\nfunction processMessage({\n  data\n}) {\n  // Verify the message is an update notification\n  const match = /^pub +(.+)/.exec(data);\n  if (!match) return; // Invalidate the cache for the resource\n\n  const url = match[1];\n  ldflex.clearCache(url); // Notify the subscribers\n\n  const update = {\n    timestamp: new Date(),\n    url\n  };\n\n  for (const subscriber of subscribers[url] || []) subscriber(update);\n\n  for (const subscriber of subscribers[ALL] || []) subscriber(update);\n}\n/** Reconnects a socket after a backoff delay */\n\n\nasync function reconnect() {\n  // Ensure this socket is no longer marked as active\n  delete webSockets[this.host]; // Try setting up a new socket\n\n  if (this.reconnectionAttempts < 6) {\n    // Wait a given backoff period before reconnecting\n    await new Promise(done => setTimeout(done, this.reconnectionDelay)); // Try reconnecting, and back off exponentially\n\n    await Promise.all([...this.resources].map(url => trackResource(url, {\n      reconnectionAttempts: this.reconnectionAttempts + 1,\n      reconnectionDelay: this.reconnectionDelay * 2\n    })));\n  }\n}\n/** Closes all sockets */\n\n\nexport async function resetWebSockets() {\n  for (const url in subscribers) delete subscribers[url];\n\n  for (const host in webSockets) {\n    const socket = await webSockets[host];\n    delete webSockets[host];\n    delete socket.onclose;\n    socket.close();\n  }\n\n  fetchedUrls.clear();\n} // Keep track of all fetched resources\n\nauth.on('request', url => {\n  if (!fetchedUrls.has(url)) {\n    if (ALL in subscribers) trackResource(url);\n    fetchedUrls.add(url);\n  }\n});","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@solid/react/module/UpdateTracker.js"],"names":["auth","ldflex","ALL","subscribers","webSockets","fetchedUrls","Set","UpdateTracker","constructor","subscriber","subscribe","urls","url","replace","tracked","Promise","all","map","trackResource","add","unsubscribe","delete","options","host","URL","resolve","then","createWebSocket","webSocket","resources","enqueue","resourceUrl","webSocketUrl","getWebSocketUrl","WebSocket","Object","assign","reconnectionAttempts","reconnectionDelay","onmessage","processMessage","onclose","reconnect","ready","onopen","response","fetch","headers","get","Error","data","send","match","exec","clearCache","update","timestamp","Date","done","setTimeout","resetWebSockets","socket","close","clear","on","has"],"mappings":"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","sourcesContent":["import auth from 'solid-auth-client';\nimport ldflex from '@solid/query-ldflex'; // Wildcard for tracking all resources\n\nconst ALL = '*'; // Subscribers per resource URL\n\nconst subscribers = {}; // WebSockets per host\n\nconst webSockets = {}; // All fetched URLs\n\nconst fetchedUrls = new Set();\n/**\n * Notifies a subscriber of updates to resources on a Solid server,\n * by listening to its WebSockets.\n */\n\nexport default class UpdateTracker {\n  /** Create a tracker that sends updates to the given subscriber function. */\n  constructor(subscriber) {\n    this.subscriber = subscriber;\n  }\n  /** Subscribes to changes in the given resources */\n\n\n  async subscribe(...urls) {\n    for (let url of urls) {\n      // Create a new subscription to the resource if none existed\n      url = url.replace(/#.*/, '');\n\n      if (!(url in subscribers)) {\n        subscribers[url] = new Set();\n        const tracked = url !== ALL ? [url] : [...fetchedUrls];\n        await Promise.all(tracked.map(trackResource));\n      } // Add the new subscriber\n\n\n      subscribers[url].add(this.subscriber);\n    }\n  }\n  /** Unsubscribes to changes in the given resources */\n\n\n  async unsubscribe(...urls) {\n    for (let url of urls) {\n      url = url.replace(/#.*/, '');\n      if (url in subscribers) subscribers[url].delete(this.subscriber);\n    }\n  }\n\n}\n/** Tracks updates to the given resource */\n\nasync function trackResource(url, options) {\n  // Obtain a WebSocket for the given host\n  const {\n    host\n  } = new URL(url);\n\n  if (!(host in webSockets)) {\n    webSockets[host] = Promise.resolve(null).then(() => createWebSocket(url, {\n      host,\n      ...options\n    }));\n  }\n\n  const webSocket = await webSockets[host]; // Track subscribed resources to resubscribe later if needed\n\n  webSocket.resources.add(url); // Subscribe to updates on the resource\n\n  webSocket.enqueue(`sub ${url}`);\n}\n/** Creates a WebSocket for the given URL. */\n\n\nasync function createWebSocket(resourceUrl, options = {}) {\n  const webSocketUrl = await getWebSocketUrl(resourceUrl);\n  const webSocket = new WebSocket(webSocketUrl);\n  return Object.assign(webSocket, {\n    resources: new Set(),\n    reconnectionAttempts: 0,\n    reconnectionDelay: 1000,\n    enqueue,\n    onmessage: processMessage,\n    onclose: reconnect,\n    ready: new Promise(resolve => {\n      webSocket.onopen = () => {\n        webSocket.reconnectionAttempts = 0;\n        webSocket.reconnectionDelay = 1000;\n        resolve();\n      };\n    })\n  }, options);\n}\n/** Retrieves the WebSocket URL for the given resource. */\n\n\nasync function getWebSocketUrl(resourceUrl) {\n  const response = await auth.fetch(resourceUrl);\n  const webSocketUrl = response.headers.get('Updates-Via');\n  if (!webSocketUrl) throw new Error(`No WebSocket found for ${resourceUrl}`);\n  return webSocketUrl;\n}\n/** Enqueues data on the WebSocket */\n\n\nasync function enqueue(data) {\n  await this.ready;\n  this.send(data);\n}\n/** Processes an update message from the WebSocket */\n\n\nfunction processMessage({\n  data\n}) {\n  // Verify the message is an update notification\n  const match = /^pub +(.+)/.exec(data);\n  if (!match) return; // Invalidate the cache for the resource\n\n  const url = match[1];\n  ldflex.clearCache(url); // Notify the subscribers\n\n  const update = {\n    timestamp: new Date(),\n    url\n  };\n\n  for (const subscriber of subscribers[url] || []) subscriber(update);\n\n  for (const subscriber of subscribers[ALL] || []) subscriber(update);\n}\n/** Reconnects a socket after a backoff delay */\n\n\nasync function reconnect() {\n  // Ensure this socket is no longer marked as active\n  delete webSockets[this.host]; // Try setting up a new socket\n\n  if (this.reconnectionAttempts < 6) {\n    // Wait a given backoff period before reconnecting\n    await new Promise(done => setTimeout(done, this.reconnectionDelay)); // Try reconnecting, and back off exponentially\n\n    await Promise.all([...this.resources].map(url => trackResource(url, {\n      reconnectionAttempts: this.reconnectionAttempts + 1,\n      reconnectionDelay: this.reconnectionDelay * 2\n    })));\n  }\n}\n/** Closes all sockets */\n\n\nexport async function resetWebSockets() {\n  for (const url in subscribers) delete subscribers[url];\n\n  for (const host in webSockets) {\n    const socket = await webSockets[host];\n    delete webSockets[host];\n    delete socket.onclose;\n    socket.close();\n  }\n\n  fetchedUrls.clear();\n} // Keep track of all fetched resources\n\nauth.on('request', url => {\n  if (!fetchedUrls.has(url)) {\n    if (ALL in subscribers) trackResource(url);\n    fetchedUrls.add(url);\n  }\n});"]},"metadata":{},"sourceType":"module"}