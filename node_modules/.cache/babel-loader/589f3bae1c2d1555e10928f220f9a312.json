{"ast":null,"code":"import { namedNode } from '@rdfjs/data-model';\nconst NEEDS_ESCAPE = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n      ESCAPE_ALL = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n      ESCAPED_CHARS = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n};\n/**\n * Expresses a path or mutation as a SPARQL query.\n *\n * Requires:\n * - a mutationExpressions or pathExpression property on the path proxy\n */\n\nexport default class SparqlHandler {\n  async handle(pathData, path) {\n    // First check if we have a mutation expression\n    const mutationExpressions = await path.mutationExpressions;\n    if (Array.isArray(mutationExpressions) && mutationExpressions.length) // Remove empty results to prevent dangling semicolons\n      return mutationExpressions.map(e => this.mutationExpressionToQuery(e)).filter(Boolean).join('\\n;\\n'); // Otherwise, fall back to checking for a path expression\n\n    const pathExpression = await path.pathExpression;\n    if (!Array.isArray(pathExpression)) throw new Error(`${pathData} has no pathExpression property`);\n    return this.pathExpressionToQuery(pathData, path, pathExpression);\n  }\n\n  pathExpressionToQuery(pathData, path, pathExpression) {\n    if (pathExpression.length < 2 && !pathData.finalClause) throw new Error(`${pathData} should at least contain a subject and a predicate`); // Create triple patterns\n\n    let queryVar = '?subject',\n        sorts = [],\n        clauses = [];\n\n    if (pathExpression.length > 1) {\n      queryVar = this.createVar(pathData.property);\n      ({\n        queryVar,\n        sorts,\n        clauses\n      } = this.expressionToTriplePatterns(pathExpression, queryVar));\n    }\n\n    if (pathData.finalClause) clauses.push(pathData.finalClause(queryVar)); // Create SPARQL query body\n\n    const distinct = pathData.distinct ? 'DISTINCT ' : '';\n    const select = `SELECT ${distinct}${pathData.select ? pathData.select : queryVar}`;\n    const where = ` WHERE {\\n  ${clauses.join('\\n  ')}\\n}`;\n    const orderClauses = sorts.map(({\n      order,\n      variable\n    }) => `${order}(${variable})`);\n    const orderBy = orderClauses.length === 0 ? '' : `\\nORDER BY ${orderClauses.join(' ')}`;\n    return `${select}${where}${orderBy}`;\n  }\n\n  mutationExpressionToQuery({\n    mutationType,\n    conditions,\n    predicateObjects\n  }) {\n    // If there are no mutations, there is no query\n    if (!mutationType || !conditions || predicateObjects && predicateObjects.length === 0) return ''; // Create the WHERE clauses\n\n    const scope = {};\n    let subject, where; // If the only condition is a subject, we need no WHERE clause\n\n    if (conditions.length === 1) {\n      subject = this.termToString(conditions[0].subject);\n      where = [];\n    } // Otherwise, create a WHERE clause from all conditions\n    else {\n      const lastPredicate = conditions[conditions.length - 1].predicate;\n      subject = this.createVar(lastPredicate.value, scope);\n      ({\n        queryVar: subject,\n        clauses: where\n      } = this.expressionToTriplePatterns(conditions, subject, scope));\n    } // Create the mutation clauses\n\n\n    const mutations = [];\n\n    for (const {\n      predicate,\n      reverse,\n      objects\n    } of predicateObjects) {\n      // Mutate either only the specified objects, or all of them\n      const objectStrings = objects ? objects.map(o => this.termToString(o)) : [this.createVar(predicate.value, scope)]; // Generate a triple pattern for all subjects\n\n      mutations.push(...this.triplePatterns(subject, predicate, objectStrings, reverse));\n    }\n\n    const mutationClauses = `{\\n  ${mutations.join('\\n  ')}\\n}`; // Join clauses into a SPARQL query\n\n    return where.length === 0 ? // If there are no WHERE clauses, just mutate raw data\n    `${mutationType} DATA ${mutationClauses}` : // Otherwise, return a DELETE/INSERT ... WHERE ... query\n    `${mutationType} ${mutationClauses} WHERE {\\n  ${where.join('\\n  ')}\\n}`;\n  }\n\n  expressionToTriplePatterns([root, ...pathExpression], lastVar, scope = {}) {\n    const lastIndex = pathExpression.length - 1;\n    const clauses = [];\n    const sorts = [];\n    let object = this.termToString(skolemize(root.subject));\n    let queryVar = object;\n    let allowValues = false;\n    pathExpression.forEach((segment, index) => {\n      // Obtain components and generate triple pattern\n      const subject = object;\n      const {\n        predicate,\n        reverse,\n        sort,\n        values\n      } = segment; // Use fixed object values values if they were specified\n\n      let objects;\n\n      if (values && values.length > 0) {\n        if (!allowValues) throw new Error('Specifying fixed values is not allowed here');\n        objects = values.map(this.termToString);\n        allowValues = false; // disallow subsequent fixed values for this predicate\n      } // Otherwise, use a variable subject\n      else {\n        object = index < lastIndex ? this.createVar(`v${index}`, scope) : lastVar;\n        objects = [object];\n        allowValues = true;\n      }\n\n      clauses.push(...this.triplePatterns(subject, predicate, objects, reverse)); // If the sort option was not set, use this object as a query variable\n\n      if (!sort) {\n        queryVar = object;\n      } // If sort was set, use this object as a sorting variable\n      else {\n        // TODO: handle when an object is used for sorting, and later also for querying\n        sorts.push({\n          variable: object,\n          order: sort\n        }); // TODO: use a descriptive lastVar in case of sorting\n\n        object = queryVar;\n      }\n    });\n    return {\n      queryVar,\n      sorts,\n      clauses\n    };\n  } // Creates a unique query variable within the given scope, based on the suggestion\n\n\n  createVar(suggestion = '', scope) {\n    let counter = 0;\n    let label = `?${suggestion.match(/[a-z0-9]*$/i)[0] || 'result'}`;\n\n    if (scope) {\n      suggestion = label;\n\n      while (scope[label]) label = `${suggestion}_${counter++}`;\n\n      scope[label] = true;\n    }\n\n    return label;\n  } // Converts an RDFJS term to a string that we can use in a query\n\n\n  termToString(term) {\n    // Determine escaped value\n    let {\n      value\n    } = term;\n    if (NEEDS_ESCAPE.test(value)) value = value.replace(ESCAPE_ALL, escapeCharacter);\n\n    switch (term.termType) {\n      case 'NamedNode':\n        return `<${value}>`;\n\n      case 'BlankNode':\n        return `_:${value}`;\n\n      case 'Literal':\n        // Determine optional language or datatype\n        let suffix = '';\n        if (term.language) suffix = `@${term.language}`;else if (term.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string') suffix = `^^<${term.datatype.value}>`;\n        return `\"${value}\"${suffix}`;\n\n      default:\n        throw new Error(`Could not convert a term of type ${term.termType}`);\n    }\n  } // Creates triple patterns for the given subject, predicate, and objects\n\n\n  triplePatterns(subjectString, predicateTerm, objectStrings, reverse = false) {\n    let subjectStrings = [subjectString];\n    if (reverse) [subjectStrings, objectStrings] = [objectStrings, subjectStrings];\n    const objects = objectStrings.join(', ');\n    const predicate = predicateTerm.termType === 'path' ? predicateTerm.value : `<${predicateTerm.value}>`;\n    return subjectStrings.map(s => `${s} ${predicate} ${objects}.`);\n  }\n\n} // Replaces a character by its escaped version\n// (borrowed from https://www.npmjs.com/package/n3)\n\nfunction escapeCharacter(character) {\n  // Replace a single character by its escaped version\n  let result = ESCAPED_CHARS[character];\n\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    } // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n      result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n      result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n    }\n  }\n\n  return result;\n} // Skolemizes the given term if it is a blank node\n\n\nlet skolemId = 0;\n\nfunction skolemize(term) {\n  if (term.termType !== 'BlankNode') return term;\n  if (!term.skolemized) term.skolemized = namedNode(`urn:ldflex:sk${skolemId++}`);\n  return term.skolemized;\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/SparqlHandler.js"],"names":["namedNode","NEEDS_ESCAPE","ESCAPE_ALL","ESCAPED_CHARS","SparqlHandler","handle","pathData","path","mutationExpressions","Array","isArray","length","map","e","mutationExpressionToQuery","filter","Boolean","join","pathExpression","Error","pathExpressionToQuery","finalClause","queryVar","sorts","clauses","createVar","property","expressionToTriplePatterns","push","distinct","select","where","orderClauses","order","variable","orderBy","mutationType","conditions","predicateObjects","scope","subject","termToString","lastPredicate","predicate","value","mutations","reverse","objects","objectStrings","o","triplePatterns","mutationClauses","root","lastVar","lastIndex","object","skolemize","allowValues","forEach","segment","index","sort","values","suggestion","counter","label","match","term","test","replace","escapeCharacter","termType","suffix","language","datatype","subjectString","predicateTerm","subjectStrings","s","character","result","undefined","charCodeAt","toString","substr","skolemId","skolemized"],"mappings":"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","sourcesContent":["import { namedNode } from '@rdfjs/data-model';\nconst NEEDS_ESCAPE = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n      ESCAPE_ALL = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n      ESCAPED_CHARS = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n};\n/**\n * Expresses a path or mutation as a SPARQL query.\n *\n * Requires:\n * - a mutationExpressions or pathExpression property on the path proxy\n */\n\nexport default class SparqlHandler {\n  async handle(pathData, path) {\n    // First check if we have a mutation expression\n    const mutationExpressions = await path.mutationExpressions;\n    if (Array.isArray(mutationExpressions) && mutationExpressions.length) // Remove empty results to prevent dangling semicolons\n      return mutationExpressions.map(e => this.mutationExpressionToQuery(e)).filter(Boolean).join('\\n;\\n'); // Otherwise, fall back to checking for a path expression\n\n    const pathExpression = await path.pathExpression;\n    if (!Array.isArray(pathExpression)) throw new Error(`${pathData} has no pathExpression property`);\n    return this.pathExpressionToQuery(pathData, path, pathExpression);\n  }\n\n  pathExpressionToQuery(pathData, path, pathExpression) {\n    if (pathExpression.length < 2 && !pathData.finalClause) throw new Error(`${pathData} should at least contain a subject and a predicate`); // Create triple patterns\n\n    let queryVar = '?subject',\n        sorts = [],\n        clauses = [];\n\n    if (pathExpression.length > 1) {\n      queryVar = this.createVar(pathData.property);\n      ({\n        queryVar,\n        sorts,\n        clauses\n      } = this.expressionToTriplePatterns(pathExpression, queryVar));\n    }\n\n    if (pathData.finalClause) clauses.push(pathData.finalClause(queryVar)); // Create SPARQL query body\n\n    const distinct = pathData.distinct ? 'DISTINCT ' : '';\n    const select = `SELECT ${distinct}${pathData.select ? pathData.select : queryVar}`;\n    const where = ` WHERE {\\n  ${clauses.join('\\n  ')}\\n}`;\n    const orderClauses = sorts.map(({\n      order,\n      variable\n    }) => `${order}(${variable})`);\n    const orderBy = orderClauses.length === 0 ? '' : `\\nORDER BY ${orderClauses.join(' ')}`;\n    return `${select}${where}${orderBy}`;\n  }\n\n  mutationExpressionToQuery({\n    mutationType,\n    conditions,\n    predicateObjects\n  }) {\n    // If there are no mutations, there is no query\n    if (!mutationType || !conditions || predicateObjects && predicateObjects.length === 0) return ''; // Create the WHERE clauses\n\n    const scope = {};\n    let subject, where; // If the only condition is a subject, we need no WHERE clause\n\n    if (conditions.length === 1) {\n      subject = this.termToString(conditions[0].subject);\n      where = [];\n    } // Otherwise, create a WHERE clause from all conditions\n    else {\n        const lastPredicate = conditions[conditions.length - 1].predicate;\n        subject = this.createVar(lastPredicate.value, scope);\n        ({\n          queryVar: subject,\n          clauses: where\n        } = this.expressionToTriplePatterns(conditions, subject, scope));\n      } // Create the mutation clauses\n\n\n    const mutations = [];\n\n    for (const {\n      predicate,\n      reverse,\n      objects\n    } of predicateObjects) {\n      // Mutate either only the specified objects, or all of them\n      const objectStrings = objects ? objects.map(o => this.termToString(o)) : [this.createVar(predicate.value, scope)]; // Generate a triple pattern for all subjects\n\n      mutations.push(...this.triplePatterns(subject, predicate, objectStrings, reverse));\n    }\n\n    const mutationClauses = `{\\n  ${mutations.join('\\n  ')}\\n}`; // Join clauses into a SPARQL query\n\n    return where.length === 0 ? // If there are no WHERE clauses, just mutate raw data\n    `${mutationType} DATA ${mutationClauses}` : // Otherwise, return a DELETE/INSERT ... WHERE ... query\n    `${mutationType} ${mutationClauses} WHERE {\\n  ${where.join('\\n  ')}\\n}`;\n  }\n\n  expressionToTriplePatterns([root, ...pathExpression], lastVar, scope = {}) {\n    const lastIndex = pathExpression.length - 1;\n    const clauses = [];\n    const sorts = [];\n    let object = this.termToString(skolemize(root.subject));\n    let queryVar = object;\n    let allowValues = false;\n    pathExpression.forEach((segment, index) => {\n      // Obtain components and generate triple pattern\n      const subject = object;\n      const {\n        predicate,\n        reverse,\n        sort,\n        values\n      } = segment; // Use fixed object values values if they were specified\n\n      let objects;\n\n      if (values && values.length > 0) {\n        if (!allowValues) throw new Error('Specifying fixed values is not allowed here');\n        objects = values.map(this.termToString);\n        allowValues = false; // disallow subsequent fixed values for this predicate\n      } // Otherwise, use a variable subject\n      else {\n          object = index < lastIndex ? this.createVar(`v${index}`, scope) : lastVar;\n          objects = [object];\n          allowValues = true;\n        }\n\n      clauses.push(...this.triplePatterns(subject, predicate, objects, reverse)); // If the sort option was not set, use this object as a query variable\n\n      if (!sort) {\n        queryVar = object;\n      } // If sort was set, use this object as a sorting variable\n      else {\n          // TODO: handle when an object is used for sorting, and later also for querying\n          sorts.push({\n            variable: object,\n            order: sort\n          }); // TODO: use a descriptive lastVar in case of sorting\n\n          object = queryVar;\n        }\n    });\n    return {\n      queryVar,\n      sorts,\n      clauses\n    };\n  } // Creates a unique query variable within the given scope, based on the suggestion\n\n\n  createVar(suggestion = '', scope) {\n    let counter = 0;\n    let label = `?${suggestion.match(/[a-z0-9]*$/i)[0] || 'result'}`;\n\n    if (scope) {\n      suggestion = label;\n\n      while (scope[label]) label = `${suggestion}_${counter++}`;\n\n      scope[label] = true;\n    }\n\n    return label;\n  } // Converts an RDFJS term to a string that we can use in a query\n\n\n  termToString(term) {\n    // Determine escaped value\n    let {\n      value\n    } = term;\n    if (NEEDS_ESCAPE.test(value)) value = value.replace(ESCAPE_ALL, escapeCharacter);\n\n    switch (term.termType) {\n      case 'NamedNode':\n        return `<${value}>`;\n\n      case 'BlankNode':\n        return `_:${value}`;\n\n      case 'Literal':\n        // Determine optional language or datatype\n        let suffix = '';\n        if (term.language) suffix = `@${term.language}`;else if (term.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string') suffix = `^^<${term.datatype.value}>`;\n        return `\"${value}\"${suffix}`;\n\n      default:\n        throw new Error(`Could not convert a term of type ${term.termType}`);\n    }\n  } // Creates triple patterns for the given subject, predicate, and objects\n\n\n  triplePatterns(subjectString, predicateTerm, objectStrings, reverse = false) {\n    let subjectStrings = [subjectString];\n    if (reverse) [subjectStrings, objectStrings] = [objectStrings, subjectStrings];\n    const objects = objectStrings.join(', ');\n    const predicate = predicateTerm.termType === 'path' ? predicateTerm.value : `<${predicateTerm.value}>`;\n    return subjectStrings.map(s => `${s} ${predicate} ${objects}.`);\n  }\n\n} // Replaces a character by its escaped version\n// (borrowed from https://www.npmjs.com/package/n3)\n\nfunction escapeCharacter(character) {\n  // Replace a single character by its escaped version\n  let result = ESCAPED_CHARS[character];\n\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    } // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n        result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n        result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n      }\n  }\n\n  return result;\n} // Skolemizes the given term if it is a blank node\n\n\nlet skolemId = 0;\n\nfunction skolemize(term) {\n  if (term.termType !== 'BlankNode') return term;\n  if (!term.skolemized) term.skolemized = namedNode(`urn:ldflex:sk${skolemId++}`);\n  return term.skolemized;\n}"]},"metadata":{},"sourceType":"module"}