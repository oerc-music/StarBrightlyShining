{"ast":null,"code":"import { isPlainObject, isAsyncIterable } from './valueUtils';\nimport { iterableToArray } from './iterableUtils';\n/**\n * Returns a function that requests the values of multiple properties.\n * You can use this function to access properties as follows:\n * - fn() returns []\n * - fn(p1) returns [path[p1]]\n * - fn(p1, p2) returns [path[p1], path[p2]]\n * - fn([p1, p2]) returns [path[p1], path[p2]]\n * - fn(asyncIterable) returns [path[p1], path[p2]]\n * - fn({ p1: null, p2: null }) returns { p1: path[p1], p2: path[p2] }\n * Combinations of the above are possible by passing them in arrays.\n */\n\nexport default class GetFunctionHandler {\n  handle(pathData, path) {\n    return (...args) => this.readProperties(path, args.length === 1 ? args[0] : args, true);\n  }\n\n  async readProperties(path, properties, wrapSingleValues = false) {\n    // Convert an async iterable to an array\n    if (isAsyncIterable(properties)) properties = await iterableToArray(properties); // If passed an array, read every property\n\n    if (Array.isArray(properties)) {\n      const values = properties.map(p => this.readProperties(path, p));\n      return Promise.all(values);\n    } // If passed an object with property names as keys,\n    // return an object with the values filled in\n\n\n    if (isPlainObject(properties)) {\n      // Use the key as property value if none is specified\n      const keys = Object.keys(properties);\n      properties = keys.map(key => properties[key] || key); // Store the resolved properties by key\n\n      const results = {};\n      const values = await this.readProperties(path, properties);\n\n      for (let i = 0; i < keys.length; i++) results[keys[i]] = values[i];\n\n      return results;\n    } // Otherwise, perform a single property access\n\n\n    const value = path[properties];\n    return wrapSingleValues ? [value] : value;\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/GetFunctionHandler.js"],"names":["isPlainObject","isAsyncIterable","iterableToArray","GetFunctionHandler","handle","pathData","path","args","readProperties","length","properties","wrapSingleValues","Array","isArray","values","map","p","Promise","all","keys","Object","key","results","i","value"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,eAAxB,QAA+C,cAA/C;AACA,SAASC,eAAT,QAAgC,iBAAhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,MAAMC,kBAAN,CAAyB;AACtCC,EAAAA,MAAM,CAACC,QAAD,EAAWC,IAAX,EAAiB;AACrB,WAAO,CAAC,GAAGC,IAAJ,KAAa,KAAKC,cAAL,CAAoBF,IAApB,EAA0BC,IAAI,CAACE,MAAL,KAAgB,CAAhB,GAAoBF,IAAI,CAAC,CAAD,CAAxB,GAA8BA,IAAxD,EAA8D,IAA9D,CAApB;AACD;;AAEmB,QAAdC,cAAc,CAACF,IAAD,EAAOI,UAAP,EAAmBC,gBAAgB,GAAG,KAAtC,EAA6C;AAC/D;AACA,QAAIV,eAAe,CAACS,UAAD,CAAnB,EAAiCA,UAAU,GAAG,MAAMR,eAAe,CAACQ,UAAD,CAAlC,CAF8B,CAEkB;;AAEjF,QAAIE,KAAK,CAACC,OAAN,CAAcH,UAAd,CAAJ,EAA+B;AAC7B,YAAMI,MAAM,GAAGJ,UAAU,CAACK,GAAX,CAAeC,CAAC,IAAI,KAAKR,cAAL,CAAoBF,IAApB,EAA0BU,CAA1B,CAApB,CAAf;AACA,aAAOC,OAAO,CAACC,GAAR,CAAYJ,MAAZ,CAAP;AACD,KAP8D,CAO7D;AACF;;;AAGA,QAAId,aAAa,CAACU,UAAD,CAAjB,EAA+B;AAC7B;AACA,YAAMS,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYT,UAAZ,CAAb;AACAA,MAAAA,UAAU,GAAGS,IAAI,CAACJ,GAAL,CAASM,GAAG,IAAIX,UAAU,CAACW,GAAD,CAAV,IAAmBA,GAAnC,CAAb,CAH6B,CAGyB;;AAEtD,YAAMC,OAAO,GAAG,EAAhB;AACA,YAAMR,MAAM,GAAG,MAAM,KAAKN,cAAL,CAAoBF,IAApB,EAA0BI,UAA1B,CAArB;;AAEA,WAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,IAAI,CAACV,MAAzB,EAAiCc,CAAC,EAAlC,EAAsCD,OAAO,CAACH,IAAI,CAACI,CAAD,CAAL,CAAP,GAAmBT,MAAM,CAACS,CAAD,CAAzB;;AAEtC,aAAOD,OAAP;AACD,KAtB8D,CAsB7D;;;AAGF,UAAME,KAAK,GAAGlB,IAAI,CAACI,UAAD,CAAlB;AACA,WAAOC,gBAAgB,GAAG,CAACa,KAAD,CAAH,GAAaA,KAApC;AACD;;AAhCqC","sourcesContent":["import { isPlainObject, isAsyncIterable } from './valueUtils';\nimport { iterableToArray } from './iterableUtils';\n/**\n * Returns a function that requests the values of multiple properties.\n * You can use this function to access properties as follows:\n * - fn() returns []\n * - fn(p1) returns [path[p1]]\n * - fn(p1, p2) returns [path[p1], path[p2]]\n * - fn([p1, p2]) returns [path[p1], path[p2]]\n * - fn(asyncIterable) returns [path[p1], path[p2]]\n * - fn({ p1: null, p2: null }) returns { p1: path[p1], p2: path[p2] }\n * Combinations of the above are possible by passing them in arrays.\n */\n\nexport default class GetFunctionHandler {\n  handle(pathData, path) {\n    return (...args) => this.readProperties(path, args.length === 1 ? args[0] : args, true);\n  }\n\n  async readProperties(path, properties, wrapSingleValues = false) {\n    // Convert an async iterable to an array\n    if (isAsyncIterable(properties)) properties = await iterableToArray(properties); // If passed an array, read every property\n\n    if (Array.isArray(properties)) {\n      const values = properties.map(p => this.readProperties(path, p));\n      return Promise.all(values);\n    } // If passed an object with property names as keys,\n    // return an object with the values filled in\n\n\n    if (isPlainObject(properties)) {\n      // Use the key as property value if none is specified\n      const keys = Object.keys(properties);\n      properties = keys.map(key => properties[key] || key); // Store the resolved properties by key\n\n      const results = {};\n      const values = await this.readProperties(path, properties);\n\n      for (let i = 0; i < keys.length; i++) results[keys[i]] = values[i];\n\n      return results;\n    } // Otherwise, perform a single property access\n\n\n    const value = path[properties];\n    return wrapSingleValues ? [value] : value;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}