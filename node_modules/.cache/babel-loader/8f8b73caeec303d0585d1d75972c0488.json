{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContainerHandlerIdentifier = void 0;\n/**\n * Container handler for @id.\n *\n * It assumes that the current key is the identifier of the current value.\n * This will add this value to the parent node.\n */\n\nclass ContainerHandlerIdentifier {\n  canCombineWithGraph() {\n    return true;\n  }\n\n  async handle(containers, parsingContext, util, keys, value, depth) {\n    let id; // First check if the child node already has a defined id.\n\n    if (parsingContext.emittedStack[depth + 1] && parsingContext.idStack[depth + 1]) {\n      // Use the existing identifier\n      id = parsingContext.idStack[depth + 1][0];\n    } else {\n      // Create the identifier\n      const keyUnaliased = await util.getContainerKey(keys[depth], keys, depth);\n      const maybeId = keyUnaliased !== null ? await util.resourceToTerm(await parsingContext.getContext(keys), keys[depth]) : util.dataFactory.blankNode(); // Do nothing if the id is invalid\n\n      if (!maybeId) {\n        parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n\n        return;\n      }\n\n      id = maybeId; // Insert the id into the stack so that buffered children can make us of it.\n\n      parsingContext.idStack[depth + 1] = [id];\n    } // Insert the id into the stack so that parents can make use of it.\n    // Insert it as an array because multiple id container entries may exist\n\n\n    let ids = parsingContext.idStack[depth];\n\n    if (!ids) {\n      ids = parsingContext.idStack[depth] = [];\n    } // Only insert the term if it does not exist yet in the array.\n\n\n    if (!ids.some(term => term.equals(id))) {\n      ids.push(id);\n    } // Flush any pending flush buffers\n\n\n    if (!(await parsingContext.handlePendingContainerFlushBuffers())) {\n      parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n    }\n  }\n\n}\n\nexports.ContainerHandlerIdentifier = ContainerHandlerIdentifier;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerIdentifier.js"],"names":["Object","defineProperty","exports","value","ContainerHandlerIdentifier","canCombineWithGraph","handle","containers","parsingContext","util","keys","depth","id","emittedStack","idStack","keyUnaliased","getContainerKey","maybeId","resourceToTerm","getContext","dataFactory","blankNode","ids","some","term","equals","push","handlePendingContainerFlushBuffers"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,0BAAR,GAAqC,KAAK,CAA1C;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMA,0BAAN,CAAiC;AAC7BC,EAAAA,mBAAmB,GAAG;AAClB,WAAO,IAAP;AACH;;AACW,QAANC,MAAM,CAACC,UAAD,EAAaC,cAAb,EAA6BC,IAA7B,EAAmCC,IAAnC,EAAyCP,KAAzC,EAAgDQ,KAAhD,EAAuD;AAC/D,QAAIC,EAAJ,CAD+D,CAE/D;;AACA,QAAIJ,cAAc,CAACK,YAAf,CAA4BF,KAAK,GAAG,CAApC,KAA0CH,cAAc,CAACM,OAAf,CAAuBH,KAAK,GAAG,CAA/B,CAA9C,EAAiF;AAC7E;AACAC,MAAAA,EAAE,GAAGJ,cAAc,CAACM,OAAf,CAAuBH,KAAK,GAAG,CAA/B,EAAkC,CAAlC,CAAL;AACH,KAHD,MAIK;AACD;AACA,YAAMI,YAAY,GAAG,MAAMN,IAAI,CAACO,eAAL,CAAqBN,IAAI,CAACC,KAAD,CAAzB,EAAkCD,IAAlC,EAAwCC,KAAxC,CAA3B;AACA,YAAMM,OAAO,GAAGF,YAAY,KAAK,IAAjB,GACV,MAAMN,IAAI,CAACS,cAAL,CAAoB,MAAMV,cAAc,CAACW,UAAf,CAA0BT,IAA1B,CAA1B,EAA2DA,IAAI,CAACC,KAAD,CAA/D,CADI,GAEVF,IAAI,CAACW,WAAL,CAAiBC,SAAjB,EAFN,CAHC,CAMD;;AACA,UAAI,CAACJ,OAAL,EAAc;AACVT,QAAAA,cAAc,CAACK,YAAf,CAA4BF,KAA5B,IAAqC,KAArC,CADU,CACkC;;AAC5C;AACH;;AACDC,MAAAA,EAAE,GAAGK,OAAL,CAXC,CAYD;;AACAT,MAAAA,cAAc,CAACM,OAAf,CAAuBH,KAAK,GAAG,CAA/B,IAAoC,CAACC,EAAD,CAApC;AACH,KArB8D,CAsB/D;AACA;;;AACA,QAAIU,GAAG,GAAGd,cAAc,CAACM,OAAf,CAAuBH,KAAvB,CAAV;;AACA,QAAI,CAACW,GAAL,EAAU;AACNA,MAAAA,GAAG,GAAGd,cAAc,CAACM,OAAf,CAAuBH,KAAvB,IAAgC,EAAtC;AACH,KA3B8D,CA4B/D;;;AACA,QAAI,CAACW,GAAG,CAACC,IAAJ,CAAUC,IAAD,IAAUA,IAAI,CAACC,MAAL,CAAYb,EAAZ,CAAnB,CAAL,EAA0C;AACtCU,MAAAA,GAAG,CAACI,IAAJ,CAASd,EAAT;AACH,KA/B8D,CAgC/D;;;AACA,QAAI,EAAC,MAAMJ,cAAc,CAACmB,kCAAf,EAAP,CAAJ,EAAgE;AAC5DnB,MAAAA,cAAc,CAACK,YAAf,CAA4BF,KAA5B,IAAqC,KAArC,CAD4D,CAChB;AAC/C;AACJ;;AAxC4B;;AA0CjCT,OAAO,CAACE,0BAAR,GAAqCA,0BAArC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerIdentifier = void 0;\n/**\n * Container handler for @id.\n *\n * It assumes that the current key is the identifier of the current value.\n * This will add this value to the parent node.\n */\nclass ContainerHandlerIdentifier {\n    canCombineWithGraph() {\n        return true;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        let id;\n        // First check if the child node already has a defined id.\n        if (parsingContext.emittedStack[depth + 1] && parsingContext.idStack[depth + 1]) {\n            // Use the existing identifier\n            id = parsingContext.idStack[depth + 1][0];\n        }\n        else {\n            // Create the identifier\n            const keyUnaliased = await util.getContainerKey(keys[depth], keys, depth);\n            const maybeId = keyUnaliased !== null\n                ? await util.resourceToTerm(await parsingContext.getContext(keys), keys[depth])\n                : util.dataFactory.blankNode();\n            // Do nothing if the id is invalid\n            if (!maybeId) {\n                parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n                return;\n            }\n            id = maybeId;\n            // Insert the id into the stack so that buffered children can make us of it.\n            parsingContext.idStack[depth + 1] = [id];\n        }\n        // Insert the id into the stack so that parents can make use of it.\n        // Insert it as an array because multiple id container entries may exist\n        let ids = parsingContext.idStack[depth];\n        if (!ids) {\n            ids = parsingContext.idStack[depth] = [];\n        }\n        // Only insert the term if it does not exist yet in the array.\n        if (!ids.some((term) => term.equals(id))) {\n            ids.push(id);\n        }\n        // Flush any pending flush buffers\n        if (!await parsingContext.handlePendingContainerFlushBuffers()) {\n            parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n        }\n    }\n}\nexports.ContainerHandlerIdentifier = ContainerHandlerIdentifier;\n//# sourceMappingURL=ContainerHandlerIdentifier.js.map"]},"metadata":{},"sourceType":"script"}