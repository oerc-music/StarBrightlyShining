{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SparqlXmlParser = void 0;\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst SparqlXmlBindingsTransformer_1 = require(\"./SparqlXmlBindingsTransformer\"); // tslint:disable-next-line:no-var-requires\n\n\nconst XmlNode = require('sax-stream');\n/**\n * Parser for the SPARQL Query Results XML format.\n * @see https://www.w3.org/TR/rdf-sparql-XMLres/\n */\n\n\nclass SparqlXmlParser {\n  constructor(settings) {\n    settings = settings || {};\n    this.dataFactory = settings.dataFactory || new rdf_data_factory_1.DataFactory();\n    this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;\n  }\n  /**\n   * Convert a SPARQL XML bindings response stream to a stream of bindings objects.\n   *\n   * The bindings stream will emit a 'variables' event that will contain\n   * the array of variables (as RDF.Variable[]), as defined in the response head.\n   *\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.\n   * @return {NodeJS.ReadableStream} A stream of bindings.\n   */\n\n\n  parseXmlResultsStream(sparqlResponseStream) {\n    // Collect variables\n    const variables = [];\n    sparqlResponseStream.pipe(XmlNode({\n      strict: true,\n      tag: 'variable'\n    })).on('data', node => variables.push(this.dataFactory.variable(node.attribs.name))).on('error', () => {\n      return;\n    }) // Ignore errors, they will emitted in the results\n    .on('finish', () => resultStream.emit('variables', variables)); // Collect results\n\n    const resultStream = sparqlResponseStream.pipe(XmlNode({\n      strict: true,\n      tag: 'result'\n    })).on('error', error => resultStream.emit('error', error)).pipe(new SparqlXmlBindingsTransformer_1.SparqlXmlBindingsTransformer(this)); // Propagate errors\n\n    sparqlResponseStream.on('error', error => resultStream.emit('error', error));\n    return resultStream;\n  }\n  /**\n   * Convert a SPARQL XML result binding to a bindings object.\n   * @param rawBindings A SPARQL XML result binding.\n   * @return {IBindings} A bindings object.\n   */\n\n\n  parseXmlBindings(rawBindings) {\n    const bindings = {};\n\n    if (rawBindings.children) {\n      const bindingsArray = Array.isArray(rawBindings.children.binding) ? rawBindings.children.binding : [rawBindings.children.binding];\n\n      for (const binding of bindingsArray) {\n        if (binding.attribs && binding.children) {\n          const key = binding.attribs.name;\n          let term = null;\n\n          if (binding.children.bnode) {\n            term = this.dataFactory.blankNode(binding.children.bnode.value);\n          } else if (binding.children.literal) {\n            const value = binding.children.literal.value || \"\";\n            const attribs = binding.children.literal.attribs;\n\n            if (attribs && attribs['xml:lang']) {\n              term = this.dataFactory.literal(value, attribs['xml:lang']);\n            } else if (attribs && attribs.datatype) {\n              term = this.dataFactory.literal(value, this.dataFactory.namedNode(attribs.datatype));\n            } else {\n              term = this.dataFactory.literal(value);\n            }\n          } else {\n            term = this.dataFactory.namedNode(binding.children.uri.value);\n          }\n\n          bindings[this.prefixVariableQuestionMark ? '?' + key : key] = term;\n        }\n      }\n    }\n\n    return bindings;\n  }\n  /**\n   * Convert a SPARQL XML boolean response stream to a promise resolving to a boolean.\n   * This will reject if the given response was not a valid boolean response.\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.\n   * @return {NodeJS.ReadableStream} A stream of bindings.\n   */\n\n\n  parseXmlBooleanStream(sparqlResponseStream) {\n    return new Promise((resolve, reject) => {\n      sparqlResponseStream.on('error', reject);\n      sparqlResponseStream.pipe(XmlNode({\n        strict: true,\n        tag: 'boolean'\n      })).on('error', reject).on('data', node => resolve(node.value === 'true')).on('end', () => reject(new Error('No valid ASK response was found.')));\n    });\n  }\n\n}\n\nexports.SparqlXmlParser = SparqlXmlParser;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/sparqlxml-parse/lib/SparqlXmlParser.js"],"names":["Object","defineProperty","exports","value","SparqlXmlParser","rdf_data_factory_1","require","SparqlXmlBindingsTransformer_1","XmlNode","constructor","settings","dataFactory","DataFactory","prefixVariableQuestionMark","parseXmlResultsStream","sparqlResponseStream","variables","pipe","strict","tag","on","node","push","variable","attribs","name","resultStream","emit","error","SparqlXmlBindingsTransformer","parseXmlBindings","rawBindings","bindings","children","bindingsArray","Array","isArray","binding","key","term","bnode","blankNode","literal","datatype","namedNode","uri","parseXmlBooleanStream","Promise","resolve","reject","Error"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SparqlXmlParser = void 0;\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst SparqlXmlBindingsTransformer_1 = require(\"./SparqlXmlBindingsTransformer\");\n// tslint:disable-next-line:no-var-requires\nconst XmlNode = require('sax-stream');\n/**\n * Parser for the SPARQL Query Results XML format.\n * @see https://www.w3.org/TR/rdf-sparql-XMLres/\n */\nclass SparqlXmlParser {\n    constructor(settings) {\n        settings = settings || {};\n        this.dataFactory = settings.dataFactory || new rdf_data_factory_1.DataFactory();\n        this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;\n    }\n    /**\n     * Convert a SPARQL XML bindings response stream to a stream of bindings objects.\n     *\n     * The bindings stream will emit a 'variables' event that will contain\n     * the array of variables (as RDF.Variable[]), as defined in the response head.\n     *\n     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.\n     * @return {NodeJS.ReadableStream} A stream of bindings.\n     */\n    parseXmlResultsStream(sparqlResponseStream) {\n        // Collect variables\n        const variables = [];\n        sparqlResponseStream\n            .pipe(XmlNode({ strict: true, tag: 'variable' }))\n            .on('data', (node) => variables.push(this.dataFactory.variable(node.attribs.name)))\n            .on('error', () => { return; }) // Ignore errors, they will emitted in the results\n            .on('finish', () => resultStream.emit('variables', variables));\n        // Collect results\n        const resultStream = sparqlResponseStream\n            .pipe(XmlNode({ strict: true, tag: 'result' }))\n            .on('error', (error) => resultStream.emit('error', error))\n            .pipe(new SparqlXmlBindingsTransformer_1.SparqlXmlBindingsTransformer(this));\n        // Propagate errors\n        sparqlResponseStream.on('error', (error) => resultStream.emit('error', error));\n        return resultStream;\n    }\n    /**\n     * Convert a SPARQL XML result binding to a bindings object.\n     * @param rawBindings A SPARQL XML result binding.\n     * @return {IBindings} A bindings object.\n     */\n    parseXmlBindings(rawBindings) {\n        const bindings = {};\n        if (rawBindings.children) {\n            const bindingsArray = Array.isArray(rawBindings.children.binding)\n                ? rawBindings.children.binding : [rawBindings.children.binding];\n            for (const binding of bindingsArray) {\n                if (binding.attribs && binding.children) {\n                    const key = binding.attribs.name;\n                    let term = null;\n                    if (binding.children.bnode) {\n                        term = this.dataFactory.blankNode(binding.children.bnode.value);\n                    }\n                    else if (binding.children.literal) {\n                        const value = binding.children.literal.value || \"\";\n                        const attribs = binding.children.literal.attribs;\n                        if (attribs && attribs['xml:lang']) {\n                            term = this.dataFactory.literal(value, attribs['xml:lang']);\n                        }\n                        else if (attribs && attribs.datatype) {\n                            term = this.dataFactory.literal(value, this.dataFactory.namedNode(attribs.datatype));\n                        }\n                        else {\n                            term = this.dataFactory.literal(value);\n                        }\n                    }\n                    else {\n                        term = this.dataFactory.namedNode(binding.children.uri.value);\n                    }\n                    bindings[this.prefixVariableQuestionMark ? ('?' + key) : key] = term;\n                }\n            }\n        }\n        return bindings;\n    }\n    /**\n     * Convert a SPARQL XML boolean response stream to a promise resolving to a boolean.\n     * This will reject if the given response was not a valid boolean response.\n     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL XML response stream.\n     * @return {NodeJS.ReadableStream} A stream of bindings.\n     */\n    parseXmlBooleanStream(sparqlResponseStream) {\n        return new Promise((resolve, reject) => {\n            sparqlResponseStream.on('error', reject);\n            sparqlResponseStream\n                .pipe(XmlNode({ strict: true, tag: 'boolean' }))\n                .on('error', reject)\n                .on('data', (node) => resolve(node.value === 'true'))\n                .on('end', () => reject(new Error('No valid ASK response was found.')));\n        });\n    }\n}\nexports.SparqlXmlParser = SparqlXmlParser;\n//# sourceMappingURL=SparqlXmlParser.js.map"]},"metadata":{},"sourceType":"script"}