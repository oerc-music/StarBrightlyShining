{"ast":null,"code":"import PathProxy from './PathProxy';\nimport JSONLDResolver from './JSONLDResolver';\nimport ComplexPathResolver from './ComplexPathResolver';\nimport defaultHandlers from './defaultHandlers';\nimport { ContextParser } from 'jsonld-context-parser';\nimport ContextProvider from './ContextProvider';\n/**\n * A PathFactory creates paths with default settings.\n */\n\nexport default class PathFactory {\n  constructor(settings, data) {\n    // Store settings and data\n    this._settings = settings = { ...settings\n    };\n    this._data = data = { ...data\n    }; // Prepare the handlers\n\n    const handlers = settings.handlers || defaultHandlers;\n\n    for (const key in handlers) handlers[key] = toHandler(handlers[key]);\n\n    for (const key of Object.getOwnPropertySymbols(handlers)) handlers[key] = toHandler(handlers[key]); // Prepare the resolvers\n\n\n    const resolvers = (settings.resolvers || []).map(toResolver);\n\n    if (settings.context) {\n      const contextProvider = new ContextProvider(settings.context);\n      resolvers.push(new ComplexPathResolver(contextProvider));\n      resolvers.push(new JSONLDResolver(contextProvider));\n      settings.parsedContext = new ContextParser().parse(settings.context).then(({\n        contextRaw\n      }) => contextRaw);\n    } else {\n      settings.context = settings.parsedContext = {};\n    } // Instantiate PathProxy that will create the paths\n\n\n    this._pathProxy = new PathProxy({\n      handlers,\n      resolvers\n    }); // Remove PathProxy settings from the settings object\n\n    delete settings.handlers;\n    delete settings.resolvers;\n  }\n  /**\n   * Creates a path with the given (optional) settings and data.\n   */\n\n\n  create(settings = {}, data) {\n    // The settings parameter is optional\n    if (!data) [data, settings] = [settings, null]; // Apply defaults on settings and data\n\n    return this._pathProxy.createPath(Object.assign(Object.create(null), this._settings, settings), Object.assign(Object.create(null), this._data, data));\n  }\n\n}\nPathFactory.defaultHandlers = defaultHandlers;\n/**\n * Converts a handler function into a handler object.\n */\n\nexport function toHandler(handle) {\n  return typeof handle.handle === 'function' ? handle : {\n    handle\n  };\n}\n/**\n * Converts a resolver function into a catch-all resolver object.\n */\n\nexport function toResolver(resolve) {\n  return typeof resolve.resolve === 'function' ? resolve : {\n    supports,\n    resolve\n  };\n} // Catch-all resolvers support everything\n\nfunction supports() {\n  return true;\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/PathFactory.js"],"names":["PathProxy","JSONLDResolver","ComplexPathResolver","defaultHandlers","ContextParser","ContextProvider","PathFactory","constructor","settings","data","_settings","_data","handlers","key","toHandler","Object","getOwnPropertySymbols","resolvers","map","toResolver","context","contextProvider","push","parsedContext","parse","then","contextRaw","_pathProxy","create","createPath","assign","handle","resolve","supports"],"mappings":"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","sourcesContent":["import PathProxy from './PathProxy';\nimport JSONLDResolver from './JSONLDResolver';\nimport ComplexPathResolver from './ComplexPathResolver';\nimport defaultHandlers from './defaultHandlers';\nimport { ContextParser } from 'jsonld-context-parser';\nimport ContextProvider from './ContextProvider';\n/**\n * A PathFactory creates paths with default settings.\n */\n\nexport default class PathFactory {\n  constructor(settings, data) {\n    // Store settings and data\n    this._settings = settings = { ...settings\n    };\n    this._data = data = { ...data\n    }; // Prepare the handlers\n\n    const handlers = settings.handlers || defaultHandlers;\n\n    for (const key in handlers) handlers[key] = toHandler(handlers[key]);\n\n    for (const key of Object.getOwnPropertySymbols(handlers)) handlers[key] = toHandler(handlers[key]); // Prepare the resolvers\n\n\n    const resolvers = (settings.resolvers || []).map(toResolver);\n\n    if (settings.context) {\n      const contextProvider = new ContextProvider(settings.context);\n      resolvers.push(new ComplexPathResolver(contextProvider));\n      resolvers.push(new JSONLDResolver(contextProvider));\n      settings.parsedContext = new ContextParser().parse(settings.context).then(({\n        contextRaw\n      }) => contextRaw);\n    } else {\n      settings.context = settings.parsedContext = {};\n    } // Instantiate PathProxy that will create the paths\n\n\n    this._pathProxy = new PathProxy({\n      handlers,\n      resolvers\n    }); // Remove PathProxy settings from the settings object\n\n    delete settings.handlers;\n    delete settings.resolvers;\n  }\n  /**\n   * Creates a path with the given (optional) settings and data.\n   */\n\n\n  create(settings = {}, data) {\n    // The settings parameter is optional\n    if (!data) [data, settings] = [settings, null]; // Apply defaults on settings and data\n\n    return this._pathProxy.createPath(Object.assign(Object.create(null), this._settings, settings), Object.assign(Object.create(null), this._data, data));\n  }\n\n}\nPathFactory.defaultHandlers = defaultHandlers;\n/**\n * Converts a handler function into a handler object.\n */\n\nexport function toHandler(handle) {\n  return typeof handle.handle === 'function' ? handle : {\n    handle\n  };\n}\n/**\n * Converts a resolver function into a catch-all resolver object.\n */\n\nexport function toResolver(resolve) {\n  return typeof resolve.resolve === 'function' ? resolve : {\n    supports,\n    resolve\n  };\n} // Catch-all resolvers support everything\n\nfunction supports() {\n  return true;\n}"]},"metadata":{},"sourceType":"module"}