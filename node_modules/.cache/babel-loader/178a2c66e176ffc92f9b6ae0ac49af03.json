{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HtmlScriptListener = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst core_1 = require(\"@comunica/core\");\n\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * An HTML parse listeners that detects <script> data blocks with known RDF media tyoes,\n * parses them, and outputs the resulting quads.\n */\n\n\nclass HtmlScriptListener {\n  constructor(mediatorRdfParseHandle, cbQuad, cbError, cbEnd, supportedTypes, context, baseIRI, headers) {\n    var _a;\n\n    this.textChunksJsonLd = [];\n    this.endBarrier = 1;\n    this.passedScripts = 0;\n    this.isFinalJsonLdProcessing = false;\n    this.mediatorRdfParseHandle = mediatorRdfParseHandle;\n    this.cbQuad = cbQuad;\n    this.cbError = cbError;\n    this.cbEnd = cbEnd;\n    this.supportedTypes = supportedTypes;\n    this.context = (context || core_1.ActionContext({})).set('@comunica/actor-rdf-parse-html-script:processing-html-script', true);\n    this.baseIRI = baseIRI;\n    this.headers = headers;\n    this.onlyFirstScript = (_a = context && context.get('extractAllScripts') === false) !== null && _a !== void 0 ? _a : false;\n    const fragmentPos = this.baseIRI.indexOf('#');\n    this.targetScriptId = fragmentPos > 0 ? this.baseIRI.slice(fragmentPos + 1, this.baseIRI.length) : null;\n  }\n\n  static newErrorCoded(message, code) {\n    // Error codes are required by the JSON-LD spec\n    const error = new Error(message);\n    error.code = code;\n    return error;\n  }\n\n  onEnd() {\n    if (--this.endBarrier === 0) {\n      if (this.textChunksJsonLd.length > 0) {\n        // First process buffered JSON-LD chunks if we have any.\n        this.handleMediaType = 'application/ld+json';\n        this.textChunks = this.textChunksJsonLd;\n        this.textChunks.push(']');\n        this.textChunksJsonLd = [];\n        this.isFinalJsonLdProcessing = true;\n        this.endBarrier++; // This will call onEnd again\n\n        this.onTagClose();\n      } else {\n        // Otherwise, end processing\n        if (this.passedScripts === 0 && this.targetScriptId) {\n          this.cbError(HtmlScriptListener.newErrorCoded(`Failed to find targeted script id \"${this.targetScriptId}\"`, 'loading document failed'));\n        }\n\n        this.cbEnd();\n      }\n\n      this.isFinalJsonLdProcessing = false;\n    }\n  }\n\n  onTagClose() {\n    if (this.handleMediaType) {\n      if (this.requiresCustomJsonLdHandling(this.handleMediaType) && !this.isFinalJsonLdProcessing) {\n        // Reset the media type and text stream\n        this.handleMediaType = undefined;\n        this.textChunks = undefined;\n        this.onEnd();\n      } else {\n        // Create a temporary text stream for pushing all the text chunks\n        const textStream = new stream_1.Readable({\n          objectMode: true\n        });\n\n        textStream._read = () => {// Do nothing\n        };\n\n        const textChunksLocal = this.textChunks; // Send all collected text to parser\n\n        const parseAction = {\n          context: this.context,\n          handle: {\n            baseIRI: this.baseIRI,\n            input: textStream,\n            headers: this.headers\n          },\n          handleMediaType: this.handleMediaType\n        };\n        this.mediatorRdfParseHandle.mediate(parseAction).then(({\n          handle\n        }) => {\n          // Initialize text parsing\n          handle.quads.on('error', error => this.cbError(HtmlScriptListener.newErrorCoded(error.message, 'invalid script element'))).on('data', this.cbQuad).on('end', () => this.onEnd()); // Push the text stream after all events have been attached\n\n          for (const textChunk of textChunksLocal) {\n            textStream.push(textChunk);\n          }\n\n          textStream.push(null);\n        }).catch(error => {\n          if (this.targetScriptId) {\n            // Error if we are targeting this script tag specifically\n            this.cbError(HtmlScriptListener.newErrorCoded(error.message, 'loading document failed'));\n          } else {\n            // Ignore script tags that we don't understand\n            this.onEnd();\n          }\n        }); // Reset the media type and text stream\n\n        this.handleMediaType = undefined;\n        this.textChunks = undefined;\n      }\n    }\n  }\n\n  onTagOpen(name, attributes) {\n    // Take into account baseIRI overrides\n    if (name === 'base' && attributes.href) {\n      this.baseIRI = relative_to_absolute_iri_1.resolve(attributes.href, this.baseIRI);\n    } // Only handle script tags with a parseable content type\n    // If targetScriptId is defined, only extract from script with that id\n\n\n    if (name === 'script' && (!this.targetScriptId || attributes.id === this.targetScriptId)) {\n      if (this.supportedTypes[attributes.type]) {\n        if (this.onlyFirstScript && this.passedScripts > 0) {\n          // Ignore script tag if only one should be extracted\n          this.handleMediaType = undefined;\n        } else {\n          this.passedScripts++;\n          this.handleMediaType = attributes.type;\n          this.endBarrier++;\n\n          if (this.requiresCustomJsonLdHandling(this.handleMediaType)) {\n            this.textChunks = this.textChunksJsonLd;\n            this.textChunks.push(this.textChunks.length === 0 ? '[' : ',');\n          } else {\n            this.textChunks = [];\n          }\n        }\n      } else if (this.targetScriptId) {\n        this.cbError(HtmlScriptListener.newErrorCoded(`Targeted script \"${this.targetScriptId}\" does not have a supported type`, 'loading document failed'));\n      }\n    } else {\n      this.handleMediaType = undefined;\n    }\n  }\n\n  onText(data) {\n    if (this.handleMediaType) {\n      this.textChunks.push(data);\n    }\n  }\n  /**\n   * If we require custom JSON-LD handling for the given media type.\n   *\n   * The JSON-LD spec requires JSON-LD within script tags to be seen as a single document.\n   * As such, we have to buffer all JSON-LD until the end of HTML processing,\n   * and encapsulate all found contents in an array.\n   *\n   * @param mediaType A media type.\n   */\n\n\n  requiresCustomJsonLdHandling(mediaType) {\n    return !this.onlyFirstScript && !this.targetScriptId && mediaType === 'application/ld+json';\n  }\n\n}\n\nexports.HtmlScriptListener = HtmlScriptListener;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-rdf-parse-html-script/lib/HtmlScriptListener.js"],"names":["Object","defineProperty","exports","value","HtmlScriptListener","stream_1","require","core_1","relative_to_absolute_iri_1","constructor","mediatorRdfParseHandle","cbQuad","cbError","cbEnd","supportedTypes","context","baseIRI","headers","_a","textChunksJsonLd","endBarrier","passedScripts","isFinalJsonLdProcessing","ActionContext","set","onlyFirstScript","get","fragmentPos","indexOf","targetScriptId","slice","length","newErrorCoded","message","code","error","Error","onEnd","handleMediaType","textChunks","push","onTagClose","requiresCustomJsonLdHandling","undefined","textStream","Readable","objectMode","_read","textChunksLocal","parseAction","handle","input","mediate","then","quads","on","textChunk","catch","onTagOpen","name","attributes","href","resolve","id","type","onText","data","mediaType"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HtmlScriptListener = void 0;\nconst stream_1 = require(\"stream\");\nconst core_1 = require(\"@comunica/core\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * An HTML parse listeners that detects <script> data blocks with known RDF media tyoes,\n * parses them, and outputs the resulting quads.\n */\nclass HtmlScriptListener {\n    constructor(mediatorRdfParseHandle, cbQuad, cbError, cbEnd, supportedTypes, context, baseIRI, headers) {\n        var _a;\n        this.textChunksJsonLd = [];\n        this.endBarrier = 1;\n        this.passedScripts = 0;\n        this.isFinalJsonLdProcessing = false;\n        this.mediatorRdfParseHandle = mediatorRdfParseHandle;\n        this.cbQuad = cbQuad;\n        this.cbError = cbError;\n        this.cbEnd = cbEnd;\n        this.supportedTypes = supportedTypes;\n        this.context = (context || core_1.ActionContext({}))\n            .set('@comunica/actor-rdf-parse-html-script:processing-html-script', true);\n        this.baseIRI = baseIRI;\n        this.headers = headers;\n        this.onlyFirstScript = (_a = (context && context.get('extractAllScripts') === false)) !== null && _a !== void 0 ? _a : false;\n        const fragmentPos = this.baseIRI.indexOf('#');\n        this.targetScriptId = fragmentPos > 0 ? this.baseIRI.slice(fragmentPos + 1, this.baseIRI.length) : null;\n    }\n    static newErrorCoded(message, code) {\n        // Error codes are required by the JSON-LD spec\n        const error = new Error(message);\n        error.code = code;\n        return error;\n    }\n    onEnd() {\n        if (--this.endBarrier === 0) {\n            if (this.textChunksJsonLd.length > 0) {\n                // First process buffered JSON-LD chunks if we have any.\n                this.handleMediaType = 'application/ld+json';\n                this.textChunks = this.textChunksJsonLd;\n                this.textChunks.push(']');\n                this.textChunksJsonLd = [];\n                this.isFinalJsonLdProcessing = true;\n                this.endBarrier++;\n                // This will call onEnd again\n                this.onTagClose();\n            }\n            else {\n                // Otherwise, end processing\n                if (this.passedScripts === 0 && this.targetScriptId) {\n                    this.cbError(HtmlScriptListener.newErrorCoded(`Failed to find targeted script id \"${this.targetScriptId}\"`, 'loading document failed'));\n                }\n                this.cbEnd();\n            }\n            this.isFinalJsonLdProcessing = false;\n        }\n    }\n    onTagClose() {\n        if (this.handleMediaType) {\n            if (this.requiresCustomJsonLdHandling(this.handleMediaType) && !this.isFinalJsonLdProcessing) {\n                // Reset the media type and text stream\n                this.handleMediaType = undefined;\n                this.textChunks = undefined;\n                this.onEnd();\n            }\n            else {\n                // Create a temporary text stream for pushing all the text chunks\n                const textStream = new stream_1.Readable({ objectMode: true });\n                textStream._read = () => {\n                    // Do nothing\n                };\n                const textChunksLocal = this.textChunks;\n                // Send all collected text to parser\n                const parseAction = {\n                    context: this.context,\n                    handle: { baseIRI: this.baseIRI, input: textStream, headers: this.headers },\n                    handleMediaType: this.handleMediaType,\n                };\n                this.mediatorRdfParseHandle.mediate(parseAction)\n                    .then(({ handle }) => {\n                    // Initialize text parsing\n                    handle.quads\n                        .on('error', error => this.cbError(HtmlScriptListener\n                        .newErrorCoded(error.message, 'invalid script element')))\n                        .on('data', this.cbQuad)\n                        .on('end', () => this.onEnd());\n                    // Push the text stream after all events have been attached\n                    for (const textChunk of textChunksLocal) {\n                        textStream.push(textChunk);\n                    }\n                    textStream.push(null);\n                })\n                    .catch((error) => {\n                    if (this.targetScriptId) {\n                        // Error if we are targeting this script tag specifically\n                        this.cbError(HtmlScriptListener.newErrorCoded(error.message, 'loading document failed'));\n                    }\n                    else {\n                        // Ignore script tags that we don't understand\n                        this.onEnd();\n                    }\n                });\n                // Reset the media type and text stream\n                this.handleMediaType = undefined;\n                this.textChunks = undefined;\n            }\n        }\n    }\n    onTagOpen(name, attributes) {\n        // Take into account baseIRI overrides\n        if (name === 'base' && attributes.href) {\n            this.baseIRI = relative_to_absolute_iri_1.resolve(attributes.href, this.baseIRI);\n        }\n        // Only handle script tags with a parseable content type\n        // If targetScriptId is defined, only extract from script with that id\n        if (name === 'script' && (!this.targetScriptId || attributes.id === this.targetScriptId)) {\n            if (this.supportedTypes[attributes.type]) {\n                if (this.onlyFirstScript && this.passedScripts > 0) {\n                    // Ignore script tag if only one should be extracted\n                    this.handleMediaType = undefined;\n                }\n                else {\n                    this.passedScripts++;\n                    this.handleMediaType = attributes.type;\n                    this.endBarrier++;\n                    if (this.requiresCustomJsonLdHandling(this.handleMediaType)) {\n                        this.textChunks = this.textChunksJsonLd;\n                        this.textChunks.push(this.textChunks.length === 0 ? '[' : ',');\n                    }\n                    else {\n                        this.textChunks = [];\n                    }\n                }\n            }\n            else if (this.targetScriptId) {\n                this.cbError(HtmlScriptListener.newErrorCoded(`Targeted script \"${this.targetScriptId}\" does not have a supported type`, 'loading document failed'));\n            }\n        }\n        else {\n            this.handleMediaType = undefined;\n        }\n    }\n    onText(data) {\n        if (this.handleMediaType) {\n            this.textChunks.push(data);\n        }\n    }\n    /**\n     * If we require custom JSON-LD handling for the given media type.\n     *\n     * The JSON-LD spec requires JSON-LD within script tags to be seen as a single document.\n     * As such, we have to buffer all JSON-LD until the end of HTML processing,\n     * and encapsulate all found contents in an array.\n     *\n     * @param mediaType A media type.\n     */\n    requiresCustomJsonLdHandling(mediaType) {\n        return !this.onlyFirstScript && !this.targetScriptId && mediaType === 'application/ld+json';\n    }\n}\nexports.HtmlScriptListener = HtmlScriptListener;\n//# sourceMappingURL=HtmlScriptListener.js.map"]},"metadata":{},"sourceType":"script"}