{"ast":null,"code":"import auth from 'solid-auth-client';\nimport { asList } from './util';\n/**\n * A wrapper around a query engine\n * that uses Solid authenticated requests for updates.\n */\n\nexport default class SolidUpdateEngine {\n  /**\n   * Creates a wrapper around the given query engine.\n   */\n  constructor(sources, baseEngine) {\n    // Preload source but silence errors; they will be thrown during execution\n    this._source = this.getUpdateSource(sources);\n\n    this._source.catch(() => null);\n\n    this._engine = baseEngine;\n  }\n  /**\n   * Creates an asynchronous iterable of results for the given SPARQL query.\n   */\n\n\n  async *execute(sparql, sources) {\n    yield* /^\\s*(?:INSERT|DELETE)/i.test(sparql) ? this.executeUpdate(sparql, sources) : this._engine.execute(sparql, sources);\n  }\n  /**\n   * Creates an asynchronous iterable with the results of the SPARQL UPDATE query.\n   */\n\n\n  executeUpdate(sparql, sources) {\n    let done = false;\n\n    const next = async () => {\n      if (done) return {\n        done\n      };\n      done = true; // Send authenticated PATCH request to the document\n\n      const source = await (sources ? this.getUpdateSource(sources) : this._source);\n      const {\n        ok,\n        status,\n        statusText\n      } = await auth.fetch(source, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/sparql-update'\n        },\n        body: sparql\n      });\n      if (!ok) throw new Error(\"Update query failed (\".concat(status, \"): \").concat(statusText)); // Clear stale cached versions of the document\n\n      await this.clearCache(source); // Return success\n\n      return {\n        value: asList({\n          ok\n        })\n      };\n    };\n\n    return {\n      next,\n      return: noop,\n      throw: noop,\n\n      // required by the interface\n      [Symbol.asyncIterator]() {\n        return this;\n      }\n\n    };\n  }\n  /**\n   * Parses the source(s) into the source to update.\n   */\n\n\n  async getUpdateSource(sources) {\n    let source = await sources; // Transform URLs or terms into strings\n\n    if (source instanceof URL) source = source.href;else if (source && typeof source.value === 'string') source = source.value; // Parse a string URL source\n\n    if (typeof source === 'string') {\n      if (!/^https?:\\/\\//.test(source)) throw new Error('Can only update an HTTP(S) document.');\n      return source.replace(/#.*/, '');\n    } // Flatten recursive calls to this function\n\n\n    if (Array.isArray(source)) {\n      source = await Promise.all(source.map(s => this.getUpdateSource(s)));\n      source = [].concat(...source).filter(s => !!s);\n      if (source.length !== 1) throw new Error('Can only update a single source.');\n      return source[0];\n    } // Error on unsupported sources\n\n\n    throw new Error(\"Unsupported source: \".concat(source));\n  }\n  /**\n   * Removes the given document (or all, if not specified) from the cache,\n   * such that fresh results are obtained next time.\n   */\n\n\n  clearCache(document) {\n    return this._engine.clearCache(document);\n  }\n\n}\n\nfunction noop() {\n  /* empty */\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@solid/query-ldflex/module/SolidUpdateEngine.js"],"names":["auth","asList","SolidUpdateEngine","constructor","sources","baseEngine","_source","getUpdateSource","catch","_engine","execute","sparql","test","executeUpdate","done","next","source","ok","status","statusText","fetch","method","headers","body","Error","concat","clearCache","value","return","noop","throw","Symbol","asyncIterator","URL","href","replace","Array","isArray","Promise","all","map","s","filter","length","document"],"mappings":"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","sourcesContent":["import auth from 'solid-auth-client';\nimport { asList } from './util';\n/**\n * A wrapper around a query engine\n * that uses Solid authenticated requests for updates.\n */\n\nexport default class SolidUpdateEngine {\n  /**\n   * Creates a wrapper around the given query engine.\n   */\n  constructor(sources, baseEngine) {\n    // Preload source but silence errors; they will be thrown during execution\n    this._source = this.getUpdateSource(sources);\n\n    this._source.catch(() => null);\n\n    this._engine = baseEngine;\n  }\n  /**\n   * Creates an asynchronous iterable of results for the given SPARQL query.\n   */\n\n\n  async *execute(sparql, sources) {\n    yield* /^\\s*(?:INSERT|DELETE)/i.test(sparql) ? this.executeUpdate(sparql, sources) : this._engine.execute(sparql, sources);\n  }\n  /**\n   * Creates an asynchronous iterable with the results of the SPARQL UPDATE query.\n   */\n\n\n  executeUpdate(sparql, sources) {\n    let done = false;\n\n    const next = async () => {\n      if (done) return {\n        done\n      };\n      done = true; // Send authenticated PATCH request to the document\n\n      const source = await (sources ? this.getUpdateSource(sources) : this._source);\n      const {\n        ok,\n        status,\n        statusText\n      } = await auth.fetch(source, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/sparql-update'\n        },\n        body: sparql\n      });\n      if (!ok) throw new Error(\"Update query failed (\".concat(status, \"): \").concat(statusText)); // Clear stale cached versions of the document\n\n      await this.clearCache(source); // Return success\n\n      return {\n        value: asList({\n          ok\n        })\n      };\n    };\n\n    return {\n      next,\n      return: noop,\n      throw: noop,\n\n      // required by the interface\n      [Symbol.asyncIterator]() {\n        return this;\n      }\n\n    };\n  }\n  /**\n   * Parses the source(s) into the source to update.\n   */\n\n\n  async getUpdateSource(sources) {\n    let source = await sources; // Transform URLs or terms into strings\n\n    if (source instanceof URL) source = source.href;else if (source && typeof source.value === 'string') source = source.value; // Parse a string URL source\n\n    if (typeof source === 'string') {\n      if (!/^https?:\\/\\//.test(source)) throw new Error('Can only update an HTTP(S) document.');\n      return source.replace(/#.*/, '');\n    } // Flatten recursive calls to this function\n\n\n    if (Array.isArray(source)) {\n      source = await Promise.all(source.map(s => this.getUpdateSource(s)));\n      source = [].concat(...source).filter(s => !!s);\n      if (source.length !== 1) throw new Error('Can only update a single source.');\n      return source[0];\n    } // Error on unsupported sources\n\n\n    throw new Error(\"Unsupported source: \".concat(source));\n  }\n  /**\n   * Removes the given document (or all, if not specified) from the cache,\n   * such that fresh results are obtained next time.\n   */\n\n\n  clearCache(document) {\n    return this._engine.clearCache(document);\n  }\n\n}\n\nfunction noop() {\n  /* empty */\n}"]},"metadata":{},"sourceType":"module"}