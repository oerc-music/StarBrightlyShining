{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorRdfJoin = void 0;\n\nconst core_1 = require(\"@comunica/core\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n/**\n * A comunica actor for joining 2 binding streams.\n *\n * Actor types:\n * * Input:  IActionRdfJoin:      The streams that need to be joined.\n * * Test:   <none>\n * * Output: IActorRdfJoinOutput: The resulting joined stream.\n *\n * @see IActionRdfJoin\n * @see IActorQueryOperationOutput\n */\n\n\nclass ActorRdfJoin extends core_1.Actor {\n  constructor(args, limitEntries, limitEntriesMin, canHandleUndefs) {\n    super(args);\n    this.limitEntries = limitEntries !== null && limitEntries !== void 0 ? limitEntries : Number.POSITIVE_INFINITY;\n    this.limitEntriesMin = limitEntriesMin !== null && limitEntriesMin !== void 0 ? limitEntriesMin : false;\n    this.canHandleUndefs = canHandleUndefs !== null && canHandleUndefs !== void 0 ? canHandleUndefs : false;\n  }\n  /**\n   * Returns an array containing all the variable names that occur in all bindings streams.\n   * @param {IActionRdfJoin} action\n   * @returns {string[]}\n   */\n\n\n  static overlappingVariables(action) {\n    const variables = action.entries.map(entry => entry.variables);\n    let baseArray = variables[0];\n\n    for (const array of variables.slice(1)) {\n      baseArray = baseArray.filter(el => array.includes(el));\n    }\n\n    return baseArray;\n  }\n  /**\n   * Returns the variables that will occur in the joined bindings.\n   * @param {IActionRdfJoin} action\n   * @returns {string[]}\n   */\n\n\n  static joinVariables(action) {\n    const variables = action.entries.map(entry => entry.variables);\n    const withDuplicates = variables.reduce((acc, it) => [...acc, ...it], []);\n    return [...new Set(withDuplicates)];\n  }\n  /**\n   * Returns the result of joining bindings, or `null` if no join is possible.\n   * @param {Bindings[]} bindings\n   * @returns {Bindings}\n   */\n\n\n  static join(...bindings) {\n    try {\n      return bindings.reduce((acc, val) => acc.mergeWith((left, right) => {\n        if (!left.equals(right)) {\n          throw new Error('Join failure');\n        }\n\n        return left;\n      }, val));\n    } catch (_a) {\n      return null;\n    }\n  }\n  /**\n   * Checks if all metadata objects are present in the action, and if they have the specified key.\n   * @param {IActionRdfJoin} action\n   * @param {string} key\n   * @returns {boolean}\n   */\n\n\n  static async iteratorsHaveMetadata(action, key) {\n    return Promise.all(action.entries.map(async entry => {\n      if (!entry.metadata) {\n        throw new Error('Missing metadata');\n      }\n\n      const metadata = await entry.metadata();\n\n      if (!(key in metadata)) {\n        throw new Error('Missing metadata value');\n      }\n    })).then(() => true).catch(() => false);\n  }\n  /**\n   * Default test function for join actors.\n   * Checks whether all iterators have metadata.\n   * If yes: call the abstract getIterations method, if not: return Infinity.\n   * @param {IActionRdfJoin} action The input action containing the relevant iterators\n   * @returns {Promise<IMediatorTypeIterations>} The calculated estime.\n   */\n\n\n  async test(action) {\n    // Allow joining of one or zero streams\n    if (action.entries.length <= 1) {\n      return {\n        iterations: 0\n      };\n    } // Check if this actor can handle the given number of streams\n\n\n    if (this.limitEntriesMin ? action.entries.length < this.limitEntries : action.entries.length > this.limitEntries) {\n      throw new Error(`${this.name} requires ${this.limitEntries} sources at ${this.limitEntriesMin ? 'least' : 'most'}. The input contained ${action.entries.length}.`);\n    } // Check if all streams are bindings streams\n\n\n    for (const entry of action.entries) {\n      if (entry.type !== 'bindings') {\n        throw new Error(`Invalid type of a join entry: Expected 'bindings' but got '${entry.type}'`);\n      }\n    } // Check if this actor can handle undefs\n\n\n    if (!this.canHandleUndefs) {\n      for (const entry of action.entries) {\n        if (entry.canContainUndefs) {\n          throw new Error(`Actor ${this.name} can not join streams containing undefs`);\n        }\n      }\n    }\n\n    if (!(await ActorRdfJoin.iteratorsHaveMetadata(action, 'totalItems'))) {\n      return {\n        iterations: Number.POSITIVE_INFINITY\n      };\n    }\n\n    return {\n      iterations: await this.getIterations(action)\n    };\n  }\n  /**\n   * Returns default input for 0 or 1 entries. Calls the getOutput function otherwise\n   * @param {IActionRdfJoin} action\n   * @returns {Promise<IActorQueryOperationOutput>}\n   */\n\n\n  async run(action) {\n    if (action.entries.length === 0) {\n      return {\n        bindingsStream: new asynciterator_1.ArrayIterator([], {\n          autoStart: false\n        }),\n        metadata: () => Promise.resolve({\n          totalItems: 0\n        }),\n        type: 'bindings',\n        variables: [],\n        canContainUndefs: false\n      };\n    }\n\n    if (action.entries.length === 1) {\n      return action.entries[0];\n    }\n\n    const result = this.getOutput(action);\n\n    function totalItems() {\n      return Promise.all(action.entries.map(entry => entry.metadata())).then(metadatas => metadatas.reduce((acc, val) => acc * val.totalItems, 1));\n    }\n\n    if (await ActorRdfJoin.iteratorsHaveMetadata(action, 'totalItems')) {\n      // Update the result promise to also add the estimated total items\n      const unwrapped = await result;\n\n      if (unwrapped.metadata) {\n        const oldMetadata = unwrapped.metadata;\n\n        unwrapped.metadata = () => oldMetadata().then(async metadata => {\n          // Don't overwrite metadata if it was generated by implementation\n          if (!('totalItems' in metadata)) {\n            metadata.totalItems = await totalItems();\n          }\n\n          return metadata;\n        });\n      } else {\n        unwrapped.metadata = () => totalItems().then(totalItemsValue => ({\n          totalItems: totalItemsValue\n        }));\n      }\n\n      return unwrapped;\n    }\n\n    return result;\n  }\n\n}\n\nexports.ActorRdfJoin = ActorRdfJoin;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/bus-rdf-join/lib/ActorRdfJoin.js"],"names":["Object","defineProperty","exports","value","ActorRdfJoin","core_1","require","asynciterator_1","Actor","constructor","args","limitEntries","limitEntriesMin","canHandleUndefs","Number","POSITIVE_INFINITY","overlappingVariables","action","variables","entries","map","entry","baseArray","array","slice","filter","el","includes","joinVariables","withDuplicates","reduce","acc","it","Set","join","bindings","val","mergeWith","left","right","equals","Error","_a","iteratorsHaveMetadata","key","Promise","all","metadata","then","catch","test","length","iterations","name","type","canContainUndefs","getIterations","run","bindingsStream","ArrayIterator","autoStart","resolve","totalItems","result","getOutput","metadatas","unwrapped","oldMetadata","totalItemsValue"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorRdfJoin = void 0;\nconst core_1 = require(\"@comunica/core\");\nconst asynciterator_1 = require(\"asynciterator\");\n/**\n * A comunica actor for joining 2 binding streams.\n *\n * Actor types:\n * * Input:  IActionRdfJoin:      The streams that need to be joined.\n * * Test:   <none>\n * * Output: IActorRdfJoinOutput: The resulting joined stream.\n *\n * @see IActionRdfJoin\n * @see IActorQueryOperationOutput\n */\nclass ActorRdfJoin extends core_1.Actor {\n    constructor(args, limitEntries, limitEntriesMin, canHandleUndefs) {\n        super(args);\n        this.limitEntries = limitEntries !== null && limitEntries !== void 0 ? limitEntries : Number.POSITIVE_INFINITY;\n        this.limitEntriesMin = limitEntriesMin !== null && limitEntriesMin !== void 0 ? limitEntriesMin : false;\n        this.canHandleUndefs = canHandleUndefs !== null && canHandleUndefs !== void 0 ? canHandleUndefs : false;\n    }\n    /**\n     * Returns an array containing all the variable names that occur in all bindings streams.\n     * @param {IActionRdfJoin} action\n     * @returns {string[]}\n     */\n    static overlappingVariables(action) {\n        const variables = action.entries.map(entry => entry.variables);\n        let baseArray = variables[0];\n        for (const array of variables.slice(1)) {\n            baseArray = baseArray.filter(el => array.includes(el));\n        }\n        return baseArray;\n    }\n    /**\n     * Returns the variables that will occur in the joined bindings.\n     * @param {IActionRdfJoin} action\n     * @returns {string[]}\n     */\n    static joinVariables(action) {\n        const variables = action.entries.map(entry => entry.variables);\n        const withDuplicates = variables.reduce((acc, it) => [...acc, ...it], []);\n        return [...new Set(withDuplicates)];\n    }\n    /**\n     * Returns the result of joining bindings, or `null` if no join is possible.\n     * @param {Bindings[]} bindings\n     * @returns {Bindings}\n     */\n    static join(...bindings) {\n        try {\n            return bindings.reduce((acc, val) => acc.mergeWith((left, right) => {\n                if (!left.equals(right)) {\n                    throw new Error('Join failure');\n                }\n                return left;\n            }, val));\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n    /**\n     * Checks if all metadata objects are present in the action, and if they have the specified key.\n     * @param {IActionRdfJoin} action\n     * @param {string} key\n     * @returns {boolean}\n     */\n    static async iteratorsHaveMetadata(action, key) {\n        return Promise.all(action.entries.map(async (entry) => {\n            if (!entry.metadata) {\n                throw new Error('Missing metadata');\n            }\n            const metadata = await entry.metadata();\n            if (!(key in metadata)) {\n                throw new Error('Missing metadata value');\n            }\n        })).then(() => true).catch(() => false);\n    }\n    /**\n     * Default test function for join actors.\n     * Checks whether all iterators have metadata.\n     * If yes: call the abstract getIterations method, if not: return Infinity.\n     * @param {IActionRdfJoin} action The input action containing the relevant iterators\n     * @returns {Promise<IMediatorTypeIterations>} The calculated estime.\n     */\n    async test(action) {\n        // Allow joining of one or zero streams\n        if (action.entries.length <= 1) {\n            return { iterations: 0 };\n        }\n        // Check if this actor can handle the given number of streams\n        if (this.limitEntriesMin ? action.entries.length < this.limitEntries : action.entries.length > this.limitEntries) {\n            throw new Error(`${this.name} requires ${this.limitEntries} sources at ${this.limitEntriesMin ? 'least' : 'most'}. The input contained ${action.entries.length}.`);\n        }\n        // Check if all streams are bindings streams\n        for (const entry of action.entries) {\n            if (entry.type !== 'bindings') {\n                throw new Error(`Invalid type of a join entry: Expected 'bindings' but got '${entry.type}'`);\n            }\n        }\n        // Check if this actor can handle undefs\n        if (!this.canHandleUndefs) {\n            for (const entry of action.entries) {\n                if (entry.canContainUndefs) {\n                    throw new Error(`Actor ${this.name} can not join streams containing undefs`);\n                }\n            }\n        }\n        if (!await ActorRdfJoin.iteratorsHaveMetadata(action, 'totalItems')) {\n            return { iterations: Number.POSITIVE_INFINITY };\n        }\n        return { iterations: await this.getIterations(action) };\n    }\n    /**\n     * Returns default input for 0 or 1 entries. Calls the getOutput function otherwise\n     * @param {IActionRdfJoin} action\n     * @returns {Promise<IActorQueryOperationOutput>}\n     */\n    async run(action) {\n        if (action.entries.length === 0) {\n            return {\n                bindingsStream: new asynciterator_1.ArrayIterator([], { autoStart: false }),\n                metadata: () => Promise.resolve({ totalItems: 0 }),\n                type: 'bindings',\n                variables: [],\n                canContainUndefs: false,\n            };\n        }\n        if (action.entries.length === 1) {\n            return action.entries[0];\n        }\n        const result = this.getOutput(action);\n        function totalItems() {\n            return Promise.all(action.entries\n                .map(entry => entry.metadata()))\n                .then(metadatas => metadatas.reduce((acc, val) => acc * val.totalItems, 1));\n        }\n        if (await ActorRdfJoin.iteratorsHaveMetadata(action, 'totalItems')) {\n            // Update the result promise to also add the estimated total items\n            const unwrapped = await result;\n            if (unwrapped.metadata) {\n                const oldMetadata = unwrapped.metadata;\n                unwrapped.metadata = () => oldMetadata().then(async (metadata) => {\n                    // Don't overwrite metadata if it was generated by implementation\n                    if (!('totalItems' in metadata)) {\n                        metadata.totalItems = await totalItems();\n                    }\n                    return metadata;\n                });\n            }\n            else {\n                unwrapped.metadata = () => totalItems().then(totalItemsValue => ({ totalItems: totalItemsValue }));\n            }\n            return unwrapped;\n        }\n        return result;\n    }\n}\nexports.ActorRdfJoin = ActorRdfJoin;\n//# sourceMappingURL=ActorRdfJoin.js.map"]},"metadata":{},"sourceType":"script"}