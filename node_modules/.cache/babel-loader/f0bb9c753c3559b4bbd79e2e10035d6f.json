{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContainerHandlerLanguage = void 0;\n\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * Container handler for @language.\n *\n * It assumes that the current key is the language of the current value.\n * This will add this value to the parent node.\n */\n\n\nclass ContainerHandlerLanguage {\n  canCombineWithGraph() {\n    return false;\n  }\n\n  async handle(containers, parsingContext, util, keys, value, depth) {\n    const language = await util.getContainerKey(keys[depth], keys, depth);\n\n    if (Array.isArray(value)) {\n      // No type-checking needed, will be handled on each value when this handler is called recursively.\n      value = value.map(subValue => ({\n        '@value': subValue,\n        '@language': language\n      }));\n    } else {\n      if (typeof value !== 'string') {\n        throw new jsonld_context_parser_1.ErrorCoded(`Got invalid language map value, got '${JSON.stringify(value)}', but expected string`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);\n      }\n\n      value = {\n        '@value': value,\n        '@language': language\n      };\n    }\n\n    await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n    parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n  }\n\n}\n\nexports.ContainerHandlerLanguage = ContainerHandlerLanguage;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerLanguage.js"],"names":["Object","defineProperty","exports","value","ContainerHandlerLanguage","jsonld_context_parser_1","require","canCombineWithGraph","handle","containers","parsingContext","util","keys","depth","language","getContainerKey","Array","isArray","map","subValue","ErrorCoded","JSON","stringify","ERROR_CODES","INVALID_LANGUAGE_MAP_VALUE","newOnValueJob","slice","length","emittedStack"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,wBAAR,GAAmC,KAAK,CAAxC;;AACA,MAAMC,uBAAuB,GAAGC,OAAO,CAAC,uBAAD,CAAvC;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMF,wBAAN,CAA+B;AAC3BG,EAAAA,mBAAmB,GAAG;AAClB,WAAO,KAAP;AACH;;AACW,QAANC,MAAM,CAACC,UAAD,EAAaC,cAAb,EAA6BC,IAA7B,EAAmCC,IAAnC,EAAyCT,KAAzC,EAAgDU,KAAhD,EAAuD;AAC/D,UAAMC,QAAQ,GAAG,MAAMH,IAAI,CAACI,eAAL,CAAqBH,IAAI,CAACC,KAAD,CAAzB,EAAkCD,IAAlC,EAAwCC,KAAxC,CAAvB;;AACA,QAAIG,KAAK,CAACC,OAAN,CAAcd,KAAd,CAAJ,EAA0B;AACtB;AACAA,MAAAA,KAAK,GAAGA,KAAK,CAACe,GAAN,CAAWC,QAAD,KAAe;AAAE,kBAAUA,QAAZ;AAAsB,qBAAaL;AAAnC,OAAf,CAAV,CAAR;AACH,KAHD,MAIK;AACD,UAAI,OAAOX,KAAP,KAAiB,QAArB,EAA+B;AAC3B,cAAM,IAAIE,uBAAuB,CAACe,UAA5B,CAAwC,wCAAuCC,IAAI,CAACC,SAAL,CAAenB,KAAf,CAAsB,wBAArG,EAA8HE,uBAAuB,CAACkB,WAAxB,CAAoCC,0BAAlK,CAAN;AACH;;AACDrB,MAAAA,KAAK,GAAG;AAAE,kBAAUA,KAAZ;AAAmB,qBAAaW;AAAhC,OAAR;AACH;;AACD,UAAMJ,cAAc,CAACe,aAAf,CAA6Bb,IAAI,CAACc,KAAL,CAAW,CAAX,EAAcd,IAAI,CAACe,MAAL,GAAc,CAA5B,CAA7B,EAA6DxB,KAA7D,EAAoEU,KAAK,GAAG,CAA5E,EAA+E,IAA/E,CAAN;AACAH,IAAAA,cAAc,CAACkB,YAAf,CAA4Bf,KAA5B,IAAqC,KAArC,CAb+D,CAanB;AAC/C;;AAlB0B;;AAoB/BX,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerLanguage = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * Container handler for @language.\n *\n * It assumes that the current key is the language of the current value.\n * This will add this value to the parent node.\n */\nclass ContainerHandlerLanguage {\n    canCombineWithGraph() {\n        return false;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        const language = await util.getContainerKey(keys[depth], keys, depth);\n        if (Array.isArray(value)) {\n            // No type-checking needed, will be handled on each value when this handler is called recursively.\n            value = value.map((subValue) => ({ '@value': subValue, '@language': language }));\n        }\n        else {\n            if (typeof value !== 'string') {\n                throw new jsonld_context_parser_1.ErrorCoded(`Got invalid language map value, got '${JSON.stringify(value)}', but expected string`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);\n            }\n            value = { '@value': value, '@language': language };\n        }\n        await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n        parsingContext.emittedStack[depth] = false; // We have emitted a level higher\n    }\n}\nexports.ContainerHandlerLanguage = ContainerHandlerLanguage;\n//# sourceMappingURL=ContainerHandlerLanguage.js.map"]},"metadata":{},"sourceType":"script"}