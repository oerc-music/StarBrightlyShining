{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LinkedRdfSourcesAsyncRdfIterator = void 0;\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst LRUCache = require(\"lru-cache\");\n\nclass LinkedRdfSourcesAsyncRdfIterator extends asynciterator_1.BufferedIterator {\n  constructor(cacheSize, subject, predicate, object, graph, firstUrl) {\n    super({\n      autoStart: true\n    });\n    this.started = false;\n    this.cacheSize = cacheSize;\n    this.subject = subject;\n    this.predicate = predicate;\n    this.object = object;\n    this.graph = graph;\n    this.firstUrl = firstUrl;\n  }\n  /**\n   * This method can optionally called after constructing an instance\n   * for allowing the sources state to be cached.\n   *\n   * When calling without args, then the default logic will be followed to determine the sources state.\n   * When calling with an arg, then the given sources state will be set instead of following the default logic.\n   *\n   * After calling this method, the `sourcesState` field can be retrieved and optionally cached.\n   *\n   * This sources state also contains a hash of all handled datasets that will be copied upon first use.\n   *\n   * @param {ISourcesState} sourcesState An optional sources state.\n   */\n\n\n  setSourcesState(sourcesState) {\n    if (sourcesState) {\n      this.sourcesState = sourcesState;\n    } else {\n      this.sourcesState = {\n        sources: new LRUCache({\n          max: this.cacheSize\n        })\n      }; // Ignore the response, we just want the promise to be cached\n\n      this.getSourceCached({\n        url: this.firstUrl\n      }, {}).catch(error => this.destroy(error));\n    }\n  }\n  /**\n   * Resolve a source for the given URL.\n   * This will first try to retrieve the source from cache.\n   * @param link A source ILink.\n   * @param handledDatasets A hash of dataset identifiers that have already been handled.\n   */\n\n\n  getSourceCached(link, handledDatasets) {\n    let source = this.sourcesState.sources.get(link.url);\n\n    if (source) {\n      return source;\n    }\n\n    source = this.getSource(link, handledDatasets);\n    this.sourcesState.sources.set(link.url, source);\n    return source;\n  }\n\n  _read(count, done) {\n    if (!this.started) {\n      // The first time this is called, prepare the first source\n      this.started = true; // Create a sources state if needed (can be defined if set from actor cache)\n\n      if (!this.sourcesState) {\n        this.setSourcesState();\n      } // Await the source to be set, and start the source iterator\n\n\n      this.getSourceCached({\n        url: this.firstUrl\n      }, {}).then(sourceState => {\n        this.setCurrentIterator(sourceState, true);\n        done();\n      }).catch(error => {\n        // We can safely ignore this error, since it handled in setSourcesState\n        done();\n      });\n    } else if (this.currentIterator) {\n      // If an iterator has been set, read from it.\n      while (count > 0) {\n        const read = this.currentIterator.read();\n\n        if (read !== null) {\n          count--;\n\n          this._push(read);\n        } else {\n          break;\n        }\n      }\n\n      done();\n    } else {\n      // This can occur during source loading.\n      done();\n    }\n  }\n  /**\n   * Start a new iterator for the given source.\n   * Once the iterator is done, it will either determine a new source, or it will close the linked iterator.\n   * @param {ISourceState} startSource The start source state.\n   * @param {boolean} emitMetadata If the metadata event should be emitted.\n   */\n\n\n  setCurrentIterator(startSource, emitMetadata) {\n    // Delegate the quad pattern query to the given source\n    this.currentIterator = startSource.source.match(this.subject, this.predicate, this.object, this.graph);\n    let receivedMetadata = false; // Attach readers to the newly created iterator\n\n    this.currentIterator._destination = this;\n    this.currentIterator.on('error', error => this.destroy(error));\n    this.currentIterator.on('readable', () => this._fillBuffer());\n    this.currentIterator.on('end', () => {\n      this.currentIterator = undefined; // If the metadata was already received, handle the next URL in the queue\n\n      if (receivedMetadata) {\n        this.handleNextUrl(startSource);\n      }\n    }); // Listen for the metadata of the source\n    // The metadata property is guaranteed to be set\n\n    this.currentIterator.getProperty('metadata', metadata => {\n      startSource.metadata = Object.assign(Object.assign({}, startSource.metadata), metadata); // Emit metadata if needed\n\n      if (emitMetadata) {\n        this.setProperty('metadata', startSource.metadata);\n      } // Determine next urls, which will eventually become a next-next source.\n\n\n      this.getSourceLinks(startSource.metadata).then(nextUrls => Promise.all(nextUrls)).then(async nextUrls => {\n        // Append all next URLs to our queue\n        const linkQueue = await this.getLinkQueue();\n\n        for (const nextUrl of nextUrls) {\n          linkQueue.push(nextUrl, startSource.link);\n        } // Handle the next queued URL if we don't have an active iterator (in which case it will be called later)\n\n\n        receivedMetadata = true;\n\n        if (!this.currentIterator) {\n          this.handleNextUrl(startSource);\n        }\n      }).catch(error => this.destroy(error));\n    });\n  }\n  /**\n   * Check if a next URL is in the queue.\n   * If yes, start a new iterator.\n   * If no, close this iterator.\n   * @param startSource\n   */\n\n\n  handleNextUrl(startSource) {\n    this.getLinkQueue().then(linkQueue => {\n      const nextLink = linkQueue.pop();\n\n      if (!nextLink) {\n        this.close();\n      } else {\n        this.getSourceCached(nextLink, startSource.handledDatasets).then(nextSourceState => this.setCurrentIterator(nextSourceState, false)).catch(error => this.destroy(error));\n      }\n    }).catch(error => this.destroy(error));\n  }\n\n}\n\nexports.LinkedRdfSourcesAsyncRdfIterator = LinkedRdfSourcesAsyncRdfIterator;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-rdf-resolve-quad-pattern-hypermedia/lib/LinkedRdfSourcesAsyncRdfIterator.js"],"names":["Object","defineProperty","exports","value","LinkedRdfSourcesAsyncRdfIterator","asynciterator_1","require","LRUCache","BufferedIterator","constructor","cacheSize","subject","predicate","object","graph","firstUrl","autoStart","started","setSourcesState","sourcesState","sources","max","getSourceCached","url","catch","error","destroy","link","handledDatasets","source","get","getSource","set","_read","count","done","then","sourceState","setCurrentIterator","currentIterator","read","_push","startSource","emitMetadata","match","receivedMetadata","_destination","on","_fillBuffer","undefined","handleNextUrl","getProperty","metadata","assign","setProperty","getSourceLinks","nextUrls","Promise","all","linkQueue","getLinkQueue","nextUrl","push","nextLink","pop","close","nextSourceState"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkedRdfSourcesAsyncRdfIterator = void 0;\nconst asynciterator_1 = require(\"asynciterator\");\nconst LRUCache = require(\"lru-cache\");\nclass LinkedRdfSourcesAsyncRdfIterator extends asynciterator_1.BufferedIterator {\n    constructor(cacheSize, subject, predicate, object, graph, firstUrl) {\n        super({ autoStart: true });\n        this.started = false;\n        this.cacheSize = cacheSize;\n        this.subject = subject;\n        this.predicate = predicate;\n        this.object = object;\n        this.graph = graph;\n        this.firstUrl = firstUrl;\n    }\n    /**\n     * This method can optionally called after constructing an instance\n     * for allowing the sources state to be cached.\n     *\n     * When calling without args, then the default logic will be followed to determine the sources state.\n     * When calling with an arg, then the given sources state will be set instead of following the default logic.\n     *\n     * After calling this method, the `sourcesState` field can be retrieved and optionally cached.\n     *\n     * This sources state also contains a hash of all handled datasets that will be copied upon first use.\n     *\n     * @param {ISourcesState} sourcesState An optional sources state.\n     */\n    setSourcesState(sourcesState) {\n        if (sourcesState) {\n            this.sourcesState = sourcesState;\n        }\n        else {\n            this.sourcesState = {\n                sources: new LRUCache({ max: this.cacheSize }),\n            };\n            // Ignore the response, we just want the promise to be cached\n            this.getSourceCached({ url: this.firstUrl }, {})\n                .catch(error => this.destroy(error));\n        }\n    }\n    /**\n     * Resolve a source for the given URL.\n     * This will first try to retrieve the source from cache.\n     * @param link A source ILink.\n     * @param handledDatasets A hash of dataset identifiers that have already been handled.\n     */\n    getSourceCached(link, handledDatasets) {\n        let source = this.sourcesState.sources.get(link.url);\n        if (source) {\n            return source;\n        }\n        source = this.getSource(link, handledDatasets);\n        this.sourcesState.sources.set(link.url, source);\n        return source;\n    }\n    _read(count, done) {\n        if (!this.started) {\n            // The first time this is called, prepare the first source\n            this.started = true;\n            // Create a sources state if needed (can be defined if set from actor cache)\n            if (!this.sourcesState) {\n                this.setSourcesState();\n            }\n            // Await the source to be set, and start the source iterator\n            this.getSourceCached({ url: this.firstUrl }, {})\n                .then(sourceState => {\n                this.setCurrentIterator(sourceState, true);\n                done();\n            })\n                .catch(error => {\n                // We can safely ignore this error, since it handled in setSourcesState\n                done();\n            });\n        }\n        else if (this.currentIterator) {\n            // If an iterator has been set, read from it.\n            while (count > 0) {\n                const read = this.currentIterator.read();\n                if (read !== null) {\n                    count--;\n                    this._push(read);\n                }\n                else {\n                    break;\n                }\n            }\n            done();\n        }\n        else {\n            // This can occur during source loading.\n            done();\n        }\n    }\n    /**\n     * Start a new iterator for the given source.\n     * Once the iterator is done, it will either determine a new source, or it will close the linked iterator.\n     * @param {ISourceState} startSource The start source state.\n     * @param {boolean} emitMetadata If the metadata event should be emitted.\n     */\n    setCurrentIterator(startSource, emitMetadata) {\n        // Delegate the quad pattern query to the given source\n        this.currentIterator = startSource.source\n            .match(this.subject, this.predicate, this.object, this.graph);\n        let receivedMetadata = false;\n        // Attach readers to the newly created iterator\n        this.currentIterator._destination = this;\n        this.currentIterator.on('error', (error) => this.destroy(error));\n        this.currentIterator.on('readable', () => this._fillBuffer());\n        this.currentIterator.on('end', () => {\n            this.currentIterator = undefined;\n            // If the metadata was already received, handle the next URL in the queue\n            if (receivedMetadata) {\n                this.handleNextUrl(startSource);\n            }\n        });\n        // Listen for the metadata of the source\n        // The metadata property is guaranteed to be set\n        this.currentIterator.getProperty('metadata', (metadata) => {\n            startSource.metadata = Object.assign(Object.assign({}, startSource.metadata), metadata);\n            // Emit metadata if needed\n            if (emitMetadata) {\n                this.setProperty('metadata', startSource.metadata);\n            }\n            // Determine next urls, which will eventually become a next-next source.\n            this.getSourceLinks(startSource.metadata)\n                .then((nextUrls) => Promise.all(nextUrls))\n                .then(async (nextUrls) => {\n                // Append all next URLs to our queue\n                const linkQueue = await this.getLinkQueue();\n                for (const nextUrl of nextUrls) {\n                    linkQueue.push(nextUrl, startSource.link);\n                }\n                // Handle the next queued URL if we don't have an active iterator (in which case it will be called later)\n                receivedMetadata = true;\n                if (!this.currentIterator) {\n                    this.handleNextUrl(startSource);\n                }\n            }).catch(error => this.destroy(error));\n        });\n    }\n    /**\n     * Check if a next URL is in the queue.\n     * If yes, start a new iterator.\n     * If no, close this iterator.\n     * @param startSource\n     */\n    handleNextUrl(startSource) {\n        this.getLinkQueue()\n            .then(linkQueue => {\n            const nextLink = linkQueue.pop();\n            if (!nextLink) {\n                this.close();\n            }\n            else {\n                this.getSourceCached(nextLink, startSource.handledDatasets)\n                    .then(nextSourceState => this.setCurrentIterator(nextSourceState, false))\n                    .catch(error => this.destroy(error));\n            }\n        })\n            .catch(error => this.destroy(error));\n    }\n}\nexports.LinkedRdfSourcesAsyncRdfIterator = LinkedRdfSourcesAsyncRdfIterator;\n//# sourceMappingURL=LinkedRdfSourcesAsyncRdfIterator.js.map"]},"metadata":{},"sourceType":"script"}