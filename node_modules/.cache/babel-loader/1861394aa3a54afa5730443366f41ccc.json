{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeHandlerAdapter = void 0;\n/**\n * A handler for converting GraphQL nodes to operations.\n */\n\nclass NodeHandlerAdapter {\n  constructor(targetKind, util, settings) {\n    this.targetKind = targetKind;\n    this.util = util;\n    this.settings = settings;\n  }\n  /* ----- Node quad context ----- */\n\n  /**\n   * Get the quad context of a selection set node that should be used for the whole definition node.\n   *\n   * This is a pre-processing step of selection sets.\n   * Its only purpose is to determine the subject within a selection set,\n   * because this subject is needed to link with its parent.\n   * In a later phase, the selection set will be processed using the discovered subject,\n   * and the field identifying the subject will be ignored.\n   *\n   * @param {SelectionSetNode} selectionSet A selection set node.\n   * @param {string} fieldLabel A field label.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {INodeQuadContext} The subject, graph and auxiliary patterns.\n   */\n\n\n  getNodeQuadContextSelectionSet(selectionSet, fieldLabel, convertContext) {\n    const nodeQuadContext = {};\n\n    if (selectionSet) {\n      for (const selectionNode of selectionSet.selections) {\n        if (selectionNode.kind === 'Field') {\n          const fieldNode = selectionNode;\n          this.handleNodeQuadContextField(fieldNode, convertContext, nodeQuadContext, 'id', 'subject');\n          this.handleNodeQuadContextField(fieldNode, convertContext, nodeQuadContext, 'graph', 'graph');\n        }\n      }\n    }\n\n    return nodeQuadContext;\n  }\n  /**\n   * Handles a single field for determining the node quad context.\n   * @param {FieldNode} fieldNode A field node.\n   * @param {IConvertContext} convertContext A convert context.\n   * @param {INodeQuadContext} nodeQuadContext The node quad context to populate.\n   * @param {string} fieldName The field name to check for.\n   * @param {'subject' | 'graph'} nodeQuadContextKey The key to fill into the node quad context.\n   */\n\n\n  handleNodeQuadContextField(fieldNode, convertContext, nodeQuadContext, fieldName, nodeQuadContextKey) {\n    if (!nodeQuadContext[nodeQuadContextKey] && fieldNode.name.value === fieldName) {\n      // Get (or set) the nodeQuadContextKey for fieldName fields\n      if (!nodeQuadContext[nodeQuadContextKey]) {\n        const argument = this.util.getArgument(fieldNode.arguments, '_');\n\n        if (argument) {\n          const valueOutput = this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n\n          if (valueOutput.terms.length !== 1) {\n            throw new Error(`Only single values can be set as ${fieldName}, but got ${valueOutput.terms.length} at ${fieldNode.name.value}`);\n          }\n\n          nodeQuadContext[nodeQuadContextKey] = valueOutput.terms[0];\n\n          if (valueOutput.auxiliaryPatterns) {\n            if (!nodeQuadContext.auxiliaryPatterns) {\n              nodeQuadContext.auxiliaryPatterns = [];\n            }\n\n            nodeQuadContext.auxiliaryPatterns.concat(valueOutput.auxiliaryPatterns);\n          }\n        }\n      }\n\n      if (!nodeQuadContext[nodeQuadContextKey]) {\n        const term = this.util.nameToVariable(this.util.getFieldLabel(fieldNode), convertContext);\n        convertContext.terminalVariables.push(term);\n        nodeQuadContext[nodeQuadContextKey] = term;\n      }\n    }\n  }\n  /* ----- Directives ----- */\n\n  /**\n   * Get an operation override defined by one of the directives.\n   *\n   * This should be called before a sub-operation is handled.\n   *\n   * @param {ReadonlyArray<DirectiveNode>} directives An option directives array.\n   * @param {string} fieldLabel The current field label.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {IDirectiveNodeHandlerOutput[]} The directive node handler outputs, or null if it should be ignored.\n   */\n\n\n  getDirectiveOutputs(directives, fieldLabel, convertContext) {\n    const outputs = [];\n\n    if (directives) {\n      for (const directive of directives) {\n        const output = this.util.handleDirectiveNode({\n          directive,\n          fieldLabel\n        }, convertContext);\n\n        if (output) {\n          if (output.ignore) {\n            return null;\n          }\n\n          outputs.push(output);\n        }\n      }\n    }\n\n    return outputs;\n  }\n  /**\n   * Handle the directive outputs with respect to an operation.\n   *\n   * This should be called after a sub-operation was handled.\n   *\n   * @param {IDirectiveNodeHandlerOutput[]} directiveOutputs\n   * @param {Operation} operation\n   * @return {Operation}\n   */\n\n\n  handleDirectiveOutputs(directiveOutputs, operation) {\n    for (const directiveOutput of directiveOutputs) {\n      if (directiveOutput.ignore) {\n        return this.util.operationFactory.createBgp([]);\n      }\n\n      if (directiveOutput.operationOverrider) {\n        operation = directiveOutput.operationOverrider(operation);\n      }\n    }\n\n    return operation;\n  }\n\n}\n\nexports.NodeHandlerAdapter = NodeHandlerAdapter;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/graphql-to-sparql/lib/handler/NodeHandlerAdapter.js"],"names":["Object","defineProperty","exports","value","NodeHandlerAdapter","constructor","targetKind","util","settings","getNodeQuadContextSelectionSet","selectionSet","fieldLabel","convertContext","nodeQuadContext","selectionNode","selections","kind","fieldNode","handleNodeQuadContextField","fieldName","nodeQuadContextKey","name","argument","getArgument","arguments","valueOutput","handleNodeValue","terms","length","Error","auxiliaryPatterns","concat","term","nameToVariable","getFieldLabel","terminalVariables","push","getDirectiveOutputs","directives","outputs","directive","output","handleDirectiveNode","ignore","handleDirectiveOutputs","directiveOutputs","operation","directiveOutput","operationFactory","createBgp","operationOverrider"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NodeHandlerAdapter = void 0;\n/**\n * A handler for converting GraphQL nodes to operations.\n */\nclass NodeHandlerAdapter {\n    constructor(targetKind, util, settings) {\n        this.targetKind = targetKind;\n        this.util = util;\n        this.settings = settings;\n    }\n    /* ----- Node quad context ----- */\n    /**\n     * Get the quad context of a selection set node that should be used for the whole definition node.\n     *\n     * This is a pre-processing step of selection sets.\n     * Its only purpose is to determine the subject within a selection set,\n     * because this subject is needed to link with its parent.\n     * In a later phase, the selection set will be processed using the discovered subject,\n     * and the field identifying the subject will be ignored.\n     *\n     * @param {SelectionSetNode} selectionSet A selection set node.\n     * @param {string} fieldLabel A field label.\n     * @param {IConvertContext} convertContext A convert context.\n     * @return {INodeQuadContext} The subject, graph and auxiliary patterns.\n     */\n    getNodeQuadContextSelectionSet(selectionSet, fieldLabel, convertContext) {\n        const nodeQuadContext = {};\n        if (selectionSet) {\n            for (const selectionNode of selectionSet.selections) {\n                if (selectionNode.kind === 'Field') {\n                    const fieldNode = selectionNode;\n                    this.handleNodeQuadContextField(fieldNode, convertContext, nodeQuadContext, 'id', 'subject');\n                    this.handleNodeQuadContextField(fieldNode, convertContext, nodeQuadContext, 'graph', 'graph');\n                }\n            }\n        }\n        return nodeQuadContext;\n    }\n    /**\n     * Handles a single field for determining the node quad context.\n     * @param {FieldNode} fieldNode A field node.\n     * @param {IConvertContext} convertContext A convert context.\n     * @param {INodeQuadContext} nodeQuadContext The node quad context to populate.\n     * @param {string} fieldName The field name to check for.\n     * @param {'subject' | 'graph'} nodeQuadContextKey The key to fill into the node quad context.\n     */\n    handleNodeQuadContextField(fieldNode, convertContext, nodeQuadContext, fieldName, nodeQuadContextKey) {\n        if (!nodeQuadContext[nodeQuadContextKey] && fieldNode.name.value === fieldName) {\n            // Get (or set) the nodeQuadContextKey for fieldName fields\n            if (!nodeQuadContext[nodeQuadContextKey]) {\n                const argument = this.util.getArgument(fieldNode.arguments, '_');\n                if (argument) {\n                    const valueOutput = this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n                    if (valueOutput.terms.length !== 1) {\n                        throw new Error(`Only single values can be set as ${fieldName}, but got ${valueOutput.terms\n                            .length} at ${fieldNode.name.value}`);\n                    }\n                    nodeQuadContext[nodeQuadContextKey] = valueOutput.terms[0];\n                    if (valueOutput.auxiliaryPatterns) {\n                        if (!nodeQuadContext.auxiliaryPatterns) {\n                            nodeQuadContext.auxiliaryPatterns = [];\n                        }\n                        nodeQuadContext.auxiliaryPatterns.concat(valueOutput.auxiliaryPatterns);\n                    }\n                }\n            }\n            if (!nodeQuadContext[nodeQuadContextKey]) {\n                const term = this.util.nameToVariable(this.util.getFieldLabel(fieldNode), convertContext);\n                convertContext.terminalVariables.push(term);\n                nodeQuadContext[nodeQuadContextKey] = term;\n            }\n        }\n    }\n    /* ----- Directives ----- */\n    /**\n     * Get an operation override defined by one of the directives.\n     *\n     * This should be called before a sub-operation is handled.\n     *\n     * @param {ReadonlyArray<DirectiveNode>} directives An option directives array.\n     * @param {string} fieldLabel The current field label.\n     * @param {IConvertContext} convertContext A convert context.\n     * @return {IDirectiveNodeHandlerOutput[]} The directive node handler outputs, or null if it should be ignored.\n     */\n    getDirectiveOutputs(directives, fieldLabel, convertContext) {\n        const outputs = [];\n        if (directives) {\n            for (const directive of directives) {\n                const output = this.util.handleDirectiveNode({ directive, fieldLabel }, convertContext);\n                if (output) {\n                    if (output.ignore) {\n                        return null;\n                    }\n                    outputs.push(output);\n                }\n            }\n        }\n        return outputs;\n    }\n    /**\n     * Handle the directive outputs with respect to an operation.\n     *\n     * This should be called after a sub-operation was handled.\n     *\n     * @param {IDirectiveNodeHandlerOutput[]} directiveOutputs\n     * @param {Operation} operation\n     * @return {Operation}\n     */\n    handleDirectiveOutputs(directiveOutputs, operation) {\n        for (const directiveOutput of directiveOutputs) {\n            if (directiveOutput.ignore) {\n                return this.util.operationFactory.createBgp([]);\n            }\n            if (directiveOutput.operationOverrider) {\n                operation = directiveOutput.operationOverrider(operation);\n            }\n        }\n        return operation;\n    }\n}\nexports.NodeHandlerAdapter = NodeHandlerAdapter;\n//# sourceMappingURL=NodeHandlerAdapter.js.map"]},"metadata":{},"sourceType":"script"}