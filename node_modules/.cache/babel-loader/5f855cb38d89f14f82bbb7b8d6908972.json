{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.namedDefinitions = void 0;\n\nconst immutable_1 = require(\"immutable\");\n\nconst Err = require(\"../util/Errors\");\n\nconst Consts_1 = require(\"../util/Consts\");\n\nconst Parsing_1 = require(\"../util/Parsing\");\n\nconst Helpers_1 = require(\"./Helpers\"); // ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// Begin definitions.\n// ----------------------------------------------------------------------------\n// XPath Constructor functions\n// https://www.w3.org/TR/sparql11-query/#\n// https://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive\n// ----------------------------------------------------------------------------\n\n\nconst toString = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(val => Helpers_1.string(Helpers_1.number(val.typedValue).str())).onBoolean1Typed(val => Helpers_1.string(Helpers_1.bool(val).str())).onTerm1(val => Helpers_1.string(val.str())).collect()\n};\nconst toFloat = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(val => Helpers_1.number(val.typedValue)).onBoolean1Typed(val => Helpers_1.number(val ? 1 : 0)).onUnary('string', val => {\n    const result = Parsing_1.parseXSDFloat(val.str());\n\n    if (result === undefined) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_FLOAT);\n    }\n\n    return Helpers_1.number(result);\n  }).copy({\n    from: ['string'],\n    to: ['nonlexical']\n  }).collect()\n};\nconst toDouble = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(val => Helpers_1.number(val.typedValue, Consts_1.TypeURL.XSD_DOUBLE)).onBoolean1Typed(val => Helpers_1.number(val ? 1 : 0, Consts_1.TypeURL.XSD_DOUBLE)).onUnary('string', val => {\n    const result = Parsing_1.parseXSDFloat(val.str());\n\n    if (result === undefined) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_DOUBLE);\n    }\n\n    return Helpers_1.number(result, Consts_1.TypeURL.XSD_DOUBLE);\n  }).copy({\n    from: ['string'],\n    to: ['nonlexical']\n  }).collect()\n};\nconst toDecimal = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(val => {\n    const result = Parsing_1.parseXSDDecimal(val.str());\n\n    if (result === undefined) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_DECIMAL);\n    }\n\n    return Helpers_1.number(result, Consts_1.TypeURL.XSD_DECIMAL);\n  }).onString1(val => {\n    const str = val.str();\n    const result = /^(\\-|\\+)?([0-9]+(\\.[0-9]+)?)$/.test(str) ? Parsing_1.parseXSDDecimal(str) : undefined;\n\n    if (result === undefined) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_DECIMAL);\n    }\n\n    return Helpers_1.number(result, Consts_1.TypeURL.XSD_DECIMAL);\n  }).copy({\n    from: ['string'],\n    to: ['nonlexical']\n  }).onBoolean1Typed(val => Helpers_1.number(val ? 1 : 0, Consts_1.TypeURL.XSD_DECIMAL)).collect()\n};\nconst toInteger = {\n  arity: 1,\n  overloads: Helpers_1.declare().onBoolean1Typed(val => Helpers_1.number(val ? 1 : 0, Consts_1.TypeURL.XSD_INTEGER)).onNumeric1(val => {\n    const result = Parsing_1.parseXSDInteger(val.str());\n\n    if (result === undefined) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_INTEGER);\n    }\n\n    return Helpers_1.number(result, Consts_1.TypeURL.XSD_INTEGER);\n  }).onString1(val => {\n    const str = val.str();\n    const result = /^[0-9]+$/.test(str) ? Parsing_1.parseXSDInteger(str) : undefined;\n\n    if (result === undefined) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_INTEGER);\n    }\n\n    return Helpers_1.number(result, Consts_1.TypeURL.XSD_INTEGER);\n  }).copy({\n    from: ['integer'],\n    to: ['nonlexical']\n  }).collect()\n};\nconst toDatetime = {\n  arity: 1,\n  overloads: Helpers_1.declare().onUnary('date', val => val).onUnary('string', val => {\n    const date = new Date(val.str());\n\n    if (isNaN(date.getTime())) {\n      throw new Err.CastError(val, Consts_1.TypeURL.XSD_DATE_TIME);\n    }\n\n    return Helpers_1.dateTime(date, val.str());\n  }).copy({\n    from: ['string'],\n    to: ['nonlexical']\n  }).collect()\n};\nconst toBoolean = {\n  arity: 1,\n  overloads: Helpers_1.declare().onNumeric1(val => Helpers_1.bool(val.coerceEBV())).onUnary('boolean', val => Helpers_1.bool(val.coerceEBV())).onUnary('string', val => {\n    switch (val.str()) {\n      case 'true':\n        return Helpers_1.bool(true);\n\n      case 'false':\n        return Helpers_1.bool(false);\n\n      case '1':\n        return Helpers_1.bool(true);\n\n      case '0':\n        return Helpers_1.bool(false);\n\n      default:\n        throw new Err.CastError(val, Consts_1.TypeURL.XSD_BOOLEAN);\n    }\n  }).copy({\n    from: ['string'],\n    to: ['nonlexical']\n  }).collect()\n}; // End definitions.\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\nconst _definitions = {\n  // --------------------------------------------------------------------------\n  // XPath Constructor functions\n  // https://www.w3.org/TR/sparql11-query/#FunctionMapping\n  // --------------------------------------------------------------------------\n  [Consts_1.TypeURL.XSD_STRING]: toString,\n  [Consts_1.TypeURL.XSD_FLOAT]: toFloat,\n  [Consts_1.TypeURL.XSD_DOUBLE]: toDouble,\n  [Consts_1.TypeURL.XSD_DECIMAL]: toDecimal,\n  [Consts_1.TypeURL.XSD_INTEGER]: toInteger,\n  [Consts_1.TypeURL.XSD_DATE_TIME]: toDatetime,\n  [Consts_1.TypeURL.XSD_DATE]: toDatetime,\n  [Consts_1.TypeURL.XSD_BOOLEAN]: toBoolean\n};\nexports.namedDefinitions = immutable_1.Map(_definitions);","map":{"version":3,"sources":["../../../lib/functions/NamedFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["import { Map } from 'immutable';\n\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport { TypeURL } from '../util/Consts';\nimport {\n  parseXSDDecimal,\n  parseXSDFloat,\n  parseXSDInteger,\n} from '../util/Parsing';\n\nimport { OverloadMap } from './Core';\nimport { bool, dateTime, declare, number, string } from './Helpers';\n\ntype Term = E.TermExpression;\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// Begin definitions.\n\n// ----------------------------------------------------------------------------\n// XPath Constructor functions\n// https://www.w3.org/TR/sparql11-query/#\n// https://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive\n// ----------------------------------------------------------------------------\n\nconst toString = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val: E.NumericLiteral) => string(number(val.typedValue).str()))\n    .onBoolean1Typed((val) => string(bool(val).str()))\n    .onTerm1((val: E.StringLiteral) => string(val.str()))\n    .collect(),\n};\n\nconst toFloat = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val: E.NumericLiteral) => number(val.typedValue))\n    .onBoolean1Typed((val) => number(val ? 1 : 0))\n    .onUnary('string', (val: E.StringLiteral) => {\n      const result = parseXSDFloat(val.str());\n      if (result === undefined) { throw new Err.CastError(val, TypeURL.XSD_FLOAT); }\n      return number(result);\n    })\n    .copy({ from: ['string'], to: ['nonlexical'] })\n    .collect(),\n};\n\nconst toDouble = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val: E.NumericLiteral) => number(val.typedValue, TypeURL.XSD_DOUBLE))\n    .onBoolean1Typed((val) => number(val ? 1 : 0, TypeURL.XSD_DOUBLE))\n    .onUnary('string', (val: E.Term) => {\n      const result = parseXSDFloat(val.str());\n      if (result === undefined) { throw new Err.CastError(val, TypeURL.XSD_DOUBLE); }\n      return number(result, TypeURL.XSD_DOUBLE);\n    })\n    .copy({ from: ['string'], to: ['nonlexical'] })\n    .collect(),\n};\n\nconst toDecimal = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val: E.Term) => {\n      const result = parseXSDDecimal(val.str());\n      if (result === undefined) { throw new Err.CastError(val, TypeURL.XSD_DECIMAL); }\n      return number(result, TypeURL.XSD_DECIMAL);\n    })\n    .onString1((val: E.Term) => {\n      const str = val.str();\n      const result = /^(\\-|\\+)?([0-9]+(\\.[0-9]+)?)$/.test(str) ? parseXSDDecimal(str) : undefined;\n      if (result === undefined) { throw new Err.CastError(val, TypeURL.XSD_DECIMAL); }\n      return number(result, TypeURL.XSD_DECIMAL);\n    })\n    .copy({ from: ['string'], to: ['nonlexical'] })\n    .onBoolean1Typed((val) => number(val ? 1 : 0, TypeURL.XSD_DECIMAL))\n    .collect(),\n};\n\nconst toInteger = {\n  arity: 1,\n  overloads: declare()\n    .onBoolean1Typed((val) => number(val ? 1 : 0, TypeURL.XSD_INTEGER))\n    .onNumeric1((val: E.Term) => {\n      const result = parseXSDInteger(val.str());\n      if (result === undefined) { throw new Err.CastError(val, TypeURL.XSD_INTEGER); }\n      return number(result, TypeURL.XSD_INTEGER);\n    })\n    .onString1((val: E.Term) => {\n      const str = val.str();\n      const result = /^[0-9]+$/.test(str) ? parseXSDInteger(str) : undefined;\n      if (result === undefined) { throw new Err.CastError(val, TypeURL.XSD_INTEGER); }\n      return number(result, TypeURL.XSD_INTEGER);\n    })\n    .copy({ from: ['integer'], to: ['nonlexical'] })\n    .collect(),\n};\n\nconst toDatetime = {\n  arity: 1,\n  overloads: declare()\n    .onUnary('date', (val: E.DateTimeLiteral) => val)\n    .onUnary('string', (val: Term) => {\n      const date = new Date(val.str());\n      if (isNaN(date.getTime())) {\n        throw new Err.CastError(val, TypeURL.XSD_DATE_TIME);\n      }\n      return dateTime(date, val.str());\n    })\n    .copy({ from: ['string'], to: ['nonlexical'] })\n    .collect(),\n};\n\nconst toBoolean = {\n  arity: 1,\n  overloads: declare()\n    .onNumeric1((val: E.NumericLiteral) => bool(val.coerceEBV()))\n    .onUnary('boolean', (val: Term) => bool(val.coerceEBV()))\n    .onUnary('string', (val: Term) => {\n      switch (val.str()) {\n        case 'true':\n          return bool(true);\n        case 'false':\n          return bool(false);\n        case '1':\n          return bool(true);\n        case '0':\n          return bool(false);\n        default:\n          throw new Err.CastError(val, TypeURL.XSD_BOOLEAN);\n      }\n    })\n    .copy({ from: ['string'], to: ['nonlexical'] })\n    .collect(),\n};\n\n// End definitions.\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\n\nconst _definitions: { [key in C.NamedOperator]: Definition } = {\n  // --------------------------------------------------------------------------\n  // XPath Constructor functions\n  // https://www.w3.org/TR/sparql11-query/#FunctionMapping\n  // --------------------------------------------------------------------------\n  [TypeURL.XSD_STRING]: toString,\n  [TypeURL.XSD_FLOAT]: toFloat,\n  [TypeURL.XSD_DOUBLE]: toDouble,\n  [TypeURL.XSD_DECIMAL]: toDecimal,\n  [TypeURL.XSD_INTEGER]: toInteger,\n  [TypeURL.XSD_DATE_TIME]: toDatetime,\n  [TypeURL.XSD_DATE]: toDatetime,\n  [TypeURL.XSD_BOOLEAN]: toBoolean,\n};\n\n// ----------------------------------------------------------------------------\n// The definitions and functionality for all operators\n// ----------------------------------------------------------------------------\n\nexport interface Definition {\n  arity: number | number[];\n  overloads: OverloadMap;\n}\n\nexport const namedDefinitions = Map<C.NamedOperator, Definition>(_definitions);\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}