{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformExistence = exports.transformAggregate = exports.transformNamed = exports.transformLiteral = exports.transformRDFTermUnsafe = exports.transformAlgebra = void 0;\n\nconst RDFString = require(\"rdf-string\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n\nconst E = require(\"./expressions\");\n\nconst C = require(\"./util/Consts\");\n\nconst Err = require(\"./util/Errors\");\n\nconst P = require(\"./util/Parsing\");\n\nconst functions_1 = require(\"./functions\");\n\nconst Consts_1 = require(\"./util/Consts\");\n\nfunction transformAlgebra(expr) {\n  if (!expr) {\n    throw new Err.InvalidExpression(expr);\n  }\n\n  const types = sparqlalgebrajs_1.Algebra.expressionTypes;\n\n  switch (expr.expressionType) {\n    case types.TERM:\n      return transformTerm(expr);\n\n    case types.OPERATOR:\n      return transformOperator(expr);\n\n    case types.NAMED:\n      return transformNamed(expr);\n\n    case types.EXISTENCE:\n      return transformExistence(expr);\n\n    case types.AGGREGATE:\n      return transformAggregate(expr);\n\n    case types.WILDCARD:\n      return transformWildcard(expr);\n\n    default:\n      throw new Err.InvalidExpressionType(expr);\n  }\n}\n\nexports.transformAlgebra = transformAlgebra;\n/**\n * Transforms an RDF term to the internal representation of a term,\n * assuming it is not a variable, which would be an expression (internally).\n *\n * @param term RDF term to transform into internal representation of a term\n */\n\nfunction transformRDFTermUnsafe(term) {\n  return transformTerm({\n    term,\n    type: 'expression',\n    expressionType: 'term'\n  });\n}\n\nexports.transformRDFTermUnsafe = transformRDFTermUnsafe;\n\nfunction transformTerm(term) {\n  if (!term.term) {\n    throw new Err.InvalidExpression(term);\n  }\n\n  switch (term.term.termType) {\n    case 'Variable':\n      return new E.Variable(RDFString.termToString(term.term));\n\n    case 'Literal':\n      return transformLiteral(term.term);\n\n    case 'NamedNode':\n      return new E.NamedNode(term.term.value);\n\n    case 'BlankNode':\n      return new E.BlankNode(term.term.value);\n\n    default:\n      throw new Err.InvalidTermType(term);\n  }\n}\n\nfunction transformWildcard(term) {\n  if (!term.wildcard) {\n    throw new Err.InvalidExpression(term);\n  }\n\n  return new E.NamedNode(term.wildcard.value);\n} // TODO: Maybe do this with a map?\n// tslint:disable-next-line:no-any\n\n\nfunction transformLiteral(lit) {\n  if (!lit.datatype) {\n    return lit.language ? new E.LangStringLiteral(lit.value, lit.language) : new E.StringLiteral(lit.value);\n  }\n\n  switch (lit.datatype.value) {\n    case null:\n    case undefined:\n    case '':\n      {\n        return lit.language ? new E.LangStringLiteral(lit.value, lit.language) : new E.StringLiteral(lit.value);\n      }\n\n    case Consts_1.TypeURL.XSD_STRING:\n      return new E.StringLiteral(lit.value);\n\n    case Consts_1.TypeURL.RDF_LANG_STRING:\n      return new E.LangStringLiteral(lit.value, lit.language);\n\n    case Consts_1.TypeURL.XSD_DATE_TIME:\n    case Consts_1.TypeURL.XSD_DATE:\n      {\n        const val = new Date(lit.value);\n\n        if (isNaN(val.getTime())) {\n          return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n        }\n\n        return new E.DateTimeLiteral(new Date(lit.value), lit.value);\n      }\n\n    case Consts_1.TypeURL.XSD_BOOLEAN:\n      {\n        if (lit.value !== 'true' && lit.value !== 'false' && lit.value !== '1' && lit.value !== '0') {\n          return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n        }\n\n        return new E.BooleanLiteral(lit.value === 'true' || lit.value === '1', lit.value);\n      }\n\n    case Consts_1.TypeURL.XSD_INTEGER:\n    case Consts_1.TypeURL.XSD_DECIMAL:\n    case Consts_1.TypeURL.XSD_NEGATIVE_INTEGER:\n    case Consts_1.TypeURL.XSD_NON_NEGATIVE_INTEGER:\n    case Consts_1.TypeURL.XSD_NON_POSITIVE_INTEGER:\n    case Consts_1.TypeURL.XSD_POSITIVE_INTEGER:\n    case Consts_1.TypeURL.XSD_LONG:\n    case Consts_1.TypeURL.XSD_SHORT:\n    case Consts_1.TypeURL.XSD_BYTE:\n    case Consts_1.TypeURL.XSD_UNSIGNED_LONG:\n    case Consts_1.TypeURL.XSD_UNSIGNED_INT:\n    case Consts_1.TypeURL.XSD_UNSIGNED_SHORT:\n    case Consts_1.TypeURL.XSD_UNSIGNED_BYTE:\n    case Consts_1.TypeURL.XSD_INT:\n      {\n        const val = P.parseXSDDecimal(lit.value);\n\n        if (val === undefined) {\n          return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n        }\n\n        return new E.NumericLiteral(val, lit.datatype, lit.value);\n      }\n\n    case Consts_1.TypeURL.XSD_FLOAT:\n    case Consts_1.TypeURL.XSD_DOUBLE:\n      {\n        const val = P.parseXSDFloat(lit.value);\n\n        if (val === undefined) {\n          return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n        }\n\n        return new E.NumericLiteral(val, lit.datatype, lit.value);\n      }\n\n    default:\n      return new E.Literal(lit.value, lit.datatype, lit.value);\n  }\n}\n\nexports.transformLiteral = transformLiteral;\n\nfunction transformOperator(expr) {\n  if (C.SpecialOperators.contains(expr.operator)) {\n    const op = expr.operator;\n    const args = expr.args.map(a => transformAlgebra(a));\n    const func = functions_1.specialFunctions.get(op);\n\n    if (!func.checkArity(args)) {\n      throw new Err.InvalidArity(args, op);\n    }\n\n    return new E.SpecialOperator(args, func.applyAsync, func.applySync);\n  } else {\n    if (!C.Operators.contains(expr.operator)) {\n      throw new Err.UnknownOperator(expr.operator);\n    }\n\n    const op = expr.operator;\n    const args = expr.args.map(a => transformAlgebra(a));\n    const func = functions_1.regularFunctions.get(op);\n\n    if (!hasCorrectArity(args, func.arity)) {\n      throw new Err.InvalidArity(args, op);\n    }\n\n    return new E.Operator(args, func.apply);\n  }\n} // TODO: Support passing functions to override default behaviour;\n\n\nfunction transformNamed(expr) {\n  const funcName = expr.name.value;\n\n  if (!C.NamedOperators.contains(funcName)) {\n    throw new Err.UnknownNamedOperator(expr.name.value);\n  } // tslint:disable-next-line:no-any\n\n\n  const op = expr.name.value;\n  const args = expr.args.map(a => transformAlgebra(a));\n  const func = functions_1.namedFunctions.get(op);\n  return new E.Named(expr.name, args, func.apply);\n}\n\nexports.transformNamed = transformNamed;\n\nfunction hasCorrectArity(args, arity) {\n  // Infinity is used to represent var-args, so it's always correct.\n  if (arity === Infinity) {\n    return true;\n  } // If the function has overloaded arity, the actual arity needs to be present.\n\n\n  if (Array.isArray(arity)) {\n    return arity.indexOf(args.length) >= 0;\n  }\n\n  return args.length === arity;\n}\n\nfunction transformAggregate(expr) {\n  const name = expr.aggregator;\n  return new E.Aggregate(name, expr);\n}\n\nexports.transformAggregate = transformAggregate;\n\nfunction transformExistence(expr) {\n  return new E.Existence(expr);\n}\n\nexports.transformExistence = transformExistence;","map":{"version":3,"sources":["../../lib/Transformation.ts"],"names":[],"mappings":";;;;;;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAEA,MAAA,CAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,GAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAKA,MAAA,QAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,SAAgB,gBAAhB,CAAiC,IAAjC,EAAqD;AACnD,MAAI,CAAC,IAAL,EAAW;AAAE,UAAM,IAAI,GAAG,CAAC,iBAAR,CAA0B,IAA1B,CAAN;AAAwC;;AAErD,QAAM,KAAK,GAAG,iBAAA,CAAA,OAAA,CAAI,eAAlB;;AAEA,UAAQ,IAAI,CAAC,cAAb;AACE,SAAK,KAAK,CAAC,IAAX;AACE,aAAO,aAAa,CAAC,IAAD,CAApB;;AACF,SAAK,KAAK,CAAC,QAAX;AACE,aAAO,iBAAiB,CAAC,IAAD,CAAxB;;AACF,SAAK,KAAK,CAAC,KAAX;AACE,aAAO,cAAc,CAAC,IAAD,CAArB;;AACF,SAAK,KAAK,CAAC,SAAX;AACE,aAAO,kBAAkB,CAAC,IAAD,CAAzB;;AACF,SAAK,KAAK,CAAC,SAAX;AACE,aAAO,kBAAkB,CAAC,IAAD,CAAzB;;AACF,SAAK,KAAK,CAAC,QAAX;AACE,aAAO,iBAAiB,CAAC,IAAD,CAAxB;;AACF;AAAS,YAAM,IAAI,GAAG,CAAC,qBAAR,CAA8B,IAA9B,CAAN;AAbX;AAeD;;AApBD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAsBA;;;;;AAKG;;AACH,SAAgB,sBAAhB,CAAuC,IAAvC,EAAqD;AACnD,SAAO,aAAa,CAAC;AACnB,IAAA,IADmB;AAEnB,IAAA,IAAI,EAAE,YAFa;AAGnB,IAAA,cAAc,EAAE;AAHG,GAAD,CAApB;AAKD;;AAND,OAAA,CAAA,sBAAA,GAAA,sBAAA;;AAQA,SAAS,aAAT,CAAuB,IAAvB,EAA+C;AAC7C,MAAI,CAAC,IAAI,CAAC,IAAV,EAAgB;AAAE,UAAM,IAAI,GAAG,CAAC,iBAAR,CAA0B,IAA1B,CAAN;AAAwC;;AAE1D,UAAQ,IAAI,CAAC,IAAL,CAAU,QAAlB;AACE,SAAK,UAAL;AAAiB,aAAO,IAAI,CAAC,CAAC,QAAN,CAAe,SAAS,CAAC,YAAV,CAAuB,IAAI,CAAC,IAA5B,CAAf,CAAP;;AACjB,SAAK,SAAL;AAAgB,aAAO,gBAAgB,CAAC,IAAI,CAAC,IAAN,CAAvB;;AAChB,SAAK,WAAL;AAAkB,aAAO,IAAI,CAAC,CAAC,SAAN,CAAgB,IAAI,CAAC,IAAL,CAAU,KAA1B,CAAP;;AAClB,SAAK,WAAL;AAAkB,aAAO,IAAI,CAAC,CAAC,SAAN,CAAgB,IAAI,CAAC,IAAL,CAAU,KAA1B,CAAP;;AAClB;AAAS,YAAM,IAAI,GAAG,CAAC,eAAR,CAAwB,IAAxB,CAAN;AALX;AAOD;;AAED,SAAS,iBAAT,CAA2B,IAA3B,EAAuD;AACrD,MAAI,CAAC,IAAI,CAAC,QAAV,EAAoB;AAAE,UAAM,IAAI,GAAG,CAAC,iBAAR,CAA0B,IAA1B,CAAN;AAAwC;;AAE9D,SAAO,IAAI,CAAC,CAAC,SAAN,CAAgB,IAAI,CAAC,QAAL,CAAc,KAA9B,CAAP;AACD,C,CAED;AACA;;;AACA,SAAgB,gBAAhB,CAAiC,GAAjC,EAAiD;AAE/C,MAAI,CAAC,GAAG,CAAC,QAAT,EAAmB;AACjB,WAAQ,GAAG,CAAC,QAAL,GACH,IAAI,CAAC,CAAC,iBAAN,CAAwB,GAAG,CAAC,KAA5B,EAAmC,GAAG,CAAC,QAAvC,CADG,GAEH,IAAI,CAAC,CAAC,aAAN,CAAoB,GAAG,CAAC,KAAxB,CAFJ;AAGD;;AAED,UAAQ,GAAG,CAAC,QAAJ,CAAa,KAArB;AACE,SAAK,IAAL;AACA,SAAK,SAAL;AACA,SAAK,EAAL;AAAS;AACP,eAAQ,GAAG,CAAC,QAAL,GACH,IAAI,CAAC,CAAC,iBAAN,CAAwB,GAAG,CAAC,KAA5B,EAAmC,GAAG,CAAC,QAAvC,CADG,GAEH,IAAI,CAAC,CAAC,aAAN,CAAoB,GAAG,CAAC,KAAxB,CAFJ;AAGD;;AAED,SAAK,QAAA,CAAA,OAAA,CAAG,UAAR;AACE,aAAO,IAAI,CAAC,CAAC,aAAN,CAAoB,GAAG,CAAC,KAAxB,CAAP;;AACF,SAAK,QAAA,CAAA,OAAA,CAAG,eAAR;AACE,aAAO,IAAI,CAAC,CAAC,iBAAN,CAAwB,GAAG,CAAC,KAA5B,EAAmC,GAAG,CAAC,QAAvC,CAAP;;AAEF,SAAK,QAAA,CAAA,OAAA,CAAG,aAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,QAAR;AAAkB;AAChB,cAAM,GAAG,GAAS,IAAI,IAAJ,CAAS,GAAG,CAAC,KAAb,CAAlB;;AACA,YAAI,KAAK,CAAC,GAAG,CAAC,OAAJ,EAAD,CAAT,EAA0B;AACxB,iBAAO,IAAI,CAAC,CAAC,iBAAN,CAAwB,SAAxB,EAAmC,GAAG,CAAC,QAAvC,EAAiD,GAAG,CAAC,KAArD,CAAP;AACD;;AACD,eAAO,IAAI,CAAC,CAAC,eAAN,CAAsB,IAAI,IAAJ,CAAS,GAAG,CAAC,KAAb,CAAtB,EAA2C,GAAG,CAAC,KAA/C,CAAP;AACD;;AAED,SAAK,QAAA,CAAA,OAAA,CAAG,WAAR;AAAqB;AACnB,YAAI,GAAG,CAAC,KAAJ,KAAc,MAAd,IAAwB,GAAG,CAAC,KAAJ,KAAc,OAAtC,IAAiD,GAAG,CAAC,KAAJ,KAAc,GAA/D,IAAsE,GAAG,CAAC,KAAJ,KAAc,GAAxF,EAA6F;AAC3F,iBAAO,IAAI,CAAC,CAAC,iBAAN,CAAwB,SAAxB,EAAmC,GAAG,CAAC,QAAvC,EAAiD,GAAG,CAAC,KAArD,CAAP;AACD;;AACD,eAAO,IAAI,CAAC,CAAC,cAAN,CAAqB,GAAG,CAAC,KAAJ,KAAc,MAAd,IAAwB,GAAG,CAAC,KAAJ,KAAc,GAA3D,EAAgE,GAAG,CAAC,KAApE,CAAP;AACD;;AAED,SAAK,QAAA,CAAA,OAAA,CAAG,WAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,WAAR;AAEA,SAAK,QAAA,CAAA,OAAA,CAAG,oBAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,wBAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,wBAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,oBAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,QAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,SAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,QAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,iBAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,gBAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,kBAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,iBAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,OAAR;AAAiB;AACf,cAAM,GAAG,GAAW,CAAC,CAAC,eAAF,CAAkB,GAAG,CAAC,KAAtB,CAApB;;AACA,YAAI,GAAG,KAAK,SAAZ,EAAuB;AACrB,iBAAO,IAAI,CAAC,CAAC,iBAAN,CAAwB,SAAxB,EAAmC,GAAG,CAAC,QAAvC,EAAiD,GAAG,CAAC,KAArD,CAAP;AACD;;AACD,eAAO,IAAI,CAAC,CAAC,cAAN,CAAqB,GAArB,EAA0B,GAAG,CAAC,QAA9B,EAAwC,GAAG,CAAC,KAA5C,CAAP;AACD;;AACD,SAAK,QAAA,CAAA,OAAA,CAAG,SAAR;AACA,SAAK,QAAA,CAAA,OAAA,CAAG,UAAR;AAAoB;AAClB,cAAM,GAAG,GAAW,CAAC,CAAC,aAAF,CAAgB,GAAG,CAAC,KAApB,CAApB;;AACA,YAAI,GAAG,KAAK,SAAZ,EAAuB;AACrB,iBAAO,IAAI,CAAC,CAAC,iBAAN,CAAwB,SAAxB,EAAmC,GAAG,CAAC,QAAvC,EAAiD,GAAG,CAAC,KAArD,CAAP;AACD;;AACD,eAAO,IAAI,CAAC,CAAC,cAAN,CAAqB,GAArB,EAA0B,GAAG,CAAC,QAA9B,EAAwC,GAAG,CAAC,KAA5C,CAAP;AACD;;AACD;AAAS,aAAO,IAAI,CAAC,CAAC,OAAN,CAAsB,GAAG,CAAC,KAA1B,EAAiC,GAAG,CAAC,QAArC,EAA+C,GAAG,CAAC,KAAnD,CAAP;AA3DX;AA6DD;;AArED,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAuEA,SAAS,iBAAT,CAA2B,IAA3B,EAAuD;AAErD,MAAI,CAAC,CAAC,gBAAF,CAAmB,QAAnB,CAA4B,IAAI,CAAC,QAAjC,CAAJ,EAAgD;AAC9C,UAAM,EAAE,GAAG,IAAI,CAAC,QAAhB;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,GAAV,CAAe,CAAD,IAAO,gBAAgB,CAAC,CAAD,CAArC,CAAb;AACA,UAAM,IAAI,GAAG,WAAA,CAAA,gBAAA,CAAiB,GAAjB,CAAqB,EAArB,CAAb;;AACA,QAAI,CAAC,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAL,EAA4B;AAC1B,YAAM,IAAI,GAAG,CAAC,YAAR,CAAqB,IAArB,EAA2B,EAA3B,CAAN;AACD;;AACD,WAAO,IAAI,CAAC,CAAC,eAAN,CAAsB,IAAtB,EAA4B,IAAI,CAAC,UAAjC,EAA6C,IAAI,CAAC,SAAlD,CAAP;AACD,GARD,MAQO;AACL,QAAI,CAAC,CAAC,CAAC,SAAF,CAAY,QAAZ,CAAqB,IAAI,CAAC,QAA1B,CAAL,EAA0C;AACxC,YAAM,IAAI,GAAG,CAAC,eAAR,CAAwB,IAAI,CAAC,QAA7B,CAAN;AACD;;AACD,UAAM,EAAE,GAAG,IAAI,CAAC,QAAhB;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,GAAV,CAAe,CAAD,IAAO,gBAAgB,CAAC,CAAD,CAArC,CAAb;AACA,UAAM,IAAI,GAAG,WAAA,CAAA,gBAAA,CAAiB,GAAjB,CAAqB,EAArB,CAAb;;AACA,QAAI,CAAC,eAAe,CAAC,IAAD,EAAO,IAAI,CAAC,KAAZ,CAApB,EAAwC;AAAE,YAAM,IAAI,GAAG,CAAC,YAAR,CAAqB,IAArB,EAA2B,EAA3B,CAAN;AAAuC;;AACjF,WAAO,IAAI,CAAC,CAAC,QAAN,CAAe,IAAf,EAAqB,IAAI,CAAC,KAA1B,CAAP;AACD;AACF,C,CAED;;;AACA,SAAgB,cAAhB,CAA+B,IAA/B,EAAwD;AACtD,QAAM,QAAQ,GAAG,IAAI,CAAC,IAAL,CAAU,KAA3B;;AACA,MAAI,CAAC,CAAC,CAAC,cAAF,CAAiB,QAAjB,CAA0B,QAA1B,CAAL,EAA6D;AAC3D,UAAM,IAAI,GAAG,CAAC,oBAAR,CAA6B,IAAI,CAAC,IAAL,CAAU,KAAvC,CAAN;AACD,GAJqD,CAMtD;;;AACA,QAAM,EAAE,GAAG,IAAI,CAAC,IAAL,CAAU,KAArB;AACA,QAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,GAAV,CAAe,CAAD,IAAO,gBAAgB,CAAC,CAAD,CAArC,CAAb;AACA,QAAM,IAAI,GAAG,WAAA,CAAA,cAAA,CAAe,GAAf,CAAmB,EAAnB,CAAb;AACA,SAAO,IAAI,CAAC,CAAC,KAAN,CAAY,IAAI,CAAC,IAAjB,EAAuB,IAAvB,EAA6B,IAAI,CAAC,KAAlC,CAAP;AACD;;AAXD,OAAA,CAAA,cAAA,GAAA,cAAA;;AAaA,SAAS,eAAT,CAAyB,IAAzB,EAA+C,KAA/C,EAAuE;AACrE;AACA,MAAI,KAAK,KAAK,QAAd,EAAwB;AAAE,WAAO,IAAP;AAAc,GAF6B,CAIrE;;;AACA,MAAI,KAAK,CAAC,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACxB,WAAO,KAAK,CAAC,OAAN,CAAc,IAAI,CAAC,MAAnB,KAA8B,CAArC;AACD;;AAED,SAAO,IAAI,CAAC,MAAL,KAAgB,KAAvB;AACD;;AAED,SAAgB,kBAAhB,CAAmC,IAAnC,EAAgE;AAC9D,QAAM,IAAI,GAAG,IAAI,CAAC,UAAlB;AACA,SAAO,IAAI,CAAC,CAAC,SAAN,CAAgB,IAAhB,EAAsB,IAAtB,CAAP;AACD;;AAHD,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAKA,SAAgB,kBAAhB,CAAmC,IAAnC,EAAgE;AAC9D,SAAO,IAAI,CAAC,CAAC,SAAN,CAAgB,IAAhB,CAAP;AACD;;AAFD,OAAA,CAAA,kBAAA,GAAA,kBAAA","sourcesContent":["import * as RDF from 'rdf-js';\nimport * as RDFString from 'rdf-string';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as E from './expressions';\nimport * as C from './util/Consts';\nimport * as Err from './util/Errors';\nimport * as P from './util/Parsing';\n\nimport {\n  namedFunctions,\n  regularFunctions,\n  specialFunctions,\n} from './functions';\nimport { TypeURL as DT } from './util/Consts';\n\nexport function transformAlgebra(expr: Alg.Expression): E.Expression {\n  if (!expr) { throw new Err.InvalidExpression(expr); }\n\n  const types = Alg.expressionTypes;\n\n  switch (expr.expressionType) {\n    case types.TERM:\n      return transformTerm(expr as Alg.TermExpression);\n    case types.OPERATOR:\n      return transformOperator(expr as Alg.OperatorExpression);\n    case types.NAMED:\n      return transformNamed(expr as Alg.NamedExpression);\n    case types.EXISTENCE:\n      return transformExistence(expr as Alg.ExistenceExpression);\n    case types.AGGREGATE:\n      return transformAggregate(expr as Alg.AggregateExpression);\n    case types.WILDCARD:\n      return transformWildcard(expr as Alg.WildcardExpression);\n    default: throw new Err.InvalidExpressionType(expr);\n  }\n}\n\n/**\n * Transforms an RDF term to the internal representation of a term,\n * assuming it is not a variable, which would be an expression (internally).\n *\n * @param term RDF term to transform into internal representation of a term\n */\nexport function transformRDFTermUnsafe(term: RDF.Term): E.Term {\n  return transformTerm({\n    term,\n    type: 'expression',\n    expressionType: 'term',\n  }) as E.Term;\n}\n\nfunction transformTerm(term: Alg.TermExpression): E.Expression {\n  if (!term.term) { throw new Err.InvalidExpression(term); }\n\n  switch (term.term.termType) {\n    case 'Variable': return new E.Variable(RDFString.termToString(term.term));\n    case 'Literal': return transformLiteral(term.term as RDF.Literal);\n    case 'NamedNode': return new E.NamedNode(term.term.value);\n    case 'BlankNode': return new E.BlankNode(term.term.value);\n    default: throw new Err.InvalidTermType(term);\n  }\n}\n\nfunction transformWildcard(term: Alg.WildcardExpression): E.Expression {\n  if (!term.wildcard) { throw new Err.InvalidExpression(term); }\n\n  return new E.NamedNode(term.wildcard.value);\n}\n\n// TODO: Maybe do this with a map?\n// tslint:disable-next-line:no-any\nexport function transformLiteral(lit: RDF.Literal): E.Literal<any> {\n\n  if (!lit.datatype) {\n    return (lit.language)\n      ? new E.LangStringLiteral(lit.value, lit.language)\n      : new E.StringLiteral(lit.value);\n  }\n\n  switch (lit.datatype.value) {\n    case null:\n    case undefined:\n    case '': {\n      return (lit.language)\n        ? new E.LangStringLiteral(lit.value, lit.language)\n        : new E.StringLiteral(lit.value);\n    }\n\n    case DT.XSD_STRING:\n      return new E.StringLiteral(lit.value);\n    case DT.RDF_LANG_STRING:\n      return new E.LangStringLiteral(lit.value, lit.language);\n\n    case DT.XSD_DATE_TIME:\n    case DT.XSD_DATE: {\n      const val: Date = new Date(lit.value);\n      if (isNaN(val.getTime())) {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.DateTimeLiteral(new Date(lit.value), lit.value);\n    }\n\n    case DT.XSD_BOOLEAN: {\n      if (lit.value !== 'true' && lit.value !== 'false' && lit.value !== '1' && lit.value !== '0') {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.BooleanLiteral(lit.value === 'true' || lit.value === '1', lit.value);\n    }\n\n    case DT.XSD_INTEGER:\n    case DT.XSD_DECIMAL:\n\n    case DT.XSD_NEGATIVE_INTEGER:\n    case DT.XSD_NON_NEGATIVE_INTEGER:\n    case DT.XSD_NON_POSITIVE_INTEGER:\n    case DT.XSD_POSITIVE_INTEGER:\n    case DT.XSD_LONG:\n    case DT.XSD_SHORT:\n    case DT.XSD_BYTE:\n    case DT.XSD_UNSIGNED_LONG:\n    case DT.XSD_UNSIGNED_INT:\n    case DT.XSD_UNSIGNED_SHORT:\n    case DT.XSD_UNSIGNED_BYTE:\n    case DT.XSD_INT: {\n      const val: number = P.parseXSDDecimal(lit.value);\n      if (val === undefined) {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.NumericLiteral(val, lit.datatype, lit.value);\n    }\n    case DT.XSD_FLOAT:\n    case DT.XSD_DOUBLE: {\n      const val: number = P.parseXSDFloat(lit.value);\n      if (val === undefined) {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.NumericLiteral(val, lit.datatype, lit.value);\n    }\n    default: return new E.Literal<string>(lit.value, lit.datatype, lit.value);\n  }\n}\n\nfunction transformOperator(expr: Alg.OperatorExpression)\n  : E.OperatorExpression | E.SpecialOperatorExpression {\n  if (C.SpecialOperators.contains(expr.operator)) {\n    const op = expr.operator as C.SpecialOperator;\n    const args = expr.args.map((a) => transformAlgebra(a));\n    const func = specialFunctions.get(op);\n    if (!func.checkArity(args)) {\n      throw new Err.InvalidArity(args, op);\n    }\n    return new E.SpecialOperator(args, func.applyAsync, func.applySync);\n  } else {\n    if (!C.Operators.contains(expr.operator)) {\n      throw new Err.UnknownOperator(expr.operator);\n    }\n    const op = expr.operator as C.RegularOperator;\n    const args = expr.args.map((a) => transformAlgebra(a));\n    const func = regularFunctions.get(op);\n    if (!hasCorrectArity(args, func.arity)) { throw new Err.InvalidArity(args, op); }\n    return new E.Operator(args, func.apply);\n  }\n}\n\n// TODO: Support passing functions to override default behaviour;\nexport function transformNamed(expr: Alg.NamedExpression): E.NamedExpression {\n  const funcName = expr.name.value;\n  if (!C.NamedOperators.contains(funcName as C.NamedOperator)) {\n    throw new Err.UnknownNamedOperator(expr.name.value);\n  }\n\n  // tslint:disable-next-line:no-any\n  const op = expr.name.value as any as C.NamedOperator;\n  const args = expr.args.map((a) => transformAlgebra(a));\n  const func = namedFunctions.get(op);\n  return new E.Named(expr.name, args, func.apply);\n}\n\nfunction hasCorrectArity(args: E.Expression[], arity: number | number[]): boolean {\n  // Infinity is used to represent var-args, so it's always correct.\n  if (arity === Infinity) { return true; }\n\n  // If the function has overloaded arity, the actual arity needs to be present.\n  if (Array.isArray(arity)) {\n    return arity.indexOf(args.length) >= 0;\n  }\n\n  return args.length === arity;\n}\n\nexport function transformAggregate(expr: Alg.AggregateExpression) {\n  const name = expr.aggregator;\n  return new E.Aggregate(name, expr);\n}\n\nexport function transformExistence(expr: Alg.ExistenceExpression) {\n  return new E.Existence(expr);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}