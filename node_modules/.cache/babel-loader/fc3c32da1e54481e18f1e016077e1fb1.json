{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationQuadpattern = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst rdf_terms_1 = require(\"rdf-terms\");\n/**\n * A comunica actor for handling 'quadpattern' query operations.\n */\n\n\nclass ActorQueryOperationQuadpattern extends bus_query_operation_1.ActorQueryOperationTyped {\n  constructor(args) {\n    super(args, 'pattern');\n  }\n  /**\n   * Check if a term is a variable.\n   * @param {RDF.Term} term An RDF term.\n   * @return {any} If the term is a variable or blank node.\n   */\n\n\n  static isTermVariable(term) {\n    return term.termType === 'Variable';\n  }\n  /**\n   * Get all variables in the given pattern.\n   * No duplicates are returned.\n   * @param {RDF.BaseQuad} pattern A quad pattern.\n   * @return {string[]} The variables in this pattern, with '?' prefix.\n   */\n\n\n  static getVariables(pattern) {\n    return rdf_terms_1.uniqTerms(rdf_terms_1.getTerms(pattern).filter(ActorQueryOperationQuadpattern.isTermVariable)).map(x => rdf_string_1.termToString(x));\n  }\n  /**\n   * A helper function to find a hash with quad elements that have duplicate variables.\n   *\n   * @param {RDF.Quad} pattern A quad pattern.\n   *\n   * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns undefined.\n   *                                   Otherwise, this maps quad elements ('subject', 'predicate', 'object', 'graph')\n   *                                   to the list of quad elements it shares a variable name with.\n   *                                   If no links for a certain element exist, this element will\n   *                                   not be included in the hash.\n   *                                   Note 1: Quad elements will never have a link to themselves.\n   *                                           So this can never occur: { subject: [ 'subject'] },\n   *                                           instead 'null' would be returned.\n   *                                   Note 2: Links only exist in one direction,\n   *                                           this means that { subject: [ 'predicate'], predicate: [ 'subject' ] }\n   *                                           will not occur, instead only { subject: [ 'predicate'] }\n   *                                           will be returned.\n   */\n\n\n  static getDuplicateElementLinks(pattern) {\n    // Collect a variable to quad elements mapping.\n    const variableElements = {};\n    let duplicateVariables = false;\n\n    for (const key of rdf_terms_1.QUAD_TERM_NAMES) {\n      if (pattern[key].termType === 'Variable') {\n        const val = rdf_string_1.termToString(pattern[key]);\n        const length = (variableElements[val] || (variableElements[val] = [])).push(key);\n        duplicateVariables = duplicateVariables || length > 1;\n      }\n    }\n\n    if (!duplicateVariables) {\n      return;\n    } // Collect quad element to elements with equal variables mapping.\n\n\n    const duplicateElementLinks = {};\n\n    for (const variable in variableElements) {\n      const elements = variableElements[variable];\n      const remainingElements = elements.slice(1); // Only store the elements that have at least one equal element.\n\n      if (remainingElements.length > 0) {\n        duplicateElementLinks[elements[0]] = remainingElements;\n      }\n    }\n\n    return duplicateElementLinks;\n  }\n  /**\n   * Get the metadata of the given action on a quad stream.\n   *\n   * @param {AsyncIterator<Quad>} data The data stream that is guaranteed to emit the metadata property.\n   * @return {() => Promise<{[p: string]: any}>} A lazy promise behind a callback resolving to a metadata object.\n   */\n\n\n  static getMetadata(data) {\n    return () => new Promise((resolve, reject) => {\n      data.getProperty('metadata', metadata => resolve(metadata));\n      data.on('error', reject);\n    });\n  }\n\n  async testOperation(operation, context) {\n    return true;\n  }\n\n  async runOperation(pattern, context) {\n    // Apply the (optional) pattern-specific context\n    if (pattern.context) {\n      context = context ? context.merge(pattern.context) : pattern.context;\n    } // Resolve the quad pattern\n\n\n    const result = await this.mediatorResolveQuadPattern.mediate({\n      pattern,\n      context\n    }); // Collect all variables from the pattern\n\n    const variables = ActorQueryOperationQuadpattern.getVariables(pattern); // Create the metadata callback\n\n    const metadata = ActorQueryOperationQuadpattern.getMetadata(result.data); // Convenience datastructure for mapping quad elements to variables\n\n    const elementVariables = rdf_terms_1.reduceTerms(pattern, (acc, term, key) => {\n      if (ActorQueryOperationQuadpattern.isTermVariable(term)) {\n        acc[key] = rdf_string_1.termToString(term);\n      }\n\n      return acc;\n    }, {});\n\n    const quadBindingsReducer = (acc, term, key) => {\n      const variable = elementVariables[key];\n\n      if (variable) {\n        acc[variable] = term;\n      }\n\n      return acc;\n    }; // Optionally filter, and construct bindings\n\n\n    const bindingsStream = new asynciterator_1.TransformIterator(async () => {\n      let filteredOutput = result.data; // Detect duplicate variables in the pattern\n\n      const duplicateElementLinks = ActorQueryOperationQuadpattern.getDuplicateElementLinks(pattern); // If there are duplicate variables in the search pattern,\n      // make sure that we filter out the triples that don't have equal values for those triple elements,\n      // as QPF ignores variable names.\n\n      if (duplicateElementLinks) {\n        filteredOutput = filteredOutput.filter(quad => {\n          // No need to check the graph, because an equal element already would have to be found in s, p, or o.\n          for (const element1 of rdf_terms_1.TRIPLE_TERM_NAMES) {\n            for (const element2 of duplicateElementLinks[element1] || []) {\n              if (!quad[element1].equals(quad[element2])) {\n                return false;\n              }\n            }\n          }\n\n          return true;\n        });\n      }\n\n      return filteredOutput.map(quad => bus_query_operation_1.Bindings(rdf_terms_1.reduceTerms(quad, quadBindingsReducer, {})), {\n        autoStart: true,\n        maxBufferSize: 128\n      });\n    }, {\n      autoStart: false\n    });\n    return {\n      type: 'bindings',\n      bindingsStream,\n      variables,\n      metadata,\n      canContainUndefs: false\n    };\n  }\n\n}\n\nexports.ActorQueryOperationQuadpattern = ActorQueryOperationQuadpattern;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-quadpattern/lib/ActorQueryOperationQuadpattern.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationQuadpattern","bus_query_operation_1","require","asynciterator_1","rdf_string_1","rdf_terms_1","ActorQueryOperationTyped","constructor","args","isTermVariable","term","termType","getVariables","pattern","uniqTerms","getTerms","filter","map","x","termToString","getDuplicateElementLinks","variableElements","duplicateVariables","key","QUAD_TERM_NAMES","val","length","push","duplicateElementLinks","variable","elements","remainingElements","slice","getMetadata","data","Promise","resolve","reject","getProperty","metadata","on","testOperation","operation","context","runOperation","merge","result","mediatorResolveQuadPattern","mediate","variables","elementVariables","reduceTerms","acc","quadBindingsReducer","bindingsStream","TransformIterator","filteredOutput","quad","element1","TRIPLE_TERM_NAMES","element2","equals","Bindings","autoStart","maxBufferSize","type","canContainUndefs"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationQuadpattern = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst rdf_terms_1 = require(\"rdf-terms\");\n/**\n * A comunica actor for handling 'quadpattern' query operations.\n */\nclass ActorQueryOperationQuadpattern extends bus_query_operation_1.ActorQueryOperationTyped {\n    constructor(args) {\n        super(args, 'pattern');\n    }\n    /**\n     * Check if a term is a variable.\n     * @param {RDF.Term} term An RDF term.\n     * @return {any} If the term is a variable or blank node.\n     */\n    static isTermVariable(term) {\n        return term.termType === 'Variable';\n    }\n    /**\n     * Get all variables in the given pattern.\n     * No duplicates are returned.\n     * @param {RDF.BaseQuad} pattern A quad pattern.\n     * @return {string[]} The variables in this pattern, with '?' prefix.\n     */\n    static getVariables(pattern) {\n        return rdf_terms_1.uniqTerms(rdf_terms_1.getTerms(pattern)\n            .filter(ActorQueryOperationQuadpattern.isTermVariable))\n            .map(x => rdf_string_1.termToString(x));\n    }\n    /**\n     * A helper function to find a hash with quad elements that have duplicate variables.\n     *\n     * @param {RDF.Quad} pattern A quad pattern.\n     *\n     * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns undefined.\n     *                                   Otherwise, this maps quad elements ('subject', 'predicate', 'object', 'graph')\n     *                                   to the list of quad elements it shares a variable name with.\n     *                                   If no links for a certain element exist, this element will\n     *                                   not be included in the hash.\n     *                                   Note 1: Quad elements will never have a link to themselves.\n     *                                           So this can never occur: { subject: [ 'subject'] },\n     *                                           instead 'null' would be returned.\n     *                                   Note 2: Links only exist in one direction,\n     *                                           this means that { subject: [ 'predicate'], predicate: [ 'subject' ] }\n     *                                           will not occur, instead only { subject: [ 'predicate'] }\n     *                                           will be returned.\n     */\n    static getDuplicateElementLinks(pattern) {\n        // Collect a variable to quad elements mapping.\n        const variableElements = {};\n        let duplicateVariables = false;\n        for (const key of rdf_terms_1.QUAD_TERM_NAMES) {\n            if (pattern[key].termType === 'Variable') {\n                const val = rdf_string_1.termToString(pattern[key]);\n                const length = (variableElements[val] || (variableElements[val] = [])).push(key);\n                duplicateVariables = duplicateVariables || length > 1;\n            }\n        }\n        if (!duplicateVariables) {\n            return;\n        }\n        // Collect quad element to elements with equal variables mapping.\n        const duplicateElementLinks = {};\n        for (const variable in variableElements) {\n            const elements = variableElements[variable];\n            const remainingElements = elements.slice(1);\n            // Only store the elements that have at least one equal element.\n            if (remainingElements.length > 0) {\n                duplicateElementLinks[elements[0]] = remainingElements;\n            }\n        }\n        return duplicateElementLinks;\n    }\n    /**\n     * Get the metadata of the given action on a quad stream.\n     *\n     * @param {AsyncIterator<Quad>} data The data stream that is guaranteed to emit the metadata property.\n     * @return {() => Promise<{[p: string]: any}>} A lazy promise behind a callback resolving to a metadata object.\n     */\n    static getMetadata(data) {\n        return () => new Promise((resolve, reject) => {\n            data.getProperty('metadata', (metadata) => resolve(metadata));\n            data.on('error', reject);\n        });\n    }\n    async testOperation(operation, context) {\n        return true;\n    }\n    async runOperation(pattern, context) {\n        // Apply the (optional) pattern-specific context\n        if (pattern.context) {\n            context = context ? context.merge(pattern.context) : pattern.context;\n        }\n        // Resolve the quad pattern\n        const result = await this.mediatorResolveQuadPattern.mediate({ pattern, context });\n        // Collect all variables from the pattern\n        const variables = ActorQueryOperationQuadpattern.getVariables(pattern);\n        // Create the metadata callback\n        const metadata = ActorQueryOperationQuadpattern.getMetadata(result.data);\n        // Convenience datastructure for mapping quad elements to variables\n        const elementVariables = rdf_terms_1.reduceTerms(pattern, (acc, term, key) => {\n            if (ActorQueryOperationQuadpattern.isTermVariable(term)) {\n                acc[key] = rdf_string_1.termToString(term);\n            }\n            return acc;\n        }, {});\n        const quadBindingsReducer = (acc, term, key) => {\n            const variable = elementVariables[key];\n            if (variable) {\n                acc[variable] = term;\n            }\n            return acc;\n        };\n        // Optionally filter, and construct bindings\n        const bindingsStream = new asynciterator_1.TransformIterator(async () => {\n            let filteredOutput = result.data;\n            // Detect duplicate variables in the pattern\n            const duplicateElementLinks = ActorQueryOperationQuadpattern\n                .getDuplicateElementLinks(pattern);\n            // If there are duplicate variables in the search pattern,\n            // make sure that we filter out the triples that don't have equal values for those triple elements,\n            // as QPF ignores variable names.\n            if (duplicateElementLinks) {\n                filteredOutput = filteredOutput.filter(quad => {\n                    // No need to check the graph, because an equal element already would have to be found in s, p, or o.\n                    for (const element1 of rdf_terms_1.TRIPLE_TERM_NAMES) {\n                        for (const element2 of duplicateElementLinks[element1] || []) {\n                            if (!quad[element1].equals(quad[element2])) {\n                                return false;\n                            }\n                        }\n                    }\n                    return true;\n                });\n            }\n            return filteredOutput.map(quad => bus_query_operation_1.Bindings(rdf_terms_1.reduceTerms(quad, quadBindingsReducer, {})), { autoStart: true, maxBufferSize: 128 });\n        }, { autoStart: false });\n        return { type: 'bindings', bindingsStream, variables, metadata, canContainUndefs: false };\n    }\n}\nexports.ActorQueryOperationQuadpattern = ActorQueryOperationQuadpattern;\n//# sourceMappingURL=ActorQueryOperationQuadpattern.js.map"]},"metadata":{},"sourceType":"script"}