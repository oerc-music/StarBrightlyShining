{"ast":null,"code":"// **N3Store** objects store N3 quads by graph in memory.\nimport { default as N3DataFactory, termToId, termFromId } from './N3DataFactory';\nimport { Readable } from 'readable-stream';\nimport namespaces from './IRIs'; // ## Constructor\n\nexport default class N3Store {\n  constructor(quads, options) {\n    // The number of quads is initially zero\n    this._size = 0; // `_graphs` contains subject, predicate, and object indexes per graph\n\n    this._graphs = Object.create(null); // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n\n    this._entities = Object.create(null); // inverse of `_ids`\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n\n    this._blankNodeIndex = 0; // Shift parameters if `quads` is not given\n\n    if (!options && quads && !quads[0]) options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory; // Add quads if passed\n\n    if (quads) this.addQuads(quads);\n  } // ## Public properties\n  // ### `size` returns the number of quads in the store\n\n\n  get size() {\n    // Return the quad count if if was cached\n    let size = this._size;\n    if (size !== null) return size; // Calculate the number of quads by counting to the deepest level\n\n    size = 0;\n    const graphs = this._graphs;\n    let subjects, subject;\n\n    for (const graphKey in graphs) for (const subjectKey in subjects = graphs[graphKey].subjects) for (const predicateKey in subject = subjects[subjectKey]) size += Object.keys(subject[predicateKey]).length;\n\n    return this._size = size;\n  } // ## Private methods\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n\n\n  _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {});\n    const index2 = index1[key1] || (index1[key1] = {}); // Setting the key to _any_ value signals the presence of the quad\n\n    const existed = (key2 in index2);\n    if (!existed) index2[key2] = null;\n    return !existed;\n  } // ### `_removeFromIndex` removes a quad from a three-layered index\n\n\n  _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0],\n          index2 = index1[key1];\n    delete index2[key2]; // Remove intermediary index layers if they are empty\n\n    for (const key in index2) return;\n\n    delete index1[key1];\n\n    for (const key in index1) return;\n\n    delete index0[key0];\n  } // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graph` will be the graph of the created quads.\n  // If `callback` is given, each result is passed through it\n  // and iteration halts when it returns truthy for any quad.\n  // If instead `array` is given, each result is added to the array.\n\n\n  _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n    let tmp, index1, index2; // Depending on the number of variables, keys or reverse index are faster\n\n    const varCount = !key0 + !key1 + !key2,\n          entityKeys = varCount > 1 ? Object.keys(this._ids) : this._entities; // If a key is specified, use only that part of index 0.\n\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n\n    for (const value0 in index0) {\n      const entity0 = entityKeys[value0];\n\n      if (index1 = index0[value0]) {\n        // If a key is specified, use only that part of index 1.\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n\n        for (const value1 in index1) {\n          const entity1 = entityKeys[value1];\n\n          if (index2 = index1[value1]) {\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2); // Create quads for all items found in index 2.\n\n            for (let l = 0; l < values.length; l++) {\n              const parts = {\n                subject: null,\n                predicate: null,\n                object: null\n              };\n              parts[name0] = termFromId(entity0, this._factory);\n              parts[name1] = termFromId(entity1, this._factory);\n              parts[name2] = termFromId(entityKeys[values[l]], this._factory);\n\n              const quad = this._factory.quad(parts.subject, parts.predicate, parts.object, termFromId(graph, this._factory));\n\n              if (array) array.push(quad);else if (callback(quad)) return true;\n            }\n          }\n        }\n      }\n    }\n\n    return array;\n  } // ### `_loop` executes the callback on all keys of index 0\n\n\n  _loop(index0, callback) {\n    for (const key0 in index0) callback(key0);\n  } // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n\n\n  _loopByKey0(index0, key0, callback) {\n    let index1, key1;\n\n    if (index1 = index0[key0]) {\n      for (key1 in index1) callback(key1);\n    }\n  } // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n\n\n  _loopByKey1(index0, key1, callback) {\n    let key0, index1;\n\n    for (key0 in index0) {\n      index1 = index0[key0];\n      if (index1[key1]) callback(key0);\n    }\n  } // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n\n\n  _loopBy2Keys(index0, key0, key1, callback) {\n    let index1, index2, key2;\n\n    if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n      for (key2 in index2) callback(key2);\n    }\n  } // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n\n\n  _countInIndex(index0, key0, key1, key2) {\n    let count = 0,\n        tmp,\n        index1,\n        index2; // If a key is specified, count only that part of index 0\n\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        // If a key is specified, count only that part of index 1\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            // If a key is specified, count the quad if it exists\n            if (key2) key2 in index2 && count++; // Otherwise, count all quads\n            else count += Object.keys(index2).length;\n          }\n        }\n      }\n    }\n\n    return count;\n  } // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n\n\n  _getGraphs(graph) {\n    if (!isString(graph)) return this._graphs;\n    const graphs = {};\n    graphs[graph] = this._graphs[graph];\n    return graphs;\n  } // ### `_uniqueEntities` returns a function that accepts an entity ID\n  // and passes the corresponding entity to callback if it hasn't occurred before.\n\n\n  _uniqueEntities(callback) {\n    const uniqueIds = Object.create(null);\n    return id => {\n      if (!(id in uniqueIds)) {\n        uniqueIds[id] = true;\n        callback(termFromId(this._entities[id], this._factory));\n      }\n    };\n  } // ## Public methods\n  // ### `add` adds the specified quad to the dataset.\n  // Returns the dataset instance it was called on.\n  // Existing quads, as defined in Quad.equals, will be ignored.\n\n\n  add(quad) {\n    this.addQuad(quad);\n    return this;\n  } // ### `addQuad` adds a new quad to the store.\n  // Returns if the quad index has changed, if the quad did not already exist.\n\n\n  addQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation\n\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph); // Find the graph that will contain the triple\n\n    let graphItem = this._graphs[graph]; // Create the graph if it doesn't exist yet\n\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = {\n        subjects: {},\n        predicates: {},\n        objects: {}\n      }; // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n\n      Object.freeze(graphItem);\n    } // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n\n\n    const ids = this._ids;\n    const entities = this._entities;\n    subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n    object = ids[object] || (ids[entities[++this._id] = object] = this._id);\n\n    const changed = this._addToIndex(graphItem.subjects, subject, predicate, object);\n\n    this._addToIndex(graphItem.predicates, predicate, object, subject);\n\n    this._addToIndex(graphItem.objects, object, subject, predicate); // The cached quad count is now invalid\n\n\n    this._size = null;\n    return changed;\n  } // ### `addQuads` adds multiple quads to the store\n\n\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++) this.addQuad(quads[i]);\n  } // ### `delete` removes the specified quad from the dataset.\n  // Returns the dataset instance it was called on.\n\n\n  delete(quad) {\n    this.removeQuad(quad);\n    return this;\n  } // ### `has` determines whether a dataset includes a certain quad.\n  // Returns true or false as appropriate.\n\n\n  has(quad) {\n    const quads = this.getQuads(quad.subject, quad.predicate, quad.object, quad.graph);\n    return quads.length !== 0;\n  } // ### `import` adds a stream of quads to the store\n\n\n  import(stream) {\n    stream.on('data', quad => {\n      this.addQuad(quad);\n    });\n    return stream;\n  } // ### `removeQuad` removes a quad from the store if it exists\n\n\n  removeQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation\n\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph); // Find internal identifiers for all components\n    // and verify the quad exists.\n\n    const ids = this._ids,\n          graphs = this._graphs;\n    let graphItem, subjects, predicates;\n    if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) return false; // Remove it from all indexes\n\n    this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n\n    this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n\n    this._removeFromIndex(graphItem.objects, object, subject, predicate);\n\n    if (this._size !== null) this._size--; // Remove the graph if it is empty\n\n    for (subject in graphItem.subjects) return true;\n\n    delete graphs[graph];\n    return true;\n  } // ### `removeQuads` removes multiple quads from the store\n\n\n  removeQuads(quads) {\n    for (let i = 0; i < quads.length; i++) this.removeQuad(quads[i]);\n  } // ### `remove` removes a stream of quads from the store\n\n\n  remove(stream) {\n    stream.on('data', quad => {\n      this.removeQuad(quad);\n    });\n    return stream;\n  } // ### `removeMatches` removes all matching quads from the store\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  removeMatches(subject, predicate, object, graph) {\n    const stream = new Readable({\n      objectMode: true\n    });\n\n    stream._read = () => {\n      for (const quad of this.getQuads(subject, predicate, object, graph)) stream.push(quad);\n\n      stream.push(null);\n    };\n\n    return this.remove(stream);\n  } // ### `deleteGraph` removes all triples with the given graph from the store\n\n\n  deleteGraph(graph) {\n    return this.removeMatches(null, null, null, graph);\n  } // ### `getQuads` returns an array of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  getQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const quads = [],\n          graphs = this._getGraphs(graph),\n          ids = this._ids;\n\n    let content, subjectId, predicateId, objectId; // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return quads;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId) // If subject and object are given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads);else // If only subject and possibly predicate are given, the subject index will be the fastest\n            this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads);\n        } else if (predicateId) // If only predicate and possibly object are given, the predicate index will be the fastest\n          this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads);else if (objectId) // If only object is given, the object index will be the fastest\n          this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads);else // If nothing is given, iterate subjects and predicates first\n          this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads);\n      }\n    }\n\n    return quads;\n  } // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.\n  // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.\n  // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.\n  // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  // For backwards compatibility, the object return also implements the Readable stream interface.\n\n\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph);\n  } // ### `countQuads` returns the number of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  countQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const graphs = this._getGraphs(graph),\n          ids = this._ids;\n\n    let count = 0,\n        content,\n        subjectId,\n        predicateId,\n        objectId; // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return 0;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subject) {\n          if (object) // If subject and object are given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);else // If only subject and possibly predicate are given, the subject index will be the fastest\n            count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n        } else if (predicate) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n        } else {\n          // If only object is possibly given, the object index will be the fastest\n          count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n        }\n      }\n    }\n\n    return count;\n  } // ### `forEach` executes the callback on all quads.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  forEach(callback, subject, predicate, object, graph) {\n    this.some(quad => {\n      callback(quad);\n      return false;\n    }, subject, predicate, object, graph);\n  } // ### `every` executes the callback on all quads,\n  // and returns `true` if it returns truthy for all them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  every(callback, subject, predicate, object, graph) {\n    let some = false;\n    const every = !this.some(quad => {\n      some = true;\n      return !callback(quad);\n    }, subject, predicate, object, graph);\n    return some && every;\n  } // ### `some` executes the callback on all quads,\n  // and returns `true` if it returns truthy for any of them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  some(callback, subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const graphs = this._getGraphs(graph),\n          ids = this._ids;\n\n    let content, subjectId, predicateId, objectId; // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return false;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId) {\n            // If subject and object are given, the object index will be the fastest\n            if (this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, callback, null)) return true;\n          } else // If only subject and possibly predicate are given, the subject index will be the fastest\n            if (this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, callback, null)) return true;\n        } else if (predicateId) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          if (this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, callback, null)) {\n            return true;\n          }\n        } else if (objectId) {\n          // If only object is given, the object index will be the fastest\n          if (this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, callback, null)) {\n            return true;\n          }\n        } else // If nothing is given, iterate subjects and predicates first\n          if (this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, callback, null)) {\n            return true;\n          }\n      }\n    }\n\n    return false;\n  } // ### `getSubjects` returns all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  getSubjects(predicate, object, graph) {\n    const results = [];\n    this.forSubjects(s => {\n      results.push(s);\n    }, predicate, object, graph);\n    return results;\n  } // ### `forSubjects` executes the callback on all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  forSubjects(callback, predicate, object, graph) {\n    // Convert terms to internal string representation\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids,\n          graphs = this._getGraphs(graph);\n\n    let content, predicateId, objectId;\n    callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n    if (isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (predicateId) {\n          if (objectId) // If predicate and object are given, the POS index is best.\n            this._loopBy2Keys(content.predicates, predicateId, objectId, callback);else // If only predicate is given, the SPO index is best.\n            this._loopByKey1(content.subjects, predicateId, callback);\n        } else if (objectId) // If only object is given, the OSP index is best.\n          this._loopByKey0(content.objects, objectId, callback);else // If no params given, iterate all the subjects\n          this._loop(content.subjects, callback);\n      }\n    }\n  } // ### `getPredicates` returns all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  getPredicates(subject, object, graph) {\n    const results = [];\n    this.forPredicates(p => {\n      results.push(p);\n    }, subject, object, graph);\n    return results;\n  } // ### `forPredicates` executes the callback on all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  forPredicates(callback, subject, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids,\n          graphs = this._getGraphs(graph);\n\n    let content, subjectId, objectId;\n    callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(object) && !(objectId = ids[object])) return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (objectId) // If subject and object are given, the OSP index is best.\n            this._loopBy2Keys(content.objects, objectId, subjectId, callback);else // If only subject is given, the SPO index is best.\n            this._loopByKey0(content.subjects, subjectId, callback);\n        } else if (objectId) // If only object is given, the POS index is best.\n          this._loopByKey1(content.predicates, objectId, callback);else // If no params given, iterate all the predicates.\n          this._loop(content.predicates, callback);\n      }\n    }\n  } // ### `getObjects` returns all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  getObjects(subject, predicate, graph) {\n    const results = [];\n    this.forObjects(o => {\n      results.push(o);\n    }, subject, predicate, graph);\n    return results;\n  } // ### `forObjects` executes the callback on all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  forObjects(callback, subject, predicate, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids,\n          graphs = this._getGraphs(graph);\n\n    let content, subjectId, predicateId;\n    callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate])) return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (predicateId) // If subject and predicate are given, the SPO index is best.\n            this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);else // If only subject is given, the OSP index is best.\n            this._loopByKey1(content.objects, subjectId, callback);\n        } else if (predicateId) // If only predicate is given, the POS index is best.\n          this._loopByKey0(content.predicates, predicateId, callback);else // If no params given, iterate all the objects.\n          this._loop(content.objects, callback);\n      }\n    }\n  } // ### `getGraphs` returns all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  getGraphs(subject, predicate, object) {\n    const results = [];\n    this.forGraphs(g => {\n      results.push(g);\n    }, subject, predicate, object);\n    return results;\n  } // ### `forGraphs` executes the callback on all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  forGraphs(callback, subject, predicate, object) {\n    for (const graph in this._graphs) {\n      this.some(quad => {\n        callback(quad.graph);\n        return true; // Halt iteration of some()\n      }, subject, predicate, object, graph);\n    }\n  } // ### `createBlankNode` creates a new blank node, returning its name\n\n\n  createBlankNode(suggestedName) {\n    let name, index; // Generate a name based on the suggested name\n\n    if (suggestedName) {\n      name = suggestedName = `_:${suggestedName}`, index = 1;\n\n      while (this._ids[name]) name = suggestedName + index++;\n    } // Generate a generic blank node name\n    else {\n      do {\n        name = `_:b${this._blankNodeIndex++}`;\n      } while (this._ids[name]);\n    } // Add the blank node to the entities, avoiding the generation of duplicates\n\n\n    this._ids[name] = ++this._id;\n    this._entities[this._id] = name;\n    return this._factory.blankNode(name.substr(2));\n  } // ### `extractLists` finds and removes all list triples\n  // and returns the items per list.\n\n\n  extractLists({\n    remove = false,\n    ignoreErrors = false\n  } = {}) {\n    const lists = {}; // has scalar keys so could be a simple Object\n\n    const onError = ignoreErrors ? () => true : (node, message) => {\n      throw new Error(`${node.value} ${message}`);\n    }; // Traverse each list from its tail\n\n    const tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);\n    const toRemove = remove ? [...tails] : [];\n    tails.forEach(tailQuad => {\n      const items = []; // the members found as objects of rdf:first quads\n\n      let malformed = false; // signals whether the current list is malformed\n\n      let head; // the head of the list (_:b1 in above example)\n\n      let headPos; // set to subject or object when head is set\n\n      const graph = tailQuad.graph; // make sure list is in exactly one graph\n      // Traverse the list from tail to end\n\n      let current = tailQuad.subject;\n\n      while (current && !malformed) {\n        const objectQuads = this.getQuads(null, null, current, null);\n        const subjectQuads = this.getQuads(current, null, null, null);\n        let quad,\n            first = null,\n            rest = null,\n            parent = null; // Find the first and rest of this list node\n\n        for (let i = 0; i < subjectQuads.length && !malformed; i++) {\n          quad = subjectQuads[i];\n          if (!quad.graph.equals(graph)) malformed = onError(current, 'not confined to single graph');else if (head) malformed = onError(current, 'has non-list arcs out'); // one rdf:first\n          else if (quad.predicate.value === namespaces.rdf.first) {\n            if (first) malformed = onError(current, 'has multiple rdf:first arcs');else toRemove.push(first = quad);\n          } // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (rest) malformed = onError(current, 'has multiple rdf:rest arcs');else toRemove.push(rest = quad);\n          } // alien triple\n          else if (objectQuads.length) malformed = onError(current, 'can\\'t be subject and object');else {\n            head = quad; // e.g. { (1 2 3) :p :o }\n\n            headPos = 'subject';\n          }\n        } // { :s :p (1 2) } arrives here with no head\n        // { (1 2) :p :o } arrives here with head set to the list.\n\n\n        for (let i = 0; i < objectQuads.length && !malformed; ++i) {\n          quad = objectQuads[i];\n          if (head) malformed = onError(current, 'can\\'t have coreferences'); // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (parent) malformed = onError(current, 'has incoming rdf:rest arcs');else parent = quad;\n          } else {\n            head = quad; // e.g. { :s :p (1 2) }\n\n            headPos = 'object';\n          }\n        } // Store the list item and continue with parent\n\n\n        if (!first) malformed = onError(current, 'has no list head');else items.unshift(first.object);\n        current = parent && parent.subject;\n      } // Don't remove any quads if the list is malformed\n\n\n      if (malformed) remove = false; // Store the list under the value of its head\n      else if (head) lists[head[headPos].value] = items;\n    }); // Remove list quads if requested\n\n    if (remove) this.removeQuads(toRemove);\n    return lists;\n  } // ### Store is an iterable.\n  // Can be used where iterables are expected: for...of loops, array spread operator,\n  // `yield*`, and destructuring assignment (order is not guaranteed).\n\n\n  *[Symbol.iterator]() {\n    yield* this.getQuads();\n  }\n\n} // Determines whether the argument is a string\n\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\n/**\n * A class that implements both DatasetCore and Readable.\n */\n\n\nclass DatasetCoreAndReadableStream extends Readable {\n  constructor(n3Store, subject, predicate, object, graph) {\n    super({\n      objectMode: true\n    });\n    Object.assign(this, {\n      n3Store,\n      subject,\n      predicate,\n      object,\n      graph\n    });\n  }\n\n  get filtered() {\n    if (!this._filtered) {\n      const {\n        n3Store,\n        graph,\n        object,\n        predicate,\n        subject\n      } = this;\n      const quads = n3Store.getQuads(subject, predicate, object, graph);\n      this._filtered = new N3Store(quads, {\n        factory: n3Store._factory\n      });\n    }\n\n    return this._filtered;\n  }\n\n  get size() {\n    return this.filtered.size;\n  }\n\n  _read() {\n    for (const quad of this.filtered.getQuads()) this.push(quad);\n\n    this.push(null);\n  }\n\n  add(quad) {\n    return this.filtered.add(quad);\n  }\n\n  delete(quad) {\n    return this.filtered.delete(quad);\n  }\n\n  has(quad) {\n    return this.filtered.has(quad);\n  }\n\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph);\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.filtered.getQuads();\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/n3/src/N3Store.js"],"names":["default","N3DataFactory","termToId","termFromId","Readable","namespaces","N3Store","constructor","quads","options","_size","_graphs","Object","create","_id","_ids","_entities","_blankNodeIndex","_factory","factory","addQuads","size","graphs","subjects","subject","graphKey","subjectKey","predicateKey","keys","length","_addToIndex","index0","key0","key1","key2","index1","index2","existed","_removeFromIndex","key","_findInIndex","name0","name1","name2","graph","callback","array","tmp","varCount","entityKeys","value0","entity0","value1","entity1","values","l","parts","predicate","object","quad","push","_loop","_loopByKey0","_loopByKey1","_loopBy2Keys","_countInIndex","count","_getGraphs","isString","_uniqueEntities","uniqueIds","id","add","addQuad","graphItem","predicates","objects","freeze","ids","entities","changed","i","delete","removeQuad","has","getQuads","import","stream","on","removeQuads","remove","removeMatches","objectMode","_read","deleteGraph","content","subjectId","predicateId","objectId","graphId","match","DatasetCoreAndReadableStream","countQuads","forEach","some","every","getSubjects","results","forSubjects","s","getPredicates","forPredicates","p","getObjects","forObjects","o","getGraphs","forGraphs","g","createBlankNode","suggestedName","name","index","blankNode","substr","extractLists","ignoreErrors","lists","onError","node","message","Error","value","tails","rdf","rest","nil","toRemove","tailQuad","items","malformed","head","headPos","current","objectQuads","subjectQuads","first","parent","equals","unshift","Symbol","iterator","String","n3Store","assign","filtered","_filtered"],"mappings":"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","sourcesContent":["// **N3Store** objects store N3 quads by graph in memory.\nimport { default as N3DataFactory, termToId, termFromId } from './N3DataFactory';\nimport { Readable } from 'readable-stream';\nimport namespaces from './IRIs';\n\n// ## Constructor\nexport default class N3Store {\n  constructor(quads, options) {\n    // The number of quads is initially zero\n    this._size = 0;\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null);\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null); // inverse of `_ids`\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n    this._blankNodeIndex = 0;\n\n    // Shift parameters if `quads` is not given\n    if (!options && quads && !quads[0])\n      options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory;\n\n    // Add quads if passed\n    if (quads)\n      this.addQuads(quads);\n  }\n\n  // ## Public properties\n\n  // ### `size` returns the number of quads in the store\n  get size() {\n    // Return the quad count if if was cached\n    let size = this._size;\n    if (size !== null)\n      return size;\n\n    // Calculate the number of quads by counting to the deepest level\n    size = 0;\n    const graphs = this._graphs;\n    let subjects, subject;\n    for (const graphKey in graphs)\n      for (const subjectKey in (subjects = graphs[graphKey].subjects))\n        for (const predicateKey in (subject = subjects[subjectKey]))\n          size += Object.keys(subject[predicateKey]).length;\n    return this._size = size;\n  }\n\n  // ## Private methods\n\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n  _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {});\n    const index2 = index1[key1] || (index1[key1] = {});\n    // Setting the key to _any_ value signals the presence of the quad\n    const existed = key2 in index2;\n    if (!existed)\n      index2[key2] = null;\n    return !existed;\n  }\n\n  // ### `_removeFromIndex` removes a quad from a three-layered index\n  _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0], index2 = index1[key1];\n    delete index2[key2];\n\n    // Remove intermediary index layers if they are empty\n    for (const key in index2) return;\n    delete index1[key1];\n    for (const key in index1) return;\n    delete index0[key0];\n  }\n\n  // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graph` will be the graph of the created quads.\n  // If `callback` is given, each result is passed through it\n  // and iteration halts when it returns truthy for any quad.\n  // If instead `array` is given, each result is added to the array.\n  _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n    let tmp, index1, index2;\n    // Depending on the number of variables, keys or reverse index are faster\n    const varCount = !key0 + !key1 + !key2,\n        entityKeys = varCount > 1 ? Object.keys(this._ids) : this._entities;\n\n    // If a key is specified, use only that part of index 0.\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (const value0 in index0) {\n      const entity0 = entityKeys[value0];\n\n      if (index1 = index0[value0]) {\n        // If a key is specified, use only that part of index 1.\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (const value1 in index1) {\n          const entity1 = entityKeys[value1];\n\n          if (index2 = index1[value1]) {\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2);\n            // Create quads for all items found in index 2.\n            for (let l = 0; l < values.length; l++) {\n              const parts = { subject: null, predicate: null, object: null };\n              parts[name0] = termFromId(entity0, this._factory);\n              parts[name1] = termFromId(entity1, this._factory);\n              parts[name2] = termFromId(entityKeys[values[l]], this._factory);\n              const quad = this._factory.quad(\n                parts.subject, parts.predicate, parts.object, termFromId(graph, this._factory));\n              if (array)\n                array.push(quad);\n              else if (callback(quad))\n                return true;\n            }\n          }\n        }\n      }\n    }\n    return array;\n  }\n\n  // ### `_loop` executes the callback on all keys of index 0\n  _loop(index0, callback) {\n    for (const key0 in index0)\n      callback(key0);\n  }\n\n  // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n  _loopByKey0(index0, key0, callback) {\n    let index1, key1;\n    if (index1 = index0[key0]) {\n      for (key1 in index1)\n        callback(key1);\n    }\n  }\n\n  // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n  _loopByKey1(index0, key1, callback) {\n    let key0, index1;\n    for (key0 in index0) {\n      index1 = index0[key0];\n      if (index1[key1])\n        callback(key0);\n    }\n  }\n\n  // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n  _loopBy2Keys(index0, key0, key1, callback) {\n    let index1, index2, key2;\n    if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n      for (key2 in index2)\n        callback(key2);\n    }\n  }\n\n  // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  _countInIndex(index0, key0, key1, key2) {\n    let count = 0, tmp, index1, index2;\n\n    // If a key is specified, count only that part of index 0\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        // If a key is specified, count only that part of index 1\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            // If a key is specified, count the quad if it exists\n            if (key2) (key2 in index2) && count++;\n            // Otherwise, count all quads\n            else count += Object.keys(index2).length;\n          }\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n  _getGraphs(graph) {\n    if (!isString(graph))\n      return this._graphs;\n    const graphs = {};\n    graphs[graph] = this._graphs[graph];\n    return graphs;\n  }\n\n  // ### `_uniqueEntities` returns a function that accepts an entity ID\n  // and passes the corresponding entity to callback if it hasn't occurred before.\n  _uniqueEntities(callback) {\n    const uniqueIds = Object.create(null);\n    return id => {\n      if (!(id in uniqueIds)) {\n        uniqueIds[id] = true;\n        callback(termFromId(this._entities[id], this._factory));\n      }\n    };\n  }\n\n  // ## Public methods\n\n  // ### `add` adds the specified quad to the dataset.\n  // Returns the dataset instance it was called on.\n  // Existing quads, as defined in Quad.equals, will be ignored.\n  add(quad) {\n    this.addQuad(quad);\n    return this;\n  }\n\n  // ### `addQuad` adds a new quad to the store.\n  // Returns if the quad index has changed, if the quad did not already exist.\n  addQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate)\n      graph = subject.graph, object = subject.object,\n        predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph);\n\n    // Find the graph that will contain the triple\n    let graphItem = this._graphs[graph];\n    // Create the graph if it doesn't exist yet\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };\n      // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n      Object.freeze(graphItem);\n    }\n\n    // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n    const ids = this._ids;\n    const entities = this._entities;\n    subject   = ids[subject]   || (ids[entities[++this._id] = subject]   = this._id);\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n    object    = ids[object]    || (ids[entities[++this._id] = object]    = this._id);\n\n    const changed = this._addToIndex(graphItem.subjects,   subject,   predicate, object);\n    this._addToIndex(graphItem.predicates, predicate, object,    subject);\n    this._addToIndex(graphItem.objects,    object,    subject,   predicate);\n\n    // The cached quad count is now invalid\n    this._size = null;\n    return changed;\n  }\n\n  // ### `addQuads` adds multiple quads to the store\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.addQuad(quads[i]);\n  }\n\n  // ### `delete` removes the specified quad from the dataset.\n  // Returns the dataset instance it was called on.\n  delete(quad) {\n    this.removeQuad(quad);\n    return this;\n  }\n\n  // ### `has` determines whether a dataset includes a certain quad.\n  // Returns true or false as appropriate.\n  has(quad) {\n    const quads = this.getQuads(quad.subject, quad.predicate, quad.object, quad.graph);\n    return quads.length !== 0;\n  }\n\n  // ### `import` adds a stream of quads to the store\n  import(stream) {\n    stream.on('data', quad => { this.addQuad(quad); });\n    return stream;\n  }\n\n  // ### `removeQuad` removes a quad from the store if it exists\n  removeQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate)\n      graph = subject.graph, object = subject.object,\n        predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph);\n\n    // Find internal identifiers for all components\n    // and verify the quad exists.\n    const ids = this._ids, graphs = this._graphs;\n    let graphItem, subjects, predicates;\n    if (!(subject    = ids[subject]) || !(predicate = ids[predicate]) ||\n        !(object     = ids[object])  || !(graphItem = graphs[graph])  ||\n        !(subjects   = graphItem.subjects[subject]) ||\n        !(predicates = subjects[predicate]) ||\n        !(object in predicates))\n      return false;\n\n    // Remove it from all indexes\n    this._removeFromIndex(graphItem.subjects,   subject,   predicate, object);\n    this._removeFromIndex(graphItem.predicates, predicate, object,    subject);\n    this._removeFromIndex(graphItem.objects,    object,    subject,   predicate);\n    if (this._size !== null) this._size--;\n\n    // Remove the graph if it is empty\n    for (subject in graphItem.subjects) return true;\n    delete graphs[graph];\n    return true;\n  }\n\n  // ### `removeQuads` removes multiple quads from the store\n  removeQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.removeQuad(quads[i]);\n  }\n\n  // ### `remove` removes a stream of quads from the store\n  remove(stream) {\n    stream.on('data', quad => { this.removeQuad(quad); });\n    return stream;\n  }\n\n  // ### `removeMatches` removes all matching quads from the store\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  removeMatches(subject, predicate, object, graph) {\n    const stream = new Readable({ objectMode: true });\n\n    stream._read = () => {\n      for (const quad of this.getQuads(subject, predicate, object, graph))\n        stream.push(quad);\n      stream.push(null);\n    };\n\n    return this.remove(stream);\n  }\n\n  // ### `deleteGraph` removes all triples with the given graph from the store\n  deleteGraph(graph) {\n    return this.removeMatches(null, null, null, graph);\n  }\n\n  // ### `getQuads` returns an array of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const quads = [], graphs = this._getGraphs(graph), ids = this._ids;\n    let content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject])   ||\n        isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return quads;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, subjectId, predicateId,\n                              'object', 'subject', 'predicate', graphId, null, quads);\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            this._findInIndex(content.subjects, subjectId, predicateId, null,\n                              'subject', 'predicate', 'object', graphId, null, quads);\n        }\n        else if (predicateId)\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          this._findInIndex(content.predicates, predicateId, objectId, null,\n                            'predicate', 'object', 'subject', graphId, null, quads);\n        else if (objectId)\n          // If only object is given, the object index will be the fastest\n          this._findInIndex(content.objects, objectId, null, null,\n                            'object', 'subject', 'predicate', graphId, null, quads);\n        else\n          // If nothing is given, iterate subjects and predicates first\n          this._findInIndex(content.subjects, null, null, null,\n                            'subject', 'predicate', 'object', graphId, null, quads);\n      }\n    }\n    return quads;\n  }\n\n  // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.\n  // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.\n  // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.\n  // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  // For backwards compatibility, the object return also implements the Readable stream interface.\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph);\n  }\n\n  // ### `countQuads` returns the number of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  countQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const graphs = this._getGraphs(graph), ids = this._ids;\n    let count = 0, content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject])   ||\n        isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return 0;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subject) {\n          if (object)\n            // If subject and object are given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n        }\n        else if (predicate) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n        }\n        else {\n          // If only object is possibly given, the object index will be the fastest\n          count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `forEach` executes the callback on all quads.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forEach(callback, subject, predicate, object, graph) {\n    this.some(quad => {\n      callback(quad);\n      return false;\n    }, subject, predicate, object, graph);\n  }\n\n  // ### `every` executes the callback on all quads,\n  // and returns `true` if it returns truthy for all them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  every(callback, subject, predicate, object, graph) {\n    let some = false;\n    const every = !this.some(quad => {\n      some = true;\n      return !callback(quad);\n    }, subject, predicate, object, graph);\n    return some && every;\n  }\n\n  // ### `some` executes the callback on all quads,\n  // and returns `true` if it returns truthy for any of them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  some(callback, subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const graphs = this._getGraphs(graph), ids = this._ids;\n    let content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject])   ||\n        isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return false;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId) {\n          // If subject and object are given, the object index will be the fastest\n            if (this._findInIndex(content.objects, objectId, subjectId, predicateId,\n                                  'object', 'subject', 'predicate', graphId, callback, null))\n              return true;\n          }\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            if (this._findInIndex(content.subjects, subjectId, predicateId, null,\n                                  'subject', 'predicate', 'object', graphId, callback, null))\n              return true;\n        }\n        else if (predicateId) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          if (this._findInIndex(content.predicates, predicateId, objectId, null,\n                                'predicate', 'object', 'subject', graphId, callback, null)) {\n            return true;\n          }\n        }\n        else if (objectId) {\n          // If only object is given, the object index will be the fastest\n          if (this._findInIndex(content.objects, objectId, null, null,\n                                'object', 'subject', 'predicate', graphId, callback, null)) {\n            return true;\n          }\n        }\n        else\n        // If nothing is given, iterate subjects and predicates first\n        if (this._findInIndex(content.subjects, null, null, null,\n                              'subject', 'predicate', 'object', graphId, callback, null)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  // ### `getSubjects` returns all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getSubjects(predicate, object, graph) {\n    const results = [];\n    this.forSubjects(s => { results.push(s); }, predicate, object, graph);\n    return results;\n  }\n\n  // ### `forSubjects` executes the callback on all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forSubjects(callback, predicate, object, graph) {\n    // Convert terms to internal string representation\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids, graphs = this._getGraphs(graph);\n    let content, predicateId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (predicateId) {\n          if (objectId)\n            // If predicate and object are given, the POS index is best.\n            this._loopBy2Keys(content.predicates, predicateId, objectId, callback);\n          else\n            // If only predicate is given, the SPO index is best.\n            this._loopByKey1(content.subjects, predicateId, callback);\n        }\n        else if (objectId)\n          // If only object is given, the OSP index is best.\n          this._loopByKey0(content.objects, objectId, callback);\n        else\n          // If no params given, iterate all the subjects\n          this._loop(content.subjects, callback);\n      }\n    }\n  }\n\n  // ### `getPredicates` returns all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getPredicates(subject, object, graph) {\n    const results = [];\n    this.forPredicates(p => { results.push(p); }, subject, object, graph);\n    return results;\n  }\n\n  // ### `forPredicates` executes the callback on all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forPredicates(callback, subject, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids, graphs = this._getGraphs(graph);\n    let content, subjectId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject) && !(subjectId = ids[subject]) ||\n        isString(object)  && !(objectId  = ids[object]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the OSP index is best.\n            this._loopBy2Keys(content.objects, objectId, subjectId, callback);\n          else\n            // If only subject is given, the SPO index is best.\n            this._loopByKey0(content.subjects, subjectId, callback);\n        }\n        else if (objectId)\n          // If only object is given, the POS index is best.\n          this._loopByKey1(content.predicates, objectId, callback);\n        else\n          // If no params given, iterate all the predicates.\n          this._loop(content.predicates, callback);\n      }\n    }\n  }\n\n  // ### `getObjects` returns all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getObjects(subject, predicate, graph) {\n    const results = [];\n    this.forObjects(o => { results.push(o); }, subject, predicate, graph);\n    return results;\n  }\n\n  // ### `forObjects` executes the callback on all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forObjects(callback, subject, predicate, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids, graphs = this._getGraphs(graph);\n    let content, subjectId, predicateId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject]) ||\n        isString(predicate) && !(predicateId = ids[predicate]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (predicateId)\n            // If subject and predicate are given, the SPO index is best.\n            this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);\n          else\n            // If only subject is given, the OSP index is best.\n            this._loopByKey1(content.objects, subjectId, callback);\n        }\n        else if (predicateId)\n          // If only predicate is given, the POS index is best.\n          this._loopByKey0(content.predicates, predicateId, callback);\n        else\n          // If no params given, iterate all the objects.\n          this._loop(content.objects, callback);\n      }\n    }\n  }\n\n  // ### `getGraphs` returns all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getGraphs(subject, predicate, object) {\n    const results = [];\n    this.forGraphs(g => { results.push(g); }, subject, predicate, object);\n    return results;\n  }\n\n  // ### `forGraphs` executes the callback on all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forGraphs(callback, subject, predicate, object) {\n    for (const graph in this._graphs) {\n      this.some(quad => {\n        callback(quad.graph);\n        return true; // Halt iteration of some()\n      }, subject, predicate, object, graph);\n    }\n  }\n\n  // ### `createBlankNode` creates a new blank node, returning its name\n  createBlankNode(suggestedName) {\n    let name, index;\n    // Generate a name based on the suggested name\n    if (suggestedName) {\n      name = suggestedName = `_:${suggestedName}`, index = 1;\n      while (this._ids[name])\n        name = suggestedName + index++;\n    }\n    // Generate a generic blank node name\n    else {\n      do { name = `_:b${this._blankNodeIndex++}`; }\n      while (this._ids[name]);\n    }\n    // Add the blank node to the entities, avoiding the generation of duplicates\n    this._ids[name] = ++this._id;\n    this._entities[this._id] = name;\n    return this._factory.blankNode(name.substr(2));\n  }\n\n  // ### `extractLists` finds and removes all list triples\n  // and returns the items per list.\n  extractLists({ remove = false, ignoreErrors = false } = {}) {\n    const lists = {}; // has scalar keys so could be a simple Object\n    const onError = ignoreErrors ? (() => true) :\n                  ((node, message) => { throw new Error(`${node.value} ${message}`); });\n\n    // Traverse each list from its tail\n    const tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);\n    const toRemove = remove ? [...tails] : [];\n    tails.forEach(tailQuad => {\n      const items = [];             // the members found as objects of rdf:first quads\n      let malformed = false;      // signals whether the current list is malformed\n      let head;                   // the head of the list (_:b1 in above example)\n      let headPos;                // set to subject or object when head is set\n      const graph = tailQuad.graph; // make sure list is in exactly one graph\n\n      // Traverse the list from tail to end\n      let current = tailQuad.subject;\n      while (current && !malformed) {\n        const objectQuads = this.getQuads(null, null, current, null);\n        const subjectQuads = this.getQuads(current, null, null, null);\n        let quad, first = null, rest = null, parent = null;\n\n        // Find the first and rest of this list node\n        for (let i = 0; i < subjectQuads.length && !malformed; i++) {\n          quad = subjectQuads[i];\n          if (!quad.graph.equals(graph))\n            malformed = onError(current, 'not confined to single graph');\n          else if (head)\n            malformed = onError(current, 'has non-list arcs out');\n\n          // one rdf:first\n          else if (quad.predicate.value === namespaces.rdf.first) {\n            if (first)\n              malformed = onError(current, 'has multiple rdf:first arcs');\n            else\n              toRemove.push(first = quad);\n          }\n\n          // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (rest)\n              malformed = onError(current, 'has multiple rdf:rest arcs');\n            else\n              toRemove.push(rest = quad);\n          }\n\n          // alien triple\n          else if (objectQuads.length)\n            malformed = onError(current, 'can\\'t be subject and object');\n          else {\n            head = quad; // e.g. { (1 2 3) :p :o }\n            headPos = 'subject';\n          }\n        }\n\n        // { :s :p (1 2) } arrives here with no head\n        // { (1 2) :p :o } arrives here with head set to the list.\n        for (let i = 0; i < objectQuads.length && !malformed; ++i) {\n          quad = objectQuads[i];\n          if (head)\n            malformed = onError(current, 'can\\'t have coreferences');\n          // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (parent)\n              malformed = onError(current, 'has incoming rdf:rest arcs');\n            else\n              parent = quad;\n          }\n          else {\n            head = quad; // e.g. { :s :p (1 2) }\n            headPos = 'object';\n          }\n        }\n\n        // Store the list item and continue with parent\n        if (!first)\n          malformed = onError(current, 'has no list head');\n        else\n          items.unshift(first.object);\n        current = parent && parent.subject;\n      }\n\n      // Don't remove any quads if the list is malformed\n      if (malformed)\n        remove = false;\n      // Store the list under the value of its head\n      else if (head)\n        lists[head[headPos].value] = items;\n    });\n\n    // Remove list quads if requested\n    if (remove)\n      this.removeQuads(toRemove);\n    return lists;\n  }\n\n  // ### Store is an iterable.\n  // Can be used where iterables are expected: for...of loops, array spread operator,\n  // `yield*`, and destructuring assignment (order is not guaranteed).\n  *[Symbol.iterator]() {\n    yield* this.getQuads();\n  }\n}\n\n// Determines whether the argument is a string\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\n\n/**\n * A class that implements both DatasetCore and Readable.\n */\nclass DatasetCoreAndReadableStream extends Readable {\n  constructor(n3Store, subject, predicate, object, graph) {\n    super({ objectMode: true });\n    Object.assign(this, { n3Store, subject, predicate, object, graph });\n  }\n\n  get filtered() {\n    if (!this._filtered) {\n      const { n3Store, graph, object, predicate, subject } = this;\n      const quads = n3Store.getQuads(subject, predicate, object, graph);\n      this._filtered = new N3Store(quads, { factory: n3Store._factory });\n    }\n    return this._filtered;\n  }\n  get size() {\n    return this.filtered.size;\n  }\n\n  _read() {\n    for (const quad of this.filtered.getQuads())\n      this.push(quad);\n    this.push(null);\n  }\n\n  add(quad) {\n    return this.filtered.add(quad);\n  }\n\n  delete(quad) {\n    return this.filtered.delete(quad);\n  }\n\n  has(quad) {\n    return this.filtered.has(quad);\n  }\n\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph);\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.filtered.getQuads();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}