{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnsupportedOperation = exports.SyncRecursiveEvaluator = exports.AsyncRecursiveEvaluator = void 0;\n\nconst E = require(\"../expressions\");\n\nconst Err = require(\"../util/Errors\");\n\nconst Transformation_1 = require(\"../Transformation\");\n\nconst sharedEvaluators = {\n  term(expr, mapping) {\n    return expr;\n  },\n\n  variable(expr, mapping) {\n    const term = mapping.get(expr.name);\n\n    if (!term) {\n      throw new Err.UnboundVariableError(expr.name, mapping);\n    }\n\n    return Transformation_1.transformRDFTermUnsafe(term);\n  }\n\n};\n\nclass AsyncRecursiveEvaluator {\n  constructor(context) {\n    this.context = context;\n    this.subEvaluators = {\n      // Shared\n      [E.ExpressionType.Term]: sharedEvaluators.term,\n      [E.ExpressionType.Variable]: sharedEvaluators.variable,\n      // Async\n      [E.ExpressionType.Operator]: this.evalOperator,\n      [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,\n      [E.ExpressionType.Named]: this.evalNamed,\n      [E.ExpressionType.Existence]: this.evalExistence,\n      [E.ExpressionType.Aggregate]: this.evalAggregate\n    };\n  }\n\n  async evaluate(expr, mapping) {\n    const evaluator = this.subEvaluators[expr.expressionType];\n\n    if (!evaluator) {\n      throw new Err.InvalidExpressionType(expr);\n    }\n\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  async evalOperator(expr, mapping) {\n    const argPromises = expr.args.map(arg => this.evaluate(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  async evalSpecialOperator(expr, mapping) {\n    const evaluate = this.evaluate.bind(this);\n    const context = {\n      args: expr.args,\n      mapping,\n      evaluate,\n      context: {\n        now: this.context.now,\n        baseIRI: this.context.baseIRI,\n        bnode: this.context.bnode\n      }\n    };\n    return expr.applyAsync(context);\n  }\n\n  async evalNamed(expr, mapping) {\n    const argPromises = expr.args.map(arg => this.evaluate(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  async evalExistence(expr, mapping) {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(await this.context.exists(expr.expression, mapping));\n  } // TODO: Remove?\n\n\n  async evalAggregate(expr, _mapping) {\n    if (!this.context.aggregate) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return Transformation_1.transformRDFTermUnsafe(await this.context.aggregate(expr.expression));\n  }\n\n}\n\nexports.AsyncRecursiveEvaluator = AsyncRecursiveEvaluator;\n\nclass SyncRecursiveEvaluator {\n  constructor(context) {\n    this.context = context;\n    this.subEvaluators = {\n      // Shared\n      [E.ExpressionType.Term]: sharedEvaluators.term,\n      [E.ExpressionType.Variable]: sharedEvaluators.variable,\n      // Sync\n      [E.ExpressionType.Operator]: this.evalOperator,\n      [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,\n      [E.ExpressionType.Named]: this.evalNamed,\n      [E.ExpressionType.Existence]: this.evalExistence,\n      [E.ExpressionType.Aggregate]: this.evalAggregate\n    };\n  }\n\n  evaluate(expr, mapping) {\n    const evaluator = this.subEvaluators[expr.expressionType];\n\n    if (!evaluator) {\n      throw new Err.InvalidExpressionType(expr);\n    }\n\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  evalOperator(expr, mapping) {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  evalSpecialOperator(expr, mapping) {\n    const evaluate = this.evaluate.bind(this);\n    const context = {\n      args: expr.args,\n      mapping,\n      evaluate,\n      context: {\n        now: this.context.now,\n        baseIRI: this.context.baseIRI,\n        bnode: this.context.bnode\n      }\n    };\n    return expr.applySync(context);\n  }\n\n  evalNamed(expr, mapping) {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  evalExistence(expr, mapping) {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(this.context.exists(expr.expression, mapping));\n  }\n\n  evalAggregate(expr, mapping) {\n    if (!this.context.aggregate) {\n      throw new Err.NoAggregator();\n    }\n\n    return Transformation_1.transformRDFTermUnsafe(this.context.aggregate(expr.expression));\n  }\n\n}\n\nexports.SyncRecursiveEvaluator = SyncRecursiveEvaluator;\n\nclass UnsupportedOperation extends Error {\n  constructor(operation) {\n    super(`Operation '${operation}' is unsupported in SimpleEvaluator`);\n  }\n\n}\n\nexports.UnsupportedOperation = UnsupportedOperation;","map":{"version":3,"sources":["../../../lib/evaluators/RecursiveExpressionEvaluator.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,CAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,GAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,MAAA,gBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAeA,MAAM,gBAAgB,GAAG;AACvB,EAAA,IAAI,CAAC,IAAD,EAAa,OAAb,EAA8B;AAChC,WAAO,IAAP;AACD,GAHsB;;AAIvB,EAAA,QAAQ,CAAC,IAAD,EAAiB,OAAjB,EAAkC;AACxC,UAAM,IAAI,GAAG,OAAO,CAAC,GAAR,CAAY,IAAI,CAAC,IAAjB,CAAb;;AACA,QAAI,CAAC,IAAL,EAAW;AACT,YAAM,IAAI,GAAG,CAAC,oBAAR,CAA6B,IAAI,CAAC,IAAlC,EAAwC,OAAxC,CAAN;AACD;;AACD,WAAO,gBAAA,CAAA,sBAAA,CAAuB,IAAvB,CAAP;AACD;;AAVsB,CAAzB;;AAaA,MAAa,uBAAb,CAAoC;AAiBlC,EAAA,WAAA,CAAoB,OAApB,EAAkD;AAA9B,SAAA,OAAA,GAAA,OAAA;AAfH,SAAA,aAAA,GAEb;AACA;AACA,OAAC,CAAC,CAAC,cAAF,CAAiB,IAAlB,GAAyB,gBAAgB,CAAC,IAF1C;AAGA,OAAC,CAAC,CAAC,cAAF,CAAiB,QAAlB,GAA6B,gBAAgB,CAAC,QAH9C;AAKA;AACA,OAAC,CAAC,CAAC,cAAF,CAAiB,QAAlB,GAA6B,KAAK,YANlC;AAOA,OAAC,CAAC,CAAC,cAAF,CAAiB,eAAlB,GAAoC,KAAK,mBAPzC;AAQA,OAAC,CAAC,CAAC,cAAF,CAAiB,KAAlB,GAA0B,KAAK,SAR/B;AASA,OAAC,CAAC,CAAC,cAAF,CAAiB,SAAlB,GAA8B,KAAK,aATnC;AAUA,OAAC,CAAC,CAAC,cAAF,CAAiB,SAAlB,GAA8B,KAAK;AAVnC,KAFa;AAesC;;AAEzC,QAAR,QAAQ,CAAC,IAAD,EAAmB,OAAnB,EAAoC;AAChD,UAAM,SAAS,GAAG,KAAK,aAAL,CAAmB,IAAI,CAAC,cAAxB,CAAlB;;AACA,QAAI,CAAC,SAAL,EAAgB;AAAE,YAAM,IAAI,GAAG,CAAC,qBAAR,CAA8B,IAA9B,CAAN;AAA4C;;AAC9D,WAAO,SAAS,CAAC,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2B,OAA3B,CAAP;AACD;;AAEyB,QAAZ,YAAY,CAAC,IAAD,EAAiB,OAAjB,EAAkC;AAC1D,UAAM,WAAW,GAAG,IAAI,CAAC,IAAL,CAAU,GAAV,CAAe,GAAD,IAAS,KAAK,QAAL,CAAc,GAAd,EAAmB,OAAnB,CAAvB,CAApB;AACA,UAAM,UAAU,GAAG,MAAM,OAAO,CAAC,GAAR,CAAY,WAAZ,CAAzB;AACA,WAAO,IAAI,CAAC,KAAL,CAAW,UAAX,CAAP;AACD;;AAEgC,QAAnB,mBAAmB,CAAC,IAAD,EAAwB,OAAxB,EAAyC;AACxE,UAAM,QAAQ,GAAG,KAAK,QAAL,CAAc,IAAd,CAAmB,IAAnB,CAAjB;AACA,UAAM,OAAO,GAAG;AACd,MAAA,IAAI,EAAE,IAAI,CAAC,IADG;AAEd,MAAA,OAFc;AAGd,MAAA,QAHc;AAId,MAAA,OAAO,EAAE;AACP,QAAA,GAAG,EAAE,KAAK,OAAL,CAAa,GADX;AAEP,QAAA,OAAO,EAAE,KAAK,OAAL,CAAa,OAFf;AAGP,QAAA,KAAK,EAAE,KAAK,OAAL,CAAa;AAHb;AAJK,KAAhB;AAUA,WAAO,IAAI,CAAC,UAAL,CAAgB,OAAhB,CAAP;AACD;;AAEsB,QAAT,SAAS,CAAC,IAAD,EAAc,OAAd,EAA+B;AACpD,UAAM,WAAW,GAAG,IAAI,CAAC,IAAL,CAAU,GAAV,CAAe,GAAD,IAAS,KAAK,QAAL,CAAc,GAAd,EAAmB,OAAnB,CAAvB,CAApB;AACA,UAAM,UAAU,GAAG,MAAM,OAAO,CAAC,GAAR,CAAY,WAAZ,CAAzB;AACA,WAAO,IAAI,CAAC,KAAL,CAAW,UAAX,CAAP;AACD;;AAE0B,QAAb,aAAa,CAAC,IAAD,EAAkB,OAAlB,EAAmC;AAC5D,QAAI,CAAC,KAAK,OAAL,CAAa,MAAlB,EAA0B;AACxB,YAAM,IAAI,GAAG,CAAC,eAAR,EAAN;AACD;;AAED,WAAO,IAAI,CAAC,CAAC,cAAN,CAAqB,MAAM,KAC/B,OAD+B,CAE/B,MAF+B,CAExB,IAAI,CAAC,UAFmB,EAEP,OAFO,CAA3B,CAAP;AAGD,GA5DiC,CA8DlC;;;AAC2B,QAAb,aAAa,CAAC,IAAD,EAAkB,QAAlB,EAAoC;AAC7D,QAAI,CAAC,KAAK,OAAL,CAAa,SAAlB,EAA6B;AAC3B,YAAM,IAAI,GAAG,CAAC,eAAR,EAAN;AACD;;AAED,WAAO,gBAAA,CAAA,sBAAA,CAAuB,MAAM,KACjC,OADiC,CAEjC,SAFiC,CAEvB,IAAI,CAAC,UAFkB,CAA7B,CAAP;AAGD;;AAvEiC;;AAApC,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AA0EA,MAAa,sBAAb,CAAmC;AAiBjC,EAAA,WAAA,CAAoB,OAApB,EAAiD;AAA7B,SAAA,OAAA,GAAA,OAAA;AAfH,SAAA,aAAA,GAEb;AACA;AACA,OAAC,CAAC,CAAC,cAAF,CAAiB,IAAlB,GAAyB,gBAAgB,CAAC,IAF1C;AAGA,OAAC,CAAC,CAAC,cAAF,CAAiB,QAAlB,GAA6B,gBAAgB,CAAC,QAH9C;AAKA;AACA,OAAC,CAAC,CAAC,cAAF,CAAiB,QAAlB,GAA6B,KAAK,YANlC;AAOA,OAAC,CAAC,CAAC,cAAF,CAAiB,eAAlB,GAAoC,KAAK,mBAPzC;AAQA,OAAC,CAAC,CAAC,cAAF,CAAiB,KAAlB,GAA0B,KAAK,SAR/B;AASA,OAAC,CAAC,CAAC,cAAF,CAAiB,SAAlB,GAA8B,KAAK,aATnC;AAUA,OAAC,CAAC,CAAC,cAAF,CAAiB,SAAlB,GAA8B,KAAK;AAVnC,KAFa;AAeqC;;AAEtD,EAAA,QAAQ,CAAC,IAAD,EAAmB,OAAnB,EAAoC;AAC1C,UAAM,SAAS,GAAG,KAAK,aAAL,CAAmB,IAAI,CAAC,cAAxB,CAAlB;;AACA,QAAI,CAAC,SAAL,EAAgB;AAAE,YAAM,IAAI,GAAG,CAAC,qBAAR,CAA8B,IAA9B,CAAN;AAA4C;;AAC9D,WAAO,SAAS,CAAC,IAAV,CAAe,IAAf,EAAqB,IAArB,EAA2B,OAA3B,CAAP;AACD;;AAEO,EAAA,YAAY,CAAC,IAAD,EAAiB,OAAjB,EAAkC;AACpD,UAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,GAAV,CAAe,GAAD,IAAS,KAAK,QAAL,CAAc,GAAd,EAAmB,OAAnB,CAAvB,CAAb;AACA,WAAO,IAAI,CAAC,KAAL,CAAW,IAAX,CAAP;AACD;;AAEO,EAAA,mBAAmB,CAAC,IAAD,EAAwB,OAAxB,EAAyC;AAClE,UAAM,QAAQ,GAAG,KAAK,QAAL,CAAc,IAAd,CAAmB,IAAnB,CAAjB;AACA,UAAM,OAAO,GAAG;AACd,MAAA,IAAI,EAAE,IAAI,CAAC,IADG;AAEd,MAAA,OAFc;AAGd,MAAA,QAHc;AAId,MAAA,OAAO,EAAE;AACP,QAAA,GAAG,EAAE,KAAK,OAAL,CAAa,GADX;AAEP,QAAA,OAAO,EAAE,KAAK,OAAL,CAAa,OAFf;AAGP,QAAA,KAAK,EAAE,KAAK,OAAL,CAAa;AAHb;AAJK,KAAhB;AAUA,WAAO,IAAI,CAAC,SAAL,CAAe,OAAf,CAAP;AACD;;AAEO,EAAA,SAAS,CAAC,IAAD,EAAc,OAAd,EAA+B;AAC9C,UAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,GAAV,CAAe,GAAD,IAAS,KAAK,QAAL,CAAc,GAAd,EAAmB,OAAnB,CAAvB,CAAb;AACA,WAAO,IAAI,CAAC,KAAL,CAAW,IAAX,CAAP;AACD;;AAEO,EAAA,aAAa,CAAC,IAAD,EAAkB,OAAlB,EAAmC;AACtD,QAAI,CAAC,KAAK,OAAL,CAAa,MAAlB,EAA0B;AACxB,YAAM,IAAI,GAAG,CAAC,eAAR,EAAN;AACD;;AAED,WAAO,IAAI,CAAC,CAAC,cAAN,CAAqB,KACzB,OADyB,CAEzB,MAFyB,CAElB,IAAI,CAAC,UAFa,EAED,OAFC,CAArB,CAAP;AAGD;;AAEO,EAAA,aAAa,CAAC,IAAD,EAAkB,OAAlB,EAAmC;AACtD,QAAI,CAAC,KAAK,OAAL,CAAa,SAAlB,EAA6B;AAC3B,YAAM,IAAI,GAAG,CAAC,YAAR,EAAN;AACD;;AAED,WAAO,gBAAA,CAAA,sBAAA,CAAuB,KAC3B,OAD2B,CAE3B,SAF2B,CAEjB,IAAI,CAAC,UAFY,CAAvB,CAAP;AAGD;;AApEgC;;AAAnC,OAAA,CAAA,sBAAA,GAAA,sBAAA;;AAuEA,MAAa,oBAAb,SAA0C,KAA1C,CAA+C;AAC7C,EAAA,WAAA,CAAY,SAAZ,EAA6B;AAC3B,UAAM,cAAc,SAAS,qCAA7B;AACD;;AAH4C;;AAA/C,OAAA,CAAA,oBAAA,GAAA,oBAAA","sourcesContent":["import * as E from '../expressions';\nimport * as Err from '../util/Errors';\n\nimport { transformRDFTermUnsafe } from '../Transformation';\nimport { Bindings, ExpressionEvaluator } from '../Types';\n\nimport { AsyncEvaluatorContext } from './AsyncEvaluator';\nimport { SyncEvaluatorContext } from './SyncEvaluator';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\ntype Variable = E.VariableExpression;\ntype Existence = E.ExistenceExpression;\ntype Operator = E.OperatorExpression;\ntype SpecialOperator = E.SpecialOperatorExpression;\ntype Named = E.NamedExpression;\ntype Aggregate = E.AggregateExpression;\n\nconst sharedEvaluators = {\n  term(expr: Term, mapping: Bindings): Term {\n    return expr;\n  },\n  variable(expr: Variable, mapping: Bindings): Term {\n    const term = mapping.get(expr.name);\n    if (!term) {\n      throw new Err.UnboundVariableError(expr.name, mapping);\n    }\n    return transformRDFTermUnsafe(term);\n  },\n};\n\nexport class AsyncRecursiveEvaluator implements ExpressionEvaluator<Expression, Promise<Term>> {\n\n  private readonly subEvaluators: {\n    [key: string]: (expr: Expression, mapping: Bindings) => Promise<Term> | Term;\n  } = {\n      // Shared\n      [E.ExpressionType.Term]: sharedEvaluators.term,\n      [E.ExpressionType.Variable]: sharedEvaluators.variable,\n\n      // Async\n      [E.ExpressionType.Operator]: this.evalOperator,\n      [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,\n      [E.ExpressionType.Named]: this.evalNamed,\n      [E.ExpressionType.Existence]: this.evalExistence,\n      [E.ExpressionType.Aggregate]: this.evalAggregate,\n    };\n\n  constructor(private context: AsyncEvaluatorContext) { }\n\n  async evaluate(expr: Expression, mapping: Bindings): Promise<Term> {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    if (!evaluator) { throw new Err.InvalidExpressionType(expr); }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private async evalOperator(expr: Operator, mapping: Bindings): Promise<Term> {\n    const argPromises = expr.args.map((arg) => this.evaluate(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  private async evalSpecialOperator(expr: SpecialOperator, mapping: Bindings): Promise<Term> {\n    const evaluate = this.evaluate.bind(this);\n    const context = {\n      args: expr.args,\n      mapping,\n      evaluate,\n      context: {\n        now: this.context.now,\n        baseIRI: this.context.baseIRI,\n        bnode: this.context.bnode,\n      },\n    };\n    return expr.applyAsync(context);\n  }\n\n  private async evalNamed(expr: Named, mapping: Bindings): Promise<Term> {\n    const argPromises = expr.args.map((arg) => this.evaluate(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  private async evalExistence(expr: Existence, mapping: Bindings): Promise<Term> {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(await this\n      .context\n      .exists(expr.expression, mapping));\n  }\n\n  // TODO: Remove?\n  private async evalAggregate(expr: Aggregate, _mapping: Bindings): Promise<Term> {\n    if (!this.context.aggregate) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return transformRDFTermUnsafe(await this\n      .context\n      .aggregate(expr.expression));\n  }\n}\n\nexport class SyncRecursiveEvaluator implements ExpressionEvaluator<Expression, Term> {\n\n  private readonly subEvaluators: {\n    [key: string]: (expr: Expression, mapping: Bindings) => Term;\n  } = {\n      // Shared\n      [E.ExpressionType.Term]: sharedEvaluators.term,\n      [E.ExpressionType.Variable]: sharedEvaluators.variable,\n\n      // Sync\n      [E.ExpressionType.Operator]: this.evalOperator,\n      [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,\n      [E.ExpressionType.Named]: this.evalNamed,\n      [E.ExpressionType.Existence]: this.evalExistence,\n      [E.ExpressionType.Aggregate]: this.evalAggregate,\n    };\n\n  constructor(private context: SyncEvaluatorContext) { }\n\n  evaluate(expr: Expression, mapping: Bindings): Term {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    if (!evaluator) { throw new Err.InvalidExpressionType(expr); }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private evalOperator(expr: Operator, mapping: Bindings): Term {\n    const args = expr.args.map((arg) => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalSpecialOperator(expr: SpecialOperator, mapping: Bindings): Term {\n    const evaluate = this.evaluate.bind(this);\n    const context = {\n      args: expr.args,\n      mapping,\n      evaluate,\n      context: {\n        now: this.context.now,\n        baseIRI: this.context.baseIRI,\n        bnode: this.context.bnode,\n      },\n    };\n    return expr.applySync(context);\n  }\n\n  private evalNamed(expr: Named, mapping: Bindings): Term {\n    const args = expr.args.map((arg) => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalExistence(expr: Existence, mapping: Bindings): Term {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(this\n      .context\n      .exists(expr.expression, mapping));\n  }\n\n  private evalAggregate(expr: Aggregate, mapping: Bindings): Term {\n    if (!this.context.aggregate) {\n      throw new Err.NoAggregator();\n    }\n\n    return transformRDFTermUnsafe(this\n      .context\n      .aggregate(expr.expression));\n  }\n}\n\nexport class UnsupportedOperation extends Error {\n  constructor(operation: string) {\n    super(`Operation '${operation}' is unsupported in SimpleEvaluator`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}