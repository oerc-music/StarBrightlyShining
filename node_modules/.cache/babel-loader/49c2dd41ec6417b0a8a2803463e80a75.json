{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeValueHandlerVariable = void 0;\n\nconst NodeValueHandlerAdapter_1 = require(\"./NodeValueHandlerAdapter\");\n/**\n * Converts GraphQL variables to terms based on the contents of the variablesDict.\n */\n\n\nclass NodeValueHandlerVariable extends NodeValueHandlerAdapter_1.NodeValueHandlerAdapter {\n  constructor(util, settings) {\n    super('Variable', util, settings);\n  }\n\n  handle(valueNode, fieldName, convertContext) {\n    const id = valueNode.name.value;\n    const value = convertContext.variablesDict[id];\n    const meta = convertContext.variablesMetaDict[id]; // Handle missing values\n\n    if (!value) {\n      if (!convertContext.ignoreUnknownVariables && (!meta || meta.mandatory)) {\n        throw new Error(`Undefined variable: ${id}`);\n      } else {\n        const variable = this.util.dataFactory.variable(id);\n\n        if (convertContext.terminalVariables.map(v => v.value).indexOf(id) < 0) {\n          convertContext.terminalVariables.push(variable);\n        }\n\n        return {\n          terms: [variable]\n        };\n      }\n    } // Don't allow variables that refer to other variables\n\n\n    if (value.kind === 'Variable') {\n      throw new Error(`Variable refers to another variable: ${id}`);\n    }\n\n    if (meta) {\n      // Check the type\n      if (meta.list) {\n        // If we expect a list, check if we got a list.\n        if (value.kind !== 'ListValue') {\n          throw new Error(`Expected a list, but got ${value.kind} for ${id}`);\n        } // Check the type in the list\n\n\n        if (meta.type) {\n          const listValue = value;\n\n          for (const v of listValue.values) {\n            if (v.kind !== meta.type) {\n              throw new Error(`Expected ${meta.type}, but got ${v.kind} for ${id}`);\n            }\n          }\n        }\n      } else if (meta.type) {// This is allowed to be different (?)\n\n        /*if (value.kind !== meta.type) {\n          throw new Error(`Expected ${meta.type}, but got ${value.kind} for ${id}`);\n        }*/\n      }\n    }\n\n    return this.util.handleNodeValue(value, fieldName, convertContext);\n  }\n\n}\n\nexports.NodeValueHandlerVariable = NodeValueHandlerVariable;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/graphql-to-sparql/lib/handler/valuenode/NodeValueHandlerVariable.js"],"names":["Object","defineProperty","exports","value","NodeValueHandlerVariable","NodeValueHandlerAdapter_1","require","NodeValueHandlerAdapter","constructor","util","settings","handle","valueNode","fieldName","convertContext","id","name","variablesDict","meta","variablesMetaDict","ignoreUnknownVariables","mandatory","Error","variable","dataFactory","terminalVariables","map","v","indexOf","push","terms","kind","list","type","listValue","values","handleNodeValue"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,wBAAR,GAAmC,KAAK,CAAxC;;AACA,MAAMC,yBAAyB,GAAGC,OAAO,CAAC,2BAAD,CAAzC;AACA;AACA;AACA;;;AACA,MAAMF,wBAAN,SAAuCC,yBAAyB,CAACE,uBAAjE,CAAyF;AACrFC,EAAAA,WAAW,CAACC,IAAD,EAAOC,QAAP,EAAiB;AACxB,UAAM,UAAN,EAAkBD,IAAlB,EAAwBC,QAAxB;AACH;;AACDC,EAAAA,MAAM,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,cAAvB,EAAuC;AACzC,UAAMC,EAAE,GAAGH,SAAS,CAACI,IAAV,CAAeb,KAA1B;AACA,UAAMA,KAAK,GAAGW,cAAc,CAACG,aAAf,CAA6BF,EAA7B,CAAd;AACA,UAAMG,IAAI,GAAGJ,cAAc,CAACK,iBAAf,CAAiCJ,EAAjC,CAAb,CAHyC,CAIzC;;AACA,QAAI,CAACZ,KAAL,EAAY;AACR,UAAI,CAACW,cAAc,CAACM,sBAAhB,KAA2C,CAACF,IAAD,IAASA,IAAI,CAACG,SAAzD,CAAJ,EAAyE;AACrE,cAAM,IAAIC,KAAJ,CAAW,uBAAsBP,EAAG,EAApC,CAAN;AACH,OAFD,MAGK;AACD,cAAMQ,QAAQ,GAAG,KAAKd,IAAL,CAAUe,WAAV,CAAsBD,QAAtB,CAA+BR,EAA/B,CAAjB;;AACA,YAAID,cAAc,CAACW,iBAAf,CAAiCC,GAAjC,CAAsCC,CAAD,IAAOA,CAAC,CAACxB,KAA9C,EAAqDyB,OAArD,CAA6Db,EAA7D,IAAmE,CAAvE,EAA0E;AACtED,UAAAA,cAAc,CAACW,iBAAf,CAAiCI,IAAjC,CAAsCN,QAAtC;AACH;;AACD,eAAO;AAAEO,UAAAA,KAAK,EAAE,CAACP,QAAD;AAAT,SAAP;AACH;AACJ,KAhBwC,CAiBzC;;;AACA,QAAIpB,KAAK,CAAC4B,IAAN,KAAe,UAAnB,EAA+B;AAC3B,YAAM,IAAIT,KAAJ,CAAW,wCAAuCP,EAAG,EAArD,CAAN;AACH;;AACD,QAAIG,IAAJ,EAAU;AACN;AACA,UAAIA,IAAI,CAACc,IAAT,EAAe;AACX;AACA,YAAI7B,KAAK,CAAC4B,IAAN,KAAe,WAAnB,EAAgC;AAC5B,gBAAM,IAAIT,KAAJ,CAAW,4BAA2BnB,KAAK,CAAC4B,IAAK,QAAOhB,EAAG,EAA3D,CAAN;AACH,SAJU,CAKX;;;AACA,YAAIG,IAAI,CAACe,IAAT,EAAe;AACX,gBAAMC,SAAS,GAAG/B,KAAlB;;AACA,eAAK,MAAMwB,CAAX,IAAgBO,SAAS,CAACC,MAA1B,EAAkC;AAC9B,gBAAIR,CAAC,CAACI,IAAF,KAAWb,IAAI,CAACe,IAApB,EAA0B;AACtB,oBAAM,IAAIX,KAAJ,CAAW,YAAWJ,IAAI,CAACe,IAAK,aAAYN,CAAC,CAACI,IAAK,QAAOhB,EAAG,EAA7D,CAAN;AACH;AACJ;AACJ;AACJ,OAdD,MAeK,IAAIG,IAAI,CAACe,IAAT,EAAe,CAChB;;AACA;AAChB;AACA;AACa;AACJ;;AACD,WAAO,KAAKxB,IAAL,CAAU2B,eAAV,CAA0BjC,KAA1B,EAAiCU,SAAjC,EAA4CC,cAA5C,CAAP;AACH;;AAlDoF;;AAoDzFZ,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NodeValueHandlerVariable = void 0;\nconst NodeValueHandlerAdapter_1 = require(\"./NodeValueHandlerAdapter\");\n/**\n * Converts GraphQL variables to terms based on the contents of the variablesDict.\n */\nclass NodeValueHandlerVariable extends NodeValueHandlerAdapter_1.NodeValueHandlerAdapter {\n    constructor(util, settings) {\n        super('Variable', util, settings);\n    }\n    handle(valueNode, fieldName, convertContext) {\n        const id = valueNode.name.value;\n        const value = convertContext.variablesDict[id];\n        const meta = convertContext.variablesMetaDict[id];\n        // Handle missing values\n        if (!value) {\n            if (!convertContext.ignoreUnknownVariables && (!meta || meta.mandatory)) {\n                throw new Error(`Undefined variable: ${id}`);\n            }\n            else {\n                const variable = this.util.dataFactory.variable(id);\n                if (convertContext.terminalVariables.map((v) => v.value).indexOf(id) < 0) {\n                    convertContext.terminalVariables.push(variable);\n                }\n                return { terms: [variable] };\n            }\n        }\n        // Don't allow variables that refer to other variables\n        if (value.kind === 'Variable') {\n            throw new Error(`Variable refers to another variable: ${id}`);\n        }\n        if (meta) {\n            // Check the type\n            if (meta.list) {\n                // If we expect a list, check if we got a list.\n                if (value.kind !== 'ListValue') {\n                    throw new Error(`Expected a list, but got ${value.kind} for ${id}`);\n                }\n                // Check the type in the list\n                if (meta.type) {\n                    const listValue = value;\n                    for (const v of listValue.values) {\n                        if (v.kind !== meta.type) {\n                            throw new Error(`Expected ${meta.type}, but got ${v.kind} for ${id}`);\n                        }\n                    }\n                }\n            }\n            else if (meta.type) {\n                // This is allowed to be different (?)\n                /*if (value.kind !== meta.type) {\n                  throw new Error(`Expected ${meta.type}, but got ${value.kind} for ${id}`);\n                }*/\n            }\n        }\n        return this.util.handleNodeValue(value, fieldName, convertContext);\n    }\n}\nexports.NodeValueHandlerVariable = NodeValueHandlerVariable;\n//# sourceMappingURL=NodeValueHandlerVariable.js.map"]},"metadata":{},"sourceType":"script"}