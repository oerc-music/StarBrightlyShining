{"ast":null,"code":"// **N3Lexer** tokenizes N3 documents.\nimport namespaces from './IRIs';\nimport queueMicrotask from 'queue-microtask';\nconst {\n  xsd\n} = namespaces; // Regular expression and replacement string to escape N3 strings\n\nconst escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\([^])/g;\nconst escapeReplacements = {\n  '\\\\': '\\\\',\n  \"'\": \"'\",\n  '\"': '\"',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'f': '\\f',\n  'b': '\\b',\n  '_': '_',\n  '~': '~',\n  '.': '.',\n  '-': '-',\n  '!': '!',\n  '$': '$',\n  '&': '&',\n  '(': '(',\n  ')': ')',\n  '*': '*',\n  '+': '+',\n  ',': ',',\n  ';': ';',\n  '=': '=',\n  '/': '/',\n  '?': '?',\n  '#': '#',\n  '@': '@',\n  '%': '%'\n};\nconst illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\nconst lineModeRegExps = {\n  _iri: true,\n  _unescapedIri: true,\n  _simpleQuotedString: true,\n  _langcode: true,\n  _blank: true,\n  _newline: true,\n  _comment: true,\n  _whitespace: true,\n  _endOfFile: true\n};\nconst invalidRegExp = /$0^/; // ## Constructor\n\nexport default class N3Lexer {\n  constructor(options) {\n    // ## Regular expressions\n    // It's slightly faster to have these as properties than as in-scope variables\n    this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n\n    this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n\n    this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n\n    this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n    this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n    this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._number = /^[\\-+]?(?:(\\d+\\.\\d*|\\.?\\d+)[eE][\\-+]?|\\d*(\\.)?)\\d+(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n    this._shortPredicates = /^a(?=[\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n    this._comment = /#([^\\n\\r]*)/;\n    this._whitespace = /^[ \\t]+/;\n    this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n    options = options || {}; // In line mode (N-Triples or N-Quads), only simple features may be parsed\n\n    if (this._lineMode = !!options.lineMode) {\n      this._n3Mode = false; // Don't tokenize special literals\n\n      for (const key in this) {\n        if (!(key in lineModeRegExps) && this[key] instanceof RegExp) this[key] = invalidRegExp;\n      }\n    } // When not in line mode, enable N3 functionality by default\n    else {\n      this._n3Mode = options.n3 !== false;\n    } // Don't output comment tokens by default\n\n\n    this._comments = !!options.comments; // Cache the last tested closing position of long literals\n\n    this._literalClosingPos = 0;\n  } // ## Private methods\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n\n\n  _tokenizeToEnd(callback, inputFinished) {\n    // Continue parsing as far as possible; the loop will return eventually\n    let input = this._input;\n    const outputComments = this._comments;\n\n    while (true) {\n      // Count and skip whitespace lines\n      let whiteSpaceMatch, comment;\n\n      while (whiteSpaceMatch = this._newline.exec(input)) {\n        // Try to find a comment\n        if (outputComments && (comment = this._comment.exec(whiteSpaceMatch[0]))) callback(null, {\n          line: this._line,\n          type: 'comment',\n          value: comment[1],\n          prefix: ''\n        }); // Advance the input\n\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n        this._line++;\n      } // Skip whitespace on current line\n\n\n      if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input))) input = input.substr(whiteSpaceMatch[0].length, input.length); // Stop for now if we're at the end\n\n      if (this._endOfFile.test(input)) {\n        // If the input is finished, emit EOF\n        if (inputFinished) {\n          // Try to find a final comment\n          if (outputComments && (comment = this._comment.exec(input))) callback(null, {\n            line: this._line,\n            type: 'comment',\n            value: comment[1],\n            prefix: ''\n          });\n          callback(input = null, {\n            line: this._line,\n            type: 'eof',\n            value: '',\n            prefix: ''\n          });\n        }\n\n        return this._input = input;\n      } // Look for specific token types based on the first character\n\n\n      const line = this._line,\n            firstChar = input[0];\n      let type = '',\n          value = '',\n          prefix = '',\n          match = null,\n          matchLength = 0,\n          inconclusive = false;\n\n      switch (firstChar) {\n        case '^':\n          // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n          if (input.length < 3) break; // Try to match a type\n          else if (input[1] === '^') {\n            this._previousMarker = '^^'; // Move to type IRI or prefixed name\n\n            input = input.substr(2);\n\n            if (input[0] !== '<') {\n              inconclusive = true;\n              break;\n            }\n          } // If no type, it must be a path expression\n          else {\n            if (this._n3Mode) {\n              matchLength = 1;\n              type = '^';\n            }\n\n            break;\n          }\n        // Fall through in case the type is an IRI\n\n        case '<':\n          // Try to find a full IRI without escape sequences\n          if (match = this._unescapedIri.exec(input)) type = 'IRI', value = match[1]; // Try to find a full IRI with escape sequences\n          else if (match = this._iri.exec(input)) {\n            value = this._unescape(match[1]);\n            if (value === null || illegalIriChars.test(value)) return reportSyntaxError(this);\n            type = 'IRI';\n          } // Try to find a nested triple\n          else if (input.length > 1 && input[1] === '<') type = '<<', matchLength = 2; // Try to find a backwards implication arrow\n          else if (this._n3Mode && input.length > 1 && input[1] === '=') type = 'inverse', matchLength = 2, value = '>';\n          break;\n\n        case '>':\n          if (input.length > 1 && input[1] === '>') type = '>>', matchLength = 2;\n          break;\n\n        case '_':\n          // Try to find a blank node. Since it can contain (but not end with) a dot,\n          // we always need a non-dot character before deciding it is a blank node.\n          // Therefore, try inserting a space if we're at the end of the input.\n          if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(`${input} `))) type = 'blank', prefix = '_', value = match[1];\n          break;\n\n        case '\"':\n          // Try to find a literal without escape sequences\n          if (match = this._simpleQuotedString.exec(input)) value = match[1]; // Try to find a literal wrapped in three pairs of quotes\n          else {\n            ({\n              value,\n              matchLength\n            } = this._parseLiteral(input));\n            if (value === null) return reportSyntaxError(this);\n          }\n\n          if (match !== null || matchLength !== 0) {\n            type = 'literal';\n            this._literalClosingPos = 0;\n          }\n\n          break;\n\n        case \"'\":\n          if (!this._lineMode) {\n            // Try to find a literal without escape sequences\n            if (match = this._simpleApostropheString.exec(input)) value = match[1]; // Try to find a literal wrapped in three pairs of quotes\n            else {\n              ({\n                value,\n                matchLength\n              } = this._parseLiteral(input));\n              if (value === null) return reportSyntaxError(this);\n            }\n\n            if (match !== null || matchLength !== 0) {\n              type = 'literal';\n              this._literalClosingPos = 0;\n            }\n          }\n\n          break;\n\n        case '?':\n          // Try to find a variable\n          if (this._n3Mode && (match = this._variable.exec(input))) type = 'var', value = match[0];\n          break;\n\n        case '@':\n          // Try to find a language code\n          if (this._previousMarker === 'literal' && (match = this._langcode.exec(input))) type = 'langcode', value = match[1]; // Try to find a keyword\n          else if (match = this._keyword.exec(input)) type = match[0];\n          break;\n\n        case '.':\n          // Try to find a dot as punctuation\n          if (input.length === 1 ? inputFinished : input[1] < '0' || input[1] > '9') {\n            type = '.';\n            matchLength = 1;\n            break;\n          }\n\n        // Fall through to numerical case (could be a decimal dot)\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n        case '+':\n        case '-':\n          // Try to find a number. Since it can contain (but not end with) a dot,\n          // we always need a non-dot character before deciding it is a number.\n          // Therefore, try inserting a space if we're at the end of the input.\n          if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(`${input} `))) {\n            type = 'literal', value = match[0];\n            prefix = typeof match[1] === 'string' ? xsd.double : typeof match[2] === 'string' ? xsd.decimal : xsd.integer;\n          }\n\n          break;\n\n        case 'B':\n        case 'b':\n        case 'p':\n        case 'P':\n        case 'G':\n        case 'g':\n          // Try to find a SPARQL-style keyword\n          if (match = this._sparqlKeyword.exec(input)) type = match[0].toUpperCase();else inconclusive = true;\n          break;\n\n        case 'f':\n        case 't':\n          // Try to match a boolean\n          if (match = this._boolean.exec(input)) type = 'literal', value = match[0], prefix = xsd.boolean;else inconclusive = true;\n          break;\n\n        case 'a':\n          // Try to find an abbreviated predicate\n          if (match = this._shortPredicates.exec(input)) type = 'abbreviation', value = 'a';else inconclusive = true;\n          break;\n\n        case '=':\n          // Try to find an implication arrow or equals sign\n          if (this._n3Mode && input.length > 1) {\n            type = 'abbreviation';\n            if (input[1] !== '>') matchLength = 1, value = '=';else matchLength = 2, value = '>';\n          }\n\n          break;\n\n        case '!':\n          if (!this._n3Mode) break;\n\n        case ',':\n        case ';':\n        case '[':\n        case ']':\n        case '(':\n        case ')':\n        case '{':\n        case '}':\n          if (!this._lineMode) {\n            matchLength = 1;\n            type = firstChar;\n          }\n\n          break;\n\n        default:\n          inconclusive = true;\n      } // Some first characters do not allow an immediate decision, so inspect more\n\n\n      if (inconclusive) {\n        // Try to find a prefix\n        if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') && (match = this._prefix.exec(input))) type = 'prefix', value = match[1] || ''; // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a prefixed name.\n        // Therefore, try inserting a space if we're at the end of the input.\n        else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(`${input} `))) type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n      } // A type token is special: it can only be emitted after an IRI or prefixed name is read\n\n\n      if (this._previousMarker === '^^') {\n        switch (type) {\n          case 'prefixed':\n            type = 'type';\n            break;\n\n          case 'IRI':\n            type = 'typeIRI';\n            break;\n\n          default:\n            type = '';\n        }\n      } // What if nothing of the above was found?\n\n\n      if (!type) {\n        // We could be in streaming mode, and then we just wait for more input to arrive.\n        // Otherwise, a syntax error has occurred in the input.\n        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n        if (inputFinished || !/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)) return reportSyntaxError(this);else return this._input = input;\n      } // Emit the parsed token\n\n\n      const token = {\n        line: line,\n        type: type,\n        value: value,\n        prefix: prefix\n      };\n      callback(null, token);\n      this.previousToken = token;\n      this._previousMarker = type; // Advance to next part to tokenize\n\n      input = input.substr(matchLength || match[0].length, input.length);\n    } // Signals the syntax error through the callback\n\n\n    function reportSyntaxError(self) {\n      callback(self._syntaxError(/^\\S*/.exec(input)[0]));\n    }\n  } // ### `_unescape` replaces N3 escape codes by their corresponding characters\n\n\n  _unescape(item) {\n    let invalid = false;\n    const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {\n      // 4-digit unicode character\n      if (typeof unicode4 === 'string') return String.fromCharCode(Number.parseInt(unicode4, 16)); // 8-digit unicode character\n\n      if (typeof unicode8 === 'string') {\n        let charCode = Number.parseInt(unicode8, 16);\n        return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));\n      } // fixed escape sequence\n\n\n      if (escapedChar in escapeReplacements) return escapeReplacements[escapedChar]; // invalid escape sequence\n\n      invalid = true;\n      return '';\n    });\n    return invalid ? null : replaced;\n  } // ### `_parseLiteral` parses a literal into an unescaped value\n\n\n  _parseLiteral(input) {\n    // Ensure we have enough lookahead to identify triple-quoted strings\n    if (input.length >= 3) {\n      // Identify the opening quote(s)\n      const opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n      const openingLength = opening.length; // Find the next candidate closing quotes\n\n      let closingPos = Math.max(this._literalClosingPos, openingLength);\n\n      while ((closingPos = input.indexOf(opening, closingPos)) > 0) {\n        // Count backslashes right before the closing quotes\n        let backslashCount = 0;\n\n        while (input[closingPos - backslashCount - 1] === '\\\\') backslashCount++; // An even number of backslashes (in particular 0)\n        // means these are actual, non-escaped closing quotes\n\n\n        if (backslashCount % 2 === 0) {\n          // Extract and unescape the value\n          const raw = input.substring(openingLength, closingPos);\n          const lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n          const matchLength = closingPos + openingLength; // Only triple-quoted strings can be multi-line\n\n          if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode) break;\n          this._line += lines;\n          return {\n            value: this._unescape(raw),\n            matchLength\n          };\n        }\n\n        closingPos++;\n      }\n\n      this._literalClosingPos = input.length - openingLength + 1;\n    }\n\n    return {\n      value: '',\n      matchLength: 0\n    };\n  } // ### `_syntaxError` creates a syntax error for the given issue\n\n\n  _syntaxError(issue) {\n    this._input = null;\n    const err = new Error(`Unexpected \"${issue}\" on line ${this._line}.`);\n    err.context = {\n      token: undefined,\n      line: this._line,\n      previousToken: this.previousToken\n    };\n    return err;\n  } // ### Strips off any starting UTF BOM mark.\n\n\n  _readStartingBom(input) {\n    return input.startsWith('\\ufeff') ? input.substr(1) : input;\n  } // ## Public methods\n  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n  // The input can be a string or a stream.\n\n\n  tokenize(input, callback) {\n    this._line = 1; // If the input is a string, continuously emit tokens through the callback until the end\n\n    if (typeof input === 'string') {\n      this._input = this._readStartingBom(input); // If a callback was passed, asynchronously call it\n\n      if (typeof callback === 'function') queueMicrotask(() => this._tokenizeToEnd(callback, true)); // If no callback was passed, tokenize synchronously and return\n      else {\n        const tokens = [];\n        let error;\n\n        this._tokenizeToEnd((e, t) => e ? error = e : tokens.push(t), true);\n\n        if (error) throw error;\n        return tokens;\n      }\n    } // Otherwise, the input must be a stream\n    else {\n      this._pendingBuffer = null;\n      if (typeof input.setEncoding === 'function') input.setEncoding('utf8'); // Adds the data chunk to the buffer and parses as far as possible\n\n      input.on('data', data => {\n        if (this._input !== null && data.length !== 0) {\n          // Prepend any previous pending writes\n          if (this._pendingBuffer) {\n            data = Buffer.concat([this._pendingBuffer, data]);\n            this._pendingBuffer = null;\n          } // Hold if the buffer ends in an incomplete unicode sequence\n\n\n          if (data[data.length - 1] & 0x80) {\n            this._pendingBuffer = data;\n          } // Otherwise, tokenize as far as possible\n          else {\n            // Only read a BOM at the start\n            if (typeof this._input === 'undefined') this._input = this._readStartingBom(typeof data === 'string' ? data : data.toString());else this._input += data;\n\n            this._tokenizeToEnd(callback, false);\n          }\n        }\n      }); // Parses until the end\n\n      input.on('end', () => {\n        if (typeof this._input === 'string') this._tokenizeToEnd(callback, true);\n      });\n      input.on('error', callback);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/n3/src/N3Lexer.js"],"names":["namespaces","queueMicrotask","xsd","escapeSequence","escapeReplacements","illegalIriChars","lineModeRegExps","_iri","_unescapedIri","_simpleQuotedString","_langcode","_blank","_newline","_comment","_whitespace","_endOfFile","invalidRegExp","N3Lexer","constructor","options","_simpleApostropheString","_prefix","_prefixed","_variable","_number","_boolean","_keyword","_sparqlKeyword","_shortPredicates","_lineMode","lineMode","_n3Mode","key","RegExp","n3","_comments","comments","_literalClosingPos","_tokenizeToEnd","callback","inputFinished","input","_input","outputComments","whiteSpaceMatch","comment","exec","line","_line","type","value","prefix","substr","length","test","firstChar","match","matchLength","inconclusive","_previousMarker","_unescape","reportSyntaxError","_parseLiteral","double","decimal","integer","toUpperCase","boolean","token","previousToken","self","_syntaxError","item","invalid","replaced","replace","sequence","unicode4","unicode8","escapedChar","String","fromCharCode","Number","parseInt","charCode","opening","openingLength","closingPos","Math","max","indexOf","backslashCount","raw","substring","lines","split","issue","err","Error","context","undefined","_readStartingBom","startsWith","tokenize","tokens","error","e","t","push","_pendingBuffer","setEncoding","on","data","Buffer","concat","toString"],"mappings":"AAAA;AACA,OAAOA,UAAP,MAAuB,QAAvB;AACA,OAAOC,cAAP,MAA2B,iBAA3B;AAEA,MAAM;AAAEC,EAAAA;AAAF,IAAUF,UAAhB,C,CAEA;;AACA,MAAMG,cAAc,GAAG,kDAAvB;AACA,MAAMC,kBAAkB,GAAG;AACzB,QAAM,IADmB;AACb,OAAK,GADQ;AACH,OAAK,GADF;AAEzB,OAAK,IAFoB;AAEd,OAAK,IAFS;AAEH,OAAK,IAFF;AAEQ,OAAK,IAFb;AAEmB,OAAK,IAFxB;AAGzB,OAAK,GAHoB;AAGf,OAAK,GAHU;AAGL,OAAK,GAHA;AAGK,OAAK,GAHV;AAGe,OAAK,GAHpB;AAGyB,OAAK,GAH9B;AAGmC,OAAK,GAHxC;AAIzB,OAAK,GAJoB;AAIf,OAAK,GAJU;AAIL,OAAK,GAJA;AAIK,OAAK,GAJV;AAIe,OAAK,GAJpB;AAIyB,OAAK,GAJ9B;AAImC,OAAK,GAJxC;AAKzB,OAAK,GALoB;AAKf,OAAK,GALU;AAKL,OAAK,GALA;AAKK,OAAK,GALV;AAKe,OAAK;AALpB,CAA3B;AAOA,MAAMC,eAAe,GAAG,4BAAxB;AAEA,MAAMC,eAAe,GAAG;AACtBC,EAAAA,IAAI,EAAE,IADgB;AAEtBC,EAAAA,aAAa,EAAE,IAFO;AAGtBC,EAAAA,mBAAmB,EAAE,IAHC;AAItBC,EAAAA,SAAS,EAAE,IAJW;AAKtBC,EAAAA,MAAM,EAAE,IALc;AAMtBC,EAAAA,QAAQ,EAAE,IANY;AAOtBC,EAAAA,QAAQ,EAAE,IAPY;AAQtBC,EAAAA,WAAW,EAAE,IARS;AAStBC,EAAAA,UAAU,EAAE;AATU,CAAxB;AAWA,MAAMC,aAAa,GAAG,KAAtB,C,CAEA;;AACA,eAAe,MAAMC,OAAN,CAAc;AAC3BC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB;AACA;AACA,SAAKZ,IAAL,GAAY,mCAAZ,CAHmB,CAG8B;;AACjD,SAAKC,aAAL,GAAqB,yCAArB,CAJmB,CAI6C;;AAChE,SAAKC,mBAAL,GAA2B,0BAA3B,CALmB,CAKoC;;AACvD,SAAKW,uBAAL,GAA+B,0BAA/B;AACA,SAAKV,SAAL,GAAiB,2CAAjB;AACA,SAAKW,OAAL,GAAe,4XAAf;AACA,SAAKC,SAAL,GAAiB,ojCAAjB;AACA,SAAKC,SAAL,GAAiB,+YAAjB;AACA,SAAKZ,MAAL,GAAc,8ZAAd;AACA,SAAKa,OAAL,GAAe,iFAAf;AACA,SAAKC,QAAL,GAAgB,2CAAhB;AACA,SAAKC,QAAL,GAAgB,sBAAhB;AACA,SAAKC,cAAL,GAAsB,mCAAtB;AACA,SAAKC,gBAAL,GAAwB,2BAAxB;AACA,SAAKhB,QAAL,GAAgB,2CAAhB;AACA,SAAKC,QAAL,GAAgB,aAAhB;AACA,SAAKC,WAAL,GAAmB,SAAnB;AACA,SAAKC,UAAL,GAAkB,kBAAlB;AACAI,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CArBmB,CAuBnB;;AACA,QAAI,KAAKU,SAAL,GAAiB,CAAC,CAACV,OAAO,CAACW,QAA/B,EAAyC;AACvC,WAAKC,OAAL,GAAe,KAAf,CADuC,CAEvC;;AACA,WAAK,MAAMC,GAAX,IAAkB,IAAlB,EAAwB;AACtB,YAAI,EAAEA,GAAG,IAAI1B,eAAT,KAA6B,KAAK0B,GAAL,aAAqBC,MAAtD,EACE,KAAKD,GAAL,IAAYhB,aAAZ;AACH;AACF,KAPD,CAQA;AARA,SASK;AACH,WAAKe,OAAL,GAAeZ,OAAO,CAACe,EAAR,KAAe,KAA9B;AACD,KAnCkB,CAoCnB;;;AACA,SAAKC,SAAL,GAAiB,CAAC,CAAChB,OAAO,CAACiB,QAA3B,CArCmB,CAsCnB;;AACA,SAAKC,kBAAL,GAA0B,CAA1B;AACD,GAzC0B,CA2C3B;AAEA;;;AACAC,EAAAA,cAAc,CAACC,QAAD,EAAWC,aAAX,EAA0B;AACtC;AACA,QAAIC,KAAK,GAAG,KAAKC,MAAjB;AACA,UAAMC,cAAc,GAAG,KAAKR,SAA5B;;AACA,WAAO,IAAP,EAAa;AACX;AACA,UAAIS,eAAJ,EAAqBC,OAArB;;AACA,aAAOD,eAAe,GAAG,KAAKhC,QAAL,CAAckC,IAAd,CAAmBL,KAAnB,CAAzB,EAAoD;AAClD;AACA,YAAIE,cAAc,KAAKE,OAAO,GAAG,KAAKhC,QAAL,CAAciC,IAAd,CAAmBF,eAAe,CAAC,CAAD,CAAlC,CAAf,CAAlB,EACEL,QAAQ,CAAC,IAAD,EAAO;AAAEQ,UAAAA,IAAI,EAAE,KAAKC,KAAb;AAAoBC,UAAAA,IAAI,EAAE,SAA1B;AAAqCC,UAAAA,KAAK,EAAEL,OAAO,CAAC,CAAD,CAAnD;AAAwDM,UAAAA,MAAM,EAAE;AAAhE,SAAP,CAAR,CAHgD,CAIlD;;AACAV,QAAAA,KAAK,GAAGA,KAAK,CAACW,MAAN,CAAaR,eAAe,CAAC,CAAD,CAAf,CAAmBS,MAAhC,EAAwCZ,KAAK,CAACY,MAA9C,CAAR;AACA,aAAKL,KAAL;AACD,OAVU,CAWX;;;AACA,UAAI,CAACJ,eAAD,KAAqBA,eAAe,GAAG,KAAK9B,WAAL,CAAiBgC,IAAjB,CAAsBL,KAAtB,CAAvC,CAAJ,EACEA,KAAK,GAAGA,KAAK,CAACW,MAAN,CAAaR,eAAe,CAAC,CAAD,CAAf,CAAmBS,MAAhC,EAAwCZ,KAAK,CAACY,MAA9C,CAAR,CAbS,CAeX;;AACA,UAAI,KAAKtC,UAAL,CAAgBuC,IAAhB,CAAqBb,KAArB,CAAJ,EAAiC;AAC/B;AACA,YAAID,aAAJ,EAAmB;AACjB;AACA,cAAIG,cAAc,KAAKE,OAAO,GAAG,KAAKhC,QAAL,CAAciC,IAAd,CAAmBL,KAAnB,CAAf,CAAlB,EACEF,QAAQ,CAAC,IAAD,EAAO;AAAEQ,YAAAA,IAAI,EAAE,KAAKC,KAAb;AAAoBC,YAAAA,IAAI,EAAE,SAA1B;AAAqCC,YAAAA,KAAK,EAAEL,OAAO,CAAC,CAAD,CAAnD;AAAwDM,YAAAA,MAAM,EAAE;AAAhE,WAAP,CAAR;AACFZ,UAAAA,QAAQ,CAACE,KAAK,GAAG,IAAT,EAAe;AAAEM,YAAAA,IAAI,EAAE,KAAKC,KAAb;AAAoBC,YAAAA,IAAI,EAAE,KAA1B;AAAiCC,YAAAA,KAAK,EAAE,EAAxC;AAA4CC,YAAAA,MAAM,EAAE;AAApD,WAAf,CAAR;AACD;;AACD,eAAO,KAAKT,MAAL,GAAcD,KAArB;AACD,OAzBU,CA2BX;;;AACA,YAAMM,IAAI,GAAG,KAAKC,KAAlB;AAAA,YAAyBO,SAAS,GAAGd,KAAK,CAAC,CAAD,CAA1C;AACA,UAAIQ,IAAI,GAAG,EAAX;AAAA,UAAeC,KAAK,GAAG,EAAvB;AAAA,UAA2BC,MAAM,GAAG,EAApC;AAAA,UACIK,KAAK,GAAG,IADZ;AAAA,UACkBC,WAAW,GAAG,CADhC;AAAA,UACmCC,YAAY,GAAG,KADlD;;AAEA,cAAQH,SAAR;AACA,aAAK,GAAL;AACE;AACA,cAAId,KAAK,CAACY,MAAN,GAAe,CAAnB,EACE,MADF,CAEA;AAFA,eAGK,IAAIZ,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsB;AACzB,iBAAKkB,eAAL,GAAuB,IAAvB,CADyB,CAEzB;;AACAlB,YAAAA,KAAK,GAAGA,KAAK,CAACW,MAAN,CAAa,CAAb,CAAR;;AACA,gBAAIX,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsB;AACpBiB,cAAAA,YAAY,GAAG,IAAf;AACA;AACD;AACF,WARI,CASL;AATK,eAUA;AACH,gBAAI,KAAK3B,OAAT,EAAkB;AAChB0B,cAAAA,WAAW,GAAG,CAAd;AACAR,cAAAA,IAAI,GAAG,GAAP;AACD;;AACD;AACD;AACD;;AACF,aAAK,GAAL;AACE;AACA,cAAIO,KAAK,GAAG,KAAKhD,aAAL,CAAmBsC,IAAnB,CAAwBL,KAAxB,CAAZ,EACEQ,IAAI,GAAG,KAAP,EAAcC,KAAK,GAAGM,KAAK,CAAC,CAAD,CAA3B,CADF,CAEA;AAFA,eAGK,IAAIA,KAAK,GAAG,KAAKjD,IAAL,CAAUuC,IAAV,CAAeL,KAAf,CAAZ,EAAmC;AACtCS,YAAAA,KAAK,GAAG,KAAKU,SAAL,CAAeJ,KAAK,CAAC,CAAD,CAApB,CAAR;AACA,gBAAIN,KAAK,KAAK,IAAV,IAAkB7C,eAAe,CAACiD,IAAhB,CAAqBJ,KAArB,CAAtB,EACE,OAAOW,iBAAiB,CAAC,IAAD,CAAxB;AACFZ,YAAAA,IAAI,GAAG,KAAP;AACD,WALI,CAML;AANK,eAOA,IAAIR,KAAK,CAACY,MAAN,GAAe,CAAf,IAAoBZ,KAAK,CAAC,CAAD,CAAL,KAAa,GAArC,EACHQ,IAAI,GAAG,IAAP,EAAaQ,WAAW,GAAG,CAA3B,CADG,CAEL;AAFK,eAGA,IAAI,KAAK1B,OAAL,IAAgBU,KAAK,CAACY,MAAN,GAAe,CAA/B,IAAoCZ,KAAK,CAAC,CAAD,CAAL,KAAa,GAArD,EACHQ,IAAI,GAAG,SAAP,EAAkBQ,WAAW,GAAG,CAAhC,EAAmCP,KAAK,GAAG,GAA3C;AACF;;AAEF,aAAK,GAAL;AACE,cAAIT,KAAK,CAACY,MAAN,GAAe,CAAf,IAAoBZ,KAAK,CAAC,CAAD,CAAL,KAAa,GAArC,EACEQ,IAAI,GAAG,IAAP,EAAaQ,WAAW,GAAG,CAA3B;AACF;;AAEF,aAAK,GAAL;AACE;AACA;AACA;AACA,cAAI,CAACD,KAAK,GAAG,KAAK7C,MAAL,CAAYmC,IAAZ,CAAiBL,KAAjB,CAAT,KACAD,aAAa,KAAKgB,KAAK,GAAG,KAAK7C,MAAL,CAAYmC,IAAZ,CAAkB,GAAEL,KAAM,GAA1B,CAAb,CADjB,EAEEQ,IAAI,GAAG,OAAP,EAAgBE,MAAM,GAAG,GAAzB,EAA8BD,KAAK,GAAGM,KAAK,CAAC,CAAD,CAA3C;AACF;;AAEF,aAAK,GAAL;AACE;AACA,cAAIA,KAAK,GAAG,KAAK/C,mBAAL,CAAyBqC,IAAzB,CAA8BL,KAA9B,CAAZ,EACES,KAAK,GAAGM,KAAK,CAAC,CAAD,CAAb,CADF,CAEA;AAFA,eAGK;AACH,aAAC;AAAEN,cAAAA,KAAF;AAASO,cAAAA;AAAT,gBAAyB,KAAKK,aAAL,CAAmBrB,KAAnB,CAA1B;AACA,gBAAIS,KAAK,KAAK,IAAd,EACE,OAAOW,iBAAiB,CAAC,IAAD,CAAxB;AACH;;AACD,cAAIL,KAAK,KAAK,IAAV,IAAkBC,WAAW,KAAK,CAAtC,EAAyC;AACvCR,YAAAA,IAAI,GAAG,SAAP;AACA,iBAAKZ,kBAAL,GAA0B,CAA1B;AACD;;AACD;;AAEF,aAAK,GAAL;AACE,cAAI,CAAC,KAAKR,SAAV,EAAqB;AACnB;AACA,gBAAI2B,KAAK,GAAG,KAAKpC,uBAAL,CAA6B0B,IAA7B,CAAkCL,KAAlC,CAAZ,EACES,KAAK,GAAGM,KAAK,CAAC,CAAD,CAAb,CADF,CAEA;AAFA,iBAGK;AACH,eAAC;AAAEN,gBAAAA,KAAF;AAASO,gBAAAA;AAAT,kBAAyB,KAAKK,aAAL,CAAmBrB,KAAnB,CAA1B;AACA,kBAAIS,KAAK,KAAK,IAAd,EACE,OAAOW,iBAAiB,CAAC,IAAD,CAAxB;AACH;;AACD,gBAAIL,KAAK,KAAK,IAAV,IAAkBC,WAAW,KAAK,CAAtC,EAAyC;AACvCR,cAAAA,IAAI,GAAG,SAAP;AACA,mBAAKZ,kBAAL,GAA0B,CAA1B;AACD;AACF;;AACD;;AAEF,aAAK,GAAL;AACE;AACA,cAAI,KAAKN,OAAL,KAAiByB,KAAK,GAAG,KAAKjC,SAAL,CAAeuB,IAAf,CAAoBL,KAApB,CAAzB,CAAJ,EACEQ,IAAI,GAAG,KAAP,EAAcC,KAAK,GAAGM,KAAK,CAAC,CAAD,CAA3B;AACF;;AAEF,aAAK,GAAL;AACE;AACA,cAAI,KAAKG,eAAL,KAAyB,SAAzB,KAAuCH,KAAK,GAAG,KAAK9C,SAAL,CAAeoC,IAAf,CAAoBL,KAApB,CAA/C,CAAJ,EACEQ,IAAI,GAAG,UAAP,EAAmBC,KAAK,GAAGM,KAAK,CAAC,CAAD,CAAhC,CADF,CAEA;AAFA,eAGK,IAAIA,KAAK,GAAG,KAAK9B,QAAL,CAAcoB,IAAd,CAAmBL,KAAnB,CAAZ,EACHQ,IAAI,GAAGO,KAAK,CAAC,CAAD,CAAZ;AACF;;AAEF,aAAK,GAAL;AACE;AACA,cAAIf,KAAK,CAACY,MAAN,KAAiB,CAAjB,GAAqBb,aAArB,GAAsCC,KAAK,CAAC,CAAD,CAAL,GAAW,GAAX,IAAkBA,KAAK,CAAC,CAAD,CAAL,GAAW,GAAvE,EAA6E;AAC3EQ,YAAAA,IAAI,GAAG,GAAP;AACAQ,YAAAA,WAAW,GAAG,CAAd;AACA;AACD;;AACD;;AAEF,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACE;AACA;AACA;AACA,cAAID,KAAK,GAAG,KAAKhC,OAAL,CAAasB,IAAb,CAAkBL,KAAlB,KACRD,aAAa,KAAKgB,KAAK,GAAG,KAAKhC,OAAL,CAAasB,IAAb,CAAmB,GAAEL,KAAM,GAA3B,CAAb,CADjB,EAC+D;AAC7DQ,YAAAA,IAAI,GAAG,SAAP,EAAkBC,KAAK,GAAGM,KAAK,CAAC,CAAD,CAA/B;AACAL,YAAAA,MAAM,GAAI,OAAOK,KAAK,CAAC,CAAD,CAAZ,KAAoB,QAApB,GAA+BtD,GAAG,CAAC6D,MAAnC,GACC,OAAOP,KAAK,CAAC,CAAD,CAAZ,KAAoB,QAApB,GAA+BtD,GAAG,CAAC8D,OAAnC,GAA6C9D,GAAG,CAAC+D,OAD5D;AAED;;AACD;;AAEF,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACE;AACA,cAAIT,KAAK,GAAG,KAAK7B,cAAL,CAAoBmB,IAApB,CAAyBL,KAAzB,CAAZ,EACEQ,IAAI,GAAGO,KAAK,CAAC,CAAD,CAAL,CAASU,WAAT,EAAP,CADF,KAGER,YAAY,GAAG,IAAf;AACF;;AAEF,aAAK,GAAL;AACA,aAAK,GAAL;AACE;AACA,cAAIF,KAAK,GAAG,KAAK/B,QAAL,CAAcqB,IAAd,CAAmBL,KAAnB,CAAZ,EACEQ,IAAI,GAAG,SAAP,EAAkBC,KAAK,GAAGM,KAAK,CAAC,CAAD,CAA/B,EAAoCL,MAAM,GAAGjD,GAAG,CAACiE,OAAjD,CADF,KAGET,YAAY,GAAG,IAAf;AACF;;AAEF,aAAK,GAAL;AACE;AACA,cAAIF,KAAK,GAAG,KAAK5B,gBAAL,CAAsBkB,IAAtB,CAA2BL,KAA3B,CAAZ,EACEQ,IAAI,GAAG,cAAP,EAAuBC,KAAK,GAAG,GAA/B,CADF,KAGEQ,YAAY,GAAG,IAAf;AACF;;AAEF,aAAK,GAAL;AACE;AACA,cAAI,KAAK3B,OAAL,IAAgBU,KAAK,CAACY,MAAN,GAAe,CAAnC,EAAsC;AACpCJ,YAAAA,IAAI,GAAG,cAAP;AACA,gBAAIR,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EACEgB,WAAW,GAAG,CAAd,EAAiBP,KAAK,GAAG,GAAzB,CADF,KAGEO,WAAW,GAAG,CAAd,EAAiBP,KAAK,GAAG,GAAzB;AACH;;AACD;;AAEF,aAAK,GAAL;AACE,cAAI,CAAC,KAAKnB,OAAV,EACE;;AACJ,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACA,aAAK,GAAL;AACE,cAAI,CAAC,KAAKF,SAAV,EAAqB;AACnB4B,YAAAA,WAAW,GAAG,CAAd;AACAR,YAAAA,IAAI,GAAGM,SAAP;AACD;;AACD;;AAEF;AACEG,UAAAA,YAAY,GAAG,IAAf;AArMF,OA/BW,CAuOX;;;AACA,UAAIA,YAAJ,EAAkB;AAChB;AACA,YAAI,CAAC,KAAKC,eAAL,KAAyB,SAAzB,IAAsC,KAAKA,eAAL,KAAyB,QAAhE,MACCH,KAAK,GAAG,KAAKnC,OAAL,CAAayB,IAAb,CAAkBL,KAAlB,CADT,CAAJ,EAEEQ,IAAI,GAAG,QAAP,EAAiBC,KAAK,GAAGM,KAAK,CAAC,CAAD,CAAL,IAAY,EAArC,CAFF,CAGA;AACA;AACA;AALA,aAMK,IAAI,CAACA,KAAK,GAAG,KAAKlC,SAAL,CAAewB,IAAf,CAAoBL,KAApB,CAAT,KACAD,aAAa,KAAKgB,KAAK,GAAG,KAAKlC,SAAL,CAAewB,IAAf,CAAqB,GAAEL,KAAM,GAA7B,CAAb,CADjB,EAEHQ,IAAI,GAAG,UAAP,EAAmBE,MAAM,GAAGK,KAAK,CAAC,CAAD,CAAL,IAAY,EAAxC,EAA4CN,KAAK,GAAG,KAAKU,SAAL,CAAeJ,KAAK,CAAC,CAAD,CAApB,CAApD;AACH,OAnPU,CAqPX;;;AACA,UAAI,KAAKG,eAAL,KAAyB,IAA7B,EAAmC;AACjC,gBAAQV,IAAR;AACA,eAAK,UAAL;AAAiBA,YAAAA,IAAI,GAAG,MAAP;AAAkB;;AACnC,eAAK,KAAL;AAAiBA,YAAAA,IAAI,GAAG,SAAP;AAAkB;;AACnC;AAAiBA,YAAAA,IAAI,GAAG,EAAP;AAHjB;AAKD,OA5PU,CA8PX;;;AACA,UAAI,CAACA,IAAL,EAAW;AACT;AACA;AACA;AACA,YAAIT,aAAa,IAAK,CAAC,YAAYc,IAAZ,CAAiBb,KAAjB,CAAD,IAA4B,QAAQa,IAAR,CAAab,KAAb,CAAlD,EACE,OAAOoB,iBAAiB,CAAC,IAAD,CAAxB,CADF,KAGE,OAAO,KAAKnB,MAAL,GAAcD,KAArB;AACH,OAvQU,CAyQX;;;AACA,YAAM2B,KAAK,GAAG;AAAErB,QAAAA,IAAI,EAAEA,IAAR;AAAcE,QAAAA,IAAI,EAAEA,IAApB;AAA0BC,QAAAA,KAAK,EAAEA,KAAjC;AAAwCC,QAAAA,MAAM,EAAEA;AAAhD,OAAd;AACAZ,MAAAA,QAAQ,CAAC,IAAD,EAAO6B,KAAP,CAAR;AACA,WAAKC,aAAL,GAAqBD,KAArB;AACA,WAAKT,eAAL,GAAuBV,IAAvB,CA7QW,CA8QX;;AACAR,MAAAA,KAAK,GAAGA,KAAK,CAACW,MAAN,CAAaK,WAAW,IAAID,KAAK,CAAC,CAAD,CAAL,CAASH,MAArC,EAA6CZ,KAAK,CAACY,MAAnD,CAAR;AACD,KApRqC,CAsRtC;;;AACA,aAASQ,iBAAT,CAA2BS,IAA3B,EAAiC;AAAE/B,MAAAA,QAAQ,CAAC+B,IAAI,CAACC,YAAL,CAAkB,OAAOzB,IAAP,CAAYL,KAAZ,EAAmB,CAAnB,CAAlB,CAAD,CAAR;AAAqD;AACzF,GAtU0B,CAwU3B;;;AACAmB,EAAAA,SAAS,CAACY,IAAD,EAAO;AACd,QAAIC,OAAO,GAAG,KAAd;AACA,UAAMC,QAAQ,GAAGF,IAAI,CAACG,OAAL,CAAaxE,cAAb,EAA6B,CAACyE,QAAD,EAAWC,QAAX,EAAqBC,QAArB,EAA+BC,WAA/B,KAA+C;AAC3F;AACA,UAAI,OAAOF,QAAP,KAAoB,QAAxB,EACE,OAAOG,MAAM,CAACC,YAAP,CAAoBC,MAAM,CAACC,QAAP,CAAgBN,QAAhB,EAA0B,EAA1B,CAApB,CAAP,CAHyF,CAI3F;;AACA,UAAI,OAAOC,QAAP,KAAoB,QAAxB,EAAkC;AAChC,YAAIM,QAAQ,GAAGF,MAAM,CAACC,QAAP,CAAgBL,QAAhB,EAA0B,EAA1B,CAAf;AACA,eAAOM,QAAQ,IAAI,MAAZ,GAAqBJ,MAAM,CAACC,YAAP,CAAoBC,MAAM,CAACC,QAAP,CAAgBL,QAAhB,EAA0B,EAA1B,CAApB,CAArB,GACLE,MAAM,CAACC,YAAP,CAAoB,UAAU,CAACG,QAAQ,IAAI,OAAb,KAAyB,EAAnC,CAApB,EAA4D,UAAUA,QAAQ,GAAG,KAArB,CAA5D,CADF;AAED,OAT0F,CAU3F;;;AACA,UAAIL,WAAW,IAAI3E,kBAAnB,EACE,OAAOA,kBAAkB,CAAC2E,WAAD,CAAzB,CAZyF,CAa3F;;AACAN,MAAAA,OAAO,GAAG,IAAV;AACA,aAAO,EAAP;AACD,KAhBgB,CAAjB;AAiBA,WAAOA,OAAO,GAAG,IAAH,GAAUC,QAAxB;AACD,GA7V0B,CA+V3B;;;AACAZ,EAAAA,aAAa,CAACrB,KAAD,EAAQ;AACnB;AACA,QAAIA,KAAK,CAACY,MAAN,IAAgB,CAApB,EAAuB;AACrB;AACA,YAAMgC,OAAO,GAAG5C,KAAK,CAACe,KAAN,CAAY,mBAAZ,EAAiC,CAAjC,CAAhB;AACA,YAAM8B,aAAa,GAAGD,OAAO,CAAChC,MAA9B,CAHqB,CAKrB;;AACA,UAAIkC,UAAU,GAAGC,IAAI,CAACC,GAAL,CAAS,KAAKpD,kBAAd,EAAkCiD,aAAlC,CAAjB;;AACA,aAAO,CAACC,UAAU,GAAG9C,KAAK,CAACiD,OAAN,CAAcL,OAAd,EAAuBE,UAAvB,CAAd,IAAoD,CAA3D,EAA8D;AAC5D;AACA,YAAII,cAAc,GAAG,CAArB;;AACA,eAAOlD,KAAK,CAAC8C,UAAU,GAAGI,cAAb,GAA8B,CAA/B,CAAL,KAA2C,IAAlD,EACEA,cAAc,GAJ4C,CAM5D;AACA;;;AACA,YAAIA,cAAc,GAAG,CAAjB,KAAuB,CAA3B,EAA8B;AAC5B;AACA,gBAAMC,GAAG,GAAGnD,KAAK,CAACoD,SAAN,CAAgBP,aAAhB,EAA+BC,UAA/B,CAAZ;AACA,gBAAMO,KAAK,GAAGF,GAAG,CAACG,KAAJ,CAAU,YAAV,EAAwB1C,MAAxB,GAAiC,CAA/C;AACA,gBAAMI,WAAW,GAAG8B,UAAU,GAAGD,aAAjC,CAJ4B,CAK5B;;AACA,cAAIA,aAAa,KAAK,CAAlB,IAAuBQ,KAAK,KAAK,CAAjC,IACAR,aAAa,KAAK,CAAlB,IAAuB,KAAKzD,SADhC,EAEE;AACF,eAAKmB,KAAL,IAAc8C,KAAd;AACA,iBAAO;AAAE5C,YAAAA,KAAK,EAAE,KAAKU,SAAL,CAAegC,GAAf,CAAT;AAA8BnC,YAAAA;AAA9B,WAAP;AACD;;AACD8B,QAAAA,UAAU;AACX;;AACD,WAAKlD,kBAAL,GAA0BI,KAAK,CAACY,MAAN,GAAeiC,aAAf,GAA+B,CAAzD;AACD;;AACD,WAAO;AAAEpC,MAAAA,KAAK,EAAE,EAAT;AAAaO,MAAAA,WAAW,EAAE;AAA1B,KAAP;AACD,GAlY0B,CAoY3B;;;AACAc,EAAAA,YAAY,CAACyB,KAAD,EAAQ;AAClB,SAAKtD,MAAL,GAAc,IAAd;AACA,UAAMuD,GAAG,GAAG,IAAIC,KAAJ,CAAW,eAAcF,KAAM,aAAY,KAAKhD,KAAM,GAAtD,CAAZ;AACAiD,IAAAA,GAAG,CAACE,OAAJ,GAAc;AACZ/B,MAAAA,KAAK,EAAEgC,SADK;AAEZrD,MAAAA,IAAI,EAAE,KAAKC,KAFC;AAGZqB,MAAAA,aAAa,EAAE,KAAKA;AAHR,KAAd;AAKA,WAAO4B,GAAP;AACD,GA9Y0B,CAgZ3B;;;AACAI,EAAAA,gBAAgB,CAAC5D,KAAD,EAAQ;AACtB,WAAOA,KAAK,CAAC6D,UAAN,CAAiB,QAAjB,IAA6B7D,KAAK,CAACW,MAAN,CAAa,CAAb,CAA7B,GAA+CX,KAAtD;AACD,GAnZ0B,CAqZ3B;AAEA;AACA;;;AACA8D,EAAAA,QAAQ,CAAC9D,KAAD,EAAQF,QAAR,EAAkB;AACxB,SAAKS,KAAL,GAAa,CAAb,CADwB,CAGxB;;AACA,QAAI,OAAOP,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAKC,MAAL,GAAc,KAAK2D,gBAAL,CAAsB5D,KAAtB,CAAd,CAD6B,CAE7B;;AACA,UAAI,OAAOF,QAAP,KAAoB,UAAxB,EACEtC,cAAc,CAAC,MAAM,KAAKqC,cAAL,CAAoBC,QAApB,EAA8B,IAA9B,CAAP,CAAd,CADF,CAEA;AAFA,WAGK;AACH,cAAMiE,MAAM,GAAG,EAAf;AACA,YAAIC,KAAJ;;AACA,aAAKnE,cAAL,CAAoB,CAACoE,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAID,KAAK,GAAGC,CAAZ,GAAiBF,MAAM,CAACI,IAAP,CAAYD,CAAZ,CAAhD,EAAgE,IAAhE;;AACA,YAAIF,KAAJ,EAAW,MAAMA,KAAN;AACX,eAAOD,MAAP;AACD;AACF,KAbD,CAcA;AAdA,SAeK;AACH,WAAKK,cAAL,GAAsB,IAAtB;AACA,UAAI,OAAOpE,KAAK,CAACqE,WAAb,KAA6B,UAAjC,EACErE,KAAK,CAACqE,WAAN,CAAkB,MAAlB,EAHC,CAIH;;AACArE,MAAAA,KAAK,CAACsE,EAAN,CAAS,MAAT,EAAiBC,IAAI,IAAI;AACvB,YAAI,KAAKtE,MAAL,KAAgB,IAAhB,IAAwBsE,IAAI,CAAC3D,MAAL,KAAgB,CAA5C,EAA+C;AAC7C;AACA,cAAI,KAAKwD,cAAT,EAAyB;AACvBG,YAAAA,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,CAAC,KAAKL,cAAN,EAAsBG,IAAtB,CAAd,CAAP;AACA,iBAAKH,cAAL,GAAsB,IAAtB;AACD,WAL4C,CAM7C;;;AACA,cAAIG,IAAI,CAACA,IAAI,CAAC3D,MAAL,GAAc,CAAf,CAAJ,GAAwB,IAA5B,EAAkC;AAChC,iBAAKwD,cAAL,GAAsBG,IAAtB;AACD,WAFD,CAGA;AAHA,eAIK;AACH;AACA,gBAAI,OAAO,KAAKtE,MAAZ,KAAuB,WAA3B,EACE,KAAKA,MAAL,GAAc,KAAK2D,gBAAL,CAAsB,OAAOW,IAAP,KAAgB,QAAhB,GAA2BA,IAA3B,GAAkCA,IAAI,CAACG,QAAL,EAAxD,CAAd,CADF,KAGE,KAAKzE,MAAL,IAAesE,IAAf;;AACF,iBAAK1E,cAAL,CAAoBC,QAApB,EAA8B,KAA9B;AACD;AACF;AACF,OArBD,EALG,CA2BH;;AACAE,MAAAA,KAAK,CAACsE,EAAN,CAAS,KAAT,EAAgB,MAAM;AACpB,YAAI,OAAO,KAAKrE,MAAZ,KAAuB,QAA3B,EACE,KAAKJ,cAAL,CAAoBC,QAApB,EAA8B,IAA9B;AACH,OAHD;AAIAE,MAAAA,KAAK,CAACsE,EAAN,CAAS,OAAT,EAAkBxE,QAAlB;AACD;AACF;;AA9c0B","sourcesContent":["// **N3Lexer** tokenizes N3 documents.\nimport namespaces from './IRIs';\nimport queueMicrotask from 'queue-microtask';\n\nconst { xsd } = namespaces;\n\n// Regular expression and replacement string to escape N3 strings\nconst escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\([^])/g;\nconst escapeReplacements = {\n  '\\\\': '\\\\', \"'\": \"'\", '\"': '\"',\n  'n': '\\n', 'r': '\\r', 't': '\\t', 'f': '\\f', 'b': '\\b',\n  '_': '_', '~': '~', '.': '.', '-': '-', '!': '!', '$': '$', '&': '&',\n  '(': '(', ')': ')', '*': '*', '+': '+', ',': ',', ';': ';', '=': '=',\n  '/': '/', '?': '?', '#': '#', '@': '@', '%': '%',\n};\nconst illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\n\nconst lineModeRegExps = {\n  _iri: true,\n  _unescapedIri: true,\n  _simpleQuotedString: true,\n  _langcode: true,\n  _blank: true,\n  _newline: true,\n  _comment: true,\n  _whitespace: true,\n  _endOfFile: true,\n};\nconst invalidRegExp = /$0^/;\n\n// ## Constructor\nexport default class N3Lexer {\n  constructor(options) {\n    // ## Regular expressions\n    // It's slightly faster to have these as properties than as in-scope variables\n    this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n    this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n    this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n    this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n    this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n    this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._number = /^[\\-+]?(?:(\\d+\\.\\d*|\\.?\\d+)[eE][\\-+]?|\\d*(\\.)?)\\d+(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n    this._shortPredicates = /^a(?=[\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n    this._comment = /#([^\\n\\r]*)/;\n    this._whitespace = /^[ \\t]+/;\n    this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n    options = options || {};\n\n    // In line mode (N-Triples or N-Quads), only simple features may be parsed\n    if (this._lineMode = !!options.lineMode) {\n      this._n3Mode = false;\n      // Don't tokenize special literals\n      for (const key in this) {\n        if (!(key in lineModeRegExps) && this[key] instanceof RegExp)\n          this[key] = invalidRegExp;\n      }\n    }\n    // When not in line mode, enable N3 functionality by default\n    else {\n      this._n3Mode = options.n3 !== false;\n    }\n    // Don't output comment tokens by default\n    this._comments = !!options.comments;\n    // Cache the last tested closing position of long literals\n    this._literalClosingPos = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n  _tokenizeToEnd(callback, inputFinished) {\n    // Continue parsing as far as possible; the loop will return eventually\n    let input = this._input;\n    const outputComments = this._comments;\n    while (true) {\n      // Count and skip whitespace lines\n      let whiteSpaceMatch, comment;\n      while (whiteSpaceMatch = this._newline.exec(input)) {\n        // Try to find a comment\n        if (outputComments && (comment = this._comment.exec(whiteSpaceMatch[0])))\n          callback(null, { line: this._line, type: 'comment', value: comment[1], prefix: '' });\n        // Advance the input\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n        this._line++;\n      }\n      // Skip whitespace on current line\n      if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n\n      // Stop for now if we're at the end\n      if (this._endOfFile.test(input)) {\n        // If the input is finished, emit EOF\n        if (inputFinished) {\n          // Try to find a final comment\n          if (outputComments && (comment = this._comment.exec(input)))\n            callback(null, { line: this._line, type: 'comment', value: comment[1], prefix: '' });\n          callback(input = null, { line: this._line, type: 'eof', value: '', prefix: '' });\n        }\n        return this._input = input;\n      }\n\n      // Look for specific token types based on the first character\n      const line = this._line, firstChar = input[0];\n      let type = '', value = '', prefix = '',\n          match = null, matchLength = 0, inconclusive = false;\n      switch (firstChar) {\n      case '^':\n        // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n        if (input.length < 3)\n          break;\n        // Try to match a type\n        else if (input[1] === '^') {\n          this._previousMarker = '^^';\n          // Move to type IRI or prefixed name\n          input = input.substr(2);\n          if (input[0] !== '<') {\n            inconclusive = true;\n            break;\n          }\n        }\n        // If no type, it must be a path expression\n        else {\n          if (this._n3Mode) {\n            matchLength = 1;\n            type = '^';\n          }\n          break;\n        }\n        // Fall through in case the type is an IRI\n      case '<':\n        // Try to find a full IRI without escape sequences\n        if (match = this._unescapedIri.exec(input))\n          type = 'IRI', value = match[1];\n        // Try to find a full IRI with escape sequences\n        else if (match = this._iri.exec(input)) {\n          value = this._unescape(match[1]);\n          if (value === null || illegalIriChars.test(value))\n            return reportSyntaxError(this);\n          type = 'IRI';\n        }\n        // Try to find a nested triple\n        else if (input.length > 1 && input[1] === '<')\n          type = '<<', matchLength = 2;\n        // Try to find a backwards implication arrow\n        else if (this._n3Mode && input.length > 1 && input[1] === '=')\n          type = 'inverse', matchLength = 2, value = '>';\n        break;\n\n      case '>':\n        if (input.length > 1 && input[1] === '>')\n          type = '>>', matchLength = 2;\n        break;\n\n      case '_':\n        // Try to find a blank node. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a blank node.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if ((match = this._blank.exec(input)) ||\n            inputFinished && (match = this._blank.exec(`${input} `)))\n          type = 'blank', prefix = '_', value = match[1];\n        break;\n\n      case '\"':\n        // Try to find a literal without escape sequences\n        if (match = this._simpleQuotedString.exec(input))\n          value = match[1];\n        // Try to find a literal wrapped in three pairs of quotes\n        else {\n          ({ value, matchLength } = this._parseLiteral(input));\n          if (value === null)\n            return reportSyntaxError(this);\n        }\n        if (match !== null || matchLength !== 0) {\n          type = 'literal';\n          this._literalClosingPos = 0;\n        }\n        break;\n\n      case \"'\":\n        if (!this._lineMode) {\n          // Try to find a literal without escape sequences\n          if (match = this._simpleApostropheString.exec(input))\n            value = match[1];\n          // Try to find a literal wrapped in three pairs of quotes\n          else {\n            ({ value, matchLength } = this._parseLiteral(input));\n            if (value === null)\n              return reportSyntaxError(this);\n          }\n          if (match !== null || matchLength !== 0) {\n            type = 'literal';\n            this._literalClosingPos = 0;\n          }\n        }\n        break;\n\n      case '?':\n        // Try to find a variable\n        if (this._n3Mode && (match = this._variable.exec(input)))\n          type = 'var', value = match[0];\n        break;\n\n      case '@':\n        // Try to find a language code\n        if (this._previousMarker === 'literal' && (match = this._langcode.exec(input)))\n          type = 'langcode', value = match[1];\n        // Try to find a keyword\n        else if (match = this._keyword.exec(input))\n          type = match[0];\n        break;\n\n      case '.':\n        // Try to find a dot as punctuation\n        if (input.length === 1 ? inputFinished : (input[1] < '0' || input[1] > '9')) {\n          type = '.';\n          matchLength = 1;\n          break;\n        }\n        // Fall through to numerical case (could be a decimal dot)\n\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '+':\n      case '-':\n        // Try to find a number. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a number.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if (match = this._number.exec(input) ||\n            inputFinished && (match = this._number.exec(`${input} `))) {\n          type = 'literal', value = match[0];\n          prefix = (typeof match[1] === 'string' ? xsd.double :\n                    (typeof match[2] === 'string' ? xsd.decimal : xsd.integer));\n        }\n        break;\n\n      case 'B':\n      case 'b':\n      case 'p':\n      case 'P':\n      case 'G':\n      case 'g':\n        // Try to find a SPARQL-style keyword\n        if (match = this._sparqlKeyword.exec(input))\n          type = match[0].toUpperCase();\n        else\n          inconclusive = true;\n        break;\n\n      case 'f':\n      case 't':\n        // Try to match a boolean\n        if (match = this._boolean.exec(input))\n          type = 'literal', value = match[0], prefix = xsd.boolean;\n        else\n          inconclusive = true;\n        break;\n\n      case 'a':\n        // Try to find an abbreviated predicate\n        if (match = this._shortPredicates.exec(input))\n          type = 'abbreviation', value = 'a';\n        else\n          inconclusive = true;\n        break;\n\n      case '=':\n        // Try to find an implication arrow or equals sign\n        if (this._n3Mode && input.length > 1) {\n          type = 'abbreviation';\n          if (input[1] !== '>')\n            matchLength = 1, value = '=';\n          else\n            matchLength = 2, value = '>';\n        }\n        break;\n\n      case '!':\n        if (!this._n3Mode)\n          break;\n      case ',':\n      case ';':\n      case '[':\n      case ']':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n        if (!this._lineMode) {\n          matchLength = 1;\n          type = firstChar;\n        }\n        break;\n\n      default:\n        inconclusive = true;\n      }\n\n      // Some first characters do not allow an immediate decision, so inspect more\n      if (inconclusive) {\n        // Try to find a prefix\n        if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') &&\n            (match = this._prefix.exec(input)))\n          type = 'prefix', value = match[1] || '';\n        // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a prefixed name.\n        // Therefore, try inserting a space if we're at the end of the input.\n        else if ((match = this._prefixed.exec(input)) ||\n                 inputFinished && (match = this._prefixed.exec(`${input} `)))\n          type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n      }\n\n      // A type token is special: it can only be emitted after an IRI or prefixed name is read\n      if (this._previousMarker === '^^') {\n        switch (type) {\n        case 'prefixed': type = 'type';    break;\n        case 'IRI':      type = 'typeIRI'; break;\n        default:         type = '';\n        }\n      }\n\n      // What if nothing of the above was found?\n      if (!type) {\n        // We could be in streaming mode, and then we just wait for more input to arrive.\n        // Otherwise, a syntax error has occurred in the input.\n        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n        if (inputFinished || (!/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)))\n          return reportSyntaxError(this);\n        else\n          return this._input = input;\n      }\n\n      // Emit the parsed token\n      const token = { line: line, type: type, value: value, prefix: prefix };\n      callback(null, token);\n      this.previousToken = token;\n      this._previousMarker = type;\n      // Advance to next part to tokenize\n      input = input.substr(matchLength || match[0].length, input.length);\n    }\n\n    // Signals the syntax error through the callback\n    function reportSyntaxError(self) { callback(self._syntaxError(/^\\S*/.exec(input)[0])); }\n  }\n\n  // ### `_unescape` replaces N3 escape codes by their corresponding characters\n  _unescape(item) {\n    let invalid = false;\n    const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {\n      // 4-digit unicode character\n      if (typeof unicode4 === 'string')\n        return String.fromCharCode(Number.parseInt(unicode4, 16));\n      // 8-digit unicode character\n      if (typeof unicode8 === 'string') {\n        let charCode = Number.parseInt(unicode8, 16);\n        return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) :\n          String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));\n      }\n      // fixed escape sequence\n      if (escapedChar in escapeReplacements)\n        return escapeReplacements[escapedChar];\n      // invalid escape sequence\n      invalid = true;\n      return '';\n    });\n    return invalid ? null : replaced;\n  }\n\n  // ### `_parseLiteral` parses a literal into an unescaped value\n  _parseLiteral(input) {\n    // Ensure we have enough lookahead to identify triple-quoted strings\n    if (input.length >= 3) {\n      // Identify the opening quote(s)\n      const opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n      const openingLength = opening.length;\n\n      // Find the next candidate closing quotes\n      let closingPos = Math.max(this._literalClosingPos, openingLength);\n      while ((closingPos = input.indexOf(opening, closingPos)) > 0) {\n        // Count backslashes right before the closing quotes\n        let backslashCount = 0;\n        while (input[closingPos - backslashCount - 1] === '\\\\')\n          backslashCount++;\n\n        // An even number of backslashes (in particular 0)\n        // means these are actual, non-escaped closing quotes\n        if (backslashCount % 2 === 0) {\n          // Extract and unescape the value\n          const raw = input.substring(openingLength, closingPos);\n          const lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n          const matchLength = closingPos + openingLength;\n          // Only triple-quoted strings can be multi-line\n          if (openingLength === 1 && lines !== 0 ||\n              openingLength === 3 && this._lineMode)\n            break;\n          this._line += lines;\n          return { value: this._unescape(raw), matchLength };\n        }\n        closingPos++;\n      }\n      this._literalClosingPos = input.length - openingLength + 1;\n    }\n    return { value: '', matchLength: 0 };\n  }\n\n  // ### `_syntaxError` creates a syntax error for the given issue\n  _syntaxError(issue) {\n    this._input = null;\n    const err = new Error(`Unexpected \"${issue}\" on line ${this._line}.`);\n    err.context = {\n      token: undefined,\n      line: this._line,\n      previousToken: this.previousToken,\n    };\n    return err;\n  }\n\n  // ### Strips off any starting UTF BOM mark.\n  _readStartingBom(input) {\n    return input.startsWith('\\ufeff') ? input.substr(1) : input;\n  }\n\n  // ## Public methods\n\n  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n  // The input can be a string or a stream.\n  tokenize(input, callback) {\n    this._line = 1;\n\n    // If the input is a string, continuously emit tokens through the callback until the end\n    if (typeof input === 'string') {\n      this._input = this._readStartingBom(input);\n      // If a callback was passed, asynchronously call it\n      if (typeof callback === 'function')\n        queueMicrotask(() => this._tokenizeToEnd(callback, true));\n      // If no callback was passed, tokenize synchronously and return\n      else {\n        const tokens = [];\n        let error;\n        this._tokenizeToEnd((e, t) => e ? (error = e) : tokens.push(t), true);\n        if (error) throw error;\n        return tokens;\n      }\n    }\n    // Otherwise, the input must be a stream\n    else {\n      this._pendingBuffer = null;\n      if (typeof input.setEncoding === 'function')\n        input.setEncoding('utf8');\n      // Adds the data chunk to the buffer and parses as far as possible\n      input.on('data', data => {\n        if (this._input !== null && data.length !== 0) {\n          // Prepend any previous pending writes\n          if (this._pendingBuffer) {\n            data = Buffer.concat([this._pendingBuffer, data]);\n            this._pendingBuffer = null;\n          }\n          // Hold if the buffer ends in an incomplete unicode sequence\n          if (data[data.length - 1] & 0x80) {\n            this._pendingBuffer = data;\n          }\n          // Otherwise, tokenize as far as possible\n          else {\n            // Only read a BOM at the start\n            if (typeof this._input === 'undefined')\n              this._input = this._readStartingBom(typeof data === 'string' ? data : data.toString());\n            else\n              this._input += data;\n            this._tokenizeToEnd(callback, false);\n          }\n        }\n      });\n      // Parses until the end\n      input.on('end', () => {\n        if (typeof this._input === 'string')\n          this._tokenizeToEnd(callback, true);\n      });\n      input.on('error', callback);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}