{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GroupsState = void 0;\n\nconst actor_abstract_bindings_hash_1 = require(\"@comunica/actor-abstract-bindings-hash\");\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst sparqlee_1 = require(\"sparqlee\");\n/**\n * A state manager for the groups constructed by consuming the bindings-stream.\n */\n\n\nclass GroupsState {\n  constructor(pattern, sparqleeConfig) {\n    this.pattern = pattern;\n    this.sparqleeConfig = sparqleeConfig;\n    this.groups = new Map();\n    this.groupVariables = new Set(this.pattern.variables.map(x => rdf_string_1.termToString(x)));\n    this.distinctHashes = pattern.aggregates.some(({\n      distinct\n    }) => distinct) ? new Map() : null;\n  }\n  /**\n   * - Consumes a stream binding\n   * - Find the corresponding group and create one if need be\n   * - Feeds the binding to the group's aggregators\n   *\n   * @param {Bindings} bindings - The Bindings to consume\n   */\n\n\n  consumeBindings(bindings) {\n    // Select the bindings on which we group\n    const grouper = bindings.filter((_, variable) => this.groupVariables.has(variable)).toMap();\n    const groupHash = this.hashBindings(grouper); // First member of group -> create new group\n\n    let group = this.groups.get(groupHash);\n\n    if (!group) {\n      // Initialize state for all aggregators for new group\n      const aggregators = {};\n\n      for (const aggregate of this.pattern.aggregates) {\n        const key = rdf_string_1.termToString(aggregate.variable);\n        aggregators[key] = new sparqlee_1.AggregateEvaluator(aggregate, this.sparqleeConfig);\n        aggregators[key].put(bindings);\n      }\n\n      group = {\n        aggregators,\n        bindings: grouper\n      };\n      this.groups.set(groupHash, group);\n\n      if (this.distinctHashes) {\n        const bindingsHash = this.hashBindings(bindings);\n        this.distinctHashes.set(groupHash, new Set([bindingsHash]));\n      }\n    } else {\n      // Group already exists\n      // Update all the aggregators with the input binding\n      for (const aggregate of this.pattern.aggregates) {\n        // If distinct, check first wether we have inserted these values already\n        if (aggregate.distinct) {\n          const hash = this.hashBindings(bindings);\n\n          if (this.distinctHashes.get(groupHash).has(hash)) {\n            continue;\n          } else {\n            this.distinctHashes.get(groupHash).add(hash);\n          }\n        }\n\n        const variable = rdf_string_1.termToString(aggregate.variable);\n        group.aggregators[variable].put(bindings);\n      }\n    }\n  }\n  /**\n   * Collect the result of the current state. This returns a Bindings per group,\n   * and a (possibly empty) Bindings in case the no Bindings have been consumed yet.\n   */\n\n\n  collectResults() {\n    // Collect groups\n    let rows = [...this.groups].map(([_, group]) => {\n      const {\n        bindings: groupBindings,\n        aggregators\n      } = group; // Collect aggregator bindings\n      // If the aggregate errorred, the result will be undefined\n\n      const aggBindings = {};\n\n      for (const variable in aggregators) {\n        const value = aggregators[variable].result();\n\n        if (value !== undefined) {\n          // Filter undefined\n          aggBindings[variable] = value;\n        }\n      } // Merge grouping bindings and aggregator bindings\n\n\n      return groupBindings.merge(aggBindings);\n    }); // Case: No Input\n    // Some aggregators still define an output on the empty input\n    // Result is a single Bindings\n\n    if (rows.length === 0 && this.groupVariables.size === 0) {\n      const single = {};\n\n      for (const aggregate of this.pattern.aggregates) {\n        const key = rdf_string_1.termToString(aggregate.variable);\n        const value = sparqlee_1.AggregateEvaluator.emptyValue(aggregate);\n\n        if (value !== undefined) {\n          single[key] = value;\n        }\n      }\n\n      rows = [bus_query_operation_1.Bindings(single)];\n    }\n\n    return rows;\n  }\n  /**\n   * @param {Bindings} bindings - Bindings to hash\n   */\n\n\n  hashBindings(bindings) {\n    return actor_abstract_bindings_hash_1.AbstractFilterHash.hash(bindings);\n  }\n\n}\n\nexports.GroupsState = GroupsState;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-group/lib/GroupsState.js"],"names":["Object","defineProperty","exports","value","GroupsState","actor_abstract_bindings_hash_1","require","bus_query_operation_1","rdf_string_1","sparqlee_1","constructor","pattern","sparqleeConfig","groups","Map","groupVariables","Set","variables","map","x","termToString","distinctHashes","aggregates","some","distinct","consumeBindings","bindings","grouper","filter","_","variable","has","toMap","groupHash","hashBindings","group","get","aggregators","aggregate","key","AggregateEvaluator","put","set","bindingsHash","hash","add","collectResults","rows","groupBindings","aggBindings","result","undefined","merge","length","size","single","emptyValue","Bindings","AbstractFilterHash"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GroupsState = void 0;\nconst actor_abstract_bindings_hash_1 = require(\"@comunica/actor-abstract-bindings-hash\");\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst sparqlee_1 = require(\"sparqlee\");\n/**\n * A state manager for the groups constructed by consuming the bindings-stream.\n */\nclass GroupsState {\n    constructor(pattern, sparqleeConfig) {\n        this.pattern = pattern;\n        this.sparqleeConfig = sparqleeConfig;\n        this.groups = new Map();\n        this.groupVariables = new Set(this.pattern.variables.map(x => rdf_string_1.termToString(x)));\n        this.distinctHashes = pattern.aggregates.some(({ distinct }) => distinct) ?\n            new Map() :\n            null;\n    }\n    /**\n     * - Consumes a stream binding\n     * - Find the corresponding group and create one if need be\n     * - Feeds the binding to the group's aggregators\n     *\n     * @param {Bindings} bindings - The Bindings to consume\n     */\n    consumeBindings(bindings) {\n        // Select the bindings on which we group\n        const grouper = bindings\n            .filter((_, variable) => this.groupVariables.has(variable))\n            .toMap();\n        const groupHash = this.hashBindings(grouper);\n        // First member of group -> create new group\n        let group = this.groups.get(groupHash);\n        if (!group) {\n            // Initialize state for all aggregators for new group\n            const aggregators = {};\n            for (const aggregate of this.pattern.aggregates) {\n                const key = rdf_string_1.termToString(aggregate.variable);\n                aggregators[key] = new sparqlee_1.AggregateEvaluator(aggregate, this.sparqleeConfig);\n                aggregators[key].put(bindings);\n            }\n            group = { aggregators, bindings: grouper };\n            this.groups.set(groupHash, group);\n            if (this.distinctHashes) {\n                const bindingsHash = this.hashBindings(bindings);\n                this.distinctHashes.set(groupHash, new Set([bindingsHash]));\n            }\n        }\n        else {\n            // Group already exists\n            // Update all the aggregators with the input binding\n            for (const aggregate of this.pattern.aggregates) {\n                // If distinct, check first wether we have inserted these values already\n                if (aggregate.distinct) {\n                    const hash = this.hashBindings(bindings);\n                    if (this.distinctHashes.get(groupHash).has(hash)) {\n                        continue;\n                    }\n                    else {\n                        this.distinctHashes.get(groupHash).add(hash);\n                    }\n                }\n                const variable = rdf_string_1.termToString(aggregate.variable);\n                group.aggregators[variable].put(bindings);\n            }\n        }\n    }\n    /**\n     * Collect the result of the current state. This returns a Bindings per group,\n     * and a (possibly empty) Bindings in case the no Bindings have been consumed yet.\n     */\n    collectResults() {\n        // Collect groups\n        let rows = [...this.groups].map(([_, group]) => {\n            const { bindings: groupBindings, aggregators } = group;\n            // Collect aggregator bindings\n            // If the aggregate errorred, the result will be undefined\n            const aggBindings = {};\n            for (const variable in aggregators) {\n                const value = aggregators[variable].result();\n                if (value !== undefined) {\n                    // Filter undefined\n                    aggBindings[variable] = value;\n                }\n            }\n            // Merge grouping bindings and aggregator bindings\n            return groupBindings.merge(aggBindings);\n        });\n        // Case: No Input\n        // Some aggregators still define an output on the empty input\n        // Result is a single Bindings\n        if (rows.length === 0 && this.groupVariables.size === 0) {\n            const single = {};\n            for (const aggregate of this.pattern.aggregates) {\n                const key = rdf_string_1.termToString(aggregate.variable);\n                const value = sparqlee_1.AggregateEvaluator.emptyValue(aggregate);\n                if (value !== undefined) {\n                    single[key] = value;\n                }\n            }\n            rows = [bus_query_operation_1.Bindings(single)];\n        }\n        return rows;\n    }\n    /**\n     * @param {Bindings} bindings - Bindings to hash\n     */\n    hashBindings(bindings) {\n        return actor_abstract_bindings_hash_1.AbstractFilterHash.hash(bindings);\n    }\n}\nexports.GroupsState = GroupsState;\n//# sourceMappingURL=GroupsState.js.map"]},"metadata":{},"sourceType":"script"}