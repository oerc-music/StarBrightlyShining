{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DataSourceUtils = void 0;\n\nconst bus_rdf_resolve_quad_pattern_1 = require(\"@comunica/bus-rdf-resolve-quad-pattern\");\n\nconst context_entries_1 = require(\"@comunica/context-entries\");\n/**\n * Comunica datasource utilities\n */\n\n\nexports.DataSourceUtils = {\n  /**\n   * Get the single source if the context contains just a single source.\n   * @param {ActionContext} context A context, can be null.\n   * @return {Promise<IDataSource>} A promise resolving to the single datasource or undefined.\n   */\n  async getSingleSource(context) {\n    if (context && context.has(context_entries_1.KeysRdfResolveQuadPattern.source)) {\n      // If the single source is set\n      return context.get(context_entries_1.KeysRdfResolveQuadPattern.source);\n    }\n\n    if (context && context.has(context_entries_1.KeysRdfResolveQuadPattern.sources)) {\n      // If multiple sources are set\n      const datasources = context.get(context_entries_1.KeysRdfResolveQuadPattern.sources);\n\n      if (datasources.length === 1) {\n        return datasources[0];\n      }\n    }\n  },\n\n  /**\n   * Get the type of a single source\n   * @param {ActionContext} context A context, can be undefined.\n   * @return {Promise<string>} A promise resolving to the type of the source, can be undefined if source is undefined.\n   */\n  async getSingleSourceType(context) {\n    const source = await this.getSingleSource(context);\n    return source ? bus_rdf_resolve_quad_pattern_1.getDataSourceType(source) : undefined;\n  },\n\n  /**\n   * Check if the given context has a single source of the given type.\n   * @param {ActionContext} context An optional context.\n   * @param {string} requiredType The required source type name.\n   * @return {boolean} If the given context has a single source of the given type.\n   */\n  async singleSourceHasType(context, requiredType) {\n    const actualType = await this.getSingleSourceType(context);\n    return actualType ? actualType === requiredType : false;\n  }\n\n};","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/utils-datasource/lib/DataSourceUtils.js"],"names":["Object","defineProperty","exports","value","DataSourceUtils","bus_rdf_resolve_quad_pattern_1","require","context_entries_1","getSingleSource","context","has","KeysRdfResolveQuadPattern","source","get","sources","datasources","length","getSingleSourceType","getDataSourceType","undefined","singleSourceHasType","requiredType","actualType"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0B,KAAK,CAA/B;;AACA,MAAMC,8BAA8B,GAAGC,OAAO,CAAC,wCAAD,CAA9C;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,2BAAD,CAAjC;AACA;AACA;AACA;;;AACAJ,OAAO,CAACE,eAAR,GAA0B;AACtB;AACJ;AACA;AACA;AACA;AACI,QAAMI,eAAN,CAAsBC,OAAtB,EAA+B;AAC3B,QAAIA,OAAO,IAAIA,OAAO,CAACC,GAAR,CAAYH,iBAAiB,CAACI,yBAAlB,CAA4CC,MAAxD,CAAf,EAAgF;AAC5E;AACA,aAAOH,OAAO,CAACI,GAAR,CAAYN,iBAAiB,CAACI,yBAAlB,CAA4CC,MAAxD,CAAP;AACH;;AACD,QAAIH,OAAO,IAAIA,OAAO,CAACC,GAAR,CAAYH,iBAAiB,CAACI,yBAAlB,CAA4CG,OAAxD,CAAf,EAAiF;AAC7E;AACA,YAAMC,WAAW,GAAGN,OAAO,CAACI,GAAR,CAAYN,iBAAiB,CAACI,yBAAlB,CAA4CG,OAAxD,CAApB;;AACA,UAAIC,WAAW,CAACC,MAAZ,KAAuB,CAA3B,EAA8B;AAC1B,eAAOD,WAAW,CAAC,CAAD,CAAlB;AACH;AACJ;AACJ,GAlBqB;;AAmBtB;AACJ;AACA;AACA;AACA;AACI,QAAME,mBAAN,CAA0BR,OAA1B,EAAmC;AAC/B,UAAMG,MAAM,GAAG,MAAM,KAAKJ,eAAL,CAAqBC,OAArB,CAArB;AACA,WAAOG,MAAM,GAAGP,8BAA8B,CAACa,iBAA/B,CAAiDN,MAAjD,CAAH,GAA8DO,SAA3E;AACH,GA3BqB;;AA4BtB;AACJ;AACA;AACA;AACA;AACA;AACI,QAAMC,mBAAN,CAA0BX,OAA1B,EAAmCY,YAAnC,EAAiD;AAC7C,UAAMC,UAAU,GAAG,MAAM,KAAKL,mBAAL,CAAyBR,OAAzB,CAAzB;AACA,WAAOa,UAAU,GAAGA,UAAU,KAAKD,YAAlB,GAAiC,KAAlD;AACH;;AArCqB,CAA1B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataSourceUtils = void 0;\nconst bus_rdf_resolve_quad_pattern_1 = require(\"@comunica/bus-rdf-resolve-quad-pattern\");\nconst context_entries_1 = require(\"@comunica/context-entries\");\n/**\n * Comunica datasource utilities\n */\nexports.DataSourceUtils = {\n    /**\n     * Get the single source if the context contains just a single source.\n     * @param {ActionContext} context A context, can be null.\n     * @return {Promise<IDataSource>} A promise resolving to the single datasource or undefined.\n     */\n    async getSingleSource(context) {\n        if (context && context.has(context_entries_1.KeysRdfResolveQuadPattern.source)) {\n            // If the single source is set\n            return context.get(context_entries_1.KeysRdfResolveQuadPattern.source);\n        }\n        if (context && context.has(context_entries_1.KeysRdfResolveQuadPattern.sources)) {\n            // If multiple sources are set\n            const datasources = context.get(context_entries_1.KeysRdfResolveQuadPattern.sources);\n            if (datasources.length === 1) {\n                return datasources[0];\n            }\n        }\n    },\n    /**\n     * Get the type of a single source\n     * @param {ActionContext} context A context, can be undefined.\n     * @return {Promise<string>} A promise resolving to the type of the source, can be undefined if source is undefined.\n     */\n    async getSingleSourceType(context) {\n        const source = await this.getSingleSource(context);\n        return source ? bus_rdf_resolve_quad_pattern_1.getDataSourceType(source) : undefined;\n    },\n    /**\n     * Check if the given context has a single source of the given type.\n     * @param {ActionContext} context An optional context.\n     * @param {string} requiredType The required source type name.\n     * @return {boolean} If the given context has a single source of the given type.\n     */\n    async singleSourceHasType(context, requiredType) {\n        const actualType = await this.getSingleSourceType(context);\n        return actualType ? actualType === requiredType : false;\n    },\n};\n//# sourceMappingURL=DataSourceUtils.js.map"]},"metadata":{},"sourceType":"script"}