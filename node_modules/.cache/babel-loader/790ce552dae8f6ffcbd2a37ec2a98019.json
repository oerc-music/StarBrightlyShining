{"ast":null,"code":"import { namedNode, literal } from '@rdfjs/data-model';\nconst xsd = 'http://www.w3.org/2001/XMLSchema#';\nconst xsdBoolean = `${xsd}boolean`;\nconst xsdDateTime = `${xsd}dateTime`;\nconst xsdDecimal = `${xsd}decimal`;\nconst xsdDouble = `${xsd}double`;\nconst xsdFloat = `${xsd}float`;\nconst xsdInteger = `${xsd}integer`;\nconst xsdBooleanTerm = namedNode(xsdBoolean);\nconst xsdDateTimeTerm = namedNode(xsdDateTime);\nconst xsdDecimalTerm = namedNode(xsdDecimal);\nconst xsdDoubleTerm = namedNode(xsdDouble);\nconst xsdIntegerTerm = namedNode(xsdInteger);\nconst xsdTrue = literal('true', xsdBooleanTerm);\nconst xsdFalse = literal('false', xsdBooleanTerm);\nconst xsdNaN = literal('NaN', xsdDoubleTerm);\nconst xsdInf = literal('INF', xsdDoubleTerm);\nconst xsdMinusInf = literal('-INF', xsdDoubleTerm);\nconst xsdPrimitives = {\n  NaN,\n  'INF': Infinity,\n  '-INF': -Infinity\n}; // Checks whether the value is asynchronously iterable\n\nexport function isAsyncIterable(value) {\n  return value && typeof value[Symbol.asyncIterator] === 'function';\n} // Checks whether the value is an object without special meaning to LDflex\n\nexport function isPlainObject(value) {\n  return value !== null && // Ignore non-objects\n  typeof value === 'object' && // Ignore arrays\n  !Array.isArray(value) && // Ignore dates\n  !(value instanceof Date) && // Ignore Promise instances\n  typeof value.then !== 'function' && // Ignore RDF/JS Term instances\n  typeof value.termType !== 'string' && // Ignore LDflex paths\n  !isAsyncIterable(value);\n} // Checks whether the arguments consist of exactly one plain object\n\nexport function hasPlainObjectArgs(args, allowMultiple = false) {\n  const hasPlainObject = args.some(isPlainObject);\n  if (hasPlainObject && !allowMultiple && args.length !== 1) throw new Error(`Expected only 1 plain object, but got ${args.length} arguments`);\n  return hasPlainObject;\n} // Ensures that the value is an array\n\nexport function ensureArray(value) {\n  if (Array.isArray(value)) return value;\n  return value ? [value] : [];\n} // Joins the arrays into a single array\n\nexport function joinArrays(arrays) {\n  return [].concat(...arrays);\n} // Ensures the value is an RDF/JS term\n\nexport function valueToTerm(value) {\n  switch (typeof value) {\n    // strings\n    case 'string':\n      return literal(value);\n    // booleans\n\n    case 'boolean':\n      return value ? xsdTrue : xsdFalse;\n    // numbers\n\n    case 'number':\n      if (Number.isInteger(value)) return literal(value.toString(), xsdIntegerTerm);else if (Number.isFinite(value)) return literal(value.toString(), xsdDecimalTerm);else if (value === Infinity) return xsdInf;else if (value === -Infinity) return xsdMinusInf;\n      return xsdNaN;\n    // other objects\n\n    default:\n      if (value) {\n        // RDF/JS Term\n        if (typeof value.termType === 'string') return value; // Date\n\n        if (value instanceof Date) return literal(value.toISOString(), xsdDateTimeTerm);\n      }\n\n  } // invalid objects\n\n\n  throw new Error(`Invalid object: ${value}`);\n} // Converts the term into a primitive value\n\nexport function termToPrimitive(term) {\n  const {\n    termType,\n    value\n  } = term; // Some literals convert into specific primitive values\n\n  if (termType === 'Literal') {\n    const datatype = term.datatype.value;\n\n    if (datatype.startsWith(xsd)) {\n      switch (datatype) {\n        case xsdBoolean:\n          return value === 'true' || value === '1';\n\n        case xsdInteger:\n          return Number.parseInt(value, 10);\n\n        case xsdDecimal:\n          return Number.parseFloat(value);\n\n        case xsdDouble:\n        case xsdFloat:\n          if (value in xsdPrimitives) return xsdPrimitives[value];\n          return Number.parseFloat(value);\n\n        case xsdDateTime:\n          return new Date(Date.parse(value));\n\n        default:\n      }\n    }\n  } // All other nodes convert to their value\n\n\n  return value;\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/valueUtils.js"],"names":["namedNode","literal","xsd","xsdBoolean","xsdDateTime","xsdDecimal","xsdDouble","xsdFloat","xsdInteger","xsdBooleanTerm","xsdDateTimeTerm","xsdDecimalTerm","xsdDoubleTerm","xsdIntegerTerm","xsdTrue","xsdFalse","xsdNaN","xsdInf","xsdMinusInf","xsdPrimitives","NaN","Infinity","isAsyncIterable","value","Symbol","asyncIterator","isPlainObject","Array","isArray","Date","then","termType","hasPlainObjectArgs","args","allowMultiple","hasPlainObject","some","length","Error","ensureArray","joinArrays","arrays","concat","valueToTerm","Number","isInteger","toString","isFinite","toISOString","termToPrimitive","term","datatype","startsWith","parseInt","parseFloat","parse"],"mappings":"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","sourcesContent":["import { namedNode, literal } from '@rdfjs/data-model';\nconst xsd = 'http://www.w3.org/2001/XMLSchema#';\nconst xsdBoolean = `${xsd}boolean`;\nconst xsdDateTime = `${xsd}dateTime`;\nconst xsdDecimal = `${xsd}decimal`;\nconst xsdDouble = `${xsd}double`;\nconst xsdFloat = `${xsd}float`;\nconst xsdInteger = `${xsd}integer`;\nconst xsdBooleanTerm = namedNode(xsdBoolean);\nconst xsdDateTimeTerm = namedNode(xsdDateTime);\nconst xsdDecimalTerm = namedNode(xsdDecimal);\nconst xsdDoubleTerm = namedNode(xsdDouble);\nconst xsdIntegerTerm = namedNode(xsdInteger);\nconst xsdTrue = literal('true', xsdBooleanTerm);\nconst xsdFalse = literal('false', xsdBooleanTerm);\nconst xsdNaN = literal('NaN', xsdDoubleTerm);\nconst xsdInf = literal('INF', xsdDoubleTerm);\nconst xsdMinusInf = literal('-INF', xsdDoubleTerm);\nconst xsdPrimitives = {\n  NaN,\n  'INF': Infinity,\n  '-INF': -Infinity\n}; // Checks whether the value is asynchronously iterable\n\nexport function isAsyncIterable(value) {\n  return value && typeof value[Symbol.asyncIterator] === 'function';\n} // Checks whether the value is an object without special meaning to LDflex\n\nexport function isPlainObject(value) {\n  return value !== null && // Ignore non-objects\n  typeof value === 'object' && // Ignore arrays\n  !Array.isArray(value) && // Ignore dates\n  !(value instanceof Date) && // Ignore Promise instances\n  typeof value.then !== 'function' && // Ignore RDF/JS Term instances\n  typeof value.termType !== 'string' && // Ignore LDflex paths\n  !isAsyncIterable(value);\n} // Checks whether the arguments consist of exactly one plain object\n\nexport function hasPlainObjectArgs(args, allowMultiple = false) {\n  const hasPlainObject = args.some(isPlainObject);\n  if (hasPlainObject && !allowMultiple && args.length !== 1) throw new Error(`Expected only 1 plain object, but got ${args.length} arguments`);\n  return hasPlainObject;\n} // Ensures that the value is an array\n\nexport function ensureArray(value) {\n  if (Array.isArray(value)) return value;\n  return value ? [value] : [];\n} // Joins the arrays into a single array\n\nexport function joinArrays(arrays) {\n  return [].concat(...arrays);\n} // Ensures the value is an RDF/JS term\n\nexport function valueToTerm(value) {\n  switch (typeof value) {\n    // strings\n    case 'string':\n      return literal(value);\n    // booleans\n\n    case 'boolean':\n      return value ? xsdTrue : xsdFalse;\n    // numbers\n\n    case 'number':\n      if (Number.isInteger(value)) return literal(value.toString(), xsdIntegerTerm);else if (Number.isFinite(value)) return literal(value.toString(), xsdDecimalTerm);else if (value === Infinity) return xsdInf;else if (value === -Infinity) return xsdMinusInf;\n      return xsdNaN;\n    // other objects\n\n    default:\n      if (value) {\n        // RDF/JS Term\n        if (typeof value.termType === 'string') return value; // Date\n\n        if (value instanceof Date) return literal(value.toISOString(), xsdDateTimeTerm);\n      }\n\n  } // invalid objects\n\n\n  throw new Error(`Invalid object: ${value}`);\n} // Converts the term into a primitive value\n\nexport function termToPrimitive(term) {\n  const {\n    termType,\n    value\n  } = term; // Some literals convert into specific primitive values\n\n  if (termType === 'Literal') {\n    const datatype = term.datatype.value;\n\n    if (datatype.startsWith(xsd)) {\n      switch (datatype) {\n        case xsdBoolean:\n          return value === 'true' || value === '1';\n\n        case xsdInteger:\n          return Number.parseInt(value, 10);\n\n        case xsdDecimal:\n          return Number.parseFloat(value);\n\n        case xsdDouble:\n        case xsdFloat:\n          if (value in xsdPrimitives) return xsdPrimitives[value];\n          return Number.parseFloat(value);\n\n        case xsdDateTime:\n          return new Date(Date.parse(value));\n\n        default:\n      }\n    }\n  } // All other nodes convert to their value\n\n\n  return value;\n}"]},"metadata":{},"sourceType":"module"}