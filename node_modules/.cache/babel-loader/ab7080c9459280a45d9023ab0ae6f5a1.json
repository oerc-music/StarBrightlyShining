{"ast":null,"code":"const resolved = Promise.resolve(undefined); // Returns a function that asynchronously schedules a task\n\nexport default function createTaskScheduler() {\n  // Use or create a microtask scheduler\n  const scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : task => resolved.then(task); // Use or create a macrotask scheduler\n\n  const scheduleMacrotask = typeof setImmediate === 'function' ? setImmediate : task => setTimeout(task, 0); // Interrupt with a macrotask every once in a while to avoid freezing\n\n  let i = 0;\n  let queue = null;\n  return task => {\n    // Tasks are currently being queued to avoid freezing\n    if (queue !== null) queue.push(task); // Tasks are being scheduled normally as microtasks\n    else if (++i < 100) scheduleMicrotask(task); // A macrotask interruption is needed\n    else {\n      // Hold all tasks in a queue, and reschedule them after a macrotask\n      queue = [task];\n      scheduleMacrotask(() => {\n        // Work through the queue\n        for (const queued of queue) scheduleMicrotask(queued);\n\n        queue = null; // Reset the interruption schedule\n\n        i = 0;\n      });\n    }\n  };\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/asynciterator/dist/taskscheduler.js"],"names":["resolved","Promise","resolve","undefined","createTaskScheduler","scheduleMicrotask","queueMicrotask","task","then","scheduleMacrotask","setImmediate","setTimeout","i","queue","push","queued"],"mappings":"AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAACC,OAAR,CAAgBC,SAAhB,CAAjB,C,CACA;;AACA,eAAe,SAASC,mBAAT,GAA+B;AAC1C;AACA,QAAMC,iBAAiB,GAAG,OAAOC,cAAP,KAA0B,UAA1B,GACtBA,cADsB,GACJC,IAAD,IAAUP,QAAQ,CAACQ,IAAT,CAAcD,IAAd,CAD/B,CAF0C,CAI1C;;AACA,QAAME,iBAAiB,GAAG,OAAOC,YAAP,KAAwB,UAAxB,GACtBA,YADsB,GACNH,IAAD,IAAUI,UAAU,CAACJ,IAAD,EAAO,CAAP,CADvC,CAL0C,CAO1C;;AACA,MAAIK,CAAC,GAAG,CAAR;AACA,MAAIC,KAAK,GAAG,IAAZ;AACA,SAAQN,IAAD,IAAU;AACb;AACA,QAAIM,KAAK,KAAK,IAAd,EACIA,KAAK,CAACC,IAAN,CAAWP,IAAX,EADJ,CAEA;AAFA,SAGK,IAAI,EAAEK,CAAF,GAAM,GAAV,EACDP,iBAAiB,CAACE,IAAD,CAAjB,CADC,CAEL;AAFK,SAGA;AACD;AACAM,MAAAA,KAAK,GAAG,CAACN,IAAD,CAAR;AACAE,MAAAA,iBAAiB,CAAC,MAAM;AACpB;AACA,aAAK,MAAMM,MAAX,IAAqBF,KAArB,EACIR,iBAAiB,CAACU,MAAD,CAAjB;;AACJF,QAAAA,KAAK,GAAG,IAAR,CAJoB,CAKpB;;AACAD,QAAAA,CAAC,GAAG,CAAJ;AACH,OAPgB,CAAjB;AAQH;AACJ,GApBD;AAqBH","sourcesContent":["const resolved = Promise.resolve(undefined);\n// Returns a function that asynchronously schedules a task\nexport default function createTaskScheduler() {\n    // Use or create a microtask scheduler\n    const scheduleMicrotask = typeof queueMicrotask === 'function' ?\n        queueMicrotask : (task) => resolved.then(task);\n    // Use or create a macrotask scheduler\n    const scheduleMacrotask = typeof setImmediate === 'function' ?\n        setImmediate : (task) => setTimeout(task, 0);\n    // Interrupt with a macrotask every once in a while to avoid freezing\n    let i = 0;\n    let queue = null;\n    return (task) => {\n        // Tasks are currently being queued to avoid freezing\n        if (queue !== null)\n            queue.push(task);\n        // Tasks are being scheduled normally as microtasks\n        else if (++i < 100)\n            scheduleMicrotask(task);\n        // A macrotask interruption is needed\n        else {\n            // Hold all tasks in a queue, and reschedule them after a macrotask\n            queue = [task];\n            scheduleMacrotask(() => {\n                // Work through the queue\n                for (const queued of queue)\n                    scheduleMicrotask(queued);\n                queue = null;\n                // Reset the interruption schedule\n                i = 0;\n            });\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}