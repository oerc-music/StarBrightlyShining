{"ast":null,"code":"/**\n * Executes the query represented by a path.\n *\n * Requires:\n * - a queryEngine property in the path settings\n * - a sparql property on the path proxy\n * - (optional) a resultsCache property on the path data\n */\nexport default class ExecuteQueryHandler {\n  async *handle(pathData, path) {\n    // Try to retrieve the result from cache\n    const resultsCache = await pathData.resultsCache;\n\n    if (resultsCache) {\n      for (const result of resultsCache) yield result;\n\n      return;\n    } // Retrieve the query engine and query\n\n\n    const {\n      queryEngine\n    } = pathData.settings;\n    if (!queryEngine) throw new Error(`${pathData} has no queryEngine setting`);\n    const query = await path.sparql;\n    if (query === null || query === undefined) throw new Error(`${pathData} has no sparql property`); // No results if the query is empty\n\n    if (query.length === 0) return; // Extract the term from every query result\n\n    for await (const bindings of queryEngine.execute(query)) yield this.extractTerm(bindings, pathData);\n  }\n  /**\n   * Extracts the first term from a query result binding as a new path.\n   */\n\n\n  extractTerm(binding, pathData) {\n    // Extract the first term from the binding map\n    if (binding.size !== 1) throw new Error('Only single-variable queries are supported');\n    const subject = binding.values().next().value; // Each result is a new path that starts from the term as subject\n\n    return pathData.extendPath({\n      subject\n    }, null);\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/ExecuteQueryHandler.js"],"names":["ExecuteQueryHandler","handle","pathData","path","resultsCache","result","queryEngine","settings","Error","query","sparql","undefined","length","bindings","execute","extractTerm","binding","size","subject","values","next","value","extendPath"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMA,mBAAN,CAA0B;AAC1B,SAANC,MAAM,CAACC,QAAD,EAAWC,IAAX,EAAiB;AAC5B;AACA,UAAMC,YAAY,GAAG,MAAMF,QAAQ,CAACE,YAApC;;AAEA,QAAIA,YAAJ,EAAkB;AAChB,WAAK,MAAMC,MAAX,IAAqBD,YAArB,EAAmC,MAAMC,MAAN;;AAEnC;AACD,KAR2B,CAQ1B;;;AAGF,UAAM;AACJC,MAAAA;AADI,QAEFJ,QAAQ,CAACK,QAFb;AAGA,QAAI,CAACD,WAAL,EAAkB,MAAM,IAAIE,KAAJ,CAAW,GAAEN,QAAS,6BAAtB,CAAN;AAClB,UAAMO,KAAK,GAAG,MAAMN,IAAI,CAACO,MAAzB;AACA,QAAID,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKE,SAAhC,EAA2C,MAAM,IAAIH,KAAJ,CAAW,GAAEN,QAAS,yBAAtB,CAAN,CAhBf,CAgBsE;;AAElG,QAAIO,KAAK,CAACG,MAAN,KAAiB,CAArB,EAAwB,OAlBI,CAkBI;;AAEhC,eAAW,MAAMC,QAAjB,IAA6BP,WAAW,CAACQ,OAAZ,CAAoBL,KAApB,CAA7B,EAAyD,MAAM,KAAKM,WAAL,CAAiBF,QAAjB,EAA2BX,QAA3B,CAAN;AAC1D;AACD;AACF;AACA;;;AAGEa,EAAAA,WAAW,CAACC,OAAD,EAAUd,QAAV,EAAoB;AAC7B;AACA,QAAIc,OAAO,CAACC,IAAR,KAAiB,CAArB,EAAwB,MAAM,IAAIT,KAAJ,CAAU,4CAAV,CAAN;AACxB,UAAMU,OAAO,GAAGF,OAAO,CAACG,MAAR,GAAiBC,IAAjB,GAAwBC,KAAxC,CAH6B,CAGkB;;AAE/C,WAAOnB,QAAQ,CAACoB,UAAT,CAAoB;AACzBJ,MAAAA;AADyB,KAApB,EAEJ,IAFI,CAAP;AAGD;;AApCsC","sourcesContent":["/**\n * Executes the query represented by a path.\n *\n * Requires:\n * - a queryEngine property in the path settings\n * - a sparql property on the path proxy\n * - (optional) a resultsCache property on the path data\n */\nexport default class ExecuteQueryHandler {\n  async *handle(pathData, path) {\n    // Try to retrieve the result from cache\n    const resultsCache = await pathData.resultsCache;\n\n    if (resultsCache) {\n      for (const result of resultsCache) yield result;\n\n      return;\n    } // Retrieve the query engine and query\n\n\n    const {\n      queryEngine\n    } = pathData.settings;\n    if (!queryEngine) throw new Error(`${pathData} has no queryEngine setting`);\n    const query = await path.sparql;\n    if (query === null || query === undefined) throw new Error(`${pathData} has no sparql property`); // No results if the query is empty\n\n    if (query.length === 0) return; // Extract the term from every query result\n\n    for await (const bindings of queryEngine.execute(query)) yield this.extractTerm(bindings, pathData);\n  }\n  /**\n   * Extracts the first term from a query result binding as a new path.\n   */\n\n\n  extractTerm(binding, pathData) {\n    // Extract the first term from the binding map\n    if (binding.size !== 1) throw new Error('Only single-variable queries are supported');\n    const subject = binding.values().next().value; // Each result is a new path that starts from the term as subject\n\n    return pathData.extendPath({\n      subject\n    }, null);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}