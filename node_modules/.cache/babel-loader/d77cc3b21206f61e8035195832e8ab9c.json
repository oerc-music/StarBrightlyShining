{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationLeftJoinLeftDeep = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst bus_rdf_join_1 = require(\"@comunica/bus-rdf-join\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica LeftJoin left-deep Query Operation Actor.\n */\n\n\nclass ActorQueryOperationLeftJoinLeftDeep extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n  constructor(args) {\n    super(args, 'leftjoin');\n  }\n  /**\n   * Create a new bindings stream\n   * that takes every binding of the base stream,\n   * materializes the remaining patterns with it,\n   * and emits all bindings from this new set of patterns.\n   * @param {BindingsStream} leftStream The base stream.\n   * @param {Algebra.Operation} rightOperation The operation to materialize with each binding of the base stream.\n   * @param {Algebra.Operation => Promise<BindingsStream>} operationBinder A callback to retrieve the bindings stream\n   *                                                                       of an operation.\n   * @return {BindingsStream}\n   */\n\n\n  static createLeftDeepStream(leftStream, rightOperation, operationBinder) {\n    return new asynciterator_1.MultiTransformIterator(leftStream, {\n      multiTransform(bindings) {\n        const bindingsMerger = subBindings => subBindings.merge(bindings);\n\n        return new asynciterator_1.TransformIterator(async () => (await operationBinder(bus_query_operation_1.materializeOperation(rightOperation, bindings))).map(bindingsMerger), {\n          maxBufferSize: 128\n        });\n      },\n\n      optional: true\n    });\n  }\n\n  async testOperation(pattern, context) {\n    return true;\n  }\n\n  async runOperation(pattern, context) {\n    // Initiate left and right operations\n    // Only the left stream will be used.\n    // The right stream is ignored and only its metadata and variables are used.\n    const left = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n      operation: pattern.left,\n      context\n    }));\n    const right = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n      operation: pattern.right,\n      context\n    })); // Close the right stream, since we don't need that one\n\n    right.bindingsStream.close(); // If an expression was defined, wrap the right operation in a filter expression.\n\n    const rightOperation = pattern.expression ? ActorQueryOperationLeftJoinLeftDeep.FACTORY.createFilter(pattern.right, pattern.expression) : pattern.right; // Create a left-deep stream with left and right.\n\n    const bindingsStream = ActorQueryOperationLeftJoinLeftDeep.createLeftDeepStream(left.bindingsStream, rightOperation, async operation => bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n      operation,\n      context\n    })).bindingsStream); // Determine variables and metadata\n\n    const variables = bus_rdf_join_1.ActorRdfJoin.joinVariables({\n      entries: [left, right]\n    });\n\n    const metadata = () => Promise.all([left, right].map(x => bus_query_operation_1.getMetadata(x))).then(metadatas => metadatas.reduce((acc, val) => acc * val.totalItems, 1)).catch(() => Number.POSITIVE_INFINITY).then(totalItems => ({\n      totalItems\n    }));\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata,\n      variables,\n      canContainUndefs: true\n    };\n  }\n\n}\n\nexports.ActorQueryOperationLeftJoinLeftDeep = ActorQueryOperationLeftJoinLeftDeep;\nActorQueryOperationLeftJoinLeftDeep.FACTORY = new sparqlalgebrajs_1.Factory();","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-leftjoin-left-deep/lib/ActorQueryOperationLeftJoinLeftDeep.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationLeftJoinLeftDeep","bus_query_operation_1","require","bus_rdf_join_1","asynciterator_1","sparqlalgebrajs_1","ActorQueryOperationTypedMediated","constructor","args","createLeftDeepStream","leftStream","rightOperation","operationBinder","MultiTransformIterator","multiTransform","bindings","bindingsMerger","subBindings","merge","TransformIterator","materializeOperation","map","maxBufferSize","optional","testOperation","pattern","context","runOperation","left","ActorQueryOperation","getSafeBindings","mediatorQueryOperation","mediate","operation","right","bindingsStream","close","expression","FACTORY","createFilter","variables","ActorRdfJoin","joinVariables","entries","metadata","Promise","all","x","getMetadata","then","metadatas","reduce","acc","val","totalItems","catch","Number","POSITIVE_INFINITY","type","canContainUndefs","Factory"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationLeftJoinLeftDeep = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst bus_rdf_join_1 = require(\"@comunica/bus-rdf-join\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica LeftJoin left-deep Query Operation Actor.\n */\nclass ActorQueryOperationLeftJoinLeftDeep extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n    constructor(args) {\n        super(args, 'leftjoin');\n    }\n    /**\n     * Create a new bindings stream\n     * that takes every binding of the base stream,\n     * materializes the remaining patterns with it,\n     * and emits all bindings from this new set of patterns.\n     * @param {BindingsStream} leftStream The base stream.\n     * @param {Algebra.Operation} rightOperation The operation to materialize with each binding of the base stream.\n     * @param {Algebra.Operation => Promise<BindingsStream>} operationBinder A callback to retrieve the bindings stream\n     *                                                                       of an operation.\n     * @return {BindingsStream}\n     */\n    static createLeftDeepStream(leftStream, rightOperation, operationBinder) {\n        return new asynciterator_1.MultiTransformIterator(leftStream, {\n            multiTransform(bindings) {\n                const bindingsMerger = (subBindings) => subBindings.merge(bindings);\n                return new asynciterator_1.TransformIterator(async () => (await operationBinder(bus_query_operation_1.materializeOperation(rightOperation, bindings)))\n                    .map(bindingsMerger), { maxBufferSize: 128 });\n            },\n            optional: true,\n        });\n    }\n    async testOperation(pattern, context) {\n        return true;\n    }\n    async runOperation(pattern, context) {\n        // Initiate left and right operations\n        // Only the left stream will be used.\n        // The right stream is ignored and only its metadata and variables are used.\n        const left = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation\n            .mediate({ operation: pattern.left, context }));\n        const right = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation\n            .mediate({ operation: pattern.right, context }));\n        // Close the right stream, since we don't need that one\n        right.bindingsStream.close();\n        // If an expression was defined, wrap the right operation in a filter expression.\n        const rightOperation = pattern.expression ?\n            ActorQueryOperationLeftJoinLeftDeep.FACTORY.createFilter(pattern.right, pattern.expression) :\n            pattern.right;\n        // Create a left-deep stream with left and right.\n        const bindingsStream = ActorQueryOperationLeftJoinLeftDeep.createLeftDeepStream(left.bindingsStream, rightOperation, async (operation) => bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation, context })).bindingsStream);\n        // Determine variables and metadata\n        const variables = bus_rdf_join_1.ActorRdfJoin.joinVariables({ entries: [left, right] });\n        const metadata = () => Promise.all([left, right].map(x => bus_query_operation_1.getMetadata(x)))\n            .then(metadatas => metadatas.reduce((acc, val) => acc * val.totalItems, 1))\n            .catch(() => Number.POSITIVE_INFINITY)\n            .then(totalItems => ({ totalItems }));\n        return { type: 'bindings', bindingsStream, metadata, variables, canContainUndefs: true };\n    }\n}\nexports.ActorQueryOperationLeftJoinLeftDeep = ActorQueryOperationLeftJoinLeftDeep;\nActorQueryOperationLeftJoinLeftDeep.FACTORY = new sparqlalgebrajs_1.Factory();\n//# sourceMappingURL=ActorQueryOperationLeftJoinLeftDeep.js.map"]},"metadata":{},"sourceType":"script"}