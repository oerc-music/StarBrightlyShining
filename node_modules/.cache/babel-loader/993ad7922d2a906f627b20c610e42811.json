{"ast":null,"code":"/*global unescape, module, define, window, global*/\n\n/*\r\n UriTemplate Copyright (c) 2012-2013 Franz Antesberger. All Rights Reserved.\r\n Available via the MIT license.\r\n*/\n(function (exportCallback) {\n  \"use strict\";\n\n  var UriTemplateError = function () {\n    function UriTemplateError(options) {\n      this.options = options;\n    }\n\n    UriTemplateError.prototype.toString = function () {\n      if (JSON && JSON.stringify) {\n        return JSON.stringify(this.options);\n      } else {\n        return this.options;\n      }\n    };\n\n    return UriTemplateError;\n  }();\n\n  var objectHelper = function () {\n    function isArray(value) {\n      return Object.prototype.toString.apply(value) === '[object Array]';\n    }\n\n    function isString(value) {\n      return Object.prototype.toString.apply(value) === '[object String]';\n    }\n\n    function isNumber(value) {\n      return Object.prototype.toString.apply(value) === '[object Number]';\n    }\n\n    function isBoolean(value) {\n      return Object.prototype.toString.apply(value) === '[object Boolean]';\n    }\n\n    function join(arr, separator) {\n      var result = '',\n          first = true,\n          index;\n\n      for (index = 0; index < arr.length; index += 1) {\n        if (first) {\n          first = false;\n        } else {\n          result += separator;\n        }\n\n        result += arr[index];\n      }\n\n      return result;\n    }\n\n    function map(arr, mapper) {\n      var result = [],\n          index = 0;\n\n      for (; index < arr.length; index += 1) {\n        result.push(mapper(arr[index]));\n      }\n\n      return result;\n    }\n\n    function filter(arr, predicate) {\n      var result = [],\n          index = 0;\n\n      for (; index < arr.length; index += 1) {\n        if (predicate(arr[index])) {\n          result.push(arr[index]);\n        }\n      }\n\n      return result;\n    }\n\n    function deepFreezeUsingObjectFreeze(object) {\n      if (typeof object !== \"object\" || object === null) {\n        return object;\n      }\n\n      Object.freeze(object);\n      var property, propertyName;\n\n      for (propertyName in object) {\n        if (object.hasOwnProperty(propertyName)) {\n          property = object[propertyName]; // be aware, arrays are 'object', too\n\n          if (typeof property === \"object\") {\n            deepFreeze(property);\n          }\n        }\n      }\n\n      return object;\n    }\n\n    function deepFreeze(object) {\n      if (typeof Object.freeze === 'function') {\n        return deepFreezeUsingObjectFreeze(object);\n      }\n\n      return object;\n    }\n\n    return {\n      isArray: isArray,\n      isString: isString,\n      isNumber: isNumber,\n      isBoolean: isBoolean,\n      join: join,\n      map: map,\n      filter: filter,\n      deepFreeze: deepFreeze\n    };\n  }();\n\n  var charHelper = function () {\n    function isAlpha(chr) {\n      return chr >= 'a' && chr <= 'z' || chr >= 'A' && chr <= 'Z';\n    }\n\n    function isDigit(chr) {\n      return chr >= '0' && chr <= '9';\n    }\n\n    function isHexDigit(chr) {\n      return isDigit(chr) || chr >= 'a' && chr <= 'f' || chr >= 'A' && chr <= 'F';\n    }\n\n    return {\n      isAlpha: isAlpha,\n      isDigit: isDigit,\n      isHexDigit: isHexDigit\n    };\n  }();\n\n  var pctEncoder = function () {\n    var utf8 = {\n      encode: function (chr) {\n        // see http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html\n        return unescape(encodeURIComponent(chr));\n      },\n      numBytes: function (firstCharCode) {\n        if (firstCharCode <= 0x7F) {\n          return 1;\n        } else if (0xC2 <= firstCharCode && firstCharCode <= 0xDF) {\n          return 2;\n        } else if (0xE0 <= firstCharCode && firstCharCode <= 0xEF) {\n          return 3;\n        } else if (0xF0 <= firstCharCode && firstCharCode <= 0xF4) {\n          return 4;\n        } // no valid first octet\n\n\n        return 0;\n      },\n      isValidFollowingCharCode: function (charCode) {\n        return 0x80 <= charCode && charCode <= 0xBF;\n      }\n    };\n    /**\r\n     * encodes a character, if needed or not.\r\n     * @param chr\r\n     * @return pct-encoded character\r\n     */\n\n    function encodeCharacter(chr) {\n      var result = '',\n          octets = utf8.encode(chr),\n          octet,\n          index;\n\n      for (index = 0; index < octets.length; index += 1) {\n        octet = octets.charCodeAt(index);\n        result += '%' + (octet < 0x10 ? '0' : '') + octet.toString(16).toUpperCase();\n      }\n\n      return result;\n    }\n    /**\r\n     * Returns, whether the given text at start is in the form 'percent hex-digit hex-digit', like '%3F'\r\n     * @param text\r\n     * @param start\r\n     * @return {boolean|*|*}\r\n     */\n\n\n    function isPercentDigitDigit(text, start) {\n      return text.charAt(start) === '%' && charHelper.isHexDigit(text.charAt(start + 1)) && charHelper.isHexDigit(text.charAt(start + 2));\n    }\n    /**\r\n     * Parses a hex number from start with length 2.\r\n     * @param text a string\r\n     * @param start the start index of the 2-digit hex number\r\n     * @return {Number}\r\n     */\n\n\n    function parseHex2(text, start) {\n      return parseInt(text.substr(start, 2), 16);\n    }\n    /**\r\n     * Returns whether or not the given char sequence is a correctly pct-encoded sequence.\r\n     * @param chr\r\n     * @return {boolean}\r\n     */\n\n\n    function isPctEncoded(chr) {\n      if (!isPercentDigitDigit(chr, 0)) {\n        return false;\n      }\n\n      var firstCharCode = parseHex2(chr, 1);\n      var numBytes = utf8.numBytes(firstCharCode);\n\n      if (numBytes === 0) {\n        return false;\n      }\n\n      for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {\n        if (!isPercentDigitDigit(chr, 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(chr, 3 * byteNumber + 1))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\r\n     * Reads as much as needed from the text, e.g. '%20' or '%C3%B6'. It does not decode!\r\n     * @param text\r\n     * @param startIndex\r\n     * @return the character or pct-string of the text at startIndex\r\n     */\n\n\n    function pctCharAt(text, startIndex) {\n      var chr = text.charAt(startIndex);\n\n      if (!isPercentDigitDigit(text, startIndex)) {\n        return chr;\n      }\n\n      var utf8CharCode = parseHex2(text, startIndex + 1);\n      var numBytes = utf8.numBytes(utf8CharCode);\n\n      if (numBytes === 0) {\n        return chr;\n      }\n\n      for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {\n        if (!isPercentDigitDigit(text, startIndex + 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(text, startIndex + 3 * byteNumber + 1))) {\n          return chr;\n        }\n      }\n\n      return text.substr(startIndex, 3 * numBytes);\n    }\n\n    return {\n      encodeCharacter: encodeCharacter,\n      isPctEncoded: isPctEncoded,\n      pctCharAt: pctCharAt\n    };\n  }();\n\n  var rfcCharHelper = function () {\n    /**\r\n     * Returns if an character is an varchar character according 2.3 of rfc 6570\r\n     * @param chr\r\n     * @return (Boolean)\r\n     */\n    function isVarchar(chr) {\n      return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '_' || pctEncoder.isPctEncoded(chr);\n    }\n    /**\r\n     * Returns if chr is an unreserved character according 1.5 of rfc 6570\r\n     * @param chr\r\n     * @return {Boolean}\r\n     */\n\n\n    function isUnreserved(chr) {\n      return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '-' || chr === '.' || chr === '_' || chr === '~';\n    }\n    /**\r\n     * Returns if chr is an reserved character according 1.5 of rfc 6570\r\n     * or the percent character mentioned in 3.2.1.\r\n     * @param chr\r\n     * @return {Boolean}\r\n     */\n\n\n    function isReserved(chr) {\n      return chr === ':' || chr === '/' || chr === '?' || chr === '#' || chr === '[' || chr === ']' || chr === '@' || chr === '!' || chr === '$' || chr === '&' || chr === '(' || chr === ')' || chr === '*' || chr === '+' || chr === ',' || chr === ';' || chr === '=' || chr === \"'\";\n    }\n\n    return {\n      isVarchar: isVarchar,\n      isUnreserved: isUnreserved,\n      isReserved: isReserved\n    };\n  }();\n  /**\r\n   * encoding of rfc 6570\r\n   */\n\n\n  var encodingHelper = function () {\n    function encode(text, passReserved) {\n      var result = '',\n          index,\n          chr = '';\n\n      if (typeof text === \"number\" || typeof text === \"boolean\") {\n        text = text.toString();\n      }\n\n      for (index = 0; index < text.length; index += chr.length) {\n        chr = text.charAt(index);\n        result += rfcCharHelper.isUnreserved(chr) || passReserved && rfcCharHelper.isReserved(chr) ? chr : pctEncoder.encodeCharacter(chr);\n      }\n\n      return result;\n    }\n\n    function encodePassReserved(text) {\n      return encode(text, true);\n    }\n\n    function encodeLiteralCharacter(literal, index) {\n      var chr = pctEncoder.pctCharAt(literal, index);\n\n      if (chr.length > 1) {\n        return chr;\n      } else {\n        return rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);\n      }\n    }\n\n    function encodeLiteral(literal) {\n      var result = '',\n          index,\n          chr = '';\n\n      for (index = 0; index < literal.length; index += chr.length) {\n        chr = pctEncoder.pctCharAt(literal, index);\n\n        if (chr.length > 1) {\n          result += chr;\n        } else {\n          result += rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);\n        }\n      }\n\n      return result;\n    }\n\n    return {\n      encode: encode,\n      encodePassReserved: encodePassReserved,\n      encodeLiteral: encodeLiteral,\n      encodeLiteralCharacter: encodeLiteralCharacter\n    };\n  }(); // the operators defined by rfc 6570\n\n\n  var operators = function () {\n    var bySymbol = {};\n\n    function create(symbol) {\n      bySymbol[symbol] = {\n        symbol: symbol,\n        separator: symbol === '?' ? '&' : symbol === '' || symbol === '+' || symbol === '#' ? ',' : symbol,\n        named: symbol === ';' || symbol === '&' || symbol === '?',\n        ifEmpty: symbol === '&' || symbol === '?' ? '=' : '',\n        first: symbol === '+' ? '' : symbol,\n        encode: symbol === '+' || symbol === '#' ? encodingHelper.encodePassReserved : encodingHelper.encode,\n        toString: function () {\n          return this.symbol;\n        }\n      };\n    }\n\n    create('');\n    create('+');\n    create('#');\n    create('.');\n    create('/');\n    create(';');\n    create('?');\n    create('&');\n    return {\n      valueOf: function (chr) {\n        if (bySymbol[chr]) {\n          return bySymbol[chr];\n        }\n\n        if (\"=,!@|\".indexOf(chr) >= 0) {\n          return null;\n        }\n\n        return bySymbol[''];\n      }\n    };\n  }();\n  /**\r\n   * Detects, whether a given element is defined in the sense of rfc 6570\r\n   * Section 2.3 of the RFC makes clear defintions:\r\n   * * undefined and null are not defined.\r\n   * * the empty string is defined\r\n   * * an array (\"list\") is defined, if it is not empty (even if all elements are not defined)\r\n   * * an object (\"map\") is defined, if it contains at least one property with defined value\r\n   * @param object\r\n   * @return {Boolean}\r\n   */\n\n\n  function isDefined(object) {\n    var propertyName;\n\n    if (object === null || object === undefined) {\n      return false;\n    }\n\n    if (objectHelper.isArray(object)) {\n      // Section 2.3: A variable defined as a list value is considered undefined if the list contains zero members\n      return object.length > 0;\n    }\n\n    if (typeof object === \"string\" || typeof object === \"number\" || typeof object === \"boolean\") {\n      // falsy values like empty strings, false or 0 are \"defined\"\n      return true;\n    } // else Object\n\n\n    for (propertyName in object) {\n      if (object.hasOwnProperty(propertyName) && isDefined(object[propertyName])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var LiteralExpression = function () {\n    function LiteralExpression(literal) {\n      this.literal = encodingHelper.encodeLiteral(literal);\n    }\n\n    LiteralExpression.prototype.expand = function () {\n      return this.literal;\n    };\n\n    LiteralExpression.prototype.toString = LiteralExpression.prototype.expand;\n    return LiteralExpression;\n  }();\n\n  var parse = function () {\n    function parseExpression(expressionText) {\n      var operator,\n          varspecs = [],\n          varspec = null,\n          varnameStart = null,\n          maxLengthStart = null,\n          index,\n          chr = '';\n\n      function closeVarname() {\n        var varname = expressionText.substring(varnameStart, index);\n\n        if (varname.length === 0) {\n          throw new UriTemplateError({\n            expressionText: expressionText,\n            message: \"a varname must be specified\",\n            position: index\n          });\n        }\n\n        varspec = {\n          varname: varname,\n          exploded: false,\n          maxLength: null\n        };\n        varnameStart = null;\n      }\n\n      function closeMaxLength() {\n        if (maxLengthStart === index) {\n          throw new UriTemplateError({\n            expressionText: expressionText,\n            message: \"after a ':' you have to specify the length\",\n            position: index\n          });\n        }\n\n        varspec.maxLength = parseInt(expressionText.substring(maxLengthStart, index), 10);\n        maxLengthStart = null;\n      }\n\n      operator = function (operatorText) {\n        var op = operators.valueOf(operatorText);\n\n        if (op === null) {\n          throw new UriTemplateError({\n            expressionText: expressionText,\n            message: \"illegal use of reserved operator\",\n            position: index,\n            operator: operatorText\n          });\n        }\n\n        return op;\n      }(expressionText.charAt(0));\n\n      index = operator.symbol.length;\n      varnameStart = index;\n\n      for (; index < expressionText.length; index += chr.length) {\n        chr = pctEncoder.pctCharAt(expressionText, index);\n\n        if (varnameStart !== null) {\n          // the spec says: varname =  varchar *( [\".\"] varchar )\n          // so a dot is allowed except for the first char\n          if (chr === '.') {\n            if (varnameStart === index) {\n              throw new UriTemplateError({\n                expressionText: expressionText,\n                message: \"a varname MUST NOT start with a dot\",\n                position: index\n              });\n            }\n\n            continue;\n          }\n\n          if (rfcCharHelper.isVarchar(chr)) {\n            continue;\n          }\n\n          closeVarname();\n        }\n\n        if (maxLengthStart !== null) {\n          if (index === maxLengthStart && chr === '0') {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"A :prefix must not start with digit 0\",\n              position: index\n            });\n          }\n\n          if (charHelper.isDigit(chr)) {\n            if (index - maxLengthStart >= 4) {\n              throw new UriTemplateError({\n                expressionText: expressionText,\n                message: \"A :prefix must have max 4 digits\",\n                position: index\n              });\n            }\n\n            continue;\n          }\n\n          closeMaxLength();\n        }\n\n        if (chr === ':') {\n          if (varspec.maxLength !== null) {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"only one :maxLength is allowed per varspec\",\n              position: index\n            });\n          }\n\n          if (varspec.exploded) {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"an exploeded varspec MUST NOT be varspeced\",\n              position: index\n            });\n          }\n\n          maxLengthStart = index + 1;\n          continue;\n        }\n\n        if (chr === '*') {\n          if (varspec === null) {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"exploded without varspec\",\n              position: index\n            });\n          }\n\n          if (varspec.exploded) {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"exploded twice\",\n              position: index\n            });\n          }\n\n          if (varspec.maxLength) {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"an explode (*) MUST NOT follow to a prefix\",\n              position: index\n            });\n          }\n\n          varspec.exploded = true;\n          continue;\n        } // the only legal character now is the comma\n\n\n        if (chr === ',') {\n          varspecs.push(varspec);\n          varspec = null;\n          varnameStart = index + 1;\n          continue;\n        }\n\n        throw new UriTemplateError({\n          expressionText: expressionText,\n          message: \"illegal character\",\n          character: chr,\n          position: index\n        });\n      } // for chr\n\n\n      if (varnameStart !== null) {\n        closeVarname();\n      }\n\n      if (maxLengthStart !== null) {\n        closeMaxLength();\n      }\n\n      varspecs.push(varspec);\n      return new VariableExpression(expressionText, operator, varspecs);\n    }\n\n    function parse(uriTemplateText) {\n      // assert filled string\n      var index,\n          chr,\n          expressions = [],\n          braceOpenIndex = null,\n          literalStart = 0;\n\n      for (index = 0; index < uriTemplateText.length; index += 1) {\n        chr = uriTemplateText.charAt(index);\n\n        if (literalStart !== null) {\n          if (chr === '}') {\n            throw new UriTemplateError({\n              templateText: uriTemplateText,\n              message: \"unopened brace closed\",\n              position: index\n            });\n          }\n\n          if (chr === '{') {\n            if (literalStart < index) {\n              expressions.push(new LiteralExpression(uriTemplateText.substring(literalStart, index)));\n            }\n\n            literalStart = null;\n            braceOpenIndex = index;\n          }\n\n          continue;\n        }\n\n        if (braceOpenIndex !== null) {\n          // here just { is forbidden\n          if (chr === '{') {\n            throw new UriTemplateError({\n              templateText: uriTemplateText,\n              message: \"brace already opened\",\n              position: index\n            });\n          }\n\n          if (chr === '}') {\n            if (braceOpenIndex + 1 === index) {\n              throw new UriTemplateError({\n                templateText: uriTemplateText,\n                message: \"empty braces\",\n                position: braceOpenIndex\n              });\n            }\n\n            try {\n              expressions.push(parseExpression(uriTemplateText.substring(braceOpenIndex + 1, index)));\n            } catch (error) {\n              if (error.prototype === UriTemplateError.prototype) {\n                throw new UriTemplateError({\n                  templateText: uriTemplateText,\n                  message: error.options.message,\n                  position: braceOpenIndex + error.options.position,\n                  details: error.options\n                });\n              }\n\n              throw error;\n            }\n\n            braceOpenIndex = null;\n            literalStart = index + 1;\n          }\n\n          continue;\n        }\n\n        throw new Error('reached unreachable code');\n      }\n\n      if (braceOpenIndex !== null) {\n        throw new UriTemplateError({\n          templateText: uriTemplateText,\n          message: \"unclosed brace\",\n          position: braceOpenIndex\n        });\n      }\n\n      if (literalStart < uriTemplateText.length) {\n        expressions.push(new LiteralExpression(uriTemplateText.substr(literalStart)));\n      }\n\n      return new UriTemplate(uriTemplateText, expressions);\n    }\n\n    return parse;\n  }();\n\n  var VariableExpression = function () {\n    // helper function if JSON is not available\n    function prettyPrint(value) {\n      return JSON && JSON.stringify ? JSON.stringify(value) : value;\n    }\n\n    function isEmpty(value) {\n      if (!isDefined(value)) {\n        return true;\n      }\n\n      if (objectHelper.isString(value)) {\n        return value === '';\n      }\n\n      if (objectHelper.isNumber(value) || objectHelper.isBoolean(value)) {\n        return false;\n      }\n\n      if (objectHelper.isArray(value)) {\n        return value.length === 0;\n      }\n\n      for (var propertyName in value) {\n        if (value.hasOwnProperty(propertyName)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    function propertyArray(object) {\n      var result = [],\n          propertyName;\n\n      for (propertyName in object) {\n        if (object.hasOwnProperty(propertyName)) {\n          result.push({\n            name: propertyName,\n            value: object[propertyName]\n          });\n        }\n      }\n\n      return result;\n    }\n\n    function VariableExpression(templateText, operator, varspecs) {\n      this.templateText = templateText;\n      this.operator = operator;\n      this.varspecs = varspecs;\n    }\n\n    VariableExpression.prototype.toString = function () {\n      return this.templateText;\n    };\n\n    function expandSimpleValue(varspec, operator, value) {\n      var result = '';\n      value = value.toString();\n\n      if (operator.named) {\n        result += encodingHelper.encodeLiteral(varspec.varname);\n\n        if (value === '') {\n          result += operator.ifEmpty;\n          return result;\n        }\n\n        result += '=';\n      }\n\n      if (varspec.maxLength !== null) {\n        value = value.substr(0, varspec.maxLength);\n      }\n\n      result += operator.encode(value);\n      return result;\n    }\n\n    function valueDefined(nameValue) {\n      return isDefined(nameValue.value);\n    }\n\n    function expandNotExploded(varspec, operator, value) {\n      var arr = [],\n          result = '';\n\n      if (operator.named) {\n        result += encodingHelper.encodeLiteral(varspec.varname);\n\n        if (isEmpty(value)) {\n          result += operator.ifEmpty;\n          return result;\n        }\n\n        result += '=';\n      }\n\n      if (objectHelper.isArray(value)) {\n        arr = value;\n        arr = objectHelper.filter(arr, isDefined);\n        arr = objectHelper.map(arr, operator.encode);\n        result += objectHelper.join(arr, ',');\n      } else {\n        arr = propertyArray(value);\n        arr = objectHelper.filter(arr, valueDefined);\n        arr = objectHelper.map(arr, function (nameValue) {\n          return operator.encode(nameValue.name) + ',' + operator.encode(nameValue.value);\n        });\n        result += objectHelper.join(arr, ',');\n      }\n\n      return result;\n    }\n\n    function expandExplodedNamed(varspec, operator, value) {\n      var isArray = objectHelper.isArray(value),\n          arr = [];\n\n      if (isArray) {\n        arr = value;\n        arr = objectHelper.filter(arr, isDefined);\n        arr = objectHelper.map(arr, function (listElement) {\n          var tmp = encodingHelper.encodeLiteral(varspec.varname);\n\n          if (isEmpty(listElement)) {\n            tmp += operator.ifEmpty;\n          } else {\n            tmp += '=' + operator.encode(listElement);\n          }\n\n          return tmp;\n        });\n      } else {\n        arr = propertyArray(value);\n        arr = objectHelper.filter(arr, valueDefined);\n        arr = objectHelper.map(arr, function (nameValue) {\n          var tmp = encodingHelper.encodeLiteral(nameValue.name);\n\n          if (isEmpty(nameValue.value)) {\n            tmp += operator.ifEmpty;\n          } else {\n            tmp += '=' + operator.encode(nameValue.value);\n          }\n\n          return tmp;\n        });\n      }\n\n      return objectHelper.join(arr, operator.separator);\n    }\n\n    function expandExplodedUnnamed(operator, value) {\n      var arr = [],\n          result = '';\n\n      if (objectHelper.isArray(value)) {\n        arr = value;\n        arr = objectHelper.filter(arr, isDefined);\n        arr = objectHelper.map(arr, operator.encode);\n        result += objectHelper.join(arr, operator.separator);\n      } else {\n        arr = propertyArray(value);\n        arr = objectHelper.filter(arr, function (nameValue) {\n          return isDefined(nameValue.value);\n        });\n        arr = objectHelper.map(arr, function (nameValue) {\n          return operator.encode(nameValue.name) + '=' + operator.encode(nameValue.value);\n        });\n        result += objectHelper.join(arr, operator.separator);\n      }\n\n      return result;\n    }\n\n    VariableExpression.prototype.expand = function (variables) {\n      var expanded = [],\n          index,\n          varspec,\n          value,\n          valueIsArr,\n          oneExploded = false,\n          operator = this.operator; // expand each varspec and join with operator's separator\n\n      for (index = 0; index < this.varspecs.length; index += 1) {\n        varspec = this.varspecs[index];\n        value = variables[varspec.varname]; // if (!isDefined(value)) {\n        // if (variables.hasOwnProperty(varspec.name)) {\n\n        if (value === null || value === undefined) {\n          continue;\n        }\n\n        if (varspec.exploded) {\n          oneExploded = true;\n        }\n\n        valueIsArr = objectHelper.isArray(value);\n\n        if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n          expanded.push(expandSimpleValue(varspec, operator, value));\n        } else if (varspec.maxLength && isDefined(value)) {\n          // 2.4.1 of the spec says: \"Prefix modifiers are not applicable to variables that have composite values.\"\n          throw new Error('Prefix modifiers are not applicable to variables that have composite values. You tried to expand ' + this + \" with \" + prettyPrint(value));\n        } else if (!varspec.exploded) {\n          if (operator.named || !isEmpty(value)) {\n            expanded.push(expandNotExploded(varspec, operator, value));\n          }\n        } else if (isDefined(value)) {\n          if (operator.named) {\n            expanded.push(expandExplodedNamed(varspec, operator, value));\n          } else {\n            expanded.push(expandExplodedUnnamed(operator, value));\n          }\n        }\n      }\n\n      if (expanded.length === 0) {\n        return \"\";\n      } else {\n        return operator.first + objectHelper.join(expanded, operator.separator);\n      }\n    };\n\n    return VariableExpression;\n  }();\n\n  var UriTemplate = function () {\n    function UriTemplate(templateText, expressions) {\n      this.templateText = templateText;\n      this.expressions = expressions;\n      objectHelper.deepFreeze(this);\n    }\n\n    UriTemplate.prototype.toString = function () {\n      return this.templateText;\n    };\n\n    UriTemplate.prototype.expand = function (variables) {\n      // this.expressions.map(function (expression) {return expression.expand(variables);}).join('');\n      var index,\n          result = '';\n\n      for (index = 0; index < this.expressions.length; index += 1) {\n        result += this.expressions[index].expand(variables);\n      }\n\n      return result;\n    };\n\n    UriTemplate.parse = parse;\n    UriTemplate.UriTemplateError = UriTemplateError;\n    return UriTemplate;\n  }();\n\n  exportCallback(UriTemplate);\n})(function (UriTemplate) {\n  \"use strict\"; // export UriTemplate, when module is present, or pass it to window or global\n\n  if (typeof module !== \"undefined\") {\n    module.exports = UriTemplate;\n  } else if (typeof define === \"function\") {\n    define([], function () {\n      return UriTemplate;\n    });\n  } else if (typeof window !== \"undefined\") {\n    window.UriTemplate = UriTemplate;\n  } else {\n    global.UriTemplate = UriTemplate;\n  }\n});","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/uritemplate/bin/uritemplate.js"],"names":["exportCallback","UriTemplateError","options","prototype","toString","JSON","stringify","objectHelper","isArray","value","Object","apply","isString","isNumber","isBoolean","join","arr","separator","result","first","index","length","map","mapper","push","filter","predicate","deepFreezeUsingObjectFreeze","object","freeze","property","propertyName","hasOwnProperty","deepFreeze","charHelper","isAlpha","chr","isDigit","isHexDigit","pctEncoder","utf8","encode","unescape","encodeURIComponent","numBytes","firstCharCode","isValidFollowingCharCode","charCode","encodeCharacter","octets","octet","charCodeAt","toUpperCase","isPercentDigitDigit","text","start","charAt","parseHex2","parseInt","substr","isPctEncoded","byteNumber","pctCharAt","startIndex","utf8CharCode","rfcCharHelper","isVarchar","isUnreserved","isReserved","encodingHelper","passReserved","encodePassReserved","encodeLiteralCharacter","literal","encodeLiteral","operators","bySymbol","create","symbol","named","ifEmpty","valueOf","indexOf","isDefined","undefined","LiteralExpression","expand","parse","parseExpression","expressionText","operator","varspecs","varspec","varnameStart","maxLengthStart","closeVarname","varname","substring","message","position","exploded","maxLength","closeMaxLength","operatorText","op","character","VariableExpression","uriTemplateText","expressions","braceOpenIndex","literalStart","templateText","error","details","Error","UriTemplate","prettyPrint","isEmpty","propertyArray","name","expandSimpleValue","valueDefined","nameValue","expandNotExploded","expandExplodedNamed","listElement","tmp","expandExplodedUnnamed","variables","expanded","valueIsArr","oneExploded","module","exports","define","window","global"],"mappings":"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","sourcesContent":["/*global unescape, module, define, window, global*/\r\n\r\n/*\r\n UriTemplate Copyright (c) 2012-2013 Franz Antesberger. All Rights Reserved.\r\n Available via the MIT license.\r\n*/\r\n\r\n(function (exportCallback) {\r\n    \"use strict\";\r\n\r\nvar UriTemplateError = (function () {\r\n\r\n    function UriTemplateError (options) {\r\n        this.options = options;\r\n    }\r\n\r\n    UriTemplateError.prototype.toString = function () {\r\n        if (JSON && JSON.stringify) {\r\n            return JSON.stringify(this.options);\r\n        }\r\n        else {\r\n            return this.options;\r\n        }\r\n    };\r\n\r\n    return UriTemplateError;\r\n}());\r\n\r\nvar objectHelper = (function () {\r\n    function isArray (value) {\r\n        return Object.prototype.toString.apply(value) === '[object Array]';\r\n    }\r\n\r\n    function isString (value) {\r\n        return Object.prototype.toString.apply(value) === '[object String]';\r\n    }\r\n    \r\n    function isNumber (value) {\r\n        return Object.prototype.toString.apply(value) === '[object Number]';\r\n    }\r\n    \r\n    function isBoolean (value) {\r\n        return Object.prototype.toString.apply(value) === '[object Boolean]';\r\n    }\r\n    \r\n    function join (arr, separator) {\r\n        var\r\n            result = '',\r\n            first = true,\r\n            index;\r\n        for (index = 0; index < arr.length; index += 1) {\r\n            if (first) {\r\n                first = false;\r\n            }\r\n            else {\r\n                result += separator;\r\n            }\r\n            result += arr[index];\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function map (arr, mapper) {\r\n        var\r\n            result = [],\r\n            index = 0;\r\n        for (; index < arr.length; index += 1) {\r\n            result.push(mapper(arr[index]));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function filter (arr, predicate) {\r\n        var\r\n            result = [],\r\n            index = 0;\r\n        for (; index < arr.length; index += 1) {\r\n            if (predicate(arr[index])) {\r\n                result.push(arr[index]);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function deepFreezeUsingObjectFreeze (object) {\r\n        if (typeof object !== \"object\" || object === null) {\r\n            return object;\r\n        }\r\n        Object.freeze(object);\r\n        var property, propertyName;\r\n        for (propertyName in object) {\r\n            if (object.hasOwnProperty(propertyName)) {\r\n                property = object[propertyName];\r\n                // be aware, arrays are 'object', too\r\n                if (typeof property === \"object\") {\r\n                    deepFreeze(property);\r\n                }\r\n            }\r\n        }\r\n        return object;\r\n    }\r\n\r\n    function deepFreeze (object) {\r\n        if (typeof Object.freeze === 'function') {\r\n            return deepFreezeUsingObjectFreeze(object);\r\n        }\r\n        return object;\r\n    }\r\n\r\n\r\n    return {\r\n        isArray: isArray,\r\n        isString: isString,\r\n        isNumber: isNumber,\r\n        isBoolean: isBoolean,\r\n        join: join,\r\n        map: map,\r\n        filter: filter,\r\n        deepFreeze: deepFreeze\r\n    };\r\n}());\r\n\r\nvar charHelper = (function () {\r\n\r\n    function isAlpha (chr) {\r\n        return (chr >= 'a' && chr <= 'z') || ((chr >= 'A' && chr <= 'Z'));\r\n    }\r\n\r\n    function isDigit (chr) {\r\n        return chr >= '0' && chr <= '9';\r\n    }\r\n\r\n    function isHexDigit (chr) {\r\n        return isDigit(chr) || (chr >= 'a' && chr <= 'f') || (chr >= 'A' && chr <= 'F');\r\n    }\r\n\r\n    return {\r\n        isAlpha: isAlpha,\r\n        isDigit: isDigit,\r\n        isHexDigit: isHexDigit\r\n    };\r\n}());\r\n\r\nvar pctEncoder = (function () {\r\n    var utf8 = {\r\n        encode: function (chr) {\r\n            // see http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html\r\n            return unescape(encodeURIComponent(chr));\r\n        },\r\n        numBytes: function (firstCharCode) {\r\n            if (firstCharCode <= 0x7F) {\r\n                return 1;\r\n            }\r\n            else if (0xC2 <= firstCharCode && firstCharCode <= 0xDF) {\r\n                return 2;\r\n            }\r\n            else if (0xE0 <= firstCharCode && firstCharCode <= 0xEF) {\r\n                return 3;\r\n            }\r\n            else if (0xF0 <= firstCharCode && firstCharCode <= 0xF4) {\r\n                return 4;\r\n            }\r\n            // no valid first octet\r\n            return 0;\r\n        },\r\n        isValidFollowingCharCode: function (charCode) {\r\n            return 0x80 <= charCode && charCode <= 0xBF;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * encodes a character, if needed or not.\r\n     * @param chr\r\n     * @return pct-encoded character\r\n     */\r\n    function encodeCharacter (chr) {\r\n        var\r\n            result = '',\r\n            octets = utf8.encode(chr),\r\n            octet,\r\n            index;\r\n        for (index = 0; index < octets.length; index += 1) {\r\n            octet = octets.charCodeAt(index);\r\n            result += '%' + (octet < 0x10 ? '0' : '') + octet.toString(16).toUpperCase();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns, whether the given text at start is in the form 'percent hex-digit hex-digit', like '%3F'\r\n     * @param text\r\n     * @param start\r\n     * @return {boolean|*|*}\r\n     */\r\n    function isPercentDigitDigit (text, start) {\r\n        return text.charAt(start) === '%' && charHelper.isHexDigit(text.charAt(start + 1)) && charHelper.isHexDigit(text.charAt(start + 2));\r\n    }\r\n\r\n    /**\r\n     * Parses a hex number from start with length 2.\r\n     * @param text a string\r\n     * @param start the start index of the 2-digit hex number\r\n     * @return {Number}\r\n     */\r\n    function parseHex2 (text, start) {\r\n        return parseInt(text.substr(start, 2), 16);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the given char sequence is a correctly pct-encoded sequence.\r\n     * @param chr\r\n     * @return {boolean}\r\n     */\r\n    function isPctEncoded (chr) {\r\n        if (!isPercentDigitDigit(chr, 0)) {\r\n            return false;\r\n        }\r\n        var firstCharCode = parseHex2(chr, 1);\r\n        var numBytes = utf8.numBytes(firstCharCode);\r\n        if (numBytes === 0) {\r\n            return false;\r\n        }\r\n        for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {\r\n            if (!isPercentDigitDigit(chr, 3*byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(chr, 3*byteNumber + 1))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Reads as much as needed from the text, e.g. '%20' or '%C3%B6'. It does not decode!\r\n     * @param text\r\n     * @param startIndex\r\n     * @return the character or pct-string of the text at startIndex\r\n     */\r\n    function pctCharAt(text, startIndex) {\r\n        var chr = text.charAt(startIndex);\r\n        if (!isPercentDigitDigit(text, startIndex)) {\r\n            return chr;\r\n        }\r\n        var utf8CharCode = parseHex2(text, startIndex + 1);\r\n        var numBytes = utf8.numBytes(utf8CharCode);\r\n        if (numBytes === 0) {\r\n            return chr;\r\n        }\r\n        for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {\r\n            if (!isPercentDigitDigit(text, startIndex + 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(text, startIndex + 3 * byteNumber + 1))) {\r\n                return chr;\r\n            }\r\n        }\r\n        return text.substr(startIndex, 3 * numBytes);\r\n    }\r\n\r\n    return {\r\n        encodeCharacter: encodeCharacter,\r\n        isPctEncoded: isPctEncoded,\r\n        pctCharAt: pctCharAt\r\n    };\r\n}());\r\n\r\nvar rfcCharHelper = (function () {\r\n\r\n    /**\r\n     * Returns if an character is an varchar character according 2.3 of rfc 6570\r\n     * @param chr\r\n     * @return (Boolean)\r\n     */\r\n    function isVarchar (chr) {\r\n        return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '_' || pctEncoder.isPctEncoded(chr);\r\n    }\r\n\r\n    /**\r\n     * Returns if chr is an unreserved character according 1.5 of rfc 6570\r\n     * @param chr\r\n     * @return {Boolean}\r\n     */\r\n    function isUnreserved (chr) {\r\n        return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '-' || chr === '.' || chr === '_' || chr === '~';\r\n    }\r\n\r\n    /**\r\n     * Returns if chr is an reserved character according 1.5 of rfc 6570\r\n     * or the percent character mentioned in 3.2.1.\r\n     * @param chr\r\n     * @return {Boolean}\r\n     */\r\n    function isReserved (chr) {\r\n        return chr === ':' || chr === '/' || chr === '?' || chr === '#' || chr === '[' || chr === ']' || chr === '@' || chr === '!' || chr === '$' || chr === '&' || chr === '(' ||\r\n            chr === ')' || chr === '*' || chr === '+' || chr === ',' || chr === ';' || chr === '=' || chr === \"'\";\r\n    }\r\n\r\n    return {\r\n        isVarchar: isVarchar,\r\n        isUnreserved: isUnreserved,\r\n        isReserved: isReserved\r\n    };\r\n\r\n}());\r\n\r\n/**\r\n * encoding of rfc 6570\r\n */\r\nvar encodingHelper = (function () {\r\n\r\n    function encode (text, passReserved) {\r\n        var\r\n            result = '',\r\n            index,\r\n            chr = '';\r\n        if (typeof text === \"number\" || typeof text === \"boolean\") {\r\n            text = text.toString();\r\n        }\r\n        for (index = 0; index < text.length; index += chr.length) {\r\n            chr = text.charAt(index);\r\n            result += rfcCharHelper.isUnreserved(chr) || (passReserved && rfcCharHelper.isReserved(chr)) ? chr : pctEncoder.encodeCharacter(chr);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function encodePassReserved (text) {\r\n        return encode(text, true);\r\n    }\r\n\r\n    function encodeLiteralCharacter (literal, index) {\r\n        var chr = pctEncoder.pctCharAt(literal, index);\r\n        if (chr.length > 1) {\r\n            return chr;\r\n        }\r\n        else {\r\n            return rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);\r\n        }\r\n    }\r\n\r\n    function encodeLiteral (literal) {\r\n        var\r\n            result = '',\r\n            index,\r\n            chr = '';\r\n        for (index = 0; index < literal.length; index += chr.length) {\r\n            chr = pctEncoder.pctCharAt(literal, index);\r\n            if (chr.length > 1) {\r\n                result += chr;\r\n            }\r\n            else {\r\n                result += rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    return {\r\n        encode: encode,\r\n        encodePassReserved: encodePassReserved,\r\n        encodeLiteral: encodeLiteral,\r\n        encodeLiteralCharacter: encodeLiteralCharacter\r\n    };\r\n\r\n}());\r\n\r\n\r\n// the operators defined by rfc 6570\r\nvar operators = (function () {\r\n\r\n    var\r\n        bySymbol = {};\r\n\r\n    function create (symbol) {\r\n        bySymbol[symbol] = {\r\n            symbol: symbol,\r\n            separator: (symbol === '?') ? '&' : (symbol === '' || symbol === '+' || symbol === '#') ? ',' : symbol,\r\n            named: symbol === ';' || symbol === '&' || symbol === '?',\r\n            ifEmpty: (symbol === '&' || symbol === '?') ? '=' : '',\r\n            first: (symbol === '+' ) ? '' : symbol,\r\n            encode: (symbol === '+' || symbol === '#') ? encodingHelper.encodePassReserved : encodingHelper.encode,\r\n            toString: function () {\r\n                return this.symbol;\r\n            }\r\n        };\r\n    }\r\n\r\n    create('');\r\n    create('+');\r\n    create('#');\r\n    create('.');\r\n    create('/');\r\n    create(';');\r\n    create('?');\r\n    create('&');\r\n    return {\r\n        valueOf: function (chr) {\r\n            if (bySymbol[chr]) {\r\n                return bySymbol[chr];\r\n            }\r\n            if (\"=,!@|\".indexOf(chr) >= 0) {\r\n                return null;\r\n            }\r\n            return bySymbol[''];\r\n        }\r\n    };\r\n}());\r\n\r\n\r\n/**\r\n * Detects, whether a given element is defined in the sense of rfc 6570\r\n * Section 2.3 of the RFC makes clear defintions:\r\n * * undefined and null are not defined.\r\n * * the empty string is defined\r\n * * an array (\"list\") is defined, if it is not empty (even if all elements are not defined)\r\n * * an object (\"map\") is defined, if it contains at least one property with defined value\r\n * @param object\r\n * @return {Boolean}\r\n */\r\nfunction isDefined (object) {\r\n    var\r\n        propertyName;\r\n    if (object === null || object === undefined) {\r\n        return false;\r\n    }\r\n    if (objectHelper.isArray(object)) {\r\n        // Section 2.3: A variable defined as a list value is considered undefined if the list contains zero members\r\n        return object.length > 0;\r\n    }\r\n    if (typeof object === \"string\" || typeof object === \"number\" || typeof object === \"boolean\") {\r\n        // falsy values like empty strings, false or 0 are \"defined\"\r\n        return true;\r\n    }\r\n    // else Object\r\n    for (propertyName in object) {\r\n        if (object.hasOwnProperty(propertyName) && isDefined(object[propertyName])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nvar LiteralExpression = (function () {\r\n    function LiteralExpression (literal) {\r\n        this.literal = encodingHelper.encodeLiteral(literal);\r\n    }\r\n\r\n    LiteralExpression.prototype.expand = function () {\r\n        return this.literal;\r\n    };\r\n\r\n    LiteralExpression.prototype.toString = LiteralExpression.prototype.expand;\r\n\r\n    return LiteralExpression;\r\n}());\r\n\r\nvar parse = (function () {\r\n\r\n    function parseExpression (expressionText) {\r\n        var\r\n            operator,\r\n            varspecs = [],\r\n            varspec = null,\r\n            varnameStart = null,\r\n            maxLengthStart = null,\r\n            index,\r\n            chr = '';\r\n\r\n        function closeVarname () {\r\n            var varname = expressionText.substring(varnameStart, index);\r\n            if (varname.length === 0) {\r\n                throw new UriTemplateError({expressionText: expressionText, message: \"a varname must be specified\", position: index});\r\n            }\r\n            varspec = {varname: varname, exploded: false, maxLength: null};\r\n            varnameStart = null;\r\n        }\r\n\r\n        function closeMaxLength () {\r\n            if (maxLengthStart === index) {\r\n                throw new UriTemplateError({expressionText: expressionText, message: \"after a ':' you have to specify the length\", position: index});\r\n            }\r\n            varspec.maxLength = parseInt(expressionText.substring(maxLengthStart, index), 10);\r\n            maxLengthStart = null;\r\n        }\r\n\r\n        operator = (function (operatorText) {\r\n            var op = operators.valueOf(operatorText);\r\n            if (op === null) {\r\n                throw new UriTemplateError({expressionText: expressionText, message: \"illegal use of reserved operator\", position: index, operator: operatorText});\r\n            }\r\n            return op;\r\n        }(expressionText.charAt(0)));\r\n        index = operator.symbol.length;\r\n\r\n        varnameStart = index;\r\n\r\n        for (; index < expressionText.length; index += chr.length) {\r\n            chr = pctEncoder.pctCharAt(expressionText, index);\r\n\r\n            if (varnameStart !== null) {\r\n                // the spec says: varname =  varchar *( [\".\"] varchar )\r\n                // so a dot is allowed except for the first char\r\n                if (chr === '.') {\r\n                    if (varnameStart === index) {\r\n                        throw new UriTemplateError({expressionText: expressionText, message: \"a varname MUST NOT start with a dot\", position: index});\r\n                    }\r\n                    continue;\r\n                }\r\n                if (rfcCharHelper.isVarchar(chr)) {\r\n                    continue;\r\n                }\r\n                closeVarname();\r\n            }\r\n            if (maxLengthStart !== null) {\r\n                if (index === maxLengthStart && chr === '0') {\r\n                    throw new UriTemplateError({expressionText: expressionText, message: \"A :prefix must not start with digit 0\", position: index});\r\n                }\r\n                if (charHelper.isDigit(chr)) {\r\n                    if (index - maxLengthStart >= 4) {\r\n                        throw new UriTemplateError({expressionText: expressionText, message: \"A :prefix must have max 4 digits\", position: index});\r\n                    }\r\n                    continue;\r\n                }\r\n                closeMaxLength();\r\n            }\r\n            if (chr === ':') {\r\n                if (varspec.maxLength !== null) {\r\n                    throw new UriTemplateError({expressionText: expressionText, message: \"only one :maxLength is allowed per varspec\", position: index});\r\n                }\r\n                if (varspec.exploded) {\r\n                    throw new UriTemplateError({expressionText: expressionText, message: \"an exploeded varspec MUST NOT be varspeced\", position: index});\r\n                }\r\n                maxLengthStart = index + 1;\r\n                continue;\r\n            }\r\n            if (chr === '*') {\r\n                if (varspec === null) {\r\n                    throw new UriTemplateError({expressionText: expressionText, message: \"exploded without varspec\", position: index});\r\n                }\r\n                if (varspec.exploded) {\r\n                    throw new UriTemplateError({expressionText: expressionText, message: \"exploded twice\", position: index});\r\n                }\r\n                if (varspec.maxLength) {\r\n                    throw new UriTemplateError({expressionText: expressionText, message: \"an explode (*) MUST NOT follow to a prefix\", position: index});\r\n                }\r\n                varspec.exploded = true;\r\n                continue;\r\n            }\r\n            // the only legal character now is the comma\r\n            if (chr === ',') {\r\n                varspecs.push(varspec);\r\n                varspec = null;\r\n                varnameStart = index + 1;\r\n                continue;\r\n            }\r\n            throw new UriTemplateError({expressionText: expressionText, message: \"illegal character\", character: chr, position: index});\r\n        } // for chr\r\n        if (varnameStart !== null) {\r\n            closeVarname();\r\n        }\r\n        if (maxLengthStart !== null) {\r\n            closeMaxLength();\r\n        }\r\n        varspecs.push(varspec);\r\n        return new VariableExpression(expressionText, operator, varspecs);\r\n    }\r\n\r\n    function parse (uriTemplateText) {\r\n        // assert filled string\r\n        var\r\n            index,\r\n            chr,\r\n            expressions = [],\r\n            braceOpenIndex = null,\r\n            literalStart = 0;\r\n        for (index = 0; index < uriTemplateText.length; index += 1) {\r\n            chr = uriTemplateText.charAt(index);\r\n            if (literalStart !== null) {\r\n                if (chr === '}') {\r\n                    throw new UriTemplateError({templateText: uriTemplateText, message: \"unopened brace closed\", position: index});\r\n                }\r\n                if (chr === '{') {\r\n                    if (literalStart < index) {\r\n                        expressions.push(new LiteralExpression(uriTemplateText.substring(literalStart, index)));\r\n                    }\r\n                    literalStart = null;\r\n                    braceOpenIndex = index;\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (braceOpenIndex !== null) {\r\n                // here just { is forbidden\r\n                if (chr === '{') {\r\n                    throw new UriTemplateError({templateText: uriTemplateText, message: \"brace already opened\", position: index});\r\n                }\r\n                if (chr === '}') {\r\n                    if (braceOpenIndex + 1 === index) {\r\n                        throw new UriTemplateError({templateText: uriTemplateText, message: \"empty braces\", position: braceOpenIndex});\r\n                    }\r\n                    try {\r\n                        expressions.push(parseExpression(uriTemplateText.substring(braceOpenIndex + 1, index)));\r\n                    }\r\n                    catch (error) {\r\n                        if (error.prototype === UriTemplateError.prototype) {\r\n                            throw new UriTemplateError({templateText: uriTemplateText, message: error.options.message, position: braceOpenIndex + error.options.position, details: error.options});\r\n                        }\r\n                        throw error;\r\n                    }\r\n                    braceOpenIndex = null;\r\n                    literalStart = index + 1;\r\n                }\r\n                continue;\r\n            }\r\n            throw new Error('reached unreachable code');\r\n        }\r\n        if (braceOpenIndex !== null) {\r\n            throw new UriTemplateError({templateText: uriTemplateText, message: \"unclosed brace\", position: braceOpenIndex});\r\n        }\r\n        if (literalStart < uriTemplateText.length) {\r\n            expressions.push(new LiteralExpression(uriTemplateText.substr(literalStart)));\r\n        }\r\n        return new UriTemplate(uriTemplateText, expressions);\r\n    }\r\n\r\n    return parse;\r\n}());\r\n\r\nvar VariableExpression = (function () {\r\n    // helper function if JSON is not available\r\n    function prettyPrint (value) {\r\n        return (JSON && JSON.stringify) ? JSON.stringify(value) : value;\r\n    }\r\n\r\n    function isEmpty (value) {\r\n        if (!isDefined(value)) {\r\n            return true;\r\n        }\r\n        if (objectHelper.isString(value)) {\r\n            return value === '';\r\n        }\r\n        if (objectHelper.isNumber(value) || objectHelper.isBoolean(value)) {\r\n            return false;\r\n        }\r\n        if (objectHelper.isArray(value)) {\r\n            return value.length === 0;\r\n        }\r\n        for (var propertyName in value) {\r\n            if (value.hasOwnProperty(propertyName)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function propertyArray (object) {\r\n        var\r\n            result = [],\r\n            propertyName;\r\n        for (propertyName in object) {\r\n            if (object.hasOwnProperty(propertyName)) {\r\n                result.push({name: propertyName, value: object[propertyName]});\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function VariableExpression (templateText, operator, varspecs) {\r\n        this.templateText = templateText;\r\n        this.operator = operator;\r\n        this.varspecs = varspecs;\r\n    }\r\n\r\n    VariableExpression.prototype.toString = function () {\r\n        return this.templateText;\r\n    };\r\n\r\n    function expandSimpleValue(varspec, operator, value) {\r\n        var result = '';\r\n        value = value.toString();\r\n        if (operator.named) {\r\n            result += encodingHelper.encodeLiteral(varspec.varname);\r\n            if (value === '') {\r\n                result += operator.ifEmpty;\r\n                return result;\r\n            }\r\n            result += '=';\r\n        }\r\n        if (varspec.maxLength !== null) {\r\n            value = value.substr(0, varspec.maxLength);\r\n        }\r\n        result += operator.encode(value);\r\n        return result;\r\n    }\r\n\r\n    function valueDefined (nameValue) {\r\n        return isDefined(nameValue.value);\r\n    }\r\n\r\n    function expandNotExploded(varspec, operator, value) {\r\n        var\r\n            arr = [],\r\n            result = '';\r\n        if (operator.named) {\r\n            result += encodingHelper.encodeLiteral(varspec.varname);\r\n            if (isEmpty(value)) {\r\n                result += operator.ifEmpty;\r\n                return result;\r\n            }\r\n            result += '=';\r\n        }\r\n        if (objectHelper.isArray(value)) {\r\n            arr = value;\r\n            arr = objectHelper.filter(arr, isDefined);\r\n            arr = objectHelper.map(arr, operator.encode);\r\n            result += objectHelper.join(arr, ',');\r\n        }\r\n        else {\r\n            arr = propertyArray(value);\r\n            arr = objectHelper.filter(arr, valueDefined);\r\n            arr = objectHelper.map(arr, function (nameValue) {\r\n                return operator.encode(nameValue.name) + ',' + operator.encode(nameValue.value);\r\n            });\r\n            result += objectHelper.join(arr, ',');\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function expandExplodedNamed (varspec, operator, value) {\r\n        var\r\n            isArray = objectHelper.isArray(value),\r\n            arr = [];\r\n        if (isArray) {\r\n            arr = value;\r\n            arr = objectHelper.filter(arr, isDefined);\r\n            arr = objectHelper.map(arr, function (listElement) {\r\n                var tmp = encodingHelper.encodeLiteral(varspec.varname);\r\n                if (isEmpty(listElement)) {\r\n                    tmp += operator.ifEmpty;\r\n                }\r\n                else {\r\n                    tmp += '=' + operator.encode(listElement);\r\n                }\r\n                return tmp;\r\n            });\r\n        }\r\n        else {\r\n            arr = propertyArray(value);\r\n            arr = objectHelper.filter(arr, valueDefined);\r\n            arr = objectHelper.map(arr, function (nameValue) {\r\n                var tmp = encodingHelper.encodeLiteral(nameValue.name);\r\n                if (isEmpty(nameValue.value)) {\r\n                    tmp += operator.ifEmpty;\r\n                }\r\n                else {\r\n                    tmp += '=' + operator.encode(nameValue.value);\r\n                }\r\n                return tmp;\r\n            });\r\n        }\r\n        return objectHelper.join(arr, operator.separator);\r\n    }\r\n\r\n    function expandExplodedUnnamed (operator, value) {\r\n        var\r\n            arr = [],\r\n            result = '';\r\n        if (objectHelper.isArray(value)) {\r\n            arr = value;\r\n            arr = objectHelper.filter(arr, isDefined);\r\n            arr = objectHelper.map(arr, operator.encode);\r\n            result += objectHelper.join(arr, operator.separator);\r\n        }\r\n        else {\r\n            arr = propertyArray(value);\r\n            arr = objectHelper.filter(arr, function (nameValue) {\r\n                return isDefined(nameValue.value);\r\n            });\r\n            arr = objectHelper.map(arr, function (nameValue) {\r\n                return operator.encode(nameValue.name) + '=' + operator.encode(nameValue.value);\r\n            });\r\n            result += objectHelper.join(arr, operator.separator);\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n    VariableExpression.prototype.expand = function (variables) {\r\n        var\r\n            expanded = [],\r\n            index,\r\n            varspec,\r\n            value,\r\n            valueIsArr,\r\n            oneExploded = false,\r\n            operator = this.operator;\r\n\r\n        // expand each varspec and join with operator's separator\r\n        for (index = 0; index < this.varspecs.length; index += 1) {\r\n            varspec = this.varspecs[index];\r\n            value = variables[varspec.varname];\r\n            // if (!isDefined(value)) {\r\n            // if (variables.hasOwnProperty(varspec.name)) {\r\n            if (value === null || value === undefined) {\r\n                continue;\r\n            }\r\n            if (varspec.exploded) {\r\n                oneExploded = true;\r\n            }\r\n            valueIsArr = objectHelper.isArray(value);\r\n            if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\r\n                expanded.push(expandSimpleValue(varspec, operator, value));\r\n            }\r\n            else if (varspec.maxLength && isDefined(value)) {\r\n                // 2.4.1 of the spec says: \"Prefix modifiers are not applicable to variables that have composite values.\"\r\n                throw new Error('Prefix modifiers are not applicable to variables that have composite values. You tried to expand ' + this + \" with \" + prettyPrint(value));\r\n            }\r\n            else if (!varspec.exploded) {\r\n                if (operator.named || !isEmpty(value)) {\r\n                    expanded.push(expandNotExploded(varspec, operator, value));\r\n                }\r\n            }\r\n            else if (isDefined(value)) {\r\n                if (operator.named) {\r\n                    expanded.push(expandExplodedNamed(varspec, operator, value));\r\n                }\r\n                else {\r\n                    expanded.push(expandExplodedUnnamed(operator, value));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (expanded.length === 0) {\r\n            return \"\";\r\n        }\r\n        else {\r\n            return operator.first + objectHelper.join(expanded, operator.separator);\r\n        }\r\n    };\r\n\r\n    return VariableExpression;\r\n}());\r\n\r\nvar UriTemplate = (function () {\r\n    function UriTemplate (templateText, expressions) {\r\n        this.templateText = templateText;\r\n        this.expressions = expressions;\r\n        objectHelper.deepFreeze(this);\r\n    }\r\n\r\n    UriTemplate.prototype.toString = function () {\r\n        return this.templateText;\r\n    };\r\n\r\n    UriTemplate.prototype.expand = function (variables) {\r\n        // this.expressions.map(function (expression) {return expression.expand(variables);}).join('');\r\n        var\r\n            index,\r\n            result = '';\r\n        for (index = 0; index < this.expressions.length; index += 1) {\r\n            result += this.expressions[index].expand(variables);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    UriTemplate.parse = parse;\r\n    UriTemplate.UriTemplateError = UriTemplateError;\r\n    return UriTemplate;\r\n}());\r\n\r\n    exportCallback(UriTemplate);\r\n\r\n}(function (UriTemplate) {\r\n        \"use strict\";\r\n        // export UriTemplate, when module is present, or pass it to window or global\r\n        if (typeof module !== \"undefined\") {\r\n            module.exports = UriTemplate;\r\n        }\r\n        else if (typeof define === \"function\") {\r\n            define([],function() {\r\n                return UriTemplate;\r\n            });\r\n        }\r\n        else if (typeof window !== \"undefined\") {\r\n            window.UriTemplate = UriTemplate;\r\n        }\r\n        else {\r\n            global.UriTemplate = UriTemplate;\r\n        }\r\n    }\r\n));\r\n"]},"metadata":{},"sourceType":"script"}