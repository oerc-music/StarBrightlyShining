{"ast":null,"code":"\"use strict\";\n\nfunction __export(m) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst handler_1 = require(\"./lib/handler\");\n\nconst Translator_1 = require(\"./lib/Translator\");\n\n__export(require(\"./lib/handler\"));\n\n__export(require(\"./lib/Translator\"));\n\nconst DF = new rdf_data_factory_1.DataFactory(); // Construct translator with built-in handlers\n\nconst translator = new Translator_1.Translator();\ntranslator.registerHandler(new handler_1.TypeHandlerString(), handler_1.TypeHandlerString.TYPES.map(t => DF.namedNode(t)), ['string']);\ntranslator.registerHandler(new handler_1.TypeHandlerBoolean(), [handler_1.TypeHandlerBoolean.TYPE].map(t => DF.namedNode(t)), ['boolean']);\ntranslator.registerHandler(new handler_1.TypeHandlerNumberDouble(), handler_1.TypeHandlerNumberDouble.TYPES.map(t => DF.namedNode(t)), ['number']);\ntranslator.registerHandler(new handler_1.TypeHandlerNumberInteger(), handler_1.TypeHandlerNumberInteger.TYPES.map(t => DF.namedNode(t)), ['number']);\ntranslator.registerHandler(new handler_1.TypeHandlerDate(), handler_1.TypeHandlerDate.TYPES.map(t => DF.namedNode(t)), ['object']);\n/**\n * Convert the given RDF literal to an JavaScript primitive.\n * @param {Literal} literal An RDF literal value.\n * @param {boolean} validate If the literal value should be validated against the datatype.\n * @return {any} A JavaScript primitive value.\n */\n\nfunction fromRdf(literal, validate) {\n  return translator.fromRdf(literal, validate);\n}\n\nexports.fromRdf = fromRdf;\n/**\n * Convert the given JavaScript primitive to an RDF literal.\n * @param value A JavaScript primitive value.\n * @param options Options for RDF conversion. May also be a data factory.\n * @return {Literal} An RDF literal value.\n */\n\nfunction toRdf(value, options) {\n  // Backwards-compatibility to accept data factory as option arg.\n  if (options && 'namedNode' in options) {\n    options = {\n      dataFactory: options\n    };\n  } // Set default data factory\n\n\n  options = options || {};\n\n  if (options && !options.dataFactory) {\n    options.dataFactory = DF;\n  }\n\n  return translator.toRdf(value, options);\n}\n\nexports.toRdf = toRdf;\n/**\n * Get the raw value of the given term.\n * If it is a literal, {@link fromRdf} will be called.\n * Otherwise {@link .value} will be returned.\n * @param {Term} term Any RDF term.\n * @param {boolean} validate If the literal value should be validated against the datatype.\n * @return {any} A JavaScript primitive value.\n */\n\nfunction getTermRaw(term, validate) {\n  if (term.termType === 'Literal') {\n    return fromRdf(term, validate);\n  }\n\n  return term.value;\n}\n\nexports.getTermRaw = getTermRaw;\n/**\n * @return {NamedNode[]} An array of all supported RDF datatypes.\n */\n\nfunction getSupportedRdfDatatypes() {\n  return translator.getSupportedRdfDatatypes();\n}\n\nexports.getSupportedRdfDatatypes = getSupportedRdfDatatypes;\n/**\n * @return {string[]} An array of all supported JavaScript types.\n */\n\nfunction getSupportedJavaScriptPrimitives() {\n  return translator.getSupportedJavaScriptPrimitives();\n}\n\nexports.getSupportedJavaScriptPrimitives = getSupportedJavaScriptPrimitives;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/rdf-literal/index.js"],"names":["__export","m","p","exports","hasOwnProperty","Object","defineProperty","value","rdf_data_factory_1","require","handler_1","Translator_1","DF","DataFactory","translator","Translator","registerHandler","TypeHandlerString","TYPES","map","t","namedNode","TypeHandlerBoolean","TYPE","TypeHandlerNumberDouble","TypeHandlerNumberInteger","TypeHandlerDate","fromRdf","literal","validate","toRdf","options","dataFactory","getTermRaw","term","termType","getSupportedRdfDatatypes","getSupportedJavaScriptPrimitives"],"mappings":"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","sourcesContent":["\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst handler_1 = require(\"./lib/handler\");\nconst Translator_1 = require(\"./lib/Translator\");\n__export(require(\"./lib/handler\"));\n__export(require(\"./lib/Translator\"));\nconst DF = new rdf_data_factory_1.DataFactory();\n// Construct translator with built-in handlers\nconst translator = new Translator_1.Translator();\ntranslator.registerHandler(new handler_1.TypeHandlerString(), handler_1.TypeHandlerString.TYPES.map(t => DF.namedNode(t)), ['string']);\ntranslator.registerHandler(new handler_1.TypeHandlerBoolean(), [handler_1.TypeHandlerBoolean.TYPE].map(t => DF.namedNode(t)), ['boolean']);\ntranslator.registerHandler(new handler_1.TypeHandlerNumberDouble(), handler_1.TypeHandlerNumberDouble.TYPES.map(t => DF.namedNode(t)), ['number']);\ntranslator.registerHandler(new handler_1.TypeHandlerNumberInteger(), handler_1.TypeHandlerNumberInteger.TYPES.map(t => DF.namedNode(t)), ['number']);\ntranslator.registerHandler(new handler_1.TypeHandlerDate(), handler_1.TypeHandlerDate.TYPES.map(t => DF.namedNode(t)), ['object']);\n/**\n * Convert the given RDF literal to an JavaScript primitive.\n * @param {Literal} literal An RDF literal value.\n * @param {boolean} validate If the literal value should be validated against the datatype.\n * @return {any} A JavaScript primitive value.\n */\nfunction fromRdf(literal, validate) {\n    return translator.fromRdf(literal, validate);\n}\nexports.fromRdf = fromRdf;\n/**\n * Convert the given JavaScript primitive to an RDF literal.\n * @param value A JavaScript primitive value.\n * @param options Options for RDF conversion. May also be a data factory.\n * @return {Literal} An RDF literal value.\n */\nfunction toRdf(value, options) {\n    // Backwards-compatibility to accept data factory as option arg.\n    if (options && 'namedNode' in options) {\n        options = { dataFactory: options };\n    }\n    // Set default data factory\n    options = options || {};\n    if (options && !options.dataFactory) {\n        options.dataFactory = DF;\n    }\n    return translator.toRdf(value, options);\n}\nexports.toRdf = toRdf;\n/**\n * Get the raw value of the given term.\n * If it is a literal, {@link fromRdf} will be called.\n * Otherwise {@link .value} will be returned.\n * @param {Term} term Any RDF term.\n * @param {boolean} validate If the literal value should be validated against the datatype.\n * @return {any} A JavaScript primitive value.\n */\nfunction getTermRaw(term, validate) {\n    if (term.termType === 'Literal') {\n        return fromRdf(term, validate);\n    }\n    return term.value;\n}\nexports.getTermRaw = getTermRaw;\n/**\n * @return {NamedNode[]} An array of all supported RDF datatypes.\n */\nfunction getSupportedRdfDatatypes() {\n    return translator.getSupportedRdfDatatypes();\n}\nexports.getSupportedRdfDatatypes = getSupportedRdfDatatypes;\n/**\n * @return {string[]} An array of all supported JavaScript types.\n */\nfunction getSupportedJavaScriptPrimitives() {\n    return translator.getSupportedJavaScriptPrimitives();\n}\nexports.getSupportedJavaScriptPrimitives = getSupportedJavaScriptPrimitives;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}