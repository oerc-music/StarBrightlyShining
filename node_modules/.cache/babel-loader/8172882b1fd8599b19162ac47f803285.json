{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toSparqlJs = exports.toSparql = void 0;\n\nconst rdf_isomorphic_1 = require(\"rdf-isomorphic\");\n\nconst Algebra = require(\"./algebra\");\n\nconst factory_1 = require(\"./factory\");\n\nconst util_1 = require(\"./util\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst SparqlGenerator = require('sparqljs').Generator;\n\nconst Wildcard = require('sparqljs').Wildcard;\n\nconst types = Algebra.types;\nconst eTypes = Algebra.expressionTypes;\nlet context;\nconst factory = new factory_1.default();\n\nfunction toSparql(op, options = {}) {\n  let generator = new SparqlGenerator(options);\n  return generator.stringify(toSparqlJs(op));\n}\n\nexports.toSparql = toSparql;\n\nfunction toSparqlJs(op) {\n  resetContext();\n  op = removeQuads(op);\n  let result = translateOperation(op);\n  if (result.type === 'group') return result.patterns[0];\n  return result;\n}\n\nexports.toSparqlJs = toSparqlJs;\n\nfunction resetContext() {\n  context = {\n    project: false,\n    extend: [],\n    group: [],\n    aggregates: [],\n    order: []\n  };\n}\n\nfunction translateOperation(op) {\n  // this allows us to differentiate between BIND and SELECT when translating EXTEND\n  // GRAPH was added because the way graphs get added back here is not the same as how they get added in the future\n  // ^ seems fine but might have to be changed if problems get detected in the future\n  if (op.type !== types.EXTEND && op.type !== types.ORDER_BY && op.type !== types.GRAPH) context.project = false;\n\n  switch (op.type) {\n    case types.EXPRESSION:\n      return translateExpression(op);\n\n    case types.ASK:\n      return translateProject(op, types.ASK);\n\n    case types.BGP:\n      return translateBgp(op);\n\n    case types.CONSTRUCT:\n      return translateConstruct(op);\n\n    case types.DESCRIBE:\n      return translateProject(op, types.DESCRIBE);\n\n    case types.DISTINCT:\n      return translateDistinct(op);\n\n    case types.EXTEND:\n      return translateExtend(op);\n\n    case types.FROM:\n      return translateFrom(op);\n\n    case types.FILTER:\n      return translateFilter(op);\n\n    case types.GRAPH:\n      return translateGraph(op);\n\n    case types.GROUP:\n      return translateGroup(op);\n\n    case types.JOIN:\n      return translateJoin(op);\n\n    case types.LEFT_JOIN:\n      return translateLeftJoin(op);\n\n    case types.MINUS:\n      return translateMinus(op);\n\n    case types.ORDER_BY:\n      return translateOrderBy(op);\n\n    case types.PATH:\n      return translatePath(op);\n\n    case types.PATTERN:\n      return translatePattern(op);\n\n    case types.PROJECT:\n      return translateProject(op, types.PROJECT);\n\n    case types.REDUCED:\n      return translateReduced(op);\n\n    case types.SERVICE:\n      return translateService(op);\n\n    case types.SLICE:\n      return translateSlice(op);\n\n    case types.UNION:\n      return translateUnion(op);\n\n    case types.VALUES:\n      return translateValues(op);\n    // UPDATE operations\n\n    case types.COMPOSITE_UPDATE:\n      return translateCompositeUpdate(op);\n\n    case types.DELETE_INSERT:\n      return translateDeleteInsert(op);\n\n    case types.LOAD:\n      return translateLoad(op);\n\n    case types.CLEAR:\n      return translateClear(op);\n\n    case types.CREATE:\n      return translateCreate(op);\n\n    case types.DROP:\n      return translateDrop(op);\n\n    case types.ADD:\n      return translateAdd(op);\n\n    case types.MOVE:\n      return translateMove(op);\n\n    case types.COPY:\n      return translateCopy(op);\n  }\n\n  throw new Error('Unknown Operation type ' + op.type);\n}\n\nfunction translateExpression(expr) {\n  switch (expr.expressionType) {\n    case eTypes.AGGREGATE:\n      return translateAggregateExpression(expr);\n\n    case eTypes.EXISTENCE:\n      return translateExistenceExpression(expr);\n\n    case eTypes.NAMED:\n      return translateNamedExpression(expr);\n\n    case eTypes.OPERATOR:\n      return translateOperatorExpression(expr);\n\n    case eTypes.TERM:\n      return translateTermExpression(expr);\n\n    case eTypes.WILDCARD:\n      return translateWildcardExpression(expr);\n  }\n\n  throw new Error('Unknown Expression Operation type ' + expr.expressionType);\n}\n\nfunction translatePathComponent(path) {\n  switch (path.type) {\n    case types.ALT:\n      return translateAlt(path);\n\n    case types.INV:\n      return translateInv(path);\n\n    case types.LINK:\n      return translateLink(path);\n\n    case types.NPS:\n      return translateNps(path);\n\n    case types.ONE_OR_MORE_PATH:\n      return translateOneOrMorePath(path);\n\n    case types.SEQ:\n      return translateSeq(path);\n\n    case types.ZERO_OR_MORE_PATH:\n      return translateZeroOrMorePath(path);\n\n    case types.ZERO_OR_ONE_PATH:\n      return translateZeroOrOnePath(path);\n  }\n\n  throw new Error('Unknown Path type ' + path.type);\n}\n\nfunction translateTerm(term) {\n  return rdf_string_1.termToString(term);\n} // ------------------------- EXPRESSIONS -------------------------\n\n\nfunction translateAggregateExpression(expr) {\n  let result = {\n    expression: translateExpression(expr.expression),\n    type: 'aggregate',\n    aggregation: expr.aggregator,\n    distinct: expr.distinct\n  };\n  if (expr.separator) result.separator = expr.separator;\n  return result;\n}\n\nfunction translateExistenceExpression(expr) {\n  return {\n    type: 'operation',\n    operator: expr.not ? 'notexists' : 'exists',\n    args: util_1.default.flatten([translateOperation(expr.input)])\n  };\n}\n\nfunction translateNamedExpression(expr) {\n  return {\n    type: 'functionCall',\n    function: expr.name,\n    args: expr.args.map(translateExpression)\n  };\n}\n\nfunction translateOperatorExpression(expr) {\n  if (expr.operator === 'desc') {\n    let result = {\n      expression: translateExpression(expr.args[0])\n    };\n    result.descending = true;\n    return result;\n  }\n\n  let result = {\n    type: 'operation',\n    operator: expr.operator,\n    args: expr.args.map(translateExpression)\n  };\n  if (result.operator === 'in' || result.operator === 'notin') result.args = [result.args[0]].concat([result.args.slice(1)]);\n  return result;\n}\n\nfunction translateTermExpression(expr) {\n  return expr.term;\n}\n\nfunction translateWildcardExpression(expr) {\n  return expr.wildcard;\n} // ------------------------- OPERATIONS -------------------------\n// these get translated in the project function\n\n\nfunction translateBoundAggregate(op) {\n  return op;\n}\n\nfunction translateBgp(op) {\n  let patterns = op.patterns.map(translatePattern);\n  if (patterns.length === 0) return null;\n  return {\n    type: 'bgp',\n    triples: patterns\n  };\n}\n\nfunction translateConstruct(op) {\n  return {\n    type: 'query',\n    prefixes: {},\n    queryType: \"CONSTRUCT\",\n    template: op.template.map(translatePattern),\n    where: util_1.default.flatten([translateOperation(op.input)])\n  };\n}\n\nfunction translateDistinct(op) {\n  let result = translateOperation(op.input); // project is nested in group object\n\n  result.patterns[0].distinct = true;\n  return result;\n}\n\nfunction translateExtend(op) {\n  if (context.project) {\n    context.extend.push(op);\n    return translateOperation(op.input);\n  }\n\n  return util_1.default.flatten([translateOperation(op.input), {\n    type: 'bind',\n    variable: op.variable,\n    expression: translateExpression(op.expression)\n  }]);\n}\n\nfunction translateFrom(op) {\n  let result = translateOperation(op.input); // project is nested in group object\n\n  let obj = result.patterns[0];\n  obj.from = {\n    default: op.default,\n    named: op.named\n  };\n  return result;\n}\n\nfunction translateFilter(op) {\n  return {\n    type: 'group',\n    patterns: util_1.default.flatten([translateOperation(op.input), {\n      type: 'filter',\n      expression: translateExpression(op.expression)\n    }])\n  };\n}\n\nfunction translateGraph(op) {\n  return {\n    type: 'graph',\n    patterns: util_1.default.flatten([translateOperation(op.input)]),\n    name: op.name\n  };\n}\n\nfunction translateGroup(op) {\n  let input = translateOperation(op.input);\n  let aggs = op.aggregates.map(translateBoundAggregate);\n  context.aggregates.push(...aggs); // TODO: apply possible extends\n\n  context.group.push(...op.variables);\n  return input;\n}\n\nfunction translateJoin(op) {\n  const arr = util_1.default.flatten([translateOperation(op.left), translateOperation(op.right)]); // Merge bgps\n  // This is possible if one side was a path and the other a bgp for example\n\n  return arr.reduce((result, val) => {\n    if (val.type !== 'bgp' || result.length == 0 || result[result.length - 1].type !== 'bgp') {\n      result.push(val);\n    } else {\n      result[result.length - 1].triples.push(...val.triples);\n    }\n\n    return result;\n  }, []);\n}\n\nfunction translateLeftJoin(op) {\n  let leftjoin = {\n    type: 'optional',\n    patterns: [translateOperation(op.right)]\n  };\n\n  if (op.expression) {\n    leftjoin.patterns.push({\n      type: 'filter',\n      expression: translateExpression(op.expression)\n    });\n  }\n\n  leftjoin.patterns = util_1.default.flatten(leftjoin.patterns);\n  return util_1.default.flatten([translateOperation(op.left), leftjoin]);\n}\n\nfunction translateMinus(op) {\n  let patterns = translateOperation(op.right);\n  if (patterns.type === 'group') patterns = patterns.patterns;\n  if (!Array.isArray(patterns)) patterns = [patterns];\n  return util_1.default.flatten([translateOperation(op.left), {\n    type: 'minus',\n    patterns: patterns\n  }]);\n}\n\nfunction translateOrderBy(op) {\n  context.order.push(...op.expressions);\n  return translateOperation(op.input);\n}\n\nfunction translatePath(op) {\n  // TODO: quads back to graph statement\n  return {\n    type: 'bgp',\n    triples: [{\n      subject: op.subject,\n      predicate: translatePathComponent(op.predicate),\n      object: op.object\n    }]\n  };\n}\n\nfunction translatePattern(op) {\n  return {\n    subject: op.subject,\n    predicate: op.predicate,\n    object: op.object\n  };\n}\n\nfunction replaceAggregatorVariables(s, map) {\n  let st = util_1.default.isTerm(s) ? translateTerm(s) : s;\n\n  if (typeof st === 'string') {\n    if (map[st]) return map[st];\n  } else if (Array.isArray(s)) {\n    s = s.map(e => replaceAggregatorVariables(e, map));\n  } else {\n    for (let key of Object.keys(s)) s[key] = replaceAggregatorVariables(s[key], map);\n  }\n\n  return s;\n}\n\nfunction translateProject(op, type) {\n  let result = {\n    type: 'query',\n    prefixes: {}\n  };\n\n  if (type === types.PROJECT) {\n    result.queryType = 'SELECT';\n    result.variables = op.variables;\n  } else if (type === types.ASK) {\n    result.queryType = 'ASK';\n  } else if (type === types.DESCRIBE) {\n    result.queryType = 'DESCRIBE';\n    result.variables = op.terms;\n  } // backup values in case of nested queries\n  // everything in extend, group, etc. is irrelevant for this project call\n\n\n  let extend = context.extend;\n  let group = context.group;\n  let aggregates = context.aggregates;\n  let order = context.order;\n  resetContext();\n  context.project = true;\n  let input = util_1.default.flatten([translateOperation(op.input)]);\n  if (input.length === 1 && input[0].type === 'group') input = input[0].patterns;\n  result.where = input;\n  let aggregators = {}; // these can not reference each other\n\n  for (let agg of context.aggregates) aggregators[translateTerm(agg.variable)] = translateExpression(agg); // do these in reverse order since variables in one extend might apply to an expression in an other extend\n\n\n  let extensions = {};\n\n  for (let i = context.extend.length - 1; i >= 0; --i) {\n    let e = context.extend[i];\n    extensions[translateTerm(e.variable)] = replaceAggregatorVariables(translateExpression(e.expression), aggregators);\n  }\n\n  if (context.group.length > 0) result.group = context.group.map(variable => {\n    let v = translateTerm(variable);\n\n    if (extensions[v]) {\n      let result = extensions[v];\n      delete extensions[v]; // make sure there is only 1 'AS' statement\n\n      return {\n        variable,\n        expression: result\n      };\n    }\n\n    return {\n      expression: variable\n    };\n  }); // descending expressions will already be in the correct format due to the structure of those\n\n  if (context.order.length > 0) result.order = context.order.map(translateOperation).map(o => o.descending ? o : {\n    expression: o\n  }); // this needs to happen after the group because it might depend on variables generated there\n\n  if (result.variables) {\n    result.variables = result.variables.map(term => {\n      let v = translateTerm(term);\n      if (extensions[v]) return {\n        variable: term,\n        expression: extensions[v]\n      };\n      return term;\n    }); // if the * didn't match any variables this would be empty\n\n    if (result.variables.length === 0) result.variables = [new Wildcard()];\n  } // convert filter to 'having' if it contains an aggregator variable\n  // could always convert, but is nicer to use filter when possible\n\n\n  if (result.where.length > 0 && result.where[result.where.length - 1].type === 'filter') {\n    let filter = result.where[result.where.length - 1];\n\n    if (objectContainsValues(filter, Object.keys(aggregators))) {\n      result.having = util_1.default.flatten([replaceAggregatorVariables(filter.expression, aggregators)]);\n      result.where.splice(-1);\n    }\n  }\n\n  context.extend = extend;\n  context.group = group;\n  context.aggregates = aggregates;\n  context.order = order; // subqueries need to be in a group\n\n  result = {\n    type: 'group',\n    patterns: [result]\n  };\n  return result;\n}\n\nfunction objectContainsValues(o, vals) {\n  if (util_1.default.isTerm(o)) return vals.indexOf(translateTerm(o)) >= 0;\n  if (Array.isArray(o)) return o.some(e => objectContainsValues(e, vals));\n  if (o === Object(o)) return Object.keys(o).some(key => objectContainsValues(o[key], vals));\n  return vals.indexOf(o) >= 0;\n}\n\nfunction translateReduced(op) {\n  let result = translateOperation(op.input); // project is nested in group object\n\n  result.patterns[0].reduced = true;\n  return result;\n}\n\nfunction translateService(op) {\n  let patterns = translateOperation(op.input);\n  if (patterns.type === 'group') patterns = patterns.patterns;\n  if (!Array.isArray(patterns)) patterns = [patterns];\n  return {\n    type: 'service',\n    name: op.name,\n    silent: op.silent,\n    patterns\n  };\n}\n\nfunction translateSlice(op) {\n  let result = translateOperation(op.input); // results can be nested in a group object\n\n  let obj = result;\n  if (result.type && result.type === 'group') obj = result.patterns[0];\n  if (op.start !== 0) obj.offset = op.start;\n  if (op.length !== undefined) obj.limit = op.length;\n  return result;\n}\n\nfunction translateUnion(op) {\n  return {\n    type: 'union',\n    patterns: util_1.default.flatten([translateOperation(op.left), translateOperation(op.right)])\n  };\n}\n\nfunction translateValues(op) {\n  // TODO: check if handled correctly when outside of select block\n  return {\n    type: 'values',\n    values: op.bindings.map(binding => {\n      let result = {};\n\n      for (let v of op.variables) {\n        let s = '?' + v.value;\n        if (binding[s]) result[s] = binding[s];else result[s] = undefined;\n      }\n\n      return result;\n    })\n  };\n} // PATH COMPONENTS\n\n\nfunction translateAlt(path) {\n  let left = translatePathComponent(path.left);\n  let right = translatePathComponent(path.right);\n\n  if (left.pathType === '!' && right.pathType === '!') {\n    return {\n      type: 'path',\n      pathType: '!',\n      items: [{\n        type: 'path',\n        pathType: '|',\n        items: [].concat(left.items, right.items)\n      }]\n    };\n  }\n\n  return {\n    type: 'path',\n    pathType: '|',\n    items: [left, right]\n  };\n}\n\nfunction translateInv(path) {\n  if (path.path.type === types.NPS) {\n    let npsPath = path.path;\n    let inv = npsPath.iris.map(iri => {\n      return {\n        type: 'path',\n        pathType: '^',\n        items: [iri]\n      };\n    });\n    if (inv.length <= 1) return {\n      type: 'path',\n      pathType: '!',\n      items: inv\n    };\n    return {\n      type: 'path',\n      pathType: '!',\n      items: [{\n        type: 'path',\n        pathType: '|',\n        items: inv\n      }]\n    };\n  }\n\n  return {\n    type: 'path',\n    pathType: '^',\n    items: [translatePathComponent(path.path)]\n  };\n}\n\nfunction translateLink(path) {\n  return path.iri;\n}\n\nfunction translateNps(path) {\n  if (path.iris.length <= 1) return {\n    type: 'path',\n    pathType: '!',\n    items: path.iris\n  };\n  return {\n    type: 'path',\n    pathType: '!',\n    items: [{\n      type: 'path',\n      pathType: '|',\n      items: path.iris\n    }]\n  };\n}\n\nfunction translateOneOrMorePath(path) {\n  return {\n    type: 'path',\n    pathType: '+',\n    items: [translatePathComponent(path.path)]\n  };\n}\n\nfunction translateSeq(path) {\n  return {\n    type: 'path',\n    pathType: '/',\n    items: [translatePathComponent(path.left), translatePathComponent(path.right)]\n  };\n}\n\nfunction translateZeroOrMorePath(path) {\n  return {\n    type: 'path',\n    pathType: '*',\n    items: [translatePathComponent(path.path)]\n  };\n}\n\nfunction translateZeroOrOnePath(path) {\n  return {\n    type: 'path',\n    pathType: '?',\n    items: [translatePathComponent(path.path)]\n  };\n} // UPDATE OPERATIONS\n\n\nfunction translateCompositeUpdate(op) {\n  const updates = op.updates.map(update => {\n    const result = translateOperation(update);\n    return result.updates[0];\n  });\n  return {\n    prefixes: {},\n    type: 'update',\n    updates\n  };\n}\n\nfunction translateDeleteInsert(op) {\n  let where = op.where;\n  let using = undefined;\n\n  if (where && where.type === types.FROM) {\n    let from = op.where;\n    where = from.input;\n    using = {\n      default: from.default,\n      named: from.named\n    };\n  }\n\n  const updates = [{\n    updateType: 'insertdelete',\n    delete: convertUpdatePatterns(op.delete),\n    insert: convertUpdatePatterns(op.insert)\n  }];\n  if (using) updates[0].using = using; // corresponds to empty array in SPARQL.js\n\n  if (!where || where.type === types.BGP && where.patterns.length === 0) updates[0].where = [];else {\n    const graphs = {};\n    let result = translateOperation(removeQuadsRecursive(where, graphs));\n    if (result.type === 'group') updates[0].where = result.patterns;else updates[0].where = [result]; // graph might not be applied yet since there was no project\n    // this can only happen if there was a single graph\n\n    const graphNames = Object.keys(graphs);\n\n    if (graphNames.length > 0) {\n      if (graphNames.length !== 1) throw new Error('This is unexpected and might indicate an error in graph handling for updates.'); // ignore if default graph\n\n      if (graphs[graphNames[0]].graph.value !== '') updates[0].where = [{\n        type: 'graph',\n        patterns: updates[0].where,\n        name: graphs[graphNames[0]].graph\n      }];\n    }\n  } // not really necessary but can give cleaner looking queries\n\n  if (!op.delete && !op.where) {\n    updates[0].updateType = 'insert';\n    delete updates[0].delete;\n    delete updates[0].where;\n  } else if (!op.insert && !op.where) {\n    delete updates[0].insert;\n    delete updates[0].where;\n    if (op.delete.some(pattern => pattern.subject.termType === 'Variable' || pattern.predicate.termType === 'Variable' || pattern.object.termType === 'Variable')) updates[0].updateType = 'deletewhere';else updates[0].updateType = 'delete';\n  } else if (!op.insert && op.where && op.where.type === 'bgp') {\n    if (rdf_isomorphic_1.isomorphic(op.delete, op.where.patterns)) {\n      delete updates[0].where;\n      updates[0].updateType = 'deletewhere';\n    }\n  }\n\n  return {\n    prefixes: {},\n    type: 'update',\n    updates\n  };\n}\n\nfunction translateLoad(op) {\n  const updates = [{\n    type: 'load',\n    silent: Boolean(op.silent),\n    source: op.source\n  }];\n  if (op.destination) updates[0].destination = op.destination;\n  return {\n    prefixes: {},\n    type: 'update',\n    updates\n  };\n}\n\nfunction translateClear(op) {\n  return translateClearCreateDrop(op, 'clear');\n}\n\nfunction translateCreate(op) {\n  return translateClearCreateDrop(op, 'create');\n}\n\nfunction translateDrop(op) {\n  return translateClearCreateDrop(op, 'drop');\n}\n\nfunction translateClearCreateDrop(op, type) {\n  const updates = [{\n    type,\n    silent: Boolean(op.silent)\n  }];\n  if (op.source === 'DEFAULT') updates[0].graph = {\n    default: true\n  };else if (op.source === 'NAMED') updates[0].graph = {\n    named: true\n  };else if (op.source === 'ALL') updates[0].graph = {\n    all: true\n  };else updates[0].graph = {\n    type: 'graph',\n    name: op.source\n  };\n  return {\n    prefixes: {},\n    type: 'update',\n    updates\n  };\n}\n\nfunction translateAdd(op) {\n  return translateUpdateGraphShortcut(op, 'add');\n}\n\nfunction translateMove(op) {\n  return translateUpdateGraphShortcut(op, 'move');\n}\n\nfunction translateCopy(op) {\n  return translateUpdateGraphShortcut(op, 'copy');\n}\n\nfunction translateUpdateGraphShortcut(op, type) {\n  const updates = [{\n    type,\n    silent: Boolean(op.silent)\n  }];\n  updates[0].source = op.source === 'DEFAULT' ? {\n    type: 'graph',\n    default: true\n  } : {\n    type: 'graph',\n    name: op.source\n  };\n  updates[0].destination = op.destination === 'DEFAULT' ? {\n    type: 'graph',\n    default: true\n  } : {\n    type: 'graph',\n    name: op.destination\n  };\n  return {\n    prefixes: {},\n    type: 'update',\n    updates\n  };\n} // similar to removeQuads but more simplified for UPDATEs\n\n\nfunction convertUpdatePatterns(patterns) {\n  if (!patterns) return [];\n  const graphs = {};\n  patterns.forEach(pattern => {\n    const graph = pattern.graph.value;\n    if (!graphs[graph]) graphs[graph] = [];\n    graphs[graph].push(pattern);\n  });\n  return Object.keys(graphs).map(graph => {\n    if (graph === '') return {\n      type: 'bgp',\n      triples: graphs[graph].map(translatePattern)\n    };\n    return {\n      type: 'graph',\n      triples: graphs[graph].map(translatePattern),\n      name: graphs[graph][0].graph\n    };\n  });\n}\n\nfunction removeQuads(op) {\n  return removeQuadsRecursive(op, {});\n} // remove quads\n\n\nfunction removeQuadsRecursive(op, graphs) {\n  if (Array.isArray(op)) return op.map(sub => removeQuadsRecursive(sub, graphs));\n  if (!op.type) return op; // UPDATE operations with Patterns handle graphs a bit differently\n\n  if (op.type === types.DELETE_INSERT) return op;\n\n  if ((op.type === types.PATTERN || op.type === types.PATH) && op.graph) {\n    if (!graphs[op.graph.value]) graphs[op.graph.value] = {\n      graph: op.graph,\n      values: []\n    };\n    graphs[op.graph.value].values.push(op);\n    return op;\n  }\n\n  const result = {};\n  const keyGraphs = {}; // unique graph per key\n\n  const globalNames = {}; // track all the unique graph names for the entire Operation\n\n  for (let key of Object.keys(op)) {\n    const newGraphs = {};\n    result[key] = removeQuadsRecursive(op[key], newGraphs);\n    const graphNames = Object.keys(newGraphs); // create graph statements if multiple graphs are found\n\n    if (graphNames.length > 1) {\n      // nest joins\n      let left = potentialGraphFromPatterns(newGraphs[graphNames[0]].values);\n\n      for (let i = 1; i < graphNames.length; ++i) {\n        const right = potentialGraphFromPatterns(newGraphs[graphNames[i]].values);\n        left = factory.createJoin(left, right);\n      }\n\n      graphNames.map(name => delete newGraphs[name]); // this ignores the result object that is being generated, but should not be a problem\n      // is only an issue for objects that have 2 keys where this can occur, which is none\n\n      return left;\n    } else if (graphNames.length === 1) {\n      const graph = newGraphs[graphNames[0]].graph;\n      keyGraphs[key] = graph;\n      globalNames[graph.value] = graph;\n    }\n  }\n\n  const graphNameSet = Object.keys(globalNames);\n\n  if (graphNameSet.length > 0) {\n    // also need to create graph statement if we are at the edge of the query\n    if (graphNameSet.length === 1 && op.type !== types.PROJECT) graphs[graphNameSet[0]] = {\n      graph: globalNames[graphNameSet[0]],\n      values: [result]\n    };else {\n      // multiple graphs (or project), need to create graph objects for them\n      for (let key of Object.keys(keyGraphs)) if (keyGraphs[key].value.length > 0) result[key] = factory.createGraph(result[key], keyGraphs[key]);\n    }\n  }\n\n  return result;\n}\n\nfunction potentialGraphFromPatterns(patterns) {\n  const bgp = factory.createBgp(patterns);\n  const name = patterns[0].graph;\n  if (name.value.length === 0) return bgp;\n  return factory.createGraph(bgp, name);\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/sparqlalgebrajs/lib/sparql.js"],"names":["Object","defineProperty","exports","value","toSparqlJs","toSparql","rdf_isomorphic_1","require","Algebra","factory_1","util_1","rdf_string_1","SparqlGenerator","Generator","Wildcard","types","eTypes","expressionTypes","context","factory","default","op","options","generator","stringify","resetContext","removeQuads","result","translateOperation","type","patterns","project","extend","group","aggregates","order","EXTEND","ORDER_BY","GRAPH","EXPRESSION","translateExpression","ASK","translateProject","BGP","translateBgp","CONSTRUCT","translateConstruct","DESCRIBE","DISTINCT","translateDistinct","translateExtend","FROM","translateFrom","FILTER","translateFilter","translateGraph","GROUP","translateGroup","JOIN","translateJoin","LEFT_JOIN","translateLeftJoin","MINUS","translateMinus","translateOrderBy","PATH","translatePath","PATTERN","translatePattern","PROJECT","REDUCED","translateReduced","SERVICE","translateService","SLICE","translateSlice","UNION","translateUnion","VALUES","translateValues","COMPOSITE_UPDATE","translateCompositeUpdate","DELETE_INSERT","translateDeleteInsert","LOAD","translateLoad","CLEAR","translateClear","CREATE","translateCreate","DROP","translateDrop","ADD","translateAdd","MOVE","translateMove","COPY","translateCopy","Error","expr","expressionType","AGGREGATE","translateAggregateExpression","EXISTENCE","translateExistenceExpression","NAMED","translateNamedExpression","OPERATOR","translateOperatorExpression","TERM","translateTermExpression","WILDCARD","translateWildcardExpression","translatePathComponent","path","ALT","translateAlt","INV","translateInv","LINK","translateLink","NPS","translateNps","ONE_OR_MORE_PATH","translateOneOrMorePath","SEQ","translateSeq","ZERO_OR_MORE_PATH","translateZeroOrMorePath","ZERO_OR_ONE_PATH","translateZeroOrOnePath","translateTerm","term","termToString","expression","aggregation","aggregator","distinct","separator","operator","not","args","flatten","input","function","name","map","descending","concat","slice","wildcard","translateBoundAggregate","length","triples","prefixes","queryType","template","where","push","variable","obj","from","named","aggs","variables","arr","left","right","reduce","val","leftjoin","Array","isArray","expressions","subject","predicate","object","replaceAggregatorVariables","s","st","isTerm","e","key","keys","terms","aggregators","agg","extensions","i","v","o","filter","objectContainsValues","having","splice","vals","indexOf","some","reduced","silent","start","offset","undefined","limit","values","bindings","binding","pathType","items","npsPath","inv","iris","iri","updates","update","using","updateType","delete","convertUpdatePatterns","insert","graphs","removeQuadsRecursive","graphNames","graph","pattern","termType","isomorphic","Boolean","source","destination","translateClearCreateDrop","all","translateUpdateGraphShortcut","forEach","sub","keyGraphs","globalNames","newGraphs","potentialGraphFromPatterns","createJoin","graphNameSet","createGraph","bgp","createBgp"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toSparqlJs = exports.toSparql = void 0;\nconst rdf_isomorphic_1 = require(\"rdf-isomorphic\");\nconst Algebra = require(\"./algebra\");\nconst factory_1 = require(\"./factory\");\nconst util_1 = require(\"./util\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst SparqlGenerator = require('sparqljs').Generator;\nconst Wildcard = require('sparqljs').Wildcard;\nconst types = Algebra.types;\nconst eTypes = Algebra.expressionTypes;\nlet context;\nconst factory = new factory_1.default();\nfunction toSparql(op, options = {}) {\n    let generator = new SparqlGenerator(options);\n    return generator.stringify(toSparqlJs(op));\n}\nexports.toSparql = toSparql;\nfunction toSparqlJs(op) {\n    resetContext();\n    op = removeQuads(op);\n    let result = translateOperation(op);\n    if (result.type === 'group')\n        return result.patterns[0];\n    return result;\n}\nexports.toSparqlJs = toSparqlJs;\nfunction resetContext() {\n    context = { project: false, extend: [], group: [], aggregates: [], order: [] };\n}\nfunction translateOperation(op) {\n    // this allows us to differentiate between BIND and SELECT when translating EXTEND\n    // GRAPH was added because the way graphs get added back here is not the same as how they get added in the future\n    // ^ seems fine but might have to be changed if problems get detected in the future\n    if (op.type !== types.EXTEND && op.type !== types.ORDER_BY && op.type !== types.GRAPH)\n        context.project = false;\n    switch (op.type) {\n        case types.EXPRESSION: return translateExpression(op);\n        case types.ASK: return translateProject(op, types.ASK);\n        case types.BGP: return translateBgp(op);\n        case types.CONSTRUCT: return translateConstruct(op);\n        case types.DESCRIBE: return translateProject(op, types.DESCRIBE);\n        case types.DISTINCT: return translateDistinct(op);\n        case types.EXTEND: return translateExtend(op);\n        case types.FROM: return translateFrom(op);\n        case types.FILTER: return translateFilter(op);\n        case types.GRAPH: return translateGraph(op);\n        case types.GROUP: return translateGroup(op);\n        case types.JOIN: return translateJoin(op);\n        case types.LEFT_JOIN: return translateLeftJoin(op);\n        case types.MINUS: return translateMinus(op);\n        case types.ORDER_BY: return translateOrderBy(op);\n        case types.PATH: return translatePath(op);\n        case types.PATTERN: return translatePattern(op);\n        case types.PROJECT: return translateProject(op, types.PROJECT);\n        case types.REDUCED: return translateReduced(op);\n        case types.SERVICE: return translateService(op);\n        case types.SLICE: return translateSlice(op);\n        case types.UNION: return translateUnion(op);\n        case types.VALUES: return translateValues(op);\n        // UPDATE operations\n        case types.COMPOSITE_UPDATE: return translateCompositeUpdate(op);\n        case types.DELETE_INSERT: return translateDeleteInsert(op);\n        case types.LOAD: return translateLoad(op);\n        case types.CLEAR: return translateClear(op);\n        case types.CREATE: return translateCreate(op);\n        case types.DROP: return translateDrop(op);\n        case types.ADD: return translateAdd(op);\n        case types.MOVE: return translateMove(op);\n        case types.COPY: return translateCopy(op);\n    }\n    throw new Error('Unknown Operation type ' + op.type);\n}\nfunction translateExpression(expr) {\n    switch (expr.expressionType) {\n        case eTypes.AGGREGATE: return translateAggregateExpression(expr);\n        case eTypes.EXISTENCE: return translateExistenceExpression(expr);\n        case eTypes.NAMED: return translateNamedExpression(expr);\n        case eTypes.OPERATOR: return translateOperatorExpression(expr);\n        case eTypes.TERM: return translateTermExpression(expr);\n        case eTypes.WILDCARD: return translateWildcardExpression(expr);\n    }\n    throw new Error('Unknown Expression Operation type ' + expr.expressionType);\n}\nfunction translatePathComponent(path) {\n    switch (path.type) {\n        case types.ALT: return translateAlt(path);\n        case types.INV: return translateInv(path);\n        case types.LINK: return translateLink(path);\n        case types.NPS: return translateNps(path);\n        case types.ONE_OR_MORE_PATH: return translateOneOrMorePath(path);\n        case types.SEQ: return translateSeq(path);\n        case types.ZERO_OR_MORE_PATH: return translateZeroOrMorePath(path);\n        case types.ZERO_OR_ONE_PATH: return translateZeroOrOnePath(path);\n    }\n    throw new Error('Unknown Path type ' + path.type);\n}\nfunction translateTerm(term) {\n    return rdf_string_1.termToString(term);\n}\n// ------------------------- EXPRESSIONS -------------------------\nfunction translateAggregateExpression(expr) {\n    let result = {\n        expression: translateExpression(expr.expression),\n        type: 'aggregate',\n        aggregation: expr.aggregator,\n        distinct: expr.distinct\n    };\n    if (expr.separator)\n        result.separator = expr.separator;\n    return result;\n}\nfunction translateExistenceExpression(expr) {\n    return {\n        type: 'operation',\n        operator: expr.not ? 'notexists' : 'exists',\n        args: util_1.default.flatten([\n            translateOperation(expr.input)\n        ])\n    };\n}\nfunction translateNamedExpression(expr) {\n    return {\n        type: 'functionCall',\n        function: expr.name,\n        args: expr.args.map(translateExpression)\n    };\n}\nfunction translateOperatorExpression(expr) {\n    if (expr.operator === 'desc') {\n        let result = { expression: translateExpression(expr.args[0]) };\n        result.descending = true;\n        return result;\n    }\n    let result = {\n        type: 'operation',\n        operator: expr.operator,\n        args: expr.args.map(translateExpression)\n    };\n    if (result.operator === 'in' || result.operator === 'notin')\n        result.args = [result.args[0]].concat([result.args.slice(1)]);\n    return result;\n}\nfunction translateTermExpression(expr) {\n    return expr.term;\n}\nfunction translateWildcardExpression(expr) {\n    return expr.wildcard;\n}\n// ------------------------- OPERATIONS -------------------------\n// these get translated in the project function\nfunction translateBoundAggregate(op) {\n    return op;\n}\nfunction translateBgp(op) {\n    let patterns = op.patterns.map(translatePattern);\n    if (patterns.length === 0)\n        return null;\n    return {\n        type: 'bgp',\n        triples: patterns\n    };\n}\nfunction translateConstruct(op) {\n    return {\n        type: 'query',\n        prefixes: {},\n        queryType: \"CONSTRUCT\",\n        template: op.template.map(translatePattern),\n        where: util_1.default.flatten([\n            translateOperation(op.input)\n        ])\n    };\n}\nfunction translateDistinct(op) {\n    let result = translateOperation(op.input);\n    // project is nested in group object\n    result.patterns[0].distinct = true;\n    return result;\n}\nfunction translateExtend(op) {\n    if (context.project) {\n        context.extend.push(op);\n        return translateOperation(op.input);\n    }\n    return util_1.default.flatten([\n        translateOperation(op.input),\n        {\n            type: 'bind',\n            variable: op.variable,\n            expression: translateExpression(op.expression)\n        }\n    ]);\n}\nfunction translateFrom(op) {\n    let result = translateOperation(op.input);\n    // project is nested in group object\n    let obj = result.patterns[0];\n    obj.from = {\n        default: op.default,\n        named: op.named\n    };\n    return result;\n}\nfunction translateFilter(op) {\n    return {\n        type: 'group',\n        patterns: util_1.default.flatten([\n            translateOperation(op.input),\n            { type: 'filter', expression: translateExpression(op.expression) }\n        ])\n    };\n}\nfunction translateGraph(op) {\n    return {\n        type: 'graph',\n        patterns: util_1.default.flatten([translateOperation(op.input)]),\n        name: op.name\n    };\n}\nfunction translateGroup(op) {\n    let input = translateOperation(op.input);\n    let aggs = op.aggregates.map(translateBoundAggregate);\n    context.aggregates.push(...aggs);\n    // TODO: apply possible extends\n    context.group.push(...op.variables);\n    return input;\n}\nfunction translateJoin(op) {\n    const arr = util_1.default.flatten([\n        translateOperation(op.left),\n        translateOperation(op.right)\n    ]);\n    // Merge bgps\n    // This is possible if one side was a path and the other a bgp for example\n    return arr.reduce((result, val) => {\n        if (val.type !== 'bgp' || result.length == 0 || result[result.length - 1].type !== 'bgp') {\n            result.push(val);\n        }\n        else {\n            result[result.length - 1].triples.push(...val.triples);\n        }\n        return result;\n    }, []);\n}\nfunction translateLeftJoin(op) {\n    let leftjoin = {\n        type: 'optional',\n        patterns: [\n            translateOperation(op.right)\n        ]\n    };\n    if (op.expression) {\n        leftjoin.patterns.push({\n            type: 'filter',\n            expression: translateExpression(op.expression)\n        });\n    }\n    leftjoin.patterns = util_1.default.flatten(leftjoin.patterns);\n    return util_1.default.flatten([\n        translateOperation(op.left),\n        leftjoin\n    ]);\n}\nfunction translateMinus(op) {\n    let patterns = translateOperation(op.right);\n    if (patterns.type === 'group')\n        patterns = patterns.patterns;\n    if (!Array.isArray(patterns))\n        patterns = [patterns];\n    return util_1.default.flatten([\n        translateOperation(op.left),\n        {\n            type: 'minus',\n            patterns: patterns\n        }\n    ]);\n}\nfunction translateOrderBy(op) {\n    context.order.push(...op.expressions);\n    return translateOperation(op.input);\n}\nfunction translatePath(op) {\n    // TODO: quads back to graph statement\n    return {\n        type: 'bgp',\n        triples: [{\n                subject: op.subject,\n                predicate: translatePathComponent(op.predicate),\n                object: op.object\n            }]\n    };\n}\nfunction translatePattern(op) {\n    return {\n        subject: op.subject,\n        predicate: op.predicate,\n        object: op.object\n    };\n}\nfunction replaceAggregatorVariables(s, map) {\n    let st = util_1.default.isTerm(s) ? translateTerm(s) : s;\n    if (typeof st === 'string') {\n        if (map[st])\n            return map[st];\n    }\n    else if (Array.isArray(s)) {\n        s = s.map(e => replaceAggregatorVariables(e, map));\n    }\n    else {\n        for (let key of Object.keys(s))\n            s[key] = replaceAggregatorVariables(s[key], map);\n    }\n    return s;\n}\nfunction translateProject(op, type) {\n    let result = {\n        type: 'query',\n        prefixes: {}\n    };\n    if (type === types.PROJECT) {\n        result.queryType = 'SELECT';\n        result.variables = op.variables;\n    }\n    else if (type === types.ASK) {\n        result.queryType = 'ASK';\n    }\n    else if (type === types.DESCRIBE) {\n        result.queryType = 'DESCRIBE';\n        result.variables = op.terms;\n    }\n    // backup values in case of nested queries\n    // everything in extend, group, etc. is irrelevant for this project call\n    let extend = context.extend;\n    let group = context.group;\n    let aggregates = context.aggregates;\n    let order = context.order;\n    resetContext();\n    context.project = true;\n    let input = util_1.default.flatten([translateOperation(op.input)]);\n    if (input.length === 1 && input[0].type === 'group')\n        input = input[0].patterns;\n    result.where = input;\n    let aggregators = {};\n    // these can not reference each other\n    for (let agg of context.aggregates)\n        aggregators[translateTerm(agg.variable)] = translateExpression(agg);\n    // do these in reverse order since variables in one extend might apply to an expression in an other extend\n    let extensions = {};\n    for (let i = context.extend.length - 1; i >= 0; --i) {\n        let e = context.extend[i];\n        extensions[translateTerm(e.variable)] = replaceAggregatorVariables(translateExpression(e.expression), aggregators);\n    }\n    if (context.group.length > 0)\n        result.group = context.group.map(variable => {\n            let v = translateTerm(variable);\n            if (extensions[v]) {\n                let result = extensions[v];\n                delete extensions[v]; // make sure there is only 1 'AS' statement\n                return {\n                    variable,\n                    expression: result\n                };\n            }\n            return { expression: variable };\n        });\n    // descending expressions will already be in the correct format due to the structure of those\n    if (context.order.length > 0)\n        result.order = context.order.map(translateOperation).map(o => o.descending ? o : ({ expression: o }));\n    // this needs to happen after the group because it might depend on variables generated there\n    if (result.variables) {\n        result.variables = result.variables.map((term) => {\n            let v = translateTerm(term);\n            if (extensions[v])\n                return {\n                    variable: term,\n                    expression: extensions[v]\n                };\n            return term;\n        });\n        // if the * didn't match any variables this would be empty\n        if (result.variables.length === 0)\n            result.variables = [new Wildcard()];\n    }\n    // convert filter to 'having' if it contains an aggregator variable\n    // could always convert, but is nicer to use filter when possible\n    if (result.where.length > 0 && result.where[result.where.length - 1].type === 'filter') {\n        let filter = result.where[result.where.length - 1];\n        if (objectContainsValues(filter, Object.keys(aggregators))) {\n            result.having = util_1.default.flatten([replaceAggregatorVariables(filter.expression, aggregators)]);\n            result.where.splice(-1);\n        }\n    }\n    context.extend = extend;\n    context.group = group;\n    context.aggregates = aggregates;\n    context.order = order;\n    // subqueries need to be in a group\n    result = { type: 'group', patterns: [result] };\n    return result;\n}\nfunction objectContainsValues(o, vals) {\n    if (util_1.default.isTerm(o))\n        return vals.indexOf(translateTerm(o)) >= 0;\n    if (Array.isArray(o))\n        return o.some(e => objectContainsValues(e, vals));\n    if (o === Object(o))\n        return Object.keys(o).some(key => objectContainsValues(o[key], vals));\n    return vals.indexOf(o) >= 0;\n}\nfunction translateReduced(op) {\n    let result = translateOperation(op.input);\n    // project is nested in group object\n    result.patterns[0].reduced = true;\n    return result;\n}\nfunction translateService(op) {\n    let patterns = translateOperation(op.input);\n    if (patterns.type === 'group')\n        patterns = patterns.patterns;\n    if (!Array.isArray(patterns))\n        patterns = [patterns];\n    return {\n        type: 'service',\n        name: op.name,\n        silent: op.silent,\n        patterns\n    };\n}\nfunction translateSlice(op) {\n    let result = translateOperation(op.input);\n    // results can be nested in a group object\n    let obj = result;\n    if (result.type && result.type === 'group')\n        obj = result.patterns[0];\n    if (op.start !== 0)\n        obj.offset = op.start;\n    if (op.length !== undefined)\n        obj.limit = op.length;\n    return result;\n}\nfunction translateUnion(op) {\n    return {\n        type: 'union',\n        patterns: util_1.default.flatten([\n            translateOperation(op.left),\n            translateOperation(op.right)\n        ])\n    };\n}\nfunction translateValues(op) {\n    // TODO: check if handled correctly when outside of select block\n    return {\n        type: 'values',\n        values: op.bindings.map(binding => {\n            let result = {};\n            for (let v of op.variables) {\n                let s = '?' + v.value;\n                if (binding[s])\n                    result[s] = binding[s];\n                else\n                    result[s] = undefined;\n            }\n            return result;\n        })\n    };\n}\n// PATH COMPONENTS\nfunction translateAlt(path) {\n    let left = translatePathComponent(path.left);\n    let right = translatePathComponent(path.right);\n    if (left.pathType === '!' && right.pathType === '!') {\n        return {\n            type: 'path',\n            pathType: '!',\n            items: [{\n                    type: 'path',\n                    pathType: '|',\n                    items: [].concat(left.items, right.items)\n                }]\n        };\n    }\n    return {\n        type: 'path',\n        pathType: '|',\n        items: [left, right]\n    };\n}\nfunction translateInv(path) {\n    if (path.path.type === types.NPS) {\n        let npsPath = path.path;\n        let inv = npsPath.iris.map((iri) => {\n            return {\n                type: 'path',\n                pathType: '^',\n                items: [iri]\n            };\n        });\n        if (inv.length <= 1)\n            return {\n                type: 'path',\n                pathType: '!',\n                items: inv\n            };\n        return {\n            type: 'path',\n            pathType: '!',\n            items: [{\n                    type: 'path',\n                    pathType: '|',\n                    items: inv\n                }]\n        };\n    }\n    return {\n        type: 'path',\n        pathType: '^',\n        items: [translatePathComponent(path.path)]\n    };\n}\nfunction translateLink(path) {\n    return path.iri;\n}\nfunction translateNps(path) {\n    if (path.iris.length <= 1)\n        return {\n            type: 'path',\n            pathType: '!',\n            items: path.iris\n        };\n    return {\n        type: 'path',\n        pathType: '!',\n        items: [{\n                type: 'path',\n                pathType: '|',\n                items: path.iris\n            }]\n    };\n}\nfunction translateOneOrMorePath(path) {\n    return {\n        type: 'path',\n        pathType: '+',\n        items: [translatePathComponent(path.path)]\n    };\n}\nfunction translateSeq(path) {\n    return {\n        type: 'path',\n        pathType: '/',\n        items: [translatePathComponent(path.left), translatePathComponent(path.right)]\n    };\n}\nfunction translateZeroOrMorePath(path) {\n    return {\n        type: 'path',\n        pathType: '*',\n        items: [translatePathComponent(path.path)]\n    };\n}\nfunction translateZeroOrOnePath(path) {\n    return {\n        type: 'path',\n        pathType: '?',\n        items: [translatePathComponent(path.path)]\n    };\n}\n// UPDATE OPERATIONS\nfunction translateCompositeUpdate(op) {\n    const updates = op.updates.map(update => {\n        const result = translateOperation(update);\n        return result.updates[0];\n    });\n    return { prefixes: {}, type: 'update', updates };\n}\nfunction translateDeleteInsert(op) {\n    let where = op.where;\n    let using = undefined;\n    if (where && where.type === types.FROM) {\n        let from = op.where;\n        where = from.input;\n        using = { default: from.default, named: from.named };\n    }\n    const updates = [{\n            updateType: 'insertdelete',\n            delete: convertUpdatePatterns(op.delete),\n            insert: convertUpdatePatterns(op.insert),\n        }];\n    if (using)\n        updates[0].using = using;\n    // corresponds to empty array in SPARQL.js\n    if (!where || (where.type === types.BGP && where.patterns.length === 0))\n        updates[0].where = [];\n    else {\n        const graphs = {};\n        let result = translateOperation(removeQuadsRecursive(where, graphs));\n        if (result.type === 'group')\n            updates[0].where = result.patterns;\n        else\n            updates[0].where = [result];\n        // graph might not be applied yet since there was no project\n        // this can only happen if there was a single graph\n        const graphNames = Object.keys(graphs);\n        if (graphNames.length > 0) {\n            if (graphNames.length !== 1)\n                throw new Error('This is unexpected and might indicate an error in graph handling for updates.');\n            // ignore if default graph\n            if (graphs[graphNames[0]].graph.value !== '')\n                updates[0].where = [{ type: 'graph', patterns: updates[0].where, name: graphs[graphNames[0]].graph }];\n        }\n    }\n    // not really necessary but can give cleaner looking queries\n    if (!op.delete && !op.where) {\n        updates[0].updateType = 'insert';\n        delete updates[0].delete;\n        delete updates[0].where;\n    }\n    else if (!op.insert && !op.where) {\n        delete updates[0].insert;\n        delete updates[0].where;\n        if (op.delete.some(pattern => pattern.subject.termType === 'Variable' ||\n            pattern.predicate.termType === 'Variable' ||\n            pattern.object.termType === 'Variable'))\n            updates[0].updateType = 'deletewhere';\n        else\n            updates[0].updateType = 'delete';\n    }\n    else if (!op.insert && op.where && op.where.type === 'bgp') {\n        if (rdf_isomorphic_1.isomorphic(op.delete, op.where.patterns)) {\n            delete updates[0].where;\n            updates[0].updateType = 'deletewhere';\n        }\n    }\n    return { prefixes: {}, type: 'update', updates };\n}\nfunction translateLoad(op) {\n    const updates = [{ type: 'load', silent: Boolean(op.silent), source: op.source }];\n    if (op.destination)\n        updates[0].destination = op.destination;\n    return { prefixes: {}, type: 'update', updates };\n}\nfunction translateClear(op) {\n    return translateClearCreateDrop(op, 'clear');\n}\nfunction translateCreate(op) {\n    return translateClearCreateDrop(op, 'create');\n}\nfunction translateDrop(op) {\n    return translateClearCreateDrop(op, 'drop');\n}\nfunction translateClearCreateDrop(op, type) {\n    const updates = [{ type, silent: Boolean(op.silent) }];\n    if (op.source === 'DEFAULT')\n        updates[0].graph = { default: true };\n    else if (op.source === 'NAMED')\n        updates[0].graph = { named: true };\n    else if (op.source === 'ALL')\n        updates[0].graph = { all: true };\n    else\n        updates[0].graph = { type: 'graph', name: op.source };\n    return { prefixes: {}, type: 'update', updates };\n}\nfunction translateAdd(op) {\n    return translateUpdateGraphShortcut(op, 'add');\n}\nfunction translateMove(op) {\n    return translateUpdateGraphShortcut(op, 'move');\n}\nfunction translateCopy(op) {\n    return translateUpdateGraphShortcut(op, 'copy');\n}\nfunction translateUpdateGraphShortcut(op, type) {\n    const updates = [{ type, silent: Boolean(op.silent) }];\n    updates[0].source = op.source === 'DEFAULT' ? { type: 'graph', default: true } : { type: 'graph', name: op.source };\n    updates[0].destination = op.destination === 'DEFAULT' ? { type: 'graph', default: true } : { type: 'graph', name: op.destination };\n    return { prefixes: {}, type: 'update', updates };\n}\n// similar to removeQuads but more simplified for UPDATEs\nfunction convertUpdatePatterns(patterns) {\n    if (!patterns)\n        return [];\n    const graphs = {};\n    patterns.forEach(pattern => {\n        const graph = pattern.graph.value;\n        if (!graphs[graph])\n            graphs[graph] = [];\n        graphs[graph].push(pattern);\n    });\n    return Object.keys(graphs).map(graph => {\n        if (graph === '')\n            return { type: 'bgp', triples: graphs[graph].map(translatePattern) };\n        return { type: 'graph', triples: graphs[graph].map(translatePattern), name: graphs[graph][0].graph };\n    });\n}\nfunction removeQuads(op) {\n    return removeQuadsRecursive(op, {});\n}\n// remove quads\nfunction removeQuadsRecursive(op, graphs) {\n    if (Array.isArray(op))\n        return op.map(sub => removeQuadsRecursive(sub, graphs));\n    if (!op.type)\n        return op;\n    // UPDATE operations with Patterns handle graphs a bit differently\n    if (op.type === types.DELETE_INSERT)\n        return op;\n    if ((op.type === types.PATTERN || op.type === types.PATH) && op.graph) {\n        if (!graphs[op.graph.value])\n            graphs[op.graph.value] = { graph: op.graph, values: [] };\n        graphs[op.graph.value].values.push(op);\n        return op;\n    }\n    const result = {};\n    const keyGraphs = {}; // unique graph per key\n    const globalNames = {}; // track all the unique graph names for the entire Operation\n    for (let key of Object.keys(op)) {\n        const newGraphs = {};\n        result[key] = removeQuadsRecursive(op[key], newGraphs);\n        const graphNames = Object.keys(newGraphs);\n        // create graph statements if multiple graphs are found\n        if (graphNames.length > 1) {\n            // nest joins\n            let left = potentialGraphFromPatterns(newGraphs[graphNames[0]].values);\n            for (let i = 1; i < graphNames.length; ++i) {\n                const right = potentialGraphFromPatterns(newGraphs[graphNames[i]].values);\n                left = factory.createJoin(left, right);\n            }\n            graphNames.map(name => delete newGraphs[name]);\n            // this ignores the result object that is being generated, but should not be a problem\n            // is only an issue for objects that have 2 keys where this can occur, which is none\n            return left;\n        }\n        else if (graphNames.length === 1) {\n            const graph = newGraphs[graphNames[0]].graph;\n            keyGraphs[key] = graph;\n            globalNames[graph.value] = graph;\n        }\n    }\n    const graphNameSet = Object.keys(globalNames);\n    if (graphNameSet.length > 0) {\n        // also need to create graph statement if we are at the edge of the query\n        if (graphNameSet.length === 1 && op.type !== types.PROJECT)\n            graphs[graphNameSet[0]] = { graph: globalNames[graphNameSet[0]], values: [result] };\n        else {\n            // multiple graphs (or project), need to create graph objects for them\n            for (let key of Object.keys(keyGraphs))\n                if (keyGraphs[key].value.length > 0)\n                    result[key] = factory.createGraph(result[key], keyGraphs[key]);\n        }\n    }\n    return result;\n}\nfunction potentialGraphFromPatterns(patterns) {\n    const bgp = factory.createBgp(patterns);\n    const name = patterns[0].graph;\n    if (name.value.length === 0)\n        return bgp;\n    return factory.createGraph(bgp, name);\n}\n//# sourceMappingURL=sparql.js.map"]},"metadata":{},"sourceType":"script"}