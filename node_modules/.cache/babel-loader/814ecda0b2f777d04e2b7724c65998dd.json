{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.specialDefinitions = void 0;\n\nconst immutable_1 = require(\"immutable\");\n\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n\nconst uuid = require(\"uuid\");\n\nconst E = require(\"../expressions\");\n\nconst C = require(\"../util/Consts\");\n\nconst Err = require(\"../util/Errors\");\n\nconst Helpers_1 = require(\"./Helpers\");\n\nconst index_1 = require(\"./index\"); // ----------------------------------------------------------------------------\n// Functional forms\n// ----------------------------------------------------------------------------\n\n\nfunction _bound({\n  args,\n  mapping\n}) {\n  const variable = args[0];\n\n  if (variable.expressionType !== E.ExpressionType.Variable) {\n    throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BOUND);\n  }\n\n  const val = mapping.has(variable.name) && !!mapping.get(variable.name);\n  return Helpers_1.bool(val);\n} // BOUND ----------------------------------------------------------------------\n\n\nconst bound = {\n  arity: 1,\n\n  async applyAsync({\n    args,\n    mapping\n  }) {\n    return _bound({\n      args,\n      mapping\n    });\n  },\n\n  applySync({\n    args,\n    mapping\n  }) {\n    return _bound({\n      args,\n      mapping\n    });\n  }\n\n}; // IF -------------------------------------------------------------------------\n\nconst ifSPARQL = {\n  arity: 3,\n\n  async applyAsync({\n    args,\n    mapping,\n    evaluate\n  }) {\n    const valFirst = await evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return ebv ? evaluate(args[1], mapping) : evaluate(args[2], mapping);\n  },\n\n  applySync({\n    args,\n    mapping,\n    evaluate\n  }) {\n    const valFirst = evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return ebv ? evaluate(args[1], mapping) : evaluate(args[2], mapping);\n  }\n\n}; // COALESCE -------------------------------------------------------------------\n\nconst coalesce = {\n  arity: Infinity,\n\n  async applyAsync({\n    args,\n    mapping,\n    evaluate\n  }) {\n    const errors = [];\n\n    for (const expr of args) {\n      try {\n        return await evaluate(expr, mapping);\n      } catch (err) {\n        errors.push(err);\n      }\n    }\n\n    throw new Err.CoalesceError(errors);\n  },\n\n  applySync({\n    args,\n    mapping,\n    evaluate\n  }) {\n    const errors = [];\n\n    for (const expr of args) {\n      try {\n        return evaluate(expr, mapping);\n      } catch (err) {\n        errors.push(err);\n      }\n    }\n\n    throw new Err.CoalesceError(errors);\n  }\n\n}; // logical-or (||) ------------------------------------------------------------\n// https://www.w3.org/TR/sparql11-query/#func-logical-or\n\nconst logicalOr = {\n  arity: 2,\n\n  async applyAsync({\n    args,\n    mapping,\n    evaluate\n  }) {\n    const [leftExpr, rightExpr] = args;\n\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n\n      if (left) {\n        return Helpers_1.bool(true);\n      }\n\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return Helpers_1.bool(right);\n    } catch (leftErr) {\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n\n      if (!right) {\n        throw leftErr;\n      }\n\n      return Helpers_1.bool(true);\n    }\n  },\n\n  applySync({\n    args,\n    mapping,\n    evaluate\n  }) {\n    const [leftExpr, rightExpr] = args;\n\n    try {\n      const leftTerm = evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n\n      if (left) {\n        return Helpers_1.bool(true);\n      }\n\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return Helpers_1.bool(right);\n    } catch (leftErr) {\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n\n      if (!right) {\n        throw leftErr;\n      }\n\n      return Helpers_1.bool(true);\n    }\n  }\n\n}; // logical-and (&&) -----------------------------------------------------------\n// https://www.w3.org/TR/sparql11-query/#func-logical-and\n\nconst logicalAnd = {\n  arity: 2,\n\n  async applyAsync({\n    args,\n    mapping,\n    evaluate\n  }) {\n    const [leftExpr, rightExpr] = args;\n\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n\n      if (!left) {\n        return Helpers_1.bool(false);\n      }\n\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return Helpers_1.bool(right);\n    } catch (leftErr) {\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n\n      if (right) {\n        throw leftErr;\n      }\n\n      return Helpers_1.bool(false);\n    }\n  },\n\n  applySync({\n    args,\n    mapping,\n    evaluate\n  }) {\n    const [leftExpr, rightExpr] = args;\n\n    try {\n      const leftTerm = evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n\n      if (!left) {\n        return Helpers_1.bool(false);\n      }\n\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return Helpers_1.bool(right);\n    } catch (leftErr) {\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n\n      if (right) {\n        throw leftErr;\n      }\n\n      return Helpers_1.bool(false);\n    }\n  }\n\n}; // sameTerm -------------------------------------------------------------------\n\nconst sameTerm = {\n  arity: 2,\n\n  async applyAsync({\n    args,\n    mapping,\n    evaluate\n  }) {\n    const [leftExpr, rightExpr] = args.map(a => evaluate(a, mapping));\n    const left = await leftExpr;\n    const right = await rightExpr;\n    return Helpers_1.bool(left.toRDF().equals(right.toRDF()));\n  },\n\n  applySync({\n    args,\n    mapping,\n    evaluate\n  }) {\n    const [left, right] = args.map(a => evaluate(a, mapping));\n    return Helpers_1.bool(left.toRDF().equals(right.toRDF()));\n  }\n\n}; // IN -------------------------------------------------------------------------\n\nconst inSPARQL = {\n  arity: Infinity,\n\n  checkArity(args) {\n    return args.length >= 1;\n  },\n\n  async applyAsync({\n    args,\n    mapping,\n    evaluate,\n    context\n  }) {\n    const [leftExpr, ...remaining] = args;\n    const left = await evaluate(leftExpr, mapping);\n    return inRecursiveAsync(left, {\n      args: remaining,\n      mapping,\n      evaluate,\n      context\n    }, []);\n  },\n\n  applySync({\n    args,\n    mapping,\n    evaluate,\n    context\n  }) {\n    const [leftExpr, ...remaining] = args;\n    const left = evaluate(leftExpr, mapping);\n    return inRecursiveSync(left, {\n      args: remaining,\n      mapping,\n      evaluate,\n      context\n    }, []);\n  }\n\n};\n\nasync function inRecursiveAsync(needle, {\n  args,\n  mapping,\n  evaluate,\n  context\n}, results) {\n  if (args.length === 0) {\n    const noErrors = results.every(v => !v);\n    return noErrors ? Helpers_1.bool(false) : Promise.reject(new Err.InError(results));\n  }\n\n  try {\n    const next = await evaluate(args.shift(), mapping);\n    const isEqual = index_1.regularFunctions.get(C.RegularOperator.EQUAL);\n\n    if (isEqual.apply([needle, next]).typedValue === true) {\n      return Helpers_1.bool(true);\n    } else {\n      return inRecursiveAsync(needle, {\n        args,\n        mapping,\n        evaluate,\n        context\n      }, [...results, false]);\n    }\n  } catch (err) {\n    return inRecursiveAsync(needle, {\n      args,\n      mapping,\n      evaluate,\n      context\n    }, [...results, err]);\n  }\n}\n\nfunction inRecursiveSync(needle, {\n  args,\n  mapping,\n  evaluate,\n  context\n}, results) {\n  if (args.length === 0) {\n    const noErrors = results.every(v => !v);\n\n    if (noErrors) {\n      Helpers_1.bool(false);\n    } else {\n      throw new Err.InError(results);\n    }\n  }\n\n  try {\n    const next = evaluate(args.shift(), mapping);\n    const isEqual = index_1.regularFunctions.get(C.RegularOperator.EQUAL);\n\n    if (isEqual.apply([needle, next]).typedValue === true) {\n      return Helpers_1.bool(true);\n    } else {\n      return inRecursiveSync(needle, {\n        args,\n        mapping,\n        evaluate,\n        context\n      }, [...results, false]);\n    }\n  } catch (err) {\n    return inRecursiveSync(needle, {\n      args,\n      mapping,\n      evaluate,\n      context\n    }, [...results, err]);\n  }\n} // NOT IN ---------------------------------------------------------------------\n\n\nconst notInSPARQL = {\n  arity: Infinity,\n\n  checkArity(args) {\n    return args.length >= 1;\n  },\n\n  async applyAsync(context) {\n    const _in = index_1.specialFunctions.get(C.SpecialOperator.IN);\n\n    const isIn = await _in.applyAsync(context);\n    return Helpers_1.bool(!isIn.typedValue);\n  },\n\n  applySync(context) {\n    const _in = index_1.specialFunctions.get(C.SpecialOperator.IN);\n\n    const isIn = _in.applySync(context);\n\n    return Helpers_1.bool(!isIn.typedValue);\n  }\n\n}; // ----------------------------------------------------------------------------\n// Annoying functions\n// ----------------------------------------------------------------------------\n// CONCAT\n\nconst concat = {\n  arity: Infinity,\n\n  async applyAsync({\n    args,\n    evaluate,\n    mapping\n  }) {\n    const pLits = args.map(async expr => evaluate(expr, mapping)).map(async pTerm => Helpers_1.typeCheckLit(await pTerm, ['string', 'langString'], args, C.SpecialOperator.CONCAT));\n    const lits = await Promise.all(pLits);\n    const strings = lits.map(lit => lit.typedValue);\n    const joined = strings.join('');\n    const lang = langAllEqual(lits) ? lits[0].language : undefined;\n    return lang ? Helpers_1.langString(joined, lang) : Helpers_1.string(joined);\n  },\n\n  applySync({\n    args,\n    evaluate,\n    mapping\n  }) {\n    const lits = args.map(expr => evaluate(expr, mapping)).map(pTerm => Helpers_1.typeCheckLit(pTerm, ['string', 'langString'], args, C.SpecialOperator.CONCAT));\n    const strings = lits.map(lit => lit.typedValue);\n    const joined = strings.join('');\n    const lang = langAllEqual(lits) ? lits[0].language : undefined;\n    return lang ? Helpers_1.langString(joined, lang) : Helpers_1.string(joined);\n  }\n\n};\n\nfunction langAllEqual(lits) {\n  return lits.length > 0 && lits.every(lit => lit.language === lits[0].language);\n} // ----------------------------------------------------------------------------\n// Context dependant functions\n// ----------------------------------------------------------------------------\n\n\nconst now = {\n  arity: 0,\n\n  async applyAsync({\n    context\n  }) {\n    return new E.DateTimeLiteral(context.now, context.now.toISOString());\n  },\n\n  applySync({\n    context\n  }) {\n    return new E.DateTimeLiteral(context.now, context.now.toISOString());\n  }\n\n}; // https://www.w3.org/TR/sparql11-query/#func-iri\n\nconst IRI = {\n  arity: 1,\n\n  async applyAsync({\n    args,\n    evaluate,\n    mapping,\n    context\n  }) {\n    const input = await evaluate(args[0], mapping);\n    return IRI_(input, context.baseIRI, args);\n  },\n\n  applySync({\n    args,\n    evaluate,\n    mapping,\n    context\n  }) {\n    const input = evaluate(args[0], mapping);\n    return IRI_(input, context.baseIRI, args);\n  }\n\n};\n\nfunction IRI_(input, baseIRI, args) {\n  const lit = input.termType !== 'namedNode' ? Helpers_1.typeCheckLit(input, ['string'], args, C.SpecialOperator.IRI) : input;\n  const iri = relative_to_absolute_iri_1.resolve(lit.str(), baseIRI || '');\n  return new E.NamedNode(iri);\n} // https://www.w3.org/TR/sparql11-query/#func-bnode\n// id has to be distinct over all id's in dataset\n\n\nconst BNODE = {\n  arity: Infinity,\n\n  checkArity(args) {\n    return args.length === 0 || args.length === 1;\n  },\n\n  async applyAsync({\n    args,\n    evaluate,\n    mapping,\n    context\n  }) {\n    const input = args.length === 1 ? await evaluate(args[0], mapping) : undefined;\n    const strInput = input ? Helpers_1.typeCheckLit(input, ['string'], args, C.SpecialOperator.BNODE).str() : undefined;\n\n    if (context.bnode) {\n      const bnode = await context.bnode(strInput);\n      return new E.BlankNode(bnode);\n    }\n\n    return BNODE_(strInput);\n  },\n\n  applySync({\n    args,\n    evaluate,\n    mapping,\n    context\n  }) {\n    const input = args.length === 1 ? evaluate(args[0], mapping) : undefined;\n    const strInput = input ? Helpers_1.typeCheckLit(input, ['string'], args, C.SpecialOperator.BNODE).str() : undefined;\n\n    if (context.bnode) {\n      const bnode = context.bnode(strInput);\n      return new E.BlankNode(bnode);\n    }\n\n    return BNODE_(strInput);\n  }\n\n};\n\nfunction BNODE_(input) {\n  return new E.BlankNode(input || uuid.v4());\n}\n\nconst _specialDefinitions = {\n  // --------------------------------------------------------------------------\n  // Functional Forms\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  'bound': bound,\n  'if': ifSPARQL,\n  'coalesce': coalesce,\n  '&&': logicalAnd,\n  '||': logicalOr,\n  'sameterm': sameTerm,\n  'in': inSPARQL,\n  'notin': notInSPARQL,\n  // Annoying functions\n  'concat': concat,\n  // Context dependent functions\n  'now': now,\n  'iri': IRI,\n  'uri': IRI,\n  'BNODE': BNODE\n};\nexports.specialDefinitions = immutable_1.Map(_specialDefinitions);","map":{"version":3,"sources":["../../../lib/functions/SpecialFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["import { Map } from 'immutable';\nimport {resolve as resolveRelativeIri} from \"relative-to-absolute-iri\";\nimport * as uuid from 'uuid';\n\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport { Bindings } from '../Types';\nimport { bool, langString, string, typeCheckLit } from './Helpers';\nimport { regularFunctions, specialFunctions } from './index';\n\ntype Term = E.TermExpression;\ntype PTerm = Promise<E.TermExpression>;\n\n// ----------------------------------------------------------------------------\n// Functional forms\n// ----------------------------------------------------------------------------\n\nfunction _bound({ args, mapping }: { args: E.Expression[], mapping: Bindings }) {\n  const variable = args[0] as E.VariableExpression;\n  if (variable.expressionType !== E.ExpressionType.Variable) {\n    throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BOUND);\n  }\n  const val = mapping.has(variable.name) && !!mapping.get(variable.name);\n  return bool(val);\n}\n\n// BOUND ----------------------------------------------------------------------\nconst bound = {\n  arity: 1,\n  async applyAsync({ args, mapping }: E.EvalContextAsync): PTerm {\n    return _bound({ args, mapping });\n  },\n  applySync({ args, mapping }: E.EvalContextSync): Term {\n    return _bound({ args, mapping });\n  },\n};\n\n// IF -------------------------------------------------------------------------\nconst ifSPARQL = {\n  arity: 3,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const valFirst = await evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return (ebv)\n      ? evaluate(args[1], mapping)\n      : evaluate(args[2], mapping);\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const valFirst = evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return (ebv)\n      ? evaluate(args[1], mapping)\n      : evaluate(args[2], mapping);\n  },\n};\n\n// COALESCE -------------------------------------------------------------------\nconst coalesce = {\n  arity: Infinity,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const errors: Error[] = [];\n    for (const expr of args) {\n      try {\n        return await evaluate(expr, mapping);\n      } catch (err) {\n        errors.push(err);\n      }\n    }\n    throw new Err.CoalesceError(errors);\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const errors: Error[] = [];\n    for (const expr of args) {\n      try {\n        return evaluate(expr, mapping);\n      } catch (err) {\n        errors.push(err);\n      }\n    }\n    throw new Err.CoalesceError(errors);\n  },\n};\n\n// logical-or (||) ------------------------------------------------------------\n// https://www.w3.org/TR/sparql11-query/#func-logical-or\nconst logicalOr = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const [leftExpr, rightExpr] = args;\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (left) { return bool(true); }\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (leftErr) {\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      if (!right) { throw leftErr; }\n      return bool(true);\n    }\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const [leftExpr, rightExpr] = args;\n    try {\n      const leftTerm = evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (left) { return bool(true); }\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (leftErr) {\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      if (!right) { throw leftErr; }\n      return bool(true);\n    }\n  },\n};\n\n// logical-and (&&) -----------------------------------------------------------\n// https://www.w3.org/TR/sparql11-query/#func-logical-and\nconst logicalAnd = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const [leftExpr, rightExpr] = args;\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (!left) { return bool(false); }\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (leftErr) {\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      if (right) { throw leftErr; }\n      return bool(false);\n    }\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const [leftExpr, rightExpr] = args;\n    try {\n      const leftTerm = evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (!left) { return bool(false); }\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (leftErr) {\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      if (right) { throw leftErr; }\n      return bool(false);\n    }\n  },\n};\n\n// sameTerm -------------------------------------------------------------------\nconst sameTerm = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const [leftExpr, rightExpr] = args.map((a) => evaluate(a, mapping));\n    const left = await leftExpr;\n    const right = await rightExpr;\n    return bool(left.toRDF().equals(right.toRDF()));\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const [left, right] = args.map((a) => evaluate(a, mapping));\n    return bool(left.toRDF().equals(right.toRDF()));\n  },\n};\n\n// IN -------------------------------------------------------------------------\nconst inSPARQL = {\n  arity: Infinity,\n  checkArity(args: E.Expression[]) { return args.length >= 1; },\n  async applyAsync({ args, mapping, evaluate, context }: E.EvalContextAsync): PTerm {\n    const [leftExpr, ...remaining] = args;\n    const left = await evaluate(leftExpr, mapping);\n    return inRecursiveAsync(left, { args: remaining, mapping, evaluate, context }, []);\n  },\n  applySync({ args, mapping, evaluate, context }: E.EvalContextSync): Term {\n    const [leftExpr, ...remaining] = args;\n    const left = evaluate(leftExpr, mapping);\n    return inRecursiveSync(left, { args: remaining, mapping, evaluate, context }, []);\n  },\n};\n\nasync function inRecursiveAsync(\n  needle: Term,\n  { args, mapping, evaluate, context }: E.EvalContextAsync,\n  results: Array<Error | false>,\n): PTerm {\n\n  if (args.length === 0) {\n    const noErrors = results.every((v) => !v);\n    return (noErrors) ? bool(false) : Promise.reject(new Err.InError(results));\n  }\n\n  try {\n    const next = await evaluate(args.shift(), mapping);\n    const isEqual = regularFunctions.get(C.RegularOperator.EQUAL);\n    if ((isEqual.apply([needle, next]) as E.BooleanLiteral).typedValue === true) {\n      return bool(true);\n    } else {\n      return inRecursiveAsync(needle, { args, mapping, evaluate, context }, [...results, false]);\n    }\n  } catch (err) {\n    return inRecursiveAsync(needle, { args, mapping, evaluate, context }, [...results, err]);\n  }\n}\n\nfunction inRecursiveSync(\n  needle: Term,\n  { args, mapping, evaluate, context }: E.EvalContextSync,\n  results: Array<Error | false>,\n): Term {\n\n  if (args.length === 0) {\n    const noErrors = results.every((v) => !v);\n    if (noErrors) {\n      bool(false);\n    } else {\n      throw new Err.InError(results);\n    }\n  }\n\n  try {\n    const next = evaluate(args.shift(), mapping);\n    const isEqual = regularFunctions.get(C.RegularOperator.EQUAL);\n    if ((isEqual.apply([needle, next]) as E.BooleanLiteral).typedValue === true) {\n      return bool(true);\n    } else {\n      return inRecursiveSync(needle, { args, mapping, evaluate, context }, [...results, false]);\n    }\n  } catch (err) {\n    return inRecursiveSync(needle, { args, mapping, evaluate, context }, [...results, err]);\n  }\n}\n\n// NOT IN ---------------------------------------------------------------------\nconst notInSPARQL = {\n  arity: Infinity,\n  checkArity(args: E.Expression[]) { return args.length >= 1; },\n  async applyAsync(context: E.EvalContextAsync): PTerm {\n    const _in = specialFunctions.get(C.SpecialOperator.IN);\n    const isIn = await _in.applyAsync(context);\n    return bool(!(isIn as E.BooleanLiteral).typedValue);\n  },\n  applySync(context: E.EvalContextSync): Term {\n    const _in = specialFunctions.get(C.SpecialOperator.IN);\n    const isIn = _in.applySync(context);\n    return bool(!(isIn as E.BooleanLiteral).typedValue);\n  },\n};\n\n// ----------------------------------------------------------------------------\n// Annoying functions\n// ----------------------------------------------------------------------------\n\n// CONCAT\nconst concat = {\n  arity: Infinity,\n  async applyAsync({ args, evaluate, mapping }: E.EvalContextAsync): PTerm {\n    const pLits = args\n      .map(async (expr) => evaluate(expr, mapping))\n      .map(async (pTerm) =>\n        typeCheckLit<string>(await pTerm, ['string', 'langString'], args, C.SpecialOperator.CONCAT));\n    const lits = await Promise.all(pLits);\n    const strings = lits.map((lit) => lit.typedValue);\n    const joined = strings.join('');\n    const lang = langAllEqual(lits) ? lits[0].language : undefined;\n    return (lang) ? langString(joined, lang) : string(joined);\n  },\n\n  applySync({ args, evaluate, mapping }: E.EvalContextSync): Term {\n    const lits = args\n      .map((expr) => evaluate(expr, mapping))\n      .map((pTerm) => typeCheckLit<string>(pTerm, ['string', 'langString'], args, C.SpecialOperator.CONCAT));\n    const strings = lits.map((lit) => lit.typedValue);\n    const joined = strings.join('');\n    const lang = langAllEqual(lits) ? lits[0].language : undefined;\n    return (lang) ? langString(joined, lang) : string(joined);\n  },\n};\n\nfunction langAllEqual(lits: Array<E.Literal<string>>): boolean {\n  return lits.length > 0 && lits.every((lit) => lit.language === lits[0].language);\n}\n\n// ----------------------------------------------------------------------------\n// Context dependant functions\n// ----------------------------------------------------------------------------\n\nconst now = {\n  arity: 0,\n  async applyAsync({ context }: E.EvalContextAsync): PTerm {\n    return new E.DateTimeLiteral(context.now, context.now.toISOString());\n  },\n  applySync({ context }: E.EvalContextSync): Term {\n    return new E.DateTimeLiteral(context.now, context.now.toISOString());\n  },\n};\n\n// https://www.w3.org/TR/sparql11-query/#func-iri\nconst IRI = {\n  arity: 1,\n  async applyAsync({ args, evaluate, mapping, context }: E.EvalContextAsync): PTerm {\n    const input = await evaluate(args[0], mapping);\n    return IRI_(input, context.baseIRI, args);\n  },\n  applySync({ args, evaluate, mapping, context }: E.EvalContextSync): Term {\n    const input = evaluate(args[0], mapping);\n    return IRI_(input, context.baseIRI, args);\n  },\n};\n\nfunction IRI_(input: Term, baseIRI: string | undefined, args: E.Expression[]): Term {\n  const lit = (input.termType !== 'namedNode')\n    ? typeCheckLit<string>(input, ['string'], args, C.SpecialOperator.IRI)\n    : input as E.NamedNode;\n\n  const iri = resolveRelativeIri(lit.str(), baseIRI || '');\n  return new E.NamedNode(iri);\n}\n\n// https://www.w3.org/TR/sparql11-query/#func-bnode\n// id has to be distinct over all id's in dataset\nconst BNODE = {\n  arity: Infinity,\n  checkArity(args: E.Expression[]) { return args.length === 0 || args.length === 1; },\n  async applyAsync({ args, evaluate, mapping, context }: E.EvalContextAsync): PTerm {\n    const input = (args.length === 1)\n      ? await evaluate(args[0], mapping)\n      : undefined;\n\n    const strInput = (input)\n      ? typeCheckLit(input, ['string'], args, C.SpecialOperator.BNODE).str()\n      : undefined;\n\n    if (context.bnode) {\n      const bnode = await context.bnode(strInput);\n      return new E.BlankNode(bnode);\n    }\n\n    return BNODE_(strInput);\n  },\n  applySync({ args, evaluate, mapping, context }: E.EvalContextSync): Term {\n    const input = (args.length === 1)\n      ? evaluate(args[0], mapping)\n      : undefined;\n\n    const strInput = (input)\n      ? typeCheckLit(input, ['string'], args, C.SpecialOperator.BNODE).str()\n      : undefined;\n\n    if (context.bnode) {\n      const bnode = context.bnode(strInput);\n      return new E.BlankNode(bnode);\n    }\n\n    return BNODE_(strInput);\n  },\n};\n\nfunction BNODE_(input?: string): E.BlankNode {\n  return new E.BlankNode(input || uuid.v4());\n}\n\n// ----------------------------------------------------------------------------\n// Wrap these declarations into functions\n// ----------------------------------------------------------------------------\n\nexport type SpecialDefinition = {\n  arity: number;\n  applyAsync: E.SpecialApplicationAsync;\n  applySync: E.SpecialApplicationSync; // TODO: Test these implementations\n  checkArity?: (args: E.Expression[]) => boolean;\n};\n\nconst _specialDefinitions: { [key in C.SpecialOperator]: SpecialDefinition } = {\n  // --------------------------------------------------------------------------\n  // Functional Forms\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  'bound': bound,\n  'if': ifSPARQL,\n  'coalesce': coalesce,\n  '&&': logicalAnd,\n  '||': logicalOr,\n  'sameterm': sameTerm,\n  'in': inSPARQL,\n  'notin': notInSPARQL,\n\n  // Annoying functions\n  'concat': concat,\n\n  // Context dependent functions\n  'now': now,\n  'iri': IRI,\n  'uri': IRI,\n  'BNODE': BNODE,\n};\n\nexport const specialDefinitions = Map<C.SpecialOperator, SpecialDefinition>(_specialDefinitions);\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}