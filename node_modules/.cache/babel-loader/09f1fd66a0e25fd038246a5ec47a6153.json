{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTermGrounded = exports.termToSignature = exports.quadToSignature = exports.sha1hex = exports.hashTerm = exports.hashTerms = exports.getGraphBlankNodes = exports.uniqGraph = exports.deindexGraph = exports.indexGraph = exports.getQuadsWithoutBlankNodes = exports.getQuadsWithBlankNodes = exports.hasValue = exports.hashValues = exports.getBijectionInner = exports.getBijection = exports.isomorphic = void 0;\n\nconst hash_js_1 = require(\"hash.js\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst rdf_terms_1 = require(\"rdf-terms\");\n/**\n * Determines if the two given graphs are isomorphic.\n *\n * @param {Quad[]} graphA An array of quads, order is not important.\n * @param {Quad[]} graphB An array of quads, order is not important.\n * @return {boolean} If the two given graphs are isomorphic.\n */\n\n\nfunction isomorphic(graphA, graphB) {\n  return !!getBijection(graphA, graphB);\n}\n\nexports.isomorphic = isomorphic;\n/**\n * Calculate a hash of graphA blank nodes to graphB blank nodes.\n * This represents a bijection from graphA's blank nodes to graphB's blank nodes.\n *\n * @param {Quad[]} graphA An array of quads, order is not important.\n * @param {Quad[]} graphB An array of quads, order is not important.\n * @return {IBijection} A hash representing a bijection, or null if none could be found.\n */\n\nfunction getBijection(graphA, graphB) {\n  // Check if all (non-blanknode-containing) quads in the two graphs are equal.\n  // We do this by creating a hash-based index for both graphs.\n  const nonBlankIndexA = indexGraph(getQuadsWithoutBlankNodes(graphA));\n  const nonBlankIndexB = indexGraph(getQuadsWithoutBlankNodes(graphB));\n\n  if (Object.keys(nonBlankIndexA).length !== Object.keys(nonBlankIndexB).length) {\n    return null;\n  }\n\n  for (const key in nonBlankIndexA) {\n    if (nonBlankIndexA[key] !== nonBlankIndexB[key]) {\n      return null;\n    }\n  } // Pre-process data that needs to be present in each iteration of getBijectionInner.\n\n\n  const blankQuadsA = uniqGraph(getQuadsWithBlankNodes(graphA));\n  const blankQuadsB = uniqGraph(getQuadsWithBlankNodes(graphB));\n  const blankNodesA = getGraphBlankNodes(graphA);\n  const blankNodesB = getGraphBlankNodes(graphB);\n  return getBijectionInner(blankQuadsA, blankQuadsB, blankNodesA, blankNodesB);\n}\n\nexports.getBijection = getBijection;\n\nfunction getBijectionInner(blankQuadsA, blankQuadsB, blankNodesA, blankNodesB, groundedHashesA, groundedHashesB) {\n  if (!groundedHashesA) {\n    groundedHashesA = {};\n  }\n\n  if (!groundedHashesB) {\n    groundedHashesB = {};\n  } // Hash every term based on the signature of the quads if appears in.\n\n\n  const [hashesA, ungroundedHashesA] = hashTerms(blankQuadsA, blankNodesA, groundedHashesA);\n  const [hashesB, ungroundedHashesB] = hashTerms(blankQuadsB, blankNodesB, groundedHashesB); // Break quickly if a graph contains a grounded node that is not contained in the other graph.\n\n  if (Object.keys(hashesA).length !== Object.keys(hashesB).length) {\n    return null;\n  }\n\n  for (const hashKeyA in hashesA) {\n    if (!hasValue(hashesB, hashesA[hashKeyA])) {\n      return null;\n    }\n  } // Map the blank nodes from graph A to the blank nodes of graph B using the created hashes.\n  // Grounded hashes will also be equal, but not needed here, we will need them in the next recursion\n  // (as we only recurse on grounded nodes).\n\n\n  let bijection = {};\n\n  for (const blankNodeA of blankNodesA) {\n    const blankNodeAString = rdf_string_1.termToString(blankNodeA);\n    const blankNodeAHash = ungroundedHashesA[blankNodeAString];\n\n    for (const blankNodeBString in ungroundedHashesB) {\n      if (ungroundedHashesB[blankNodeBString] === blankNodeAHash) {\n        bijection[blankNodeAString] = blankNodeBString;\n        delete ungroundedHashesB[blankNodeBString];\n        break;\n      }\n    }\n  } // Check if all nodes from graph A and B are present in the bijection,\n  // if not, speculatively mark pairs with matching ungrounded hashes as bijected, and recurse.\n\n\n  if (!arraysEqual(Object.keys(bijection).sort(), blankNodesA.map(rdf_string_1.termToString).sort()) || !arraysEqual(hashValues(bijection).sort(), blankNodesB.map(rdf_string_1.termToString).sort())) {\n    // I have not yet been able to find any pathological cases where this code is reached.\n    // This may be removable, but let's wait until someone proves that.\n    bijection = null;\n\n    for (const blankNodeA of blankNodesA) {\n      // Only replace ungrounded node hashes\n      const blankNodeAString = rdf_string_1.termToString(blankNodeA);\n\n      if (!hashesA[blankNodeAString]) {\n        for (const blankNodeB of blankNodesB) {\n          // Only replace ungrounded node hashes\n          const blankNodeBString = rdf_string_1.termToString(blankNodeB);\n\n          if (!hashesB[blankNodeBString]) {\n            if (ungroundedHashesA[blankNodeAString] === ungroundedHashesB[blankNodeBString]) {\n              const hash = sha1hex(blankNodeAString);\n              bijection = getBijectionInner(blankQuadsA, blankQuadsB, blankNodesA, blankNodesB, Object.assign(Object.assign({}, hashesA), {\n                [blankNodeAString]: hash\n              }), Object.assign(Object.assign({}, hashesB), {\n                [blankNodeBString]: hash\n              }));\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return bijection;\n}\n\nexports.getBijectionInner = getBijectionInner;\n\nfunction arraysEqual(array1, array2) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n\n  for (let i = array1.length; i--;) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Get all values from the given hash\n * @param hash A hash.\n * @return {any[]} The array of values.\n */\n\n\nfunction hashValues(hash) {\n  const arr = [];\n\n  for (const e in hash) {\n    arr.push(hash[e]);\n  }\n\n  return arr;\n}\n\nexports.hashValues = hashValues;\n/**\n * Check if the given hash contains the given value.\n * @param hash A hash.\n * @param {string} value A value.\n * @return {boolean} If it contains the value.\n */\n\nfunction hasValue(hash, value) {\n  for (const hashValue in hash) {\n    if (hash[hashValue] === value) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.hasValue = hasValue;\n/**\n * Get all quads with blank nodes.\n * @param {Quad[]} graph An array of quads.\n * @return {Quad[]} An array of quads with blank nodes\n */\n\nfunction getQuadsWithBlankNodes(graph) {\n  return graph.filter(quad => rdf_terms_1.someTerms(quad, value => {\n    return value.termType === 'BlankNode' || value.termType === 'Quad' && rdf_terms_1.getTermsNested(value).some(term => term.termType === 'BlankNode');\n  }));\n}\n\nexports.getQuadsWithBlankNodes = getQuadsWithBlankNodes;\n/**\n * Get all quads without blank nodes.\n * @param {Quad[]} graph An array of quads.\n * @return {Quad[]} An array of quads without blank nodes\n */\n\nfunction getQuadsWithoutBlankNodes(graph) {\n  return graph.filter(quad => rdf_terms_1.everyTerms(quad, value => {\n    return value.termType !== 'BlankNode' && !(value.termType === 'Quad' && rdf_terms_1.getTermsNested(value).some(term => term.termType === 'BlankNode'));\n  }));\n}\n\nexports.getQuadsWithoutBlankNodes = getQuadsWithoutBlankNodes;\n/**\n * Create a hash-based index of the given graph.\n * @param {Quad[]} graph An array of quads, the order does not matter.\n * @return {{[p: string]: boolean}} A hash-based datastructure representing the graph.\n */\n\nfunction indexGraph(graph) {\n  const index = {};\n\n  for (const quad of graph) {\n    index[JSON.stringify(rdf_string_1.quadToStringQuad(quad))] = true;\n  }\n\n  return index;\n}\n\nexports.indexGraph = indexGraph;\n/**\n * Create a graph from the given hash-based index.\n * @param {{[p: string]: boolean}} indexedGraph A hash-based datastructure representing the graph.\n * @return {Quad[]} An array of quads, the order does not matter.\n */\n\nfunction deindexGraph(indexedGraph) {\n  return Object.keys(indexedGraph).map(str => rdf_string_1.stringQuadToQuad(JSON.parse(str)));\n}\n\nexports.deindexGraph = deindexGraph;\n/**\n * Unique-ify the given RDF graph based on strict equality.\n * The output graph will consist of new quad and term instances.\n * @param {Quad[]} graph An input graph.\n * @return {Quad[]} The input graph without duplicates.\n */\n\nfunction uniqGraph(graph) {\n  return deindexGraph(indexGraph(graph));\n}\n\nexports.uniqGraph = uniqGraph;\n/**\n * Find all blank nodes in the given graph.\n * @param {Quad[]} graph An array of quads.\n * @return {BlankNode[]} A list of (unique) blank nodes.\n */\n\nfunction getGraphBlankNodes(graph) {\n  return rdf_terms_1.uniqTerms(graph.map(quad => rdf_terms_1.getBlankNodes(rdf_terms_1.getTermsNested(quad))).reduce((acc, val) => acc.concat(val), []));\n}\n\nexports.getGraphBlankNodes = getGraphBlankNodes;\n/**\n * Create term hashes for the given set of quads and blank node terms.\n *\n * @param {Quad[]} quads A set of quads.\n * @param {Term[]} terms Blank node terms.\n * @param {ITermHash} groundedHashes Grounded term hashes that are used to create more specific signatures\n *                                   of other terms, because they are based on non-blank nodes and grounded blank nodes.\n * @return {[ITermHash]} A tuple of grounded and ungrounded hashes.\n */\n\nfunction hashTerms(quads, terms, groundedHashes) {\n  const hashes = Object.assign({}, groundedHashes);\n  const ungroundedHashes = {};\n  let hashNeeded = true; // Iteratively mark nodes as grounded.\n  // If a node is marked as grounded, then the next iteration can lead to new grounded states\n\n  while (hashNeeded) {\n    const initialGroundedNodesCount = Object.keys(hashes).length;\n\n    for (const term of terms) {\n      const termString = rdf_string_1.termToString(term);\n\n      if (!hashes[termString]) {\n        const [grounded, hash] = hashTerm(term, quads, hashes);\n\n        if (grounded) {\n          hashes[termString] = hash;\n        }\n\n        ungroundedHashes[termString] = hash;\n      }\n    } // All terms that have a unique hash at this point can be marked as grounded\n\n\n    const uniques = {};\n\n    for (const termKey in ungroundedHashes) {\n      const hash = ungroundedHashes[termKey];\n\n      if (uniques[hash] === undefined) {\n        uniques[hash] = termKey;\n      } else {\n        uniques[hash] = false;\n      }\n    }\n\n    for (const hash in uniques) {\n      const value = uniques[hash];\n\n      if (value) {\n        hashes[value] = hash;\n      }\n    } // Check if the loop needs to terminate\n\n\n    hashNeeded = initialGroundedNodesCount !== Object.keys(hashes).length;\n  }\n\n  return [hashes, ungroundedHashes];\n}\n\nexports.hashTerms = hashTerms;\n/**\n * Generate a hash for the given term based on the signature of the quads it appears in.\n *\n * Signatures are made up of grounded terms in quads that are associated with a term,\n * i.e., everything except for ungrounded blank nodes.\n * The hash is created by hashing a sorted list of each quad's signature,\n * where each quad signature is a concatenation of the signature of all grounded terms.\n *\n * Terms are considered grounded if they are a member in the given hash AND if they are not the given term.\n *\n * @param {Term} term The term to get the hash around.\n * @param {Quad[]} quads The quads to include in the hashing.\n * @param {ITermHash} hashes A grounded term hash object.\n * @return {[boolean , string]} A tuple indicating if the given term is grounded in all the given quads, and the hash.\n */\n\nfunction hashTerm(term, quads, hashes) {\n  const quadSignatures = [];\n  let grounded = true;\n\n  for (const quad of quads) {\n    const terms = rdf_terms_1.getTermsNested(quad);\n\n    if (terms.some(quadTerm => quadTerm.equals(term))) {\n      quadSignatures.push(quadToSignature(quad, hashes, term));\n\n      for (const quadTerm of terms) {\n        if (!isTermGrounded(quadTerm, hashes) && !quadTerm.equals(term)) {\n          grounded = false;\n        }\n      }\n    }\n  }\n\n  const hash = sha1hex(quadSignatures.sort().join(''));\n  return [grounded, hash];\n}\n\nexports.hashTerm = hashTerm;\n/**\n * Create a hash using sha1 as a hex digest.\n * @param {string | Buffer | NodeJS.TypedArray | DataView} data Something to hash.\n * @return {string} A hash string.\n */\n\nfunction sha1hex(data) {\n  return hash_js_1.sha1().update(data).digest('hex');\n}\n\nexports.sha1hex = sha1hex;\n/**\n * Convert the given quad to a string signature so that it can be used in the hash structure.\n * @param {Quad} quad A quad.\n * @param {ITermHash} hashes A grounded term hash object.\n * @param {Term} term A target term to compare with.\n * @return {string} A string signature.\n */\n\nfunction quadToSignature(quad, hashes, term) {\n  return rdf_terms_1.getTerms(quad).map(quadTerm => termToSignature(quadTerm, hashes, term)).join('|');\n}\n\nexports.quadToSignature = quadToSignature;\n/**\n * Convert the given term to a string signature so that it can be used in the hash structure.\n * @param {Term} term A term.\n * @param {ITermHash} hashes A grounded term hash object.\n * @param {Term} target A target term to compare with.\n * @return {string} A string signature.\n */\n\nfunction termToSignature(term, hashes, target) {\n  if (term.equals(target)) {\n    return '@self';\n  } else if (term.termType === 'BlankNode') {\n    return hashes[rdf_string_1.termToString(term)] || '@blank';\n  } else if (term.termType === 'Quad') {\n    return `<${quadToSignature(term, hashes, target)}>`;\n  } else {\n    return rdf_string_1.termToString(term);\n  }\n}\n\nexports.termToSignature = termToSignature;\n/**\n * Check if a term is grounded.\n *\n * A term is grounded if it is not a blank node\n * or if it included in the given hash of grounded nodes.\n *\n * @param {Term} term A term.\n * @param {ITermHash} hashes A grounded term hash object.\n * @return {boolean} If the given term is grounded.\n */\n\nfunction isTermGrounded(term, hashes) {\n  return term.termType !== 'BlankNode' && !(term.termType === 'Quad' && rdf_terms_1.getTermsNested(term).some(subTerm => !isTermGrounded(subTerm, hashes))) || !!hashes[rdf_string_1.termToString(term)];\n}\n\nexports.isTermGrounded = isTermGrounded;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/rdf-isomorphic/lib/RdfIsomorphic.js"],"names":["Object","defineProperty","exports","value","isTermGrounded","termToSignature","quadToSignature","sha1hex","hashTerm","hashTerms","getGraphBlankNodes","uniqGraph","deindexGraph","indexGraph","getQuadsWithoutBlankNodes","getQuadsWithBlankNodes","hasValue","hashValues","getBijectionInner","getBijection","isomorphic","hash_js_1","require","rdf_string_1","rdf_terms_1","graphA","graphB","nonBlankIndexA","nonBlankIndexB","keys","length","key","blankQuadsA","blankQuadsB","blankNodesA","blankNodesB","groundedHashesA","groundedHashesB","hashesA","ungroundedHashesA","hashesB","ungroundedHashesB","hashKeyA","bijection","blankNodeA","blankNodeAString","termToString","blankNodeAHash","blankNodeBString","arraysEqual","sort","map","blankNodeB","hash","assign","array1","array2","i","arr","e","push","hashValue","graph","filter","quad","someTerms","termType","getTermsNested","some","term","everyTerms","index","JSON","stringify","quadToStringQuad","indexedGraph","str","stringQuadToQuad","parse","uniqTerms","getBlankNodes","reduce","acc","val","concat","quads","terms","groundedHashes","hashes","ungroundedHashes","hashNeeded","initialGroundedNodesCount","termString","grounded","uniques","termKey","undefined","quadSignatures","quadTerm","equals","join","data","sha1","update","digest","getTerms","target","subTerm"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTermGrounded = exports.termToSignature = exports.quadToSignature = exports.sha1hex = exports.hashTerm = exports.hashTerms = exports.getGraphBlankNodes = exports.uniqGraph = exports.deindexGraph = exports.indexGraph = exports.getQuadsWithoutBlankNodes = exports.getQuadsWithBlankNodes = exports.hasValue = exports.hashValues = exports.getBijectionInner = exports.getBijection = exports.isomorphic = void 0;\nconst hash_js_1 = require(\"hash.js\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst rdf_terms_1 = require(\"rdf-terms\");\n/**\n * Determines if the two given graphs are isomorphic.\n *\n * @param {Quad[]} graphA An array of quads, order is not important.\n * @param {Quad[]} graphB An array of quads, order is not important.\n * @return {boolean} If the two given graphs are isomorphic.\n */\nfunction isomorphic(graphA, graphB) {\n    return !!getBijection(graphA, graphB);\n}\nexports.isomorphic = isomorphic;\n/**\n * Calculate a hash of graphA blank nodes to graphB blank nodes.\n * This represents a bijection from graphA's blank nodes to graphB's blank nodes.\n *\n * @param {Quad[]} graphA An array of quads, order is not important.\n * @param {Quad[]} graphB An array of quads, order is not important.\n * @return {IBijection} A hash representing a bijection, or null if none could be found.\n */\nfunction getBijection(graphA, graphB) {\n    // Check if all (non-blanknode-containing) quads in the two graphs are equal.\n    // We do this by creating a hash-based index for both graphs.\n    const nonBlankIndexA = indexGraph(getQuadsWithoutBlankNodes(graphA));\n    const nonBlankIndexB = indexGraph(getQuadsWithoutBlankNodes(graphB));\n    if (Object.keys(nonBlankIndexA).length !== Object.keys(nonBlankIndexB).length) {\n        return null;\n    }\n    for (const key in nonBlankIndexA) {\n        if (nonBlankIndexA[key] !== nonBlankIndexB[key]) {\n            return null;\n        }\n    }\n    // Pre-process data that needs to be present in each iteration of getBijectionInner.\n    const blankQuadsA = uniqGraph(getQuadsWithBlankNodes(graphA));\n    const blankQuadsB = uniqGraph(getQuadsWithBlankNodes(graphB));\n    const blankNodesA = getGraphBlankNodes(graphA);\n    const blankNodesB = getGraphBlankNodes(graphB);\n    return getBijectionInner(blankQuadsA, blankQuadsB, blankNodesA, blankNodesB);\n}\nexports.getBijection = getBijection;\nfunction getBijectionInner(blankQuadsA, blankQuadsB, blankNodesA, blankNodesB, groundedHashesA, groundedHashesB) {\n    if (!groundedHashesA) {\n        groundedHashesA = {};\n    }\n    if (!groundedHashesB) {\n        groundedHashesB = {};\n    }\n    // Hash every term based on the signature of the quads if appears in.\n    const [hashesA, ungroundedHashesA] = hashTerms(blankQuadsA, blankNodesA, groundedHashesA);\n    const [hashesB, ungroundedHashesB] = hashTerms(blankQuadsB, blankNodesB, groundedHashesB);\n    // Break quickly if a graph contains a grounded node that is not contained in the other graph.\n    if (Object.keys(hashesA).length !== Object.keys(hashesB).length) {\n        return null;\n    }\n    for (const hashKeyA in hashesA) {\n        if (!hasValue(hashesB, hashesA[hashKeyA])) {\n            return null;\n        }\n    }\n    // Map the blank nodes from graph A to the blank nodes of graph B using the created hashes.\n    // Grounded hashes will also be equal, but not needed here, we will need them in the next recursion\n    // (as we only recurse on grounded nodes).\n    let bijection = {};\n    for (const blankNodeA of blankNodesA) {\n        const blankNodeAString = rdf_string_1.termToString(blankNodeA);\n        const blankNodeAHash = ungroundedHashesA[blankNodeAString];\n        for (const blankNodeBString in ungroundedHashesB) {\n            if (ungroundedHashesB[blankNodeBString] === blankNodeAHash) {\n                bijection[blankNodeAString] = blankNodeBString;\n                delete ungroundedHashesB[blankNodeBString];\n                break;\n            }\n        }\n    }\n    // Check if all nodes from graph A and B are present in the bijection,\n    // if not, speculatively mark pairs with matching ungrounded hashes as bijected, and recurse.\n    if (!arraysEqual(Object.keys(bijection).sort(), blankNodesA.map(rdf_string_1.termToString).sort())\n        || !arraysEqual(hashValues(bijection).sort(), blankNodesB.map(rdf_string_1.termToString).sort())) {\n        // I have not yet been able to find any pathological cases where this code is reached.\n        // This may be removable, but let's wait until someone proves that.\n        bijection = null;\n        for (const blankNodeA of blankNodesA) {\n            // Only replace ungrounded node hashes\n            const blankNodeAString = rdf_string_1.termToString(blankNodeA);\n            if (!hashesA[blankNodeAString]) {\n                for (const blankNodeB of blankNodesB) {\n                    // Only replace ungrounded node hashes\n                    const blankNodeBString = rdf_string_1.termToString(blankNodeB);\n                    if (!hashesB[blankNodeBString]) {\n                        if (ungroundedHashesA[blankNodeAString] === ungroundedHashesB[blankNodeBString]) {\n                            const hash = sha1hex(blankNodeAString);\n                            bijection = getBijectionInner(blankQuadsA, blankQuadsB, blankNodesA, blankNodesB, Object.assign(Object.assign({}, hashesA), { [blankNodeAString]: hash }), Object.assign(Object.assign({}, hashesB), { [blankNodeBString]: hash }));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return bijection;\n}\nexports.getBijectionInner = getBijectionInner;\nfunction arraysEqual(array1, array2) {\n    if (array1.length !== array2.length) {\n        return false;\n    }\n    for (let i = array1.length; i--;) {\n        if (array1[i] !== array2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Get all values from the given hash\n * @param hash A hash.\n * @return {any[]} The array of values.\n */\nfunction hashValues(hash) {\n    const arr = [];\n    for (const e in hash) {\n        arr.push(hash[e]);\n    }\n    return arr;\n}\nexports.hashValues = hashValues;\n/**\n * Check if the given hash contains the given value.\n * @param hash A hash.\n * @param {string} value A value.\n * @return {boolean} If it contains the value.\n */\nfunction hasValue(hash, value) {\n    for (const hashValue in hash) {\n        if (hash[hashValue] === value) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.hasValue = hasValue;\n/**\n * Get all quads with blank nodes.\n * @param {Quad[]} graph An array of quads.\n * @return {Quad[]} An array of quads with blank nodes\n */\nfunction getQuadsWithBlankNodes(graph) {\n    return graph.filter((quad) => rdf_terms_1.someTerms(quad, (value) => {\n        return value.termType === 'BlankNode'\n            || (value.termType === 'Quad' && rdf_terms_1.getTermsNested(value).some(term => term.termType === 'BlankNode'));\n    }));\n}\nexports.getQuadsWithBlankNodes = getQuadsWithBlankNodes;\n/**\n * Get all quads without blank nodes.\n * @param {Quad[]} graph An array of quads.\n * @return {Quad[]} An array of quads without blank nodes\n */\nfunction getQuadsWithoutBlankNodes(graph) {\n    return graph.filter((quad) => rdf_terms_1.everyTerms(quad, (value) => {\n        return value.termType !== 'BlankNode'\n            && !(value.termType === 'Quad' && rdf_terms_1.getTermsNested(value).some(term => term.termType === 'BlankNode'));\n    }));\n}\nexports.getQuadsWithoutBlankNodes = getQuadsWithoutBlankNodes;\n/**\n * Create a hash-based index of the given graph.\n * @param {Quad[]} graph An array of quads, the order does not matter.\n * @return {{[p: string]: boolean}} A hash-based datastructure representing the graph.\n */\nfunction indexGraph(graph) {\n    const index = {};\n    for (const quad of graph) {\n        index[JSON.stringify(rdf_string_1.quadToStringQuad(quad))] = true;\n    }\n    return index;\n}\nexports.indexGraph = indexGraph;\n/**\n * Create a graph from the given hash-based index.\n * @param {{[p: string]: boolean}} indexedGraph A hash-based datastructure representing the graph.\n * @return {Quad[]} An array of quads, the order does not matter.\n */\nfunction deindexGraph(indexedGraph) {\n    return Object.keys(indexedGraph).map((str) => rdf_string_1.stringQuadToQuad(JSON.parse(str)));\n}\nexports.deindexGraph = deindexGraph;\n/**\n * Unique-ify the given RDF graph based on strict equality.\n * The output graph will consist of new quad and term instances.\n * @param {Quad[]} graph An input graph.\n * @return {Quad[]} The input graph without duplicates.\n */\nfunction uniqGraph(graph) {\n    return deindexGraph(indexGraph(graph));\n}\nexports.uniqGraph = uniqGraph;\n/**\n * Find all blank nodes in the given graph.\n * @param {Quad[]} graph An array of quads.\n * @return {BlankNode[]} A list of (unique) blank nodes.\n */\nfunction getGraphBlankNodes(graph) {\n    return rdf_terms_1.uniqTerms(graph.map((quad) => rdf_terms_1.getBlankNodes(rdf_terms_1.getTermsNested(quad)))\n        .reduce((acc, val) => acc.concat(val), []));\n}\nexports.getGraphBlankNodes = getGraphBlankNodes;\n/**\n * Create term hashes for the given set of quads and blank node terms.\n *\n * @param {Quad[]} quads A set of quads.\n * @param {Term[]} terms Blank node terms.\n * @param {ITermHash} groundedHashes Grounded term hashes that are used to create more specific signatures\n *                                   of other terms, because they are based on non-blank nodes and grounded blank nodes.\n * @return {[ITermHash]} A tuple of grounded and ungrounded hashes.\n */\nfunction hashTerms(quads, terms, groundedHashes) {\n    const hashes = Object.assign({}, groundedHashes);\n    const ungroundedHashes = {};\n    let hashNeeded = true;\n    // Iteratively mark nodes as grounded.\n    // If a node is marked as grounded, then the next iteration can lead to new grounded states\n    while (hashNeeded) {\n        const initialGroundedNodesCount = Object.keys(hashes).length;\n        for (const term of terms) {\n            const termString = rdf_string_1.termToString(term);\n            if (!hashes[termString]) {\n                const [grounded, hash] = hashTerm(term, quads, hashes);\n                if (grounded) {\n                    hashes[termString] = hash;\n                }\n                ungroundedHashes[termString] = hash;\n            }\n        }\n        // All terms that have a unique hash at this point can be marked as grounded\n        const uniques = {};\n        for (const termKey in ungroundedHashes) {\n            const hash = ungroundedHashes[termKey];\n            if (uniques[hash] === undefined) {\n                uniques[hash] = termKey;\n            }\n            else {\n                uniques[hash] = false;\n            }\n        }\n        for (const hash in uniques) {\n            const value = uniques[hash];\n            if (value) {\n                hashes[value] = hash;\n            }\n        }\n        // Check if the loop needs to terminate\n        hashNeeded = initialGroundedNodesCount !== Object.keys(hashes).length;\n    }\n    return [hashes, ungroundedHashes];\n}\nexports.hashTerms = hashTerms;\n/**\n * Generate a hash for the given term based on the signature of the quads it appears in.\n *\n * Signatures are made up of grounded terms in quads that are associated with a term,\n * i.e., everything except for ungrounded blank nodes.\n * The hash is created by hashing a sorted list of each quad's signature,\n * where each quad signature is a concatenation of the signature of all grounded terms.\n *\n * Terms are considered grounded if they are a member in the given hash AND if they are not the given term.\n *\n * @param {Term} term The term to get the hash around.\n * @param {Quad[]} quads The quads to include in the hashing.\n * @param {ITermHash} hashes A grounded term hash object.\n * @return {[boolean , string]} A tuple indicating if the given term is grounded in all the given quads, and the hash.\n */\nfunction hashTerm(term, quads, hashes) {\n    const quadSignatures = [];\n    let grounded = true;\n    for (const quad of quads) {\n        const terms = rdf_terms_1.getTermsNested(quad);\n        if (terms.some((quadTerm) => quadTerm.equals(term))) {\n            quadSignatures.push(quadToSignature(quad, hashes, term));\n            for (const quadTerm of terms) {\n                if (!isTermGrounded(quadTerm, hashes) && !quadTerm.equals(term)) {\n                    grounded = false;\n                }\n            }\n        }\n    }\n    const hash = sha1hex(quadSignatures.sort().join(''));\n    return [grounded, hash];\n}\nexports.hashTerm = hashTerm;\n/**\n * Create a hash using sha1 as a hex digest.\n * @param {string | Buffer | NodeJS.TypedArray | DataView} data Something to hash.\n * @return {string} A hash string.\n */\nfunction sha1hex(data) {\n    return hash_js_1.sha1().update(data).digest('hex');\n}\nexports.sha1hex = sha1hex;\n/**\n * Convert the given quad to a string signature so that it can be used in the hash structure.\n * @param {Quad} quad A quad.\n * @param {ITermHash} hashes A grounded term hash object.\n * @param {Term} term A target term to compare with.\n * @return {string} A string signature.\n */\nfunction quadToSignature(quad, hashes, term) {\n    return rdf_terms_1.getTerms(quad).map((quadTerm) => termToSignature(quadTerm, hashes, term)).join('|');\n}\nexports.quadToSignature = quadToSignature;\n/**\n * Convert the given term to a string signature so that it can be used in the hash structure.\n * @param {Term} term A term.\n * @param {ITermHash} hashes A grounded term hash object.\n * @param {Term} target A target term to compare with.\n * @return {string} A string signature.\n */\nfunction termToSignature(term, hashes, target) {\n    if (term.equals(target)) {\n        return '@self';\n    }\n    else if (term.termType === 'BlankNode') {\n        return hashes[rdf_string_1.termToString(term)] || '@blank';\n    }\n    else if (term.termType === 'Quad') {\n        return `<${quadToSignature(term, hashes, target)}>`;\n    }\n    else {\n        return rdf_string_1.termToString(term);\n    }\n}\nexports.termToSignature = termToSignature;\n/**\n * Check if a term is grounded.\n *\n * A term is grounded if it is not a blank node\n * or if it included in the given hash of grounded nodes.\n *\n * @param {Term} term A term.\n * @param {ITermHash} hashes A grounded term hash object.\n * @return {boolean} If the given term is grounded.\n */\nfunction isTermGrounded(term, hashes) {\n    return (term.termType !== 'BlankNode'\n        && !(term.termType === 'Quad' && rdf_terms_1.getTermsNested(term).some(subTerm => !isTermGrounded(subTerm, hashes)))) || !!hashes[rdf_string_1.termToString(term)];\n}\nexports.isTermGrounded = isTermGrounded;\n//# sourceMappingURL=RdfIsomorphic.js.map"]},"metadata":{},"sourceType":"script"}