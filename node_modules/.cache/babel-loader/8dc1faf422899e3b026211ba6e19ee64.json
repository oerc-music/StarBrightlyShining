{"ast":null,"code":"\"use strict\"; // TODO: Find a library for this\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseXSDDateTime = exports.parseXSDInteger = exports.parseXSDDecimal = exports.parseXSDFloat = void 0;\n/**\n * TODO: Fix decently\n * Parses float datatypes (double, float).\n *\n * All invalid lexical values return undefined.\n *\n * @param value the string to interpret as a number\n */\n\nfunction parseXSDFloat(value) {\n  const numb = Number(value);\n\n  if (isNaN(numb)) {\n    if (value === 'NaN') {\n      return NaN;\n    }\n\n    if (value === 'INF') {\n      return Infinity;\n    }\n\n    if (value === '-INF') {\n      return -Infinity;\n    }\n\n    return undefined;\n  }\n\n  return numb;\n}\n\nexports.parseXSDFloat = parseXSDFloat;\n/**\n * Parses decimal datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\n\nfunction parseXSDDecimal(value) {\n  const numb = Number(value);\n  return isNaN(numb) ? undefined : numb;\n}\n\nexports.parseXSDDecimal = parseXSDDecimal;\n/**\n * Parses integer datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\n\nfunction parseXSDInteger(value) {\n  const numb = parseInt(value, 10);\n  return isNaN(numb) ? undefined : numb;\n}\n\nexports.parseXSDInteger = parseXSDInteger;\n/**\n * Parses ISO date or date time strings into it's parts.\n * I found no lib providing this functionality online, but it's needed heavily\n * by the spec (functions on dates), using any form of JS DateTime will lose the\n * original timezone notation.\n *\n * Example strings:\n *  - \"2011-01-10T14:45:13.815-05:00\"\n *  - \"2011-01-10T14:45:13.815Z\"\n *  - \"2011-01-10T14:45:13Z\"\n *  - \"2011-01-10\"\n * @param value the ISO date time string\n */\n\nfunction parseXSDDateTime(value) {\n  const posT = value.indexOf('T');\n  const date = posT >= 0 ? value.substr(0, posT) : value;\n  const [year, month, day] = date.split('-');\n  let hours = '';\n  let minutes = '';\n  let seconds = '';\n  let timezone = '';\n\n  if (posT >= 0) {\n    const timeAndTimeZone = value.substr(posT + 1);\n    const [time, _timeZoneChopped] = timeAndTimeZone.split(/[\\+\\-Z]/);\n    [hours, minutes, seconds] = time.split(':');\n    const timezoneOrNull = new RegExp(/([\\+\\-Z].*)/).exec(timeAndTimeZone);\n    timezone = timezoneOrNull ? timezoneOrNull[0] : '';\n  } else {\n    hours = '00';\n    minutes = '00';\n    seconds = '00';\n    timezone = '';\n  }\n\n  return {\n    year,\n    month,\n    day,\n    hours,\n    minutes,\n    seconds,\n    timezone\n  };\n}\n\nexports.parseXSDDateTime = parseXSDDateTime;","map":{"version":3,"sources":["../../../lib/util/Parsing.ts"],"names":[],"mappings":"cAAA;;;;;;AAEA;;;;;;;AAOG;;AACH,SAAgB,aAAhB,CAA8B,KAA9B,EAA2C;AACzC,QAAM,IAAI,GAAW,MAAM,CAAC,KAAD,CAA3B;;AACA,MAAI,KAAK,CAAC,IAAD,CAAT,EAAiB;AACf,QAAI,KAAK,KAAK,KAAd,EAAqB;AAAE,aAAO,GAAP;AAAa;;AACpC,QAAI,KAAK,KAAK,KAAd,EAAqB;AAAE,aAAO,QAAP;AAAkB;;AACzC,QAAI,KAAK,KAAK,MAAd,EAAsB;AAAE,aAAO,CAAC,QAAR;AAAmB;;AAC3C,WAAO,SAAP;AACD;;AACD,SAAO,IAAP;AACD;;AATD,OAAA,CAAA,aAAA,GAAA,aAAA;AAWA;;;;;;;AAOG;;AACH,SAAgB,eAAhB,CAAgC,KAAhC,EAA6C;AAC3C,QAAM,IAAI,GAAW,MAAM,CAAC,KAAD,CAA3B;AACA,SAAQ,KAAK,CAAC,IAAD,CAAN,GAAgB,SAAhB,GAA4B,IAAnC;AACD;;AAHD,OAAA,CAAA,eAAA,GAAA,eAAA;AAKA;;;;;;;AAOG;;AACH,SAAgB,eAAhB,CAAgC,KAAhC,EAA6C;AAC3C,QAAM,IAAI,GAAW,QAAQ,CAAC,KAAD,EAAQ,EAAR,CAA7B;AACA,SAAQ,KAAK,CAAC,IAAD,CAAN,GAAgB,SAAhB,GAA4B,IAAnC;AACD;;AAHD,OAAA,CAAA,eAAA,GAAA,eAAA;AAeA;;;;;;;;;;;;AAYG;;AACH,SAAgB,gBAAhB,CAAiC,KAAjC,EAA8C;AAC5C,QAAM,IAAI,GAAG,KAAK,CAAC,OAAN,CAAc,GAAd,CAAb;AACA,QAAM,IAAI,GAAG,IAAI,IAAI,CAAR,GAAY,KAAK,CAAC,MAAN,CAAa,CAAb,EAAgB,IAAhB,CAAZ,GAAoC,KAAjD;AACA,QAAM,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,IAAqB,IAAI,CAAC,KAAL,CAAW,GAAX,CAA3B;AACA,MAAI,KAAK,GAAG,EAAZ;AACA,MAAI,OAAO,GAAG,EAAd;AACA,MAAI,OAAO,GAAG,EAAd;AACA,MAAI,QAAQ,GAAG,EAAf;;AACA,MAAI,IAAI,IAAI,CAAZ,EAAe;AACb,UAAM,eAAe,GAAG,KAAK,CAAC,MAAN,CAAa,IAAI,GAAG,CAApB,CAAxB;AACA,UAAM,CAAC,IAAD,EAAO,gBAAP,IAA2B,eAAe,CAAC,KAAhB,CAAsB,SAAtB,CAAjC;AACA,KAAC,KAAD,EAAQ,OAAR,EAAiB,OAAjB,IAA4B,IAAI,CAAC,KAAL,CAAW,GAAX,CAA5B;AACA,UAAM,cAAc,GAAG,IAAI,MAAJ,CAAW,aAAX,EAA0B,IAA1B,CAA+B,eAA/B,CAAvB;AACA,IAAA,QAAQ,GAAI,cAAD,GAAmB,cAAc,CAAC,CAAD,CAAjC,GAAuC,EAAlD;AACD,GAND,MAMO;AACL,IAAA,KAAK,GAAG,IAAR;AACA,IAAA,OAAO,GAAG,IAAV;AACA,IAAA,OAAO,GAAG,IAAV;AACA,IAAA,QAAQ,GAAG,EAAX;AACD;;AACD,SAAO;AAAE,IAAA,IAAF;AAAQ,IAAA,KAAR;AAAe,IAAA,GAAf;AAAoB,IAAA,KAApB;AAA2B,IAAA,OAA3B;AAAoC,IAAA,OAApC;AAA6C,IAAA;AAA7C,GAAP;AACD;;AArBD,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourcesContent":["// TODO: Find a library for this\n\n/**\n * TODO: Fix decently\n * Parses float datatypes (double, float).\n *\n * All invalid lexical values return undefined.\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDFloat(value: string): number | undefined {\n  const numb: number = Number(value);\n  if (isNaN(numb)) {\n    if (value === 'NaN') { return NaN; }\n    if (value === 'INF') { return Infinity; }\n    if (value === '-INF') { return -Infinity; }\n    return undefined;\n  }\n  return numb;\n}\n\n/**\n * Parses decimal datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDDecimal(value: string): number | undefined {\n  const numb: number = Number(value);\n  return (isNaN(numb)) ? undefined : numb;\n}\n\n/**\n * Parses integer datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDInteger(value: string): number | undefined {\n  const numb: number = parseInt(value, 10);\n  return (isNaN(numb)) ? undefined : numb;\n}\n\nexport interface SplittedDate {\n  year: string;\n  month: string;\n  day: string;\n  hours: string;\n  minutes: string;\n  seconds: string;\n  timezone: string;\n}\n\n/**\n * Parses ISO date or date time strings into it's parts.\n * I found no lib providing this functionality online, but it's needed heavily\n * by the spec (functions on dates), using any form of JS DateTime will lose the\n * original timezone notation.\n *\n * Example strings:\n *  - \"2011-01-10T14:45:13.815-05:00\"\n *  - \"2011-01-10T14:45:13.815Z\"\n *  - \"2011-01-10T14:45:13Z\"\n *  - \"2011-01-10\"\n * @param value the ISO date time string\n */\nexport function parseXSDDateTime(value: string): SplittedDate {\n  const posT = value.indexOf('T');\n  const date = posT >= 0 ? value.substr(0, posT) : value;\n  const [year, month, day] = date.split('-');\n  let hours = '';\n  let minutes = '';\n  let seconds = '';\n  let timezone = '';\n  if (posT >= 0) {\n    const timeAndTimeZone = value.substr(posT + 1);\n    const [time, _timeZoneChopped] = timeAndTimeZone.split(/[\\+\\-Z]/);\n    [hours, minutes, seconds] = time.split(':');\n    const timezoneOrNull = new RegExp(/([\\+\\-Z].*)/).exec(timeAndTimeZone);\n    timezone = (timezoneOrNull) ? timezoneOrNull[0] : '';\n  } else {\n    hours = '00';\n    minutes = '00';\n    seconds = '00';\n    timezone = '';\n  }\n  return { year, month, day, hours, minutes, seconds, timezone };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}