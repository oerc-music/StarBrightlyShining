{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Util = void 0;\n\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * Utility functions and methods.\n */\n\n\nclass Util {\n  /**\n   * Convert an RDF term to a JSON value.\n   * @param {Term} term An RDF term.\n   * @param {JsonLdContextNormalized} context The context.\n   * @param {ITermToValueOptions} options Conversion options.\n   * @return {any} A JSON value.\n   */\n  static termToValue(term, context, options = {\n    compactIds: false,\n    useNativeTypes: false\n  }) {\n    switch (term.termType) {\n      case 'NamedNode':\n        const compacted = context.compactIri(term.value, options.vocab);\n        return options.compactIds ? compacted : {\n          '@id': compacted\n        };\n\n      case 'DefaultGraph':\n        return options.compactIds ? term.value : {\n          '@id': term.value\n        };\n\n      case 'BlankNode':\n        const id = `_:${term.value}`;\n        return options.compactIds ? id : {\n          '@id': id\n        };\n\n      case 'Literal':\n        // Handle JSON datatype\n        if (term.datatype.value === Util.RDF_JSON) {\n          let parsedJson;\n\n          try {\n            parsedJson = JSON.parse(term.value);\n          } catch (e) {\n            throw new jsonld_context_parser_1.ErrorCoded('Invalid JSON literal: ' + e.message, jsonld_context_parser_1.ERROR_CODES.INVALID_JSON_LITERAL);\n          }\n\n          return {\n            '@value': parsedJson,\n            '@type': '@json'\n          };\n        } // Handle rdfDirection: i18n-datatype\n\n\n        if (options.rdfDirection === 'i18n-datatype' && term.datatype.value.startsWith(Util.I18N)) {\n          const [language, direction] = term.datatype.value.substr(Util.I18N.length, term.datatype.value.length).split('_');\n          return Object.assign(Object.assign({\n            '@value': term.value\n          }, language ? {\n            '@language': language\n          } : {}), direction ? {\n            '@direction': direction\n          } : {});\n        }\n\n        const stringType = term.datatype.value === Util.XSD_STRING;\n        const rawValue = {\n          '@value': !stringType && options.useNativeTypes ? Util.stringToNativeType(term.value, term.datatype.value) : term.value\n        };\n\n        if (term.language) {\n          return Object.assign(Object.assign({}, rawValue), {\n            '@language': term.language\n          });\n        } else if (!stringType && typeof rawValue['@value'] === 'string') {\n          return Object.assign(Object.assign({}, rawValue), {\n            '@type': term.datatype.value\n          });\n        } else {\n          return rawValue;\n        }\n\n    }\n  }\n  /**\n   * Convert a string term to a native type.\n   * If no conversion is possible, the original string will be returned.\n   * @param {string} value An RDF term's string value.\n   * @param {string} type\n   * @return {any}\n   */\n\n\n  static stringToNativeType(value, type) {\n    if (type.startsWith(Util.XSD)) {\n      const xsdType = type.substr(Util.XSD.length);\n\n      switch (xsdType) {\n        case 'boolean':\n          if (value === 'true') {\n            return true;\n          } else if (value === 'false') {\n            return false;\n          }\n\n          throw new Error(`Invalid xsd:boolean value '${value}'`);\n\n        case 'integer':\n        case 'number':\n        case 'int':\n        case 'byte':\n        case 'long':\n          const parsedInt = parseInt(value, 10);\n\n          if (isNaN(parsedInt)) {\n            throw new Error(`Invalid xsd:integer value '${value}'`);\n          }\n\n          return parsedInt;\n\n        case 'float':\n        case 'double':\n          const parsedFloat = parseFloat(value);\n\n          if (isNaN(parsedFloat)) {\n            throw new Error(`Invalid xsd:float value '${value}'`);\n          }\n\n          return parsedFloat;\n      }\n    }\n\n    return value;\n  }\n\n}\n\nexports.Util = Util;\nUtil.XSD = 'http://www.w3.org/2001/XMLSchema#';\nUtil.XSD_STRING = Util.XSD + 'string';\nUtil.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nUtil.RDF_TYPE = Util.RDF + 'type';\nUtil.RDF_JSON = Util.RDF + 'JSON';\nUtil.I18N = 'https://www.w3.org/ns/i18n#';","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-serializer/lib/Util.js"],"names":["Object","defineProperty","exports","value","Util","jsonld_context_parser_1","require","termToValue","term","context","options","compactIds","useNativeTypes","termType","compacted","compactIri","vocab","id","datatype","RDF_JSON","parsedJson","JSON","parse","e","ErrorCoded","message","ERROR_CODES","INVALID_JSON_LITERAL","rdfDirection","startsWith","I18N","language","direction","substr","length","split","assign","stringType","XSD_STRING","rawValue","stringToNativeType","type","XSD","xsdType","Error","parsedInt","parseInt","isNaN","parsedFloat","parseFloat","RDF","RDF_TYPE"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n/**\n * Utility functions and methods.\n */\nclass Util {\n    /**\n     * Convert an RDF term to a JSON value.\n     * @param {Term} term An RDF term.\n     * @param {JsonLdContextNormalized} context The context.\n     * @param {ITermToValueOptions} options Conversion options.\n     * @return {any} A JSON value.\n     */\n    static termToValue(term, context, options = {\n        compactIds: false,\n        useNativeTypes: false,\n    }) {\n        switch (term.termType) {\n            case 'NamedNode':\n                const compacted = context.compactIri(term.value, options.vocab);\n                return options.compactIds ? compacted : { '@id': compacted };\n            case 'DefaultGraph':\n                return options.compactIds ? term.value : { '@id': term.value };\n            case 'BlankNode':\n                const id = `_:${term.value}`;\n                return options.compactIds ? id : { '@id': id };\n            case 'Literal':\n                // Handle JSON datatype\n                if (term.datatype.value === Util.RDF_JSON) {\n                    let parsedJson;\n                    try {\n                        parsedJson = JSON.parse(term.value);\n                    }\n                    catch (e) {\n                        throw new jsonld_context_parser_1.ErrorCoded('Invalid JSON literal: ' + e.message, jsonld_context_parser_1.ERROR_CODES.INVALID_JSON_LITERAL);\n                    }\n                    return {\n                        '@value': parsedJson,\n                        '@type': '@json',\n                    };\n                }\n                // Handle rdfDirection: i18n-datatype\n                if (options.rdfDirection === 'i18n-datatype' && term.datatype.value.startsWith(Util.I18N)) {\n                    const [language, direction] = term.datatype.value\n                        .substr(Util.I18N.length, term.datatype.value.length)\n                        .split('_');\n                    return Object.assign(Object.assign({ '@value': term.value }, language ? { '@language': language } : {}), direction ? { '@direction': direction } : {});\n                }\n                const stringType = term.datatype.value === Util.XSD_STRING;\n                const rawValue = {\n                    '@value': !stringType && options.useNativeTypes\n                        ? Util.stringToNativeType(term.value, term.datatype.value) : term.value,\n                };\n                if (term.language) {\n                    return Object.assign(Object.assign({}, rawValue), { '@language': term.language });\n                }\n                else if (!stringType && typeof rawValue['@value'] === 'string') {\n                    return Object.assign(Object.assign({}, rawValue), { '@type': term.datatype.value });\n                }\n                else {\n                    return rawValue;\n                }\n        }\n    }\n    /**\n     * Convert a string term to a native type.\n     * If no conversion is possible, the original string will be returned.\n     * @param {string} value An RDF term's string value.\n     * @param {string} type\n     * @return {any}\n     */\n    static stringToNativeType(value, type) {\n        if (type.startsWith(Util.XSD)) {\n            const xsdType = type.substr(Util.XSD.length);\n            switch (xsdType) {\n                case 'boolean':\n                    if (value === 'true') {\n                        return true;\n                    }\n                    else if (value === 'false') {\n                        return false;\n                    }\n                    throw new Error(`Invalid xsd:boolean value '${value}'`);\n                case 'integer':\n                case 'number':\n                case 'int':\n                case 'byte':\n                case 'long':\n                    const parsedInt = parseInt(value, 10);\n                    if (isNaN(parsedInt)) {\n                        throw new Error(`Invalid xsd:integer value '${value}'`);\n                    }\n                    return parsedInt;\n                case 'float':\n                case 'double':\n                    const parsedFloat = parseFloat(value);\n                    if (isNaN(parsedFloat)) {\n                        throw new Error(`Invalid xsd:float value '${value}'`);\n                    }\n                    return parsedFloat;\n            }\n        }\n        return value;\n    }\n}\nexports.Util = Util;\nUtil.XSD = 'http://www.w3.org/2001/XMLSchema#';\nUtil.XSD_STRING = Util.XSD + 'string';\nUtil.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nUtil.RDF_TYPE = Util.RDF + 'type';\nUtil.RDF_JSON = Util.RDF + 'JSON';\nUtil.I18N = 'https://www.w3.org/ns/i18n#';\n//# sourceMappingURL=Util.js.map"]},"metadata":{},"sourceType":"script"}