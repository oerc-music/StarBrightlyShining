{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonLdContextNormalized = void 0;\n\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n\nconst ContextParser_1 = require(\"./ContextParser\");\n\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\n\nconst Util_1 = require(\"./Util\");\n/**\n * A class exposing operations over a normalized JSON-LD context.\n */\n\n\nclass JsonLdContextNormalized {\n  constructor(contextRaw) {\n    this.contextRaw = contextRaw;\n  }\n  /**\n   * @return The raw inner context.\n   */\n\n\n  getContextRaw() {\n    return this.contextRaw;\n  }\n  /**\n   * Expand the term or prefix of the given term if it has one,\n   * otherwise return the term as-is.\n   *\n   * This will try to expand the IRI as much as possible.\n   *\n   * Iff in vocab-mode, then other references to other terms in the context can be used,\n   * such as to `myTerm`:\n   * ```\n   * {\n   *   \"myTerm\": \"http://example.org/myLongTerm\"\n   * }\n   * ```\n   *\n   * @param {string} term A term that is an URL or a prefixed URL.\n   * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,\n   *                              otherwise it is considered a regular term that is expanded based on @base.\n   * @param {IExpandOptions} options Options that define the way how expansion must be done.\n   * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n   * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).\n   */\n\n\n  expandTerm(term, expandVocab, options = ContextParser_1.defaultExpandOptions) {\n    const contextValue = this.contextRaw[term]; // Immediately return if the term was disabled in the context\n\n    if (contextValue === null || contextValue && contextValue['@id'] === null) {\n      return null;\n    } // Check the @id\n\n\n    let validIriMapping = true;\n\n    if (contextValue && expandVocab) {\n      const value = Util_1.Util.getContextValueId(contextValue);\n\n      if (value && value !== term) {\n        if (typeof value !== 'string' || !Util_1.Util.isValidIri(value) && !Util_1.Util.isValidKeyword(value)) {\n          // Don't mark this mapping as invalid if we have an unknown keyword, but of the correct form.\n          if (!Util_1.Util.isPotentialKeyword(value)) {\n            validIriMapping = false;\n          }\n        } else {\n          return value;\n        }\n      }\n    } // Check if the term is prefixed\n\n\n    const prefix = Util_1.Util.getPrefix(term, this.contextRaw);\n    const vocab = this.contextRaw['@vocab'];\n    const vocabRelative = (!!vocab || vocab === '') && vocab.indexOf(':') < 0;\n    const base = this.contextRaw['@base'];\n    const potentialKeyword = Util_1.Util.isPotentialKeyword(term);\n\n    if (prefix) {\n      const contextPrefixValue = this.contextRaw[prefix];\n      const value = Util_1.Util.getContextValueId(contextPrefixValue);\n\n      if (value) {\n        if (typeof contextPrefixValue === 'string' || !options.allowPrefixForcing) {\n          // If we have a simple term definition,\n          // check the last character of the prefix to determine whether or not it is a prefix.\n          // Validate that prefix ends with gen-delim character, unless @prefix is true\n          if (!Util_1.Util.isSimpleTermDefinitionPrefix(value, options)) {\n            // Treat the term as an absolute IRI\n            return term;\n          }\n        } else {\n          // If we have an expanded term definition, default to @prefix: false\n          if (value[0] !== '_' && !potentialKeyword && !contextPrefixValue['@prefix'] && !(term in this.contextRaw)) {\n            // Treat the term as an absolute IRI\n            return term;\n          }\n        }\n\n        return value + term.substr(prefix.length + 1);\n      }\n    } else if (expandVocab && (vocab || vocab === '' || options.allowVocabRelativeToBase && base && vocabRelative) && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n      if (vocabRelative) {\n        if (options.allowVocabRelativeToBase) {\n          return relative_to_absolute_iri_1.resolve(vocab, base) + term;\n        } else {\n          throw new ErrorCoded_1.ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${vocab}' is not allowed.`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n        }\n      } else {\n        return vocab + term;\n      }\n    } else if (!expandVocab && base && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n      return relative_to_absolute_iri_1.resolve(term, base);\n    } // Return the term as-is, unless we discovered an invalid IRI mapping for this term in the context earlier.\n\n\n    if (validIriMapping) {\n      return term;\n    } else {\n      throw new ErrorCoded_1.ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${JSON.stringify(contextValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n    }\n  }\n  /**\n   * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.\n   *\n   * This will try to compact the IRI as much as possible.\n   *\n   * @param {string} iri An IRI to compact.\n   * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,\n   *                        otherwise it is considered a regular term that is compacted based on @base.\n   * @return {string} The compacted term or the IRI as-is.\n   */\n\n\n  compactIri(iri, vocab) {\n    // Try @vocab compacting\n    if (vocab && this.contextRaw['@vocab'] && iri.startsWith(this.contextRaw['@vocab'])) {\n      return iri.substr(this.contextRaw['@vocab'].length);\n    } // Try @base compacting\n\n\n    if (!vocab && this.contextRaw['@base'] && iri.startsWith(this.contextRaw['@base'])) {\n      return iri.substr(this.contextRaw['@base'].length);\n    } // Loop over all terms in the context\n    // This will try to prefix as short as possible.\n    // Once a fully compacted alias is found, return immediately, as we can not go any shorter.\n\n\n    const shortestPrefixing = {\n      prefix: '',\n      suffix: iri\n    };\n\n    for (const key in this.contextRaw) {\n      const value = this.contextRaw[key];\n\n      if (value && !Util_1.Util.isPotentialKeyword(key)) {\n        const contextIri = Util_1.Util.getContextValueId(value);\n\n        if (iri.startsWith(contextIri)) {\n          const suffix = iri.substr(contextIri.length);\n\n          if (!suffix) {\n            if (vocab) {\n              // Immediately return on compacted alias\n              return key;\n            }\n          } else if (suffix.length < shortestPrefixing.suffix.length) {\n            // Overwrite the shortest prefix\n            shortestPrefixing.prefix = key;\n            shortestPrefixing.suffix = suffix;\n          }\n        }\n      }\n    } // Return the shortest prefix\n\n\n    if (shortestPrefixing.prefix) {\n      return shortestPrefixing.prefix + ':' + shortestPrefixing.suffix;\n    }\n\n    return iri;\n  }\n\n}\n\nexports.JsonLdContextNormalized = JsonLdContextNormalized;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js"],"names":["Object","defineProperty","exports","value","JsonLdContextNormalized","relative_to_absolute_iri_1","require","ContextParser_1","ErrorCoded_1","Util_1","constructor","contextRaw","getContextRaw","expandTerm","term","expandVocab","options","defaultExpandOptions","contextValue","validIriMapping","Util","getContextValueId","isValidIri","isValidKeyword","isPotentialKeyword","prefix","getPrefix","vocab","vocabRelative","indexOf","base","potentialKeyword","contextPrefixValue","allowPrefixForcing","isSimpleTermDefinitionPrefix","substr","length","allowVocabRelativeToBase","isCompactIri","resolve","ErrorCoded","ERROR_CODES","INVALID_VOCAB_MAPPING","JSON","stringify","INVALID_IRI_MAPPING","compactIri","iri","startsWith","shortestPrefixing","suffix","key","contextIri"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonLdContextNormalized = void 0;\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ContextParser_1 = require(\"./ContextParser\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst Util_1 = require(\"./Util\");\n/**\n * A class exposing operations over a normalized JSON-LD context.\n */\nclass JsonLdContextNormalized {\n    constructor(contextRaw) {\n        this.contextRaw = contextRaw;\n    }\n    /**\n     * @return The raw inner context.\n     */\n    getContextRaw() {\n        return this.contextRaw;\n    }\n    /**\n     * Expand the term or prefix of the given term if it has one,\n     * otherwise return the term as-is.\n     *\n     * This will try to expand the IRI as much as possible.\n     *\n     * Iff in vocab-mode, then other references to other terms in the context can be used,\n     * such as to `myTerm`:\n     * ```\n     * {\n     *   \"myTerm\": \"http://example.org/myLongTerm\"\n     * }\n     * ```\n     *\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,\n     *                              otherwise it is considered a regular term that is expanded based on @base.\n     * @param {IExpandOptions} options Options that define the way how expansion must be done.\n     * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n     * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).\n     */\n    expandTerm(term, expandVocab, options = ContextParser_1.defaultExpandOptions) {\n        const contextValue = this.contextRaw[term];\n        // Immediately return if the term was disabled in the context\n        if (contextValue === null || (contextValue && contextValue['@id'] === null)) {\n            return null;\n        }\n        // Check the @id\n        let validIriMapping = true;\n        if (contextValue && expandVocab) {\n            const value = Util_1.Util.getContextValueId(contextValue);\n            if (value && value !== term) {\n                if (typeof value !== 'string' || (!Util_1.Util.isValidIri(value) && !Util_1.Util.isValidKeyword(value))) {\n                    // Don't mark this mapping as invalid if we have an unknown keyword, but of the correct form.\n                    if (!Util_1.Util.isPotentialKeyword(value)) {\n                        validIriMapping = false;\n                    }\n                }\n                else {\n                    return value;\n                }\n            }\n        }\n        // Check if the term is prefixed\n        const prefix = Util_1.Util.getPrefix(term, this.contextRaw);\n        const vocab = this.contextRaw['@vocab'];\n        const vocabRelative = (!!vocab || vocab === '') && vocab.indexOf(':') < 0;\n        const base = this.contextRaw['@base'];\n        const potentialKeyword = Util_1.Util.isPotentialKeyword(term);\n        if (prefix) {\n            const contextPrefixValue = this.contextRaw[prefix];\n            const value = Util_1.Util.getContextValueId(contextPrefixValue);\n            if (value) {\n                if (typeof contextPrefixValue === 'string' || !options.allowPrefixForcing) {\n                    // If we have a simple term definition,\n                    // check the last character of the prefix to determine whether or not it is a prefix.\n                    // Validate that prefix ends with gen-delim character, unless @prefix is true\n                    if (!Util_1.Util.isSimpleTermDefinitionPrefix(value, options)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                else {\n                    // If we have an expanded term definition, default to @prefix: false\n                    if (value[0] !== '_' && !potentialKeyword && !contextPrefixValue['@prefix'] && !(term in this.contextRaw)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                return value + term.substr(prefix.length + 1);\n            }\n        }\n        else if (expandVocab && ((vocab || vocab === '') || (options.allowVocabRelativeToBase && (base && vocabRelative)))\n            && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            if (vocabRelative) {\n                if (options.allowVocabRelativeToBase) {\n                    return relative_to_absolute_iri_1.resolve(vocab, base) + term;\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${vocab}' is not allowed.`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                }\n            }\n            else {\n                return vocab + term;\n            }\n        }\n        else if (!expandVocab && base && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            return relative_to_absolute_iri_1.resolve(term, base);\n        }\n        // Return the term as-is, unless we discovered an invalid IRI mapping for this term in the context earlier.\n        if (validIriMapping) {\n            return term;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${JSON.stringify(contextValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n        }\n    }\n    /**\n     * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.\n     *\n     * This will try to compact the IRI as much as possible.\n     *\n     * @param {string} iri An IRI to compact.\n     * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,\n     *                        otherwise it is considered a regular term that is compacted based on @base.\n     * @return {string} The compacted term or the IRI as-is.\n     */\n    compactIri(iri, vocab) {\n        // Try @vocab compacting\n        if (vocab && this.contextRaw['@vocab'] && iri.startsWith(this.contextRaw['@vocab'])) {\n            return iri.substr(this.contextRaw['@vocab'].length);\n        }\n        // Try @base compacting\n        if (!vocab && this.contextRaw['@base'] && iri.startsWith(this.contextRaw['@base'])) {\n            return iri.substr(this.contextRaw['@base'].length);\n        }\n        // Loop over all terms in the context\n        // This will try to prefix as short as possible.\n        // Once a fully compacted alias is found, return immediately, as we can not go any shorter.\n        const shortestPrefixing = { prefix: '', suffix: iri };\n        for (const key in this.contextRaw) {\n            const value = this.contextRaw[key];\n            if (value && !Util_1.Util.isPotentialKeyword(key)) {\n                const contextIri = Util_1.Util.getContextValueId(value);\n                if (iri.startsWith(contextIri)) {\n                    const suffix = iri.substr(contextIri.length);\n                    if (!suffix) {\n                        if (vocab) {\n                            // Immediately return on compacted alias\n                            return key;\n                        }\n                    }\n                    else if (suffix.length < shortestPrefixing.suffix.length) {\n                        // Overwrite the shortest prefix\n                        shortestPrefixing.prefix = key;\n                        shortestPrefixing.suffix = suffix;\n                    }\n                }\n            }\n        }\n        // Return the shortest prefix\n        if (shortestPrefixing.prefix) {\n            return shortestPrefixing.prefix + ':' + shortestPrefixing.suffix;\n        }\n        return iri;\n    }\n}\nexports.JsonLdContextNormalized = JsonLdContextNormalized;\n//# sourceMappingURL=JsonLdContextNormalized.js.map"]},"metadata":{},"sourceType":"script"}