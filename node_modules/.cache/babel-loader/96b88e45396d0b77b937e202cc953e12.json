{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMetadata = exports.ActorQueryOperation = exports.KEY_CONTEXT_READONLY = exports.KEY_CONTEXT_QUERY_TIMESTAMP = exports.KEY_CONTEXT_BASEIRI = exports.KEY_CONTEXT_PATTERN_PARENTMETADATA = exports.KEY_CONTEXT_BGP_PATTERNBINDINGS = exports.KEY_CONTEXT_BGP_PARENTMETADATA = exports.KEY_CONTEXT_BGP_CURRENTMETADATA = void 0;\n\nconst context_entries_1 = require(\"@comunica/context-entries\");\n\nconst core_1 = require(\"@comunica/core\");\n\nconst data_factory_1 = require(\"@comunica/data-factory\");\n\nconst Bindings_1 = require(\"./Bindings\");\n/**\n * @type {string} Context entry for current metadata.\n *                I.e., the metadata that was used to determine the next BGP operation.\n * @value {any} A metadata hash.\n * @deprecated Import this constant from @comunica/context-entries.\n */\n\n\nexports.KEY_CONTEXT_BGP_CURRENTMETADATA = context_entries_1.KeysQueryOperation.bgpCurrentMetadata;\n/**\n * @type {string} Context entry for an array of parent metadata.\n *                I.e., an array of the metadata that was present before materializing the current BGP operations.\n *                This can be passed in 'bgp' actions.\n *                The array entries should correspond to the pattern entries in the BGP.\n * @value {any} An array of metadata hashes.\n * @deprecated Import this constant from @comunica/context-entries.\n */\n\nexports.KEY_CONTEXT_BGP_PARENTMETADATA = context_entries_1.KeysQueryOperation.bgpParentMetadata;\n/**\n * @type {string} Context entry for indicating which patterns were bound from variables.\n *                I.e., an array of the same length as the value of KeysQueryOperation.patternParentMetadata,\n *                where each array value corresponds to the pattern bindings for the corresponding pattern.\n * @value {any} An array of {@link PatternBindings}.\n * @deprecated Import this constant from @comunica/context-entries.\n */\n\nexports.KEY_CONTEXT_BGP_PATTERNBINDINGS = context_entries_1.KeysQueryOperation.bgpPatternBindings;\n/**\n * @type {string} Context entry for parent metadata.\n *                I.e., the metadata that was present before materializing the current operation.\n *                This can be passed in 'pattern' actions.\n * @value {any} A metadata hash.\n * @deprecated Import this constant from @comunica/context-entries.\n */\n\nexports.KEY_CONTEXT_PATTERN_PARENTMETADATA = context_entries_1.KeysQueryOperation.patternParentMetadata;\n/**\n * @type {string} Context entry for query's base IRI.\n * @value {any} A string.\n * @deprecated Import this constant from @comunica/context-entries.\n */\n\nexports.KEY_CONTEXT_BASEIRI = context_entries_1.KeysInitSparql.baseIRI;\n/**\n * @type {string} A timestamp representing the current time.\n *                This is required for certain SPARQL operations such as NOW().\n * @value {any} a date.\n * @deprecated Import this constant from @comunica/context-entries.\n */\n\nexports.KEY_CONTEXT_QUERY_TIMESTAMP = context_entries_1.KeysInitSparql.queryTimestamp;\n/**\n * @type {string} Context entry for indicating that only read operations are allowed, defaults to false.\n * @value {any} A boolean.\n * @deprecated Import this constant from @comunica/context-entries.\n */\n\nexports.KEY_CONTEXT_READONLY = context_entries_1.KeysQueryOperation.readOnly;\n/**\n * A counter that keeps track blank node generated through BNODE() SPARQL\n * expressions.\n *\n * @type {number}\n */\n\nlet bnodeCounter = 0;\n/**\n * A comunica actor for query-operation events.\n *\n * Actor types:\n * * Input:  IActionQueryOperation:      A SPARQL Algebra operation.\n * * Test:   <none>\n * * Output: IActorQueryOperationOutput: A bindings stream.\n *\n * @see IActionQueryOperation\n * @see IActorQueryOperationOutput\n */\n\nclass ActorQueryOperation extends core_1.Actor {\n  constructor(args) {\n    super(args);\n  }\n  /**\n   * Safely cast a query operation output to a bindings output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IActorQueryOperationOutput} output A query operation output.\n   * @return {IActorQueryOperationOutputBindings} A bindings query operation output.\n   */\n\n\n  static getSafeBindings(output) {\n    ActorQueryOperation.validateQueryOutput(output, 'bindings');\n    return output;\n  }\n  /**\n   * Safely cast a query operation output to a quads output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IActorQueryOperationOutput} output A query operation output.\n   * @return {IActorQueryOperationOutputQuads} A quads query operation output.\n   */\n\n\n  static getSafeQuads(output) {\n    ActorQueryOperation.validateQueryOutput(output, 'quads');\n    return output;\n  }\n  /**\n   * Safely cast a query operation output to a boolean output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IActorQueryOperationOutput} output A query operation output.\n   * @return {IActorQueryOperationOutputBoolean} A boolean query operation output.\n   */\n\n\n  static getSafeBoolean(output) {\n    ActorQueryOperation.validateQueryOutput(output, 'boolean');\n    return output;\n  }\n  /**\n   * Safely cast a query operation output to an update output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IActorQueryOperationOutput} output A query operation output.\n   * @return {IActorQueryOperationOutputUpdate} An update query operation output.\n   */\n\n\n  static getSafeUpdate(output) {\n    ActorQueryOperation.validateQueryOutput(output, 'update');\n    return output;\n  }\n  /**\n   * Convert a metadata callback to a lazy callback where the response value is cached.\n   * @param {() => Promise<{[p: string]: any}>} metadata A metadata callback\n   * @return {() => Promise<{[p: string]: any}>} The callback where the response will be cached.\n   */\n\n\n  static cachifyMetadata(metadata) {\n    let lastReturn; // eslint-disable-next-line no-return-assign,@typescript-eslint/no-misused-promises\n\n    return metadata && (() => lastReturn || (lastReturn = metadata()));\n  }\n  /**\n   * Throw an error if the output type does not match the expected type.\n   * @param {IActorQueryOperationOutput} output A query operation output.\n   * @param {string} expectedType The expected output type.\n   */\n\n\n  static validateQueryOutput(output, expectedType) {\n    if (output.type !== expectedType) {\n      throw new Error(`Invalid query output type: Expected '${expectedType}' but got '${output.type}'`);\n    }\n  }\n\n  static getBaseExpressionContext(context) {\n    if (context) {\n      const now = context.get(context_entries_1.KeysInitSparql.queryTimestamp);\n      const baseIRI = context.get(context_entries_1.KeysInitSparql.baseIRI);\n      return {\n        now,\n        baseIRI\n      };\n    }\n\n    return {};\n  }\n  /**\n   * Create an options object that can be used to construct a sparqlee synchronous evaluator.\n   * @param context An action context.\n   * @param mediatorQueryOperation An optional query query operation mediator.\n   *                               If defined, the existence resolver will be defined as `exists`.\n   */\n\n\n  static getExpressionContext(context, mediatorQueryOperation) {\n    return Object.assign(Object.assign({}, this.getBaseExpressionContext(context)), {\n      bnode: input => new data_factory_1.BlankNodeBindingsScoped(input || `BNODE_${bnodeCounter++}`)\n    });\n  }\n  /**\n   * Create an options object that can be used to construct a sparqlee asynchronous evaluator.\n   * @param context An action context.\n   * @param mediatorQueryOperation An optional query query operation mediator.\n   *                               If defined, the existence resolver will be defined as `exists`.\n   */\n\n\n  static getAsyncExpressionContext(context, mediatorQueryOperation) {\n    const expressionContext = Object.assign(Object.assign({}, this.getBaseExpressionContext(context)), {\n      bnode: input => Promise.resolve(new data_factory_1.BlankNodeBindingsScoped(input || `BNODE_${bnodeCounter++}`))\n    });\n\n    if (context && mediatorQueryOperation) {\n      expressionContext.exists = ActorQueryOperation.createExistenceResolver(context, mediatorQueryOperation);\n    }\n\n    return expressionContext;\n  }\n  /**\n   * Create an existence resolver for usage within an expression context.\n   * @param context An action context.\n   * @param mediatorQueryOperation A query operation mediator.\n   */\n\n\n  static createExistenceResolver(context, mediatorQueryOperation) {\n    return async (expr, bindings) => {\n      const operation = Bindings_1.materializeOperation(expr.input, bindings);\n      const outputRaw = await mediatorQueryOperation.mediate({\n        operation,\n        context\n      });\n      const output = ActorQueryOperation.getSafeBindings(outputRaw);\n      return new Promise((resolve, reject) => {\n        output.bindingsStream.on('end', () => {\n          resolve(false);\n        });\n        output.bindingsStream.on('error', reject);\n        output.bindingsStream.on('data', () => {\n          output.bindingsStream.close();\n          resolve(true);\n        });\n      }).then(exists => expr.not ? !exists : exists);\n    };\n  }\n  /**\n   * Throw an error if the context contains the readOnly flag.\n   * @param context An action context.\n   */\n\n\n  static throwOnReadOnly(context) {\n    if (context && context.get(exports.KEY_CONTEXT_READONLY)) {\n      throw new Error(`Attempted a write operation in read-only mode`);\n    }\n  }\n\n}\n\nexports.ActorQueryOperation = ActorQueryOperation;\n/**\n * Helper function to get the metadata of an action output.\n * @param actionOutput An action output, with an optional metadata function.\n * @return The metadata.\n */\n\nfunction getMetadata(actionOutput) {\n  if (!actionOutput.metadata) {\n    return Promise.resolve({});\n  }\n\n  return actionOutput.metadata();\n}\n\nexports.getMetadata = getMetadata;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/bus-query-operation/lib/ActorQueryOperation.js"],"names":["Object","defineProperty","exports","value","getMetadata","ActorQueryOperation","KEY_CONTEXT_READONLY","KEY_CONTEXT_QUERY_TIMESTAMP","KEY_CONTEXT_BASEIRI","KEY_CONTEXT_PATTERN_PARENTMETADATA","KEY_CONTEXT_BGP_PATTERNBINDINGS","KEY_CONTEXT_BGP_PARENTMETADATA","KEY_CONTEXT_BGP_CURRENTMETADATA","context_entries_1","require","core_1","data_factory_1","Bindings_1","KeysQueryOperation","bgpCurrentMetadata","bgpParentMetadata","bgpPatternBindings","patternParentMetadata","KeysInitSparql","baseIRI","queryTimestamp","readOnly","bnodeCounter","Actor","constructor","args","getSafeBindings","output","validateQueryOutput","getSafeQuads","getSafeBoolean","getSafeUpdate","cachifyMetadata","metadata","lastReturn","expectedType","type","Error","getBaseExpressionContext","context","now","get","getExpressionContext","mediatorQueryOperation","assign","bnode","input","BlankNodeBindingsScoped","getAsyncExpressionContext","expressionContext","Promise","resolve","exists","createExistenceResolver","expr","bindings","operation","materializeOperation","outputRaw","mediate","reject","bindingsStream","on","close","then","not","throwOnReadOnly","actionOutput"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,WAAR,GAAsBF,OAAO,CAACG,mBAAR,GAA8BH,OAAO,CAACI,oBAAR,GAA+BJ,OAAO,CAACK,2BAAR,GAAsCL,OAAO,CAACM,mBAAR,GAA8BN,OAAO,CAACO,kCAAR,GAA6CP,OAAO,CAACQ,+BAAR,GAA0CR,OAAO,CAACS,8BAAR,GAAyCT,OAAO,CAACU,+BAAR,GAA0C,KAAK,CAAtU;;AACA,MAAMC,iBAAiB,GAAGC,OAAO,CAAC,2BAAD,CAAjC;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,gBAAD,CAAtB;;AACA,MAAME,cAAc,GAAGF,OAAO,CAAC,wBAAD,CAA9B;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,YAAD,CAA1B;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAZ,OAAO,CAACU,+BAAR,GAA0CC,iBAAiB,CAACK,kBAAlB,CAAqCC,kBAA/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAjB,OAAO,CAACS,8BAAR,GAAyCE,iBAAiB,CAACK,kBAAlB,CAAqCE,iBAA9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAlB,OAAO,CAACQ,+BAAR,GAA0CG,iBAAiB,CAACK,kBAAlB,CAAqCG,kBAA/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAnB,OAAO,CAACO,kCAAR,GAA6CI,iBAAiB,CAACK,kBAAlB,CAAqCI,qBAAlF;AACA;AACA;AACA;AACA;AACA;;AACApB,OAAO,CAACM,mBAAR,GAA8BK,iBAAiB,CAACU,cAAlB,CAAiCC,OAA/D;AACA;AACA;AACA;AACA;AACA;AACA;;AACAtB,OAAO,CAACK,2BAAR,GAAsCM,iBAAiB,CAACU,cAAlB,CAAiCE,cAAvE;AACA;AACA;AACA;AACA;AACA;;AACAvB,OAAO,CAACI,oBAAR,GAA+BO,iBAAiB,CAACK,kBAAlB,CAAqCQ,QAApE;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,YAAY,GAAG,CAAnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMtB,mBAAN,SAAkCU,MAAM,CAACa,KAAzC,CAA+C;AAC3CC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAMA,IAAN;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AAC0B,SAAfC,eAAe,CAACC,MAAD,EAAS;AAC3B3B,IAAAA,mBAAmB,CAAC4B,mBAApB,CAAwCD,MAAxC,EAAgD,UAAhD;AACA,WAAOA,MAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACuB,SAAZE,YAAY,CAACF,MAAD,EAAS;AACxB3B,IAAAA,mBAAmB,CAAC4B,mBAApB,CAAwCD,MAAxC,EAAgD,OAAhD;AACA,WAAOA,MAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACyB,SAAdG,cAAc,CAACH,MAAD,EAAS;AAC1B3B,IAAAA,mBAAmB,CAAC4B,mBAApB,CAAwCD,MAAxC,EAAgD,SAAhD;AACA,WAAOA,MAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACwB,SAAbI,aAAa,CAACJ,MAAD,EAAS;AACzB3B,IAAAA,mBAAmB,CAAC4B,mBAApB,CAAwCD,MAAxC,EAAgD,QAAhD;AACA,WAAOA,MAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AAC0B,SAAfK,eAAe,CAACC,QAAD,EAAW;AAC7B,QAAIC,UAAJ,CAD6B,CAE7B;;AACA,WAAQD,QAAQ,KAAK,MAAOC,UAAU,KAAKA,UAAU,GAAGD,QAAQ,EAA1B,CAAtB,CAAhB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AAC8B,SAAnBL,mBAAmB,CAACD,MAAD,EAASQ,YAAT,EAAuB;AAC7C,QAAIR,MAAM,CAACS,IAAP,KAAgBD,YAApB,EAAkC;AAC9B,YAAM,IAAIE,KAAJ,CAAW,wCAAuCF,YAAa,cAAaR,MAAM,CAACS,IAAK,GAAxF,CAAN;AACH;AACJ;;AAC8B,SAAxBE,wBAAwB,CAACC,OAAD,EAAU;AACrC,QAAIA,OAAJ,EAAa;AACT,YAAMC,GAAG,GAAGD,OAAO,CAACE,GAAR,CAAYjC,iBAAiB,CAACU,cAAlB,CAAiCE,cAA7C,CAAZ;AACA,YAAMD,OAAO,GAAGoB,OAAO,CAACE,GAAR,CAAYjC,iBAAiB,CAACU,cAAlB,CAAiCC,OAA7C,CAAhB;AACA,aAAO;AAAEqB,QAAAA,GAAF;AAAOrB,QAAAA;AAAP,OAAP;AACH;;AACD,WAAO,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AAC+B,SAApBuB,oBAAoB,CAACH,OAAD,EAAUI,sBAAV,EAAkC;AACzD,WAAOhD,MAAM,CAACiD,MAAP,CAAcjD,MAAM,CAACiD,MAAP,CAAc,EAAd,EAAkB,KAAKN,wBAAL,CAA8BC,OAA9B,CAAlB,CAAd,EAAyE;AAAEM,MAAAA,KAAK,EAAGC,KAAD,IAAW,IAAInC,cAAc,CAACoC,uBAAnB,CAA2CD,KAAK,IAAK,SAAQxB,YAAY,EAAG,EAA5E;AAApB,KAAzE,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACoC,SAAzB0B,yBAAyB,CAACT,OAAD,EAAUI,sBAAV,EAAkC;AAC9D,UAAMM,iBAAiB,GAAGtD,MAAM,CAACiD,MAAP,CAAcjD,MAAM,CAACiD,MAAP,CAAc,EAAd,EAAkB,KAAKN,wBAAL,CAA8BC,OAA9B,CAAlB,CAAd,EAAyE;AAAEM,MAAAA,KAAK,EAAGC,KAAD,IAAWI,OAAO,CAACC,OAAR,CAAgB,IAAIxC,cAAc,CAACoC,uBAAnB,CAA2CD,KAAK,IAAK,SAAQxB,YAAY,EAAG,EAA5E,CAAhB;AAApB,KAAzE,CAA1B;;AACA,QAAIiB,OAAO,IAAII,sBAAf,EAAuC;AACnCM,MAAAA,iBAAiB,CAACG,MAAlB,GAA2BpD,mBAAmB,CAACqD,uBAApB,CAA4Cd,OAA5C,EAAqDI,sBAArD,CAA3B;AACH;;AACD,WAAOM,iBAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACkC,SAAvBI,uBAAuB,CAACd,OAAD,EAAUI,sBAAV,EAAkC;AAC5D,WAAO,OAAOW,IAAP,EAAaC,QAAb,KAA0B;AAC7B,YAAMC,SAAS,GAAG5C,UAAU,CAAC6C,oBAAX,CAAgCH,IAAI,CAACR,KAArC,EAA4CS,QAA5C,CAAlB;AACA,YAAMG,SAAS,GAAG,MAAMf,sBAAsB,CAACgB,OAAvB,CAA+B;AAAEH,QAAAA,SAAF;AAAajB,QAAAA;AAAb,OAA/B,CAAxB;AACA,YAAMZ,MAAM,GAAG3B,mBAAmB,CAAC0B,eAApB,CAAoCgC,SAApC,CAAf;AACA,aAAO,IAAIR,OAAJ,CAAY,CAACC,OAAD,EAAUS,MAAV,KAAqB;AACpCjC,QAAAA,MAAM,CAACkC,cAAP,CAAsBC,EAAtB,CAAyB,KAAzB,EAAgC,MAAM;AAClCX,UAAAA,OAAO,CAAC,KAAD,CAAP;AACH,SAFD;AAGAxB,QAAAA,MAAM,CAACkC,cAAP,CAAsBC,EAAtB,CAAyB,OAAzB,EAAkCF,MAAlC;AACAjC,QAAAA,MAAM,CAACkC,cAAP,CAAsBC,EAAtB,CAAyB,MAAzB,EAAiC,MAAM;AACnCnC,UAAAA,MAAM,CAACkC,cAAP,CAAsBE,KAAtB;AACAZ,UAAAA,OAAO,CAAC,IAAD,CAAP;AACH,SAHD;AAIH,OATM,EAUFa,IAVE,CAUIZ,MAAD,IAAYE,IAAI,CAACW,GAAL,GAAW,CAACb,MAAZ,GAAqBA,MAVpC,CAAP;AAWH,KAfD;AAgBH;AACD;AACJ;AACA;AACA;;;AAC0B,SAAfc,eAAe,CAAC3B,OAAD,EAAU;AAC5B,QAAIA,OAAO,IAAIA,OAAO,CAACE,GAAR,CAAY5C,OAAO,CAACI,oBAApB,CAAf,EAA0D;AACtD,YAAM,IAAIoC,KAAJ,CAAW,+CAAX,CAAN;AACH;AACJ;;AA7H0C;;AA+H/CxC,OAAO,CAACG,mBAAR,GAA8BA,mBAA9B;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,WAAT,CAAqBoE,YAArB,EAAmC;AAC/B,MAAI,CAACA,YAAY,CAAClC,QAAlB,EAA4B;AACxB,WAAOiB,OAAO,CAACC,OAAR,CAAgB,EAAhB,CAAP;AACH;;AACD,SAAOgB,YAAY,CAAClC,QAAb,EAAP;AACH;;AACDpC,OAAO,CAACE,WAAR,GAAsBA,WAAtB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getMetadata = exports.ActorQueryOperation = exports.KEY_CONTEXT_READONLY = exports.KEY_CONTEXT_QUERY_TIMESTAMP = exports.KEY_CONTEXT_BASEIRI = exports.KEY_CONTEXT_PATTERN_PARENTMETADATA = exports.KEY_CONTEXT_BGP_PATTERNBINDINGS = exports.KEY_CONTEXT_BGP_PARENTMETADATA = exports.KEY_CONTEXT_BGP_CURRENTMETADATA = void 0;\nconst context_entries_1 = require(\"@comunica/context-entries\");\nconst core_1 = require(\"@comunica/core\");\nconst data_factory_1 = require(\"@comunica/data-factory\");\nconst Bindings_1 = require(\"./Bindings\");\n/**\n * @type {string} Context entry for current metadata.\n *                I.e., the metadata that was used to determine the next BGP operation.\n * @value {any} A metadata hash.\n * @deprecated Import this constant from @comunica/context-entries.\n */\nexports.KEY_CONTEXT_BGP_CURRENTMETADATA = context_entries_1.KeysQueryOperation.bgpCurrentMetadata;\n/**\n * @type {string} Context entry for an array of parent metadata.\n *                I.e., an array of the metadata that was present before materializing the current BGP operations.\n *                This can be passed in 'bgp' actions.\n *                The array entries should correspond to the pattern entries in the BGP.\n * @value {any} An array of metadata hashes.\n * @deprecated Import this constant from @comunica/context-entries.\n */\nexports.KEY_CONTEXT_BGP_PARENTMETADATA = context_entries_1.KeysQueryOperation.bgpParentMetadata;\n/**\n * @type {string} Context entry for indicating which patterns were bound from variables.\n *                I.e., an array of the same length as the value of KeysQueryOperation.patternParentMetadata,\n *                where each array value corresponds to the pattern bindings for the corresponding pattern.\n * @value {any} An array of {@link PatternBindings}.\n * @deprecated Import this constant from @comunica/context-entries.\n */\nexports.KEY_CONTEXT_BGP_PATTERNBINDINGS = context_entries_1.KeysQueryOperation.bgpPatternBindings;\n/**\n * @type {string} Context entry for parent metadata.\n *                I.e., the metadata that was present before materializing the current operation.\n *                This can be passed in 'pattern' actions.\n * @value {any} A metadata hash.\n * @deprecated Import this constant from @comunica/context-entries.\n */\nexports.KEY_CONTEXT_PATTERN_PARENTMETADATA = context_entries_1.KeysQueryOperation.patternParentMetadata;\n/**\n * @type {string} Context entry for query's base IRI.\n * @value {any} A string.\n * @deprecated Import this constant from @comunica/context-entries.\n */\nexports.KEY_CONTEXT_BASEIRI = context_entries_1.KeysInitSparql.baseIRI;\n/**\n * @type {string} A timestamp representing the current time.\n *                This is required for certain SPARQL operations such as NOW().\n * @value {any} a date.\n * @deprecated Import this constant from @comunica/context-entries.\n */\nexports.KEY_CONTEXT_QUERY_TIMESTAMP = context_entries_1.KeysInitSparql.queryTimestamp;\n/**\n * @type {string} Context entry for indicating that only read operations are allowed, defaults to false.\n * @value {any} A boolean.\n * @deprecated Import this constant from @comunica/context-entries.\n */\nexports.KEY_CONTEXT_READONLY = context_entries_1.KeysQueryOperation.readOnly;\n/**\n * A counter that keeps track blank node generated through BNODE() SPARQL\n * expressions.\n *\n * @type {number}\n */\nlet bnodeCounter = 0;\n/**\n * A comunica actor for query-operation events.\n *\n * Actor types:\n * * Input:  IActionQueryOperation:      A SPARQL Algebra operation.\n * * Test:   <none>\n * * Output: IActorQueryOperationOutput: A bindings stream.\n *\n * @see IActionQueryOperation\n * @see IActorQueryOperationOutput\n */\nclass ActorQueryOperation extends core_1.Actor {\n    constructor(args) {\n        super(args);\n    }\n    /**\n     * Safely cast a query operation output to a bindings output.\n     * This will throw a runtime error if the output is of the incorrect type.\n     * @param {IActorQueryOperationOutput} output A query operation output.\n     * @return {IActorQueryOperationOutputBindings} A bindings query operation output.\n     */\n    static getSafeBindings(output) {\n        ActorQueryOperation.validateQueryOutput(output, 'bindings');\n        return output;\n    }\n    /**\n     * Safely cast a query operation output to a quads output.\n     * This will throw a runtime error if the output is of the incorrect type.\n     * @param {IActorQueryOperationOutput} output A query operation output.\n     * @return {IActorQueryOperationOutputQuads} A quads query operation output.\n     */\n    static getSafeQuads(output) {\n        ActorQueryOperation.validateQueryOutput(output, 'quads');\n        return output;\n    }\n    /**\n     * Safely cast a query operation output to a boolean output.\n     * This will throw a runtime error if the output is of the incorrect type.\n     * @param {IActorQueryOperationOutput} output A query operation output.\n     * @return {IActorQueryOperationOutputBoolean} A boolean query operation output.\n     */\n    static getSafeBoolean(output) {\n        ActorQueryOperation.validateQueryOutput(output, 'boolean');\n        return output;\n    }\n    /**\n     * Safely cast a query operation output to an update output.\n     * This will throw a runtime error if the output is of the incorrect type.\n     * @param {IActorQueryOperationOutput} output A query operation output.\n     * @return {IActorQueryOperationOutputUpdate} An update query operation output.\n     */\n    static getSafeUpdate(output) {\n        ActorQueryOperation.validateQueryOutput(output, 'update');\n        return output;\n    }\n    /**\n     * Convert a metadata callback to a lazy callback where the response value is cached.\n     * @param {() => Promise<{[p: string]: any}>} metadata A metadata callback\n     * @return {() => Promise<{[p: string]: any}>} The callback where the response will be cached.\n     */\n    static cachifyMetadata(metadata) {\n        let lastReturn;\n        // eslint-disable-next-line no-return-assign,@typescript-eslint/no-misused-promises\n        return (metadata && (() => (lastReturn || (lastReturn = metadata()))));\n    }\n    /**\n     * Throw an error if the output type does not match the expected type.\n     * @param {IActorQueryOperationOutput} output A query operation output.\n     * @param {string} expectedType The expected output type.\n     */\n    static validateQueryOutput(output, expectedType) {\n        if (output.type !== expectedType) {\n            throw new Error(`Invalid query output type: Expected '${expectedType}' but got '${output.type}'`);\n        }\n    }\n    static getBaseExpressionContext(context) {\n        if (context) {\n            const now = context.get(context_entries_1.KeysInitSparql.queryTimestamp);\n            const baseIRI = context.get(context_entries_1.KeysInitSparql.baseIRI);\n            return { now, baseIRI };\n        }\n        return {};\n    }\n    /**\n     * Create an options object that can be used to construct a sparqlee synchronous evaluator.\n     * @param context An action context.\n     * @param mediatorQueryOperation An optional query query operation mediator.\n     *                               If defined, the existence resolver will be defined as `exists`.\n     */\n    static getExpressionContext(context, mediatorQueryOperation) {\n        return Object.assign(Object.assign({}, this.getBaseExpressionContext(context)), { bnode: (input) => new data_factory_1.BlankNodeBindingsScoped(input || `BNODE_${bnodeCounter++}`) });\n    }\n    /**\n     * Create an options object that can be used to construct a sparqlee asynchronous evaluator.\n     * @param context An action context.\n     * @param mediatorQueryOperation An optional query query operation mediator.\n     *                               If defined, the existence resolver will be defined as `exists`.\n     */\n    static getAsyncExpressionContext(context, mediatorQueryOperation) {\n        const expressionContext = Object.assign(Object.assign({}, this.getBaseExpressionContext(context)), { bnode: (input) => Promise.resolve(new data_factory_1.BlankNodeBindingsScoped(input || `BNODE_${bnodeCounter++}`)) });\n        if (context && mediatorQueryOperation) {\n            expressionContext.exists = ActorQueryOperation.createExistenceResolver(context, mediatorQueryOperation);\n        }\n        return expressionContext;\n    }\n    /**\n     * Create an existence resolver for usage within an expression context.\n     * @param context An action context.\n     * @param mediatorQueryOperation A query operation mediator.\n     */\n    static createExistenceResolver(context, mediatorQueryOperation) {\n        return async (expr, bindings) => {\n            const operation = Bindings_1.materializeOperation(expr.input, bindings);\n            const outputRaw = await mediatorQueryOperation.mediate({ operation, context });\n            const output = ActorQueryOperation.getSafeBindings(outputRaw);\n            return new Promise((resolve, reject) => {\n                output.bindingsStream.on('end', () => {\n                    resolve(false);\n                });\n                output.bindingsStream.on('error', reject);\n                output.bindingsStream.on('data', () => {\n                    output.bindingsStream.close();\n                    resolve(true);\n                });\n            })\n                .then((exists) => expr.not ? !exists : exists);\n        };\n    }\n    /**\n     * Throw an error if the context contains the readOnly flag.\n     * @param context An action context.\n     */\n    static throwOnReadOnly(context) {\n        if (context && context.get(exports.KEY_CONTEXT_READONLY)) {\n            throw new Error(`Attempted a write operation in read-only mode`);\n        }\n    }\n}\nexports.ActorQueryOperation = ActorQueryOperation;\n/**\n * Helper function to get the metadata of an action output.\n * @param actionOutput An action output, with an optional metadata function.\n * @return The metadata.\n */\nfunction getMetadata(actionOutput) {\n    if (!actionOutput.metadata) {\n        return Promise.resolve({});\n    }\n    return actionOutput.metadata();\n}\nexports.getMetadata = getMetadata;\n//# sourceMappingURL=ActorQueryOperation.js.map"]},"metadata":{},"sourceType":"script"}