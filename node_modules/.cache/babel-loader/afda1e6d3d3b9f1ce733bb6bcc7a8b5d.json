{"ast":null,"code":"const VARIABLE = /(SELECT\\s+)(\\?\\S+)/;\nconst QUERY_TAIL = /\\}[^}]*$/;\n/**\n * Returns a function that preloads and caches\n * certain properties of results on the current path.\n *\n * Requires:\n * - a predicate handler on the path proxy\n * - a queryEngine property in the path settings\n *\n * Creates:\n * - a resultsCache property on the path data\n */\n\nexport default class PreloadHandler {\n  /**\n   * Creates a preload function.\n   */\n  handle(pathData, pathProxy) {\n    return async (...properties) => {\n      if (properties.length > 0) {\n        // Map the properties to predicates\n        const predicates = await Promise.all(properties.map(async p => (await pathProxy[p].predicate).value)); // Create and attach the results cache to the path data\n\n        pathData.resultsCache = await this.createResultsCache(predicates, pathData, pathProxy);\n      }\n\n      return pathProxy;\n    };\n  }\n  /**\n   * Creates a cache for the results of\n   * resolving the given predicates against the path.\n   */\n\n\n  async createResultsCache(predicates, pathData, path) {\n    // Execute the preloading query\n    const {\n      query,\n      vars,\n      resultVar\n    } = await this.createQuery(predicates, path);\n    const {\n      settings: {\n        queryEngine\n      }\n    } = pathData;\n    const bindings = queryEngine.execute(query); // Extract all results and their preloaded property values\n\n    const resultsCache = {};\n    const propertyCaches = {};\n\n    for await (const binding of bindings) {\n      // Initialize the result's cache if needed\n      const result = binding.get(resultVar),\n            hash = hashTerm(result);\n\n      if (!(hash in resultsCache)) {\n        // Create the property cache\n        const propertyCache = propertyCaches[hash] = {};\n\n        for (const predicate of predicates) propertyCache[predicate] = []; // Create the result path\n\n\n        const resultData = {\n          subject: result,\n          propertyCache\n        };\n        resultsCache[hash] = pathData.extendPath(resultData, null);\n      } // Create and cache a possible property value path from the binding\n\n\n      const propertyCache = propertyCaches[hash];\n\n      for (let i = 0; i < vars.length; i++) {\n        const value = binding.get(vars[i]);\n\n        if (value) {\n          const valuePath = pathData.extendPath({\n            subject: value\n          }, null);\n          propertyCache[predicates[i]].push(valuePath);\n        }\n      }\n    }\n\n    return Object.values(resultsCache);\n  }\n  /**\n   * Creates the query for preloading the given predicates on the path\n   */\n\n\n  async createQuery(predicates, path) {\n    // Obtain the query for the current path, and its main variable\n    const parentQuery = await path.sparql;\n    const variableMatch = VARIABLE.exec(parentQuery);\n    if (!variableMatch) throw new Error(`Unexpected path query: ${parentQuery}`);\n    const resultVar = variableMatch[2]; // Modify the query to include the preload clauses\n    // TODO: instead of query manipulation, adjust the query generator\n    // TODO: support reverse predicates\n\n    const vars = predicates.map((p, i) => `?preload_${i}`);\n    const preloadClauses = predicates.map((predicate, i) => `    { ${resultVar} <${predicate}> ${vars[i]}. }`).join('\\n    UNION\\n');\n    const query = parentQuery.replace(VARIABLE, `$1$2 ${vars.join(' ')}`).replace(QUERY_TAIL, `  OPTIONAL {\\n${preloadClauses}\\n  }\\n$&`);\n    return {\n      query,\n      vars,\n      resultVar\n    };\n  }\n\n} // Returns a unique string representation of the term\n\nfunction hashTerm(term) {\n  const {\n    termType,\n    value\n  } = term;\n\n  switch (termType) {\n    case 'NamedNode':\n      return value;\n\n    case 'Literal':\n      const {\n        language,\n        datatype\n      } = term;\n      return `${termType}|${language}|${datatype.value}|${value}`;\n\n    default:\n      return `${termType}|${value}`;\n  }\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/PreloadHandler.js"],"names":["VARIABLE","QUERY_TAIL","PreloadHandler","handle","pathData","pathProxy","properties","length","predicates","Promise","all","map","p","predicate","value","resultsCache","createResultsCache","path","query","vars","resultVar","createQuery","settings","queryEngine","bindings","execute","propertyCaches","binding","result","get","hash","hashTerm","propertyCache","resultData","subject","extendPath","i","valuePath","push","Object","values","parentQuery","sparql","variableMatch","exec","Error","preloadClauses","join","replace","term","termType","language","datatype"],"mappings":"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","sourcesContent":["const VARIABLE = /(SELECT\\s+)(\\?\\S+)/;\nconst QUERY_TAIL = /\\}[^}]*$/;\n/**\n * Returns a function that preloads and caches\n * certain properties of results on the current path.\n *\n * Requires:\n * - a predicate handler on the path proxy\n * - a queryEngine property in the path settings\n *\n * Creates:\n * - a resultsCache property on the path data\n */\n\nexport default class PreloadHandler {\n  /**\n   * Creates a preload function.\n   */\n  handle(pathData, pathProxy) {\n    return async (...properties) => {\n      if (properties.length > 0) {\n        // Map the properties to predicates\n        const predicates = await Promise.all(properties.map(async (p) => (await pathProxy[p].predicate).value)); // Create and attach the results cache to the path data\n\n        pathData.resultsCache = await this.createResultsCache(predicates, pathData, pathProxy);\n      }\n\n      return pathProxy;\n    };\n  }\n  /**\n   * Creates a cache for the results of\n   * resolving the given predicates against the path.\n   */\n\n\n  async createResultsCache(predicates, pathData, path) {\n    // Execute the preloading query\n    const {\n      query,\n      vars,\n      resultVar\n    } = await this.createQuery(predicates, path);\n    const {\n      settings: {\n        queryEngine\n      }\n    } = pathData;\n    const bindings = queryEngine.execute(query); // Extract all results and their preloaded property values\n\n    const resultsCache = {};\n    const propertyCaches = {};\n\n    for await (const binding of bindings) {\n      // Initialize the result's cache if needed\n      const result = binding.get(resultVar),\n            hash = hashTerm(result);\n\n      if (!(hash in resultsCache)) {\n        // Create the property cache\n        const propertyCache = propertyCaches[hash] = {};\n\n        for (const predicate of predicates) propertyCache[predicate] = []; // Create the result path\n\n\n        const resultData = {\n          subject: result,\n          propertyCache\n        };\n        resultsCache[hash] = pathData.extendPath(resultData, null);\n      } // Create and cache a possible property value path from the binding\n\n\n      const propertyCache = propertyCaches[hash];\n\n      for (let i = 0; i < vars.length; i++) {\n        const value = binding.get(vars[i]);\n\n        if (value) {\n          const valuePath = pathData.extendPath({\n            subject: value\n          }, null);\n          propertyCache[predicates[i]].push(valuePath);\n        }\n      }\n    }\n\n    return Object.values(resultsCache);\n  }\n  /**\n   * Creates the query for preloading the given predicates on the path\n   */\n\n\n  async createQuery(predicates, path) {\n    // Obtain the query for the current path, and its main variable\n    const parentQuery = await path.sparql;\n    const variableMatch = VARIABLE.exec(parentQuery);\n    if (!variableMatch) throw new Error(`Unexpected path query: ${parentQuery}`);\n    const resultVar = variableMatch[2]; // Modify the query to include the preload clauses\n    // TODO: instead of query manipulation, adjust the query generator\n    // TODO: support reverse predicates\n\n    const vars = predicates.map((p, i) => `?preload_${i}`);\n    const preloadClauses = predicates.map((predicate, i) => `    { ${resultVar} <${predicate}> ${vars[i]}. }`).join('\\n    UNION\\n');\n    const query = parentQuery.replace(VARIABLE, `$1$2 ${vars.join(' ')}`).replace(QUERY_TAIL, `  OPTIONAL {\\n${preloadClauses}\\n  }\\n$&`);\n    return {\n      query,\n      vars,\n      resultVar\n    };\n  }\n\n} // Returns a unique string representation of the term\n\nfunction hashTerm(term) {\n  const {\n    termType,\n    value\n  } = term;\n\n  switch (termType) {\n    case 'NamedNode':\n      return value;\n\n    case 'Literal':\n      const {\n        language,\n        datatype\n      } = term;\n      return `${termType}|${language}|${datatype.value}|${value}`;\n\n    default:\n      return `${termType}|${value}`;\n  }\n}"]},"metadata":{},"sourceType":"module"}