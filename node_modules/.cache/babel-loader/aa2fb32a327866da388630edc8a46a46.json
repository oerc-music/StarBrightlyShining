{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationPathZeroOrMore = void 0;\n\nconst actor_abstract_path_1 = require(\"@comunica/actor-abstract-path\");\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica Path ZeroOrMore Query Operation Actor.\n */\n\n\nclass ActorQueryOperationPathZeroOrMore extends actor_abstract_path_1.ActorAbstractPath {\n  constructor(args) {\n    super(args, sparqlalgebrajs_1.Algebra.types.ZERO_OR_MORE_PATH);\n  }\n\n  async runOperation(path, context) {\n    const distinct = await this.isPathArbitraryLengthDistinct(context, path);\n\n    if (distinct.operation) {\n      return distinct.operation;\n    }\n\n    context = distinct.context;\n    const predicate = path.predicate;\n    const sVar = path.subject.termType === 'Variable';\n    const oVar = path.object.termType === 'Variable';\n    const gVar = path.graph.termType === 'Variable';\n\n    if (sVar && oVar) {\n      // Query ?s ?p ?o, to get all possible namedNodes in de the db\n      const predVar = this.generateVariable(path);\n      const single = actor_abstract_path_1.ActorAbstractPath.FACTORY.createPattern(path.subject, predVar, path.object, path.graph);\n      const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n        context,\n        operation: single\n      }));\n      const subjectString = rdf_string_1.termToString(path.subject);\n      const objectString = rdf_string_1.termToString(path.object); // Set with all namedNodes we have already started a predicate* search from\n\n      const entities = new Set();\n      const termHashes = {};\n      const bindingsStream = new asynciterator_1.MultiTransformIterator(results.bindingsStream, {\n        multiTransform: bindings => {\n          // Get the subject and object of the triples (?s ?p ?o) and extract graph if it was a variable\n          const subject = bindings.get(subjectString);\n          const object = bindings.get(objectString);\n          const graph = gVar ? bindings.get(rdf_string_1.termToString(path.graph)) : path.graph; // Make a hash of namedNode + graph to remember from where we already started a search\n\n          const subjectGraphHash = rdf_string_1.termToString(subject) + rdf_string_1.termToString(graph);\n          const objectGraphHash = rdf_string_1.termToString(object) + rdf_string_1.termToString(graph);\n          return new asynciterator_1.TransformIterator(async () => {\n            // If no new namedNodes in this triple, return nothing\n            if (entities.has(subjectGraphHash) && entities.has(objectGraphHash)) {\n              return new asynciterator_1.EmptyIterator();\n            } // Set up an iterator to which getSubjectAndObjectBindingsPredicateStar will push solutions\n\n\n            const it = new asynciterator_1.BufferedIterator();\n            const counter = {\n              count: 0\n            }; // If not started from this namedNode (subject in triple) in this graph, start a search\n\n            if (!entities.has(subjectGraphHash)) {\n              entities.add(subjectGraphHash);\n              await this.getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, subject, subject, predicate.path, graph, context, termHashes, {}, it, counter);\n            } // If not started from this namedNode (object in triple) in this graph, start a search\n\n\n            if (!entities.has(objectGraphHash)) {\n              entities.add(objectGraphHash);\n              await this.getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, object, object, predicate.path, graph, context, termHashes, {}, it, counter);\n            }\n\n            return it.transform({\n              transform(item, next, push) {\n                // If the graph was a variable, fill in it's binding (we got it from the ?s ?p ?o binding)\n                if (gVar) {\n                  item = item.set(rdf_string_1.termToString(path.graph), graph);\n                }\n\n                push(item);\n                next();\n              }\n\n            });\n          });\n        }\n      });\n      const variables = gVar ? [subjectString, objectString, rdf_string_1.termToString(path.graph)] : [subjectString, objectString];\n      return {\n        type: 'bindings',\n        bindingsStream,\n        variables,\n        canContainUndefs: false\n      };\n    }\n\n    if (!sVar && !oVar) {\n      const variable = this.generateVariable();\n      const bindingsStream = (await this.getObjectsPredicateStarEval(path.subject, variable, predicate.path, path.graph, context)).transform({\n        filter: item => item.get(rdf_string_1.termToString(variable)).equals(path.object),\n\n        transform(item, next, push) {\n          // Return graph binding if graph was a variable, otherwise empty binding\n          const binding = gVar ? bus_query_operation_1.Bindings({\n            [rdf_string_1.termToString(path.graph)]: item.get(rdf_string_1.termToString(path.graph))\n          }) : bus_query_operation_1.Bindings({});\n          push(binding);\n          next();\n        }\n\n      });\n      return {\n        type: 'bindings',\n        bindingsStream,\n        variables: gVar ? [rdf_string_1.termToString(path.graph)] : [],\n        canContainUndefs: false\n      };\n    } // If (sVar || oVar)\n\n\n    const subject = sVar ? path.object : path.subject;\n    const value = sVar ? path.subject : path.object;\n    const pred = sVar ? actor_abstract_path_1.ActorAbstractPath.FACTORY.createInv(predicate.path) : predicate.path;\n    const bindingsStream = (await this.getObjectsPredicateStarEval(subject, value, pred, path.graph, context)).transform({\n      transform(item, next, push) {\n        push(item);\n        next();\n      }\n\n    });\n    const variables = gVar ? [rdf_string_1.termToString(value), rdf_string_1.termToString(path.graph)] : [rdf_string_1.termToString(value)];\n    return {\n      type: 'bindings',\n      bindingsStream,\n      variables,\n      canContainUndefs: false\n    };\n  }\n\n}\n\nexports.ActorQueryOperationPathZeroOrMore = ActorQueryOperationPathZeroOrMore;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-path-zero-or-more/lib/ActorQueryOperationPathZeroOrMore.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationPathZeroOrMore","actor_abstract_path_1","require","bus_query_operation_1","asynciterator_1","rdf_string_1","sparqlalgebrajs_1","ActorAbstractPath","constructor","args","Algebra","types","ZERO_OR_MORE_PATH","runOperation","path","context","distinct","isPathArbitraryLengthDistinct","operation","predicate","sVar","subject","termType","oVar","object","gVar","graph","predVar","generateVariable","single","FACTORY","createPattern","results","ActorQueryOperation","getSafeBindings","mediatorQueryOperation","mediate","subjectString","termToString","objectString","entities","Set","termHashes","bindingsStream","MultiTransformIterator","multiTransform","bindings","get","subjectGraphHash","objectGraphHash","TransformIterator","has","EmptyIterator","it","BufferedIterator","counter","count","add","getSubjectAndObjectBindingsPredicateStar","transform","item","next","push","set","variables","type","canContainUndefs","variable","getObjectsPredicateStarEval","filter","equals","binding","Bindings","pred","createInv"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationPathZeroOrMore = void 0;\nconst actor_abstract_path_1 = require(\"@comunica/actor-abstract-path\");\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica Path ZeroOrMore Query Operation Actor.\n */\nclass ActorQueryOperationPathZeroOrMore extends actor_abstract_path_1.ActorAbstractPath {\n    constructor(args) {\n        super(args, sparqlalgebrajs_1.Algebra.types.ZERO_OR_MORE_PATH);\n    }\n    async runOperation(path, context) {\n        const distinct = await this.isPathArbitraryLengthDistinct(context, path);\n        if (distinct.operation) {\n            return distinct.operation;\n        }\n        context = distinct.context;\n        const predicate = path.predicate;\n        const sVar = path.subject.termType === 'Variable';\n        const oVar = path.object.termType === 'Variable';\n        const gVar = path.graph.termType === 'Variable';\n        if (sVar && oVar) {\n            // Query ?s ?p ?o, to get all possible namedNodes in de the db\n            const predVar = this.generateVariable(path);\n            const single = actor_abstract_path_1.ActorAbstractPath.FACTORY.createPattern(path.subject, predVar, path.object, path.graph);\n            const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ context, operation: single }));\n            const subjectString = rdf_string_1.termToString(path.subject);\n            const objectString = rdf_string_1.termToString(path.object);\n            // Set with all namedNodes we have already started a predicate* search from\n            const entities = new Set();\n            const termHashes = {};\n            const bindingsStream = new asynciterator_1.MultiTransformIterator(results.bindingsStream, {\n                multiTransform: (bindings) => {\n                    // Get the subject and object of the triples (?s ?p ?o) and extract graph if it was a variable\n                    const subject = bindings.get(subjectString);\n                    const object = bindings.get(objectString);\n                    const graph = gVar ? bindings.get(rdf_string_1.termToString(path.graph)) : path.graph;\n                    // Make a hash of namedNode + graph to remember from where we already started a search\n                    const subjectGraphHash = rdf_string_1.termToString(subject) + rdf_string_1.termToString(graph);\n                    const objectGraphHash = rdf_string_1.termToString(object) + rdf_string_1.termToString(graph);\n                    return new asynciterator_1.TransformIterator(async () => {\n                        // If no new namedNodes in this triple, return nothing\n                        if (entities.has(subjectGraphHash) && entities.has(objectGraphHash)) {\n                            return new asynciterator_1.EmptyIterator();\n                        }\n                        // Set up an iterator to which getSubjectAndObjectBindingsPredicateStar will push solutions\n                        const it = new asynciterator_1.BufferedIterator();\n                        const counter = { count: 0 };\n                        // If not started from this namedNode (subject in triple) in this graph, start a search\n                        if (!entities.has(subjectGraphHash)) {\n                            entities.add(subjectGraphHash);\n                            await this.getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, subject, subject, predicate.path, graph, context, termHashes, {}, it, counter);\n                        }\n                        // If not started from this namedNode (object in triple) in this graph, start a search\n                        if (!entities.has(objectGraphHash)) {\n                            entities.add(objectGraphHash);\n                            await this.getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, object, object, predicate.path, graph, context, termHashes, {}, it, counter);\n                        }\n                        return it.transform({\n                            transform(item, next, push) {\n                                // If the graph was a variable, fill in it's binding (we got it from the ?s ?p ?o binding)\n                                if (gVar) {\n                                    item = item.set(rdf_string_1.termToString(path.graph), graph);\n                                }\n                                push(item);\n                                next();\n                            },\n                        });\n                    });\n                },\n            });\n            const variables = gVar ?\n                [subjectString, objectString, rdf_string_1.termToString(path.graph)] :\n                [subjectString, objectString];\n            return { type: 'bindings', bindingsStream, variables, canContainUndefs: false };\n        }\n        if (!sVar && !oVar) {\n            const variable = this.generateVariable();\n            const bindingsStream = (await this.getObjectsPredicateStarEval(path.subject, variable, predicate.path, path.graph, context))\n                .transform({\n                filter: item => item.get(rdf_string_1.termToString(variable)).equals(path.object),\n                transform(item, next, push) {\n                    // Return graph binding if graph was a variable, otherwise empty binding\n                    const binding = gVar ?\n                        bus_query_operation_1.Bindings({ [rdf_string_1.termToString(path.graph)]: item.get(rdf_string_1.termToString(path.graph)) }) :\n                        bus_query_operation_1.Bindings({});\n                    push(binding);\n                    next();\n                },\n            });\n            return {\n                type: 'bindings',\n                bindingsStream,\n                variables: gVar ? [rdf_string_1.termToString(path.graph)] : [],\n                canContainUndefs: false,\n            };\n        }\n        // If (sVar || oVar)\n        const subject = sVar ? path.object : path.subject;\n        const value = (sVar ? path.subject : path.object);\n        const pred = sVar ? actor_abstract_path_1.ActorAbstractPath.FACTORY.createInv(predicate.path) : predicate.path;\n        const bindingsStream = (await this.getObjectsPredicateStarEval(subject, value, pred, path.graph, context))\n            .transform({\n            transform(item, next, push) {\n                push(item);\n                next();\n            },\n        });\n        const variables = gVar ? [rdf_string_1.termToString(value), rdf_string_1.termToString(path.graph)] : [rdf_string_1.termToString(value)];\n        return { type: 'bindings', bindingsStream, variables, canContainUndefs: false };\n    }\n}\nexports.ActorQueryOperationPathZeroOrMore = ActorQueryOperationPathZeroOrMore;\n//# sourceMappingURL=ActorQueryOperationPathZeroOrMore.js.map"]},"metadata":{},"sourceType":"script"}