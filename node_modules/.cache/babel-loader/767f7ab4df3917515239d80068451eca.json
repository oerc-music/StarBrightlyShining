{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Converter = void 0;\n\nconst language_1 = require(\"graphql/language\");\n\nconst handler_1 = require(\"./handler\");\n\nconst directivenode_1 = require(\"./handler/directivenode\");\n\nconst IConvertContext_1 = require(\"./IConvertContext\");\n\nconst Util_1 = require(\"./Util\");\n/**\n * Translate GraphQL queries into SPARQL algebra.\n */\n\n\nclass Converter {\n  constructor(settings) {\n    settings = settings || {};\n    settings.variableDelimiter = settings.variableDelimiter || '_';\n    settings.expressionVariableCounter = settings.expressionVariableCounter || 0;\n    this.util = new Util_1.Util(settings);\n    this.initializeNodeHandlers(settings);\n  }\n\n  static registerNodeHandlers(util, settings) {\n    util.registerNodeHandler(new handler_1.NodeHandlerDocument(util, settings));\n    util.registerNodeHandler(new handler_1.NodeHandlerDefinitionOperation(util, settings));\n    util.registerNodeHandler(new handler_1.NodeHandlerDefinitionFragment(util, settings));\n    util.registerNodeHandler(new handler_1.NodeHandlerSelectionFragmentSpread(util, settings));\n    util.registerNodeHandler(new handler_1.NodeHandlerSelectionInlineFragment(util, settings));\n    util.registerNodeHandler(new handler_1.NodeHandlerSelectionField(util, settings));\n  }\n\n  static registerNodeValueHandlers(util, settings) {\n    util.registerNodeValueHandler(new handler_1.NodeValueHandlerVariable(util, settings));\n    util.registerNodeValueHandler(new handler_1.NodeValueHandlerInt(util, settings));\n    util.registerNodeValueHandler(new handler_1.NodeValueHandlerFloat(util, settings));\n    util.registerNodeValueHandler(new handler_1.NodeValueHandlerString(util, settings));\n    util.registerNodeValueHandler(new handler_1.NodeValueHandlerBoolean(util, settings));\n    util.registerNodeValueHandler(new handler_1.NodeValueHandlerNull(util, settings));\n    util.registerNodeValueHandler(new handler_1.NodeValueHandlerEnum(util, settings));\n    util.registerNodeValueHandler(new handler_1.NodeValueHandlerList(util, settings));\n    util.registerNodeValueHandler(new handler_1.NodeValueHandlerObject(util, settings));\n  }\n\n  static registerDirectiveNodeHandlers(util, settings) {\n    util.registerDirectiveNodeHandler(new directivenode_1.DirectiveNodeHandlerInclude(util, settings));\n    util.registerDirectiveNodeHandler(new directivenode_1.DirectiveNodeHandlerOptional(util, settings));\n    util.registerDirectiveNodeHandler(new directivenode_1.DirectiveNodeHandlerPlural(util, settings));\n    util.registerDirectiveNodeHandler(new directivenode_1.DirectiveNodeHandlerSingle(util, settings));\n    util.registerDirectiveNodeHandler(new directivenode_1.DirectiveNodeHandlerSkip(util, settings));\n  }\n  /**\n   * Translates a GraphQL query into SPARQL algebra.\n   * @param {string | DocumentNode} graphqlQuery A GraphQL query string or node.\n   * @param {IContext} context A JSON-LD context.\n   * @param {IConvertOptions} options An options object.\n   * @return {Promise<Operation>} A promise resolving to an operation.\n   */\n\n\n  graphqlToSparqlAlgebra(graphqlQuery, context, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.graphqlToSparqlAlgebraRawContext(graphqlQuery, yield this.util.contextParser.parse(context), options);\n    });\n  }\n  /**\n   * Translates a GraphQL query into SPARQL algebra.\n   * @param {string | DocumentNode} graphqlQuery A GraphQL query string or node.\n   * @param {IContext} context A JSON-LD context.\n   * @param {IConvertOptions} options An options object.\n   * @return {Operation} An operation.\n   */\n\n\n  graphqlToSparqlAlgebraRawContext(graphqlQuery, context, options) {\n    options = options || {};\n    const document = typeof graphqlQuery === 'string' ? language_1.parse(graphqlQuery) : graphqlQuery;\n    const fragmentDefinitions = this.indexFragments(document);\n    const convertContext = {\n      context,\n      fragmentDefinitions,\n      graph: this.util.dataFactory.defaultGraph(),\n      path: [],\n      singularizeState: IConvertContext_1.SingularizeState.PLURAL,\n      singularizeVariables: options.singularizeVariables || {},\n      subject: null,\n      terminalVariables: [],\n      variablesDict: options.variablesDict || {},\n      variablesMetaDict: {}\n    };\n    return this.util.handleNode(document, convertContext);\n  }\n  /**\n   * Create an index of all fragment definitions in the given document.\n   *\n   * This will assign a new array of definition nodes without fragment definition.\n   *\n   * @param {DocumentNode} document A document node.\n   * @return {{[p: string]: FragmentDefinitionNode}} An index of fragment definition nodes.\n   */\n\n\n  indexFragments(document) {\n    const fragmentDefinitions = {};\n    const newDefinitions = [];\n\n    for (const definition of document.definitions) {\n      if (definition.kind === 'FragmentDefinition') {\n        fragmentDefinitions[definition.name.value] = definition;\n      } else {\n        newDefinitions.push(definition);\n      }\n    }\n\n    document.definitions = newDefinitions;\n    return fragmentDefinitions;\n  }\n\n  initializeNodeHandlers(settings) {\n    Converter.registerNodeHandlers(this.util, settings);\n    Converter.registerNodeValueHandlers(this.util, settings);\n    Converter.registerDirectiveNodeHandlers(this.util, settings);\n  }\n\n}\n\nexports.Converter = Converter;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/graphql-to-sparql/lib/Converter.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","Converter","language_1","require","handler_1","directivenode_1","IConvertContext_1","Util_1","constructor","settings","variableDelimiter","expressionVariableCounter","util","Util","initializeNodeHandlers","registerNodeHandlers","registerNodeHandler","NodeHandlerDocument","NodeHandlerDefinitionOperation","NodeHandlerDefinitionFragment","NodeHandlerSelectionFragmentSpread","NodeHandlerSelectionInlineFragment","NodeHandlerSelectionField","registerNodeValueHandlers","registerNodeValueHandler","NodeValueHandlerVariable","NodeValueHandlerInt","NodeValueHandlerFloat","NodeValueHandlerString","NodeValueHandlerBoolean","NodeValueHandlerNull","NodeValueHandlerEnum","NodeValueHandlerList","NodeValueHandlerObject","registerDirectiveNodeHandlers","registerDirectiveNodeHandler","DirectiveNodeHandlerInclude","DirectiveNodeHandlerOptional","DirectiveNodeHandlerPlural","DirectiveNodeHandlerSingle","DirectiveNodeHandlerSkip","graphqlToSparqlAlgebra","graphqlQuery","context","options","graphqlToSparqlAlgebraRawContext","contextParser","parse","document","fragmentDefinitions","indexFragments","convertContext","graph","dataFactory","defaultGraph","path","singularizeState","SingularizeState","PLURAL","singularizeVariables","subject","terminalVariables","variablesDict","variablesMetaDict","handleNode","newDefinitions","definition","definitions","kind","name","push"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Converter = void 0;\nconst language_1 = require(\"graphql/language\");\nconst handler_1 = require(\"./handler\");\nconst directivenode_1 = require(\"./handler/directivenode\");\nconst IConvertContext_1 = require(\"./IConvertContext\");\nconst Util_1 = require(\"./Util\");\n/**\n * Translate GraphQL queries into SPARQL algebra.\n */\nclass Converter {\n    constructor(settings) {\n        settings = settings || {};\n        settings.variableDelimiter = settings.variableDelimiter || '_';\n        settings.expressionVariableCounter = settings.expressionVariableCounter || 0;\n        this.util = new Util_1.Util(settings);\n        this.initializeNodeHandlers(settings);\n    }\n    static registerNodeHandlers(util, settings) {\n        util.registerNodeHandler(new handler_1.NodeHandlerDocument(util, settings));\n        util.registerNodeHandler(new handler_1.NodeHandlerDefinitionOperation(util, settings));\n        util.registerNodeHandler(new handler_1.NodeHandlerDefinitionFragment(util, settings));\n        util.registerNodeHandler(new handler_1.NodeHandlerSelectionFragmentSpread(util, settings));\n        util.registerNodeHandler(new handler_1.NodeHandlerSelectionInlineFragment(util, settings));\n        util.registerNodeHandler(new handler_1.NodeHandlerSelectionField(util, settings));\n    }\n    static registerNodeValueHandlers(util, settings) {\n        util.registerNodeValueHandler(new handler_1.NodeValueHandlerVariable(util, settings));\n        util.registerNodeValueHandler(new handler_1.NodeValueHandlerInt(util, settings));\n        util.registerNodeValueHandler(new handler_1.NodeValueHandlerFloat(util, settings));\n        util.registerNodeValueHandler(new handler_1.NodeValueHandlerString(util, settings));\n        util.registerNodeValueHandler(new handler_1.NodeValueHandlerBoolean(util, settings));\n        util.registerNodeValueHandler(new handler_1.NodeValueHandlerNull(util, settings));\n        util.registerNodeValueHandler(new handler_1.NodeValueHandlerEnum(util, settings));\n        util.registerNodeValueHandler(new handler_1.NodeValueHandlerList(util, settings));\n        util.registerNodeValueHandler(new handler_1.NodeValueHandlerObject(util, settings));\n    }\n    static registerDirectiveNodeHandlers(util, settings) {\n        util.registerDirectiveNodeHandler(new directivenode_1.DirectiveNodeHandlerInclude(util, settings));\n        util.registerDirectiveNodeHandler(new directivenode_1.DirectiveNodeHandlerOptional(util, settings));\n        util.registerDirectiveNodeHandler(new directivenode_1.DirectiveNodeHandlerPlural(util, settings));\n        util.registerDirectiveNodeHandler(new directivenode_1.DirectiveNodeHandlerSingle(util, settings));\n        util.registerDirectiveNodeHandler(new directivenode_1.DirectiveNodeHandlerSkip(util, settings));\n    }\n    /**\n     * Translates a GraphQL query into SPARQL algebra.\n     * @param {string | DocumentNode} graphqlQuery A GraphQL query string or node.\n     * @param {IContext} context A JSON-LD context.\n     * @param {IConvertOptions} options An options object.\n     * @return {Promise<Operation>} A promise resolving to an operation.\n     */\n    graphqlToSparqlAlgebra(graphqlQuery, context, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.graphqlToSparqlAlgebraRawContext(graphqlQuery, yield this.util.contextParser.parse(context), options);\n        });\n    }\n    /**\n     * Translates a GraphQL query into SPARQL algebra.\n     * @param {string | DocumentNode} graphqlQuery A GraphQL query string or node.\n     * @param {IContext} context A JSON-LD context.\n     * @param {IConvertOptions} options An options object.\n     * @return {Operation} An operation.\n     */\n    graphqlToSparqlAlgebraRawContext(graphqlQuery, context, options) {\n        options = options || {};\n        const document = typeof graphqlQuery === 'string' ? language_1.parse(graphqlQuery) : graphqlQuery;\n        const fragmentDefinitions = this.indexFragments(document);\n        const convertContext = {\n            context,\n            fragmentDefinitions,\n            graph: this.util.dataFactory.defaultGraph(),\n            path: [],\n            singularizeState: IConvertContext_1.SingularizeState.PLURAL,\n            singularizeVariables: options.singularizeVariables || {},\n            subject: null,\n            terminalVariables: [],\n            variablesDict: options.variablesDict || {},\n            variablesMetaDict: {},\n        };\n        return this.util.handleNode(document, convertContext);\n    }\n    /**\n     * Create an index of all fragment definitions in the given document.\n     *\n     * This will assign a new array of definition nodes without fragment definition.\n     *\n     * @param {DocumentNode} document A document node.\n     * @return {{[p: string]: FragmentDefinitionNode}} An index of fragment definition nodes.\n     */\n    indexFragments(document) {\n        const fragmentDefinitions = {};\n        const newDefinitions = [];\n        for (const definition of document.definitions) {\n            if (definition.kind === 'FragmentDefinition') {\n                fragmentDefinitions[definition.name.value] = definition;\n            }\n            else {\n                newDefinitions.push(definition);\n            }\n        }\n        document.definitions = newDefinitions;\n        return fragmentDefinitions;\n    }\n    initializeNodeHandlers(settings) {\n        Converter.registerNodeHandlers(this.util, settings);\n        Converter.registerNodeValueHandlers(this.util, settings);\n        Converter.registerDirectiveNodeHandlers(this.util, settings);\n    }\n}\nexports.Converter = Converter;\n//# sourceMappingURL=Converter.js.map"]},"metadata":{},"sourceType":"script"}