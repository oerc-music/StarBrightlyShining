{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationOrderBySparqlee = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n\nconst sparqlee_1 = require(\"sparqlee\");\n\nconst SortIterator_1 = require(\"./SortIterator\");\n/**\n * A comunica OrderBy Sparqlee Query Operation Actor.\n */\n\n\nclass ActorQueryOperationOrderBySparqlee extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n  constructor(args) {\n    var _a;\n\n    super(args, 'orderby');\n    this.window = (_a = args.window) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY;\n  }\n\n  async testOperation(pattern, context) {\n    // Will throw error for unsupported operators\n    for (let expr of pattern.expressions) {\n      expr = this.extractSortExpression(expr);\n\n      const _ = new sparqlee_1.AsyncEvaluator(expr);\n    }\n\n    return true;\n  }\n\n  async runOperation(pattern, context) {\n    const outputRaw = await this.mediatorQueryOperation.mediate({\n      operation: pattern.input,\n      context\n    });\n    const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(outputRaw);\n    const options = {\n      window: this.window\n    };\n    const sparqleeConfig = Object.assign({}, bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context));\n    let {\n      bindingsStream\n    } = output; // Sorting backwards since the first one is the most important therefore should be ordered last.\n\n    for (let i = pattern.expressions.length - 1; i >= 0; i--) {\n      let expr = pattern.expressions[i];\n      const isAscending = this.isAscending(expr);\n      expr = this.extractSortExpression(expr); // Transform the stream by annotating it with the expr result\n\n      const evaluator = new sparqlee_1.AsyncEvaluator(expr, sparqleeConfig); // eslint-disable-next-line @typescript-eslint/no-loop-func\n\n      const transform = async (bindings, next, push) => {\n        try {\n          const result = await evaluator.evaluate(bindings);\n          push({\n            bindings,\n            result\n          });\n        } catch (error) {\n          // We ignore all Expression errors.\n          // Other errors (likely programming mistakes) are still propagated.\n          // I can't recall where this is defined in the spec.\n          if (!sparqlee_1.isExpressionError(error)) {\n            bindingsStream.emit('error', error);\n          }\n\n          push({\n            bindings,\n            result: undefined\n          });\n        }\n\n        next();\n      };\n\n      const transformedStream = bindingsStream.transform({\n        transform\n      }); // Sort the annoted stream\n\n      const sortedStream = new SortIterator_1.SortIterator(transformedStream, (left, right) => sparqlee_1.orderTypes(left.result, right.result, isAscending), options); // Remove the annotation\n\n      bindingsStream = sortedStream.map(({\n        bindings,\n        result\n      }) => bindings);\n    }\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata: output.metadata,\n      variables: output.variables,\n      canContainUndefs: output.canContainUndefs\n    };\n  } // Remove descending operator if necessary\n\n\n  extractSortExpression(expr) {\n    const {\n      expressionType,\n      operator\n    } = expr;\n\n    if (expressionType !== sparqlalgebrajs_1.Algebra.expressionTypes.OPERATOR) {\n      return expr;\n    }\n\n    return operator === 'desc' ? expr.args[0] : expr;\n  }\n\n  isAscending(expr) {\n    const {\n      expressionType,\n      operator\n    } = expr;\n\n    if (expressionType !== sparqlalgebrajs_1.Algebra.expressionTypes.OPERATOR) {\n      return true;\n    }\n\n    return operator !== 'desc';\n  }\n\n}\n\nexports.ActorQueryOperationOrderBySparqlee = ActorQueryOperationOrderBySparqlee;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-orderby-sparqlee/lib/ActorQueryOperationOrderBySparqlee.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationOrderBySparqlee","bus_query_operation_1","require","sparqlalgebrajs_1","sparqlee_1","SortIterator_1","ActorQueryOperationTypedMediated","constructor","args","_a","window","Number","POSITIVE_INFINITY","testOperation","pattern","context","expr","expressions","extractSortExpression","_","AsyncEvaluator","runOperation","outputRaw","mediatorQueryOperation","mediate","operation","input","output","ActorQueryOperation","getSafeBindings","options","sparqleeConfig","assign","getAsyncExpressionContext","bindingsStream","i","length","isAscending","evaluator","transform","bindings","next","push","result","evaluate","error","isExpressionError","emit","undefined","transformedStream","sortedStream","SortIterator","left","right","orderTypes","map","type","metadata","variables","canContainUndefs","expressionType","operator","Algebra","expressionTypes","OPERATOR"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,kCAAR,GAA6C,KAAK,CAAlD;;AACA,MAAMC,qBAAqB,GAAGC,OAAO,CAAC,+BAAD,CAArC;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,iBAAD,CAAjC;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,UAAD,CAA1B;;AACA,MAAMG,cAAc,GAAGH,OAAO,CAAC,gBAAD,CAA9B;AACA;AACA;AACA;;;AACA,MAAMF,kCAAN,SAAiDC,qBAAqB,CAACK,gCAAvE,CAAwG;AACpGC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,QAAIC,EAAJ;;AACA,UAAMD,IAAN,EAAY,SAAZ;AACA,SAAKE,MAAL,GAAc,CAACD,EAAE,GAAGD,IAAI,CAACE,MAAX,MAAuB,IAAvB,IAA+BD,EAAE,KAAK,KAAK,CAA3C,GAA+CA,EAA/C,GAAoDE,MAAM,CAACC,iBAAzE;AACH;;AACkB,QAAbC,aAAa,CAACC,OAAD,EAAUC,OAAV,EAAmB;AAClC;AACA,SAAK,IAAIC,IAAT,IAAiBF,OAAO,CAACG,WAAzB,EAAsC;AAClCD,MAAAA,IAAI,GAAG,KAAKE,qBAAL,CAA2BF,IAA3B,CAAP;;AACA,YAAMG,CAAC,GAAG,IAAIf,UAAU,CAACgB,cAAf,CAA8BJ,IAA9B,CAAV;AACH;;AACD,WAAO,IAAP;AACH;;AACiB,QAAZK,YAAY,CAACP,OAAD,EAAUC,OAAV,EAAmB;AACjC,UAAMO,SAAS,GAAG,MAAM,KAAKC,sBAAL,CAA4BC,OAA5B,CAAoC;AAAEC,MAAAA,SAAS,EAAEX,OAAO,CAACY,KAArB;AAA4BX,MAAAA;AAA5B,KAApC,CAAxB;AACA,UAAMY,MAAM,GAAG1B,qBAAqB,CAAC2B,mBAAtB,CAA0CC,eAA1C,CAA0DP,SAA1D,CAAf;AACA,UAAMQ,OAAO,GAAG;AAAEpB,MAAAA,MAAM,EAAE,KAAKA;AAAf,KAAhB;AACA,UAAMqB,cAAc,GAAGnC,MAAM,CAACoC,MAAP,CAAc,EAAd,EAAkB/B,qBAAqB,CAAC2B,mBAAtB,CAA0CK,yBAA1C,CAAoElB,OAApE,CAAlB,CAAvB;AACA,QAAI;AAAEmB,MAAAA;AAAF,QAAqBP,MAAzB,CALiC,CAMjC;;AACA,SAAK,IAAIQ,CAAC,GAAGrB,OAAO,CAACG,WAAR,CAAoBmB,MAApB,GAA6B,CAA1C,EAA6CD,CAAC,IAAI,CAAlD,EAAqDA,CAAC,EAAtD,EAA0D;AACtD,UAAInB,IAAI,GAAGF,OAAO,CAACG,WAAR,CAAoBkB,CAApB,CAAX;AACA,YAAME,WAAW,GAAG,KAAKA,WAAL,CAAiBrB,IAAjB,CAApB;AACAA,MAAAA,IAAI,GAAG,KAAKE,qBAAL,CAA2BF,IAA3B,CAAP,CAHsD,CAItD;;AACA,YAAMsB,SAAS,GAAG,IAAIlC,UAAU,CAACgB,cAAf,CAA8BJ,IAA9B,EAAoCe,cAApC,CAAlB,CALsD,CAMtD;;AACA,YAAMQ,SAAS,GAAG,OAAOC,QAAP,EAAiBC,IAAjB,EAAuBC,IAAvB,KAAgC;AAC9C,YAAI;AACA,gBAAMC,MAAM,GAAG,MAAML,SAAS,CAACM,QAAV,CAAmBJ,QAAnB,CAArB;AACAE,UAAAA,IAAI,CAAC;AAAEF,YAAAA,QAAF;AAAYG,YAAAA;AAAZ,WAAD,CAAJ;AACH,SAHD,CAIA,OAAOE,KAAP,EAAc;AACV;AACA;AACA;AACA,cAAI,CAACzC,UAAU,CAAC0C,iBAAX,CAA6BD,KAA7B,CAAL,EAA0C;AACtCX,YAAAA,cAAc,CAACa,IAAf,CAAoB,OAApB,EAA6BF,KAA7B;AACH;;AACDH,UAAAA,IAAI,CAAC;AAAEF,YAAAA,QAAF;AAAYG,YAAAA,MAAM,EAAEK;AAApB,WAAD,CAAJ;AACH;;AACDP,QAAAA,IAAI;AACP,OAfD;;AAgBA,YAAMQ,iBAAiB,GAAGf,cAAc,CAACK,SAAf,CAAyB;AAAEA,QAAAA;AAAF,OAAzB,CAA1B,CAvBsD,CAwBtD;;AACA,YAAMW,YAAY,GAAG,IAAI7C,cAAc,CAAC8C,YAAnB,CAAgCF,iBAAhC,EAAmD,CAACG,IAAD,EAAOC,KAAP,KAAiBjD,UAAU,CAACkD,UAAX,CAAsBF,IAAI,CAACT,MAA3B,EAAmCU,KAAK,CAACV,MAAzC,EAAiDN,WAAjD,CAApE,EAAmIP,OAAnI,CAArB,CAzBsD,CA0BtD;;AACAI,MAAAA,cAAc,GAAGgB,YAAY,CAACK,GAAb,CAAiB,CAAC;AAAEf,QAAAA,QAAF;AAAYG,QAAAA;AAAZ,OAAD,KAA0BH,QAA3C,CAAjB;AACH;;AACD,WAAO;AACHgB,MAAAA,IAAI,EAAE,UADH;AAEHtB,MAAAA,cAFG;AAGHuB,MAAAA,QAAQ,EAAE9B,MAAM,CAAC8B,QAHd;AAIHC,MAAAA,SAAS,EAAE/B,MAAM,CAAC+B,SAJf;AAKHC,MAAAA,gBAAgB,EAAEhC,MAAM,CAACgC;AALtB,KAAP;AAOH,GAzDmG,CA0DpG;;;AACAzC,EAAAA,qBAAqB,CAACF,IAAD,EAAO;AACxB,UAAM;AAAE4C,MAAAA,cAAF;AAAkBC,MAAAA;AAAlB,QAA+B7C,IAArC;;AACA,QAAI4C,cAAc,KAAKzD,iBAAiB,CAAC2D,OAAlB,CAA0BC,eAA1B,CAA0CC,QAAjE,EAA2E;AACvE,aAAOhD,IAAP;AACH;;AACD,WAAO6C,QAAQ,KAAK,MAAb,GACH7C,IAAI,CAACR,IAAL,CAAU,CAAV,CADG,GAEHQ,IAFJ;AAGH;;AACDqB,EAAAA,WAAW,CAACrB,IAAD,EAAO;AACd,UAAM;AAAE4C,MAAAA,cAAF;AAAkBC,MAAAA;AAAlB,QAA+B7C,IAArC;;AACA,QAAI4C,cAAc,KAAKzD,iBAAiB,CAAC2D,OAAlB,CAA0BC,eAA1B,CAA0CC,QAAjE,EAA2E;AACvE,aAAO,IAAP;AACH;;AACD,WAAOH,QAAQ,KAAK,MAApB;AACH;;AA1EmG;;AA4ExG/D,OAAO,CAACE,kCAAR,GAA6CA,kCAA7C","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationOrderBySparqlee = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\nconst sparqlee_1 = require(\"sparqlee\");\nconst SortIterator_1 = require(\"./SortIterator\");\n/**\n * A comunica OrderBy Sparqlee Query Operation Actor.\n */\nclass ActorQueryOperationOrderBySparqlee extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n    constructor(args) {\n        var _a;\n        super(args, 'orderby');\n        this.window = (_a = args.window) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY;\n    }\n    async testOperation(pattern, context) {\n        // Will throw error for unsupported operators\n        for (let expr of pattern.expressions) {\n            expr = this.extractSortExpression(expr);\n            const _ = new sparqlee_1.AsyncEvaluator(expr);\n        }\n        return true;\n    }\n    async runOperation(pattern, context) {\n        const outputRaw = await this.mediatorQueryOperation.mediate({ operation: pattern.input, context });\n        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(outputRaw);\n        const options = { window: this.window };\n        const sparqleeConfig = Object.assign({}, bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context));\n        let { bindingsStream } = output;\n        // Sorting backwards since the first one is the most important therefore should be ordered last.\n        for (let i = pattern.expressions.length - 1; i >= 0; i--) {\n            let expr = pattern.expressions[i];\n            const isAscending = this.isAscending(expr);\n            expr = this.extractSortExpression(expr);\n            // Transform the stream by annotating it with the expr result\n            const evaluator = new sparqlee_1.AsyncEvaluator(expr, sparqleeConfig);\n            // eslint-disable-next-line @typescript-eslint/no-loop-func\n            const transform = async (bindings, next, push) => {\n                try {\n                    const result = await evaluator.evaluate(bindings);\n                    push({ bindings, result });\n                }\n                catch (error) {\n                    // We ignore all Expression errors.\n                    // Other errors (likely programming mistakes) are still propagated.\n                    // I can't recall where this is defined in the spec.\n                    if (!sparqlee_1.isExpressionError(error)) {\n                        bindingsStream.emit('error', error);\n                    }\n                    push({ bindings, result: undefined });\n                }\n                next();\n            };\n            const transformedStream = bindingsStream.transform({ transform });\n            // Sort the annoted stream\n            const sortedStream = new SortIterator_1.SortIterator(transformedStream, (left, right) => sparqlee_1.orderTypes(left.result, right.result, isAscending), options);\n            // Remove the annotation\n            bindingsStream = sortedStream.map(({ bindings, result }) => bindings);\n        }\n        return {\n            type: 'bindings',\n            bindingsStream,\n            metadata: output.metadata,\n            variables: output.variables,\n            canContainUndefs: output.canContainUndefs,\n        };\n    }\n    // Remove descending operator if necessary\n    extractSortExpression(expr) {\n        const { expressionType, operator } = expr;\n        if (expressionType !== sparqlalgebrajs_1.Algebra.expressionTypes.OPERATOR) {\n            return expr;\n        }\n        return operator === 'desc' ?\n            expr.args[0] :\n            expr;\n    }\n    isAscending(expr) {\n        const { expressionType, operator } = expr;\n        if (expressionType !== sparqlalgebrajs_1.Algebra.expressionTypes.OPERATOR) {\n            return true;\n        }\n        return operator !== 'desc';\n    }\n}\nexports.ActorQueryOperationOrderBySparqlee = ActorQueryOperationOrderBySparqlee;\n//# sourceMappingURL=ActorQueryOperationOrderBySparqlee.js.map"]},"metadata":{},"sourceType":"script"}