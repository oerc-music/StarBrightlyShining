{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringQuadToQuad = exports.quadToStringQuad = exports.stringToTerm = exports.getLiteralLanguage = exports.getLiteralType = exports.getLiteralValue = exports.termToString = void 0;\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst FACTORY = new rdf_data_factory_1.DataFactory();\n/**\n * Utility methods for converting between string-based RDF representations and RDFJS objects.\n *\n * RDF Terms are represented as follows:\n * * Blank nodes: '_:myBlankNode'\n * * Variables:   '_myVariable'\n * * Literals:    '\"myString\"', '\"myLanguageString\"@en-us', '\"<p>e</p>\"^^<http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML>'\n * * URIs:        '<http://example.org>'\n *\n * Quads/triples are represented as hashes with 'subject', 'predicate', 'object' and 'graph' (optional)\n * as keys, and string-based RDF terms as values.\n */\n\n/**\n * Convert an RDFJS term to a string-based representation.\n * @param {RDF.Term} term An RDFJS term.\n * @return {string} A string-based term representation.\n */\n\nfunction termToString(term) {\n  // TODO: remove nasty any casts when this TS bug has been fixed: https://github.com/microsoft/TypeScript/issues/26933\n  if (!term) {\n    return undefined;\n  }\n\n  switch (term.termType) {\n    case 'NamedNode':\n      return '<' + term.value + '>';\n\n    case 'BlankNode':\n      return '_:' + term.value;\n\n    case 'Literal':\n      const literalValue = term;\n      return '\"' + literalValue.value.replace(/\"/ug, '\\\\\"') + '\"' + (literalValue.datatype && literalValue.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string' && literalValue.datatype.value !== 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' ? '^^<' + literalValue.datatype.value + '>' : '') + (literalValue.language ? '@' + literalValue.language : '');\n\n    case 'Quad':\n      return `<<${termToString(term.subject)} ${termToString(term.predicate)} ${termToString(term.object)}${term.graph.termType === 'DefaultGraph' ? '' : ' ' + termToString(term.graph)}>>`;\n\n    case 'Variable':\n      return '?' + term.value;\n\n    case 'DefaultGraph':\n      return term.value;\n  }\n}\n\nexports.termToString = termToString;\n/**\n * Get the string value of a literal.\n * @param {string} literalValue An RDF literal enclosed by '\"'.\n * @return {string} The literal value inside the '\"'.\n */\n\nfunction getLiteralValue(literalValue) {\n  const match = /^\"([^]*)\"((\\^\\^.*)|(@.*))?$/.exec(literalValue);\n\n  if (!match) {\n    throw new Error(literalValue + ' is not a literal');\n  }\n\n  return match[1].replace(/\\\\\"/ug, '\"');\n}\n\nexports.getLiteralValue = getLiteralValue;\n/**\n * Get the datatype of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The datatype of the literal.\n */\n\nfunction getLiteralType(literalValue) {\n  const match = /^\"[^]*\"(?:\\^\\^<([^\"]+)>|(@)[^@\"]+)?$/.exec(literalValue);\n\n  if (!match) {\n    throw new Error(literalValue + ' is not a literal');\n  }\n\n  return match[1] || (match[2] ? 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' : 'http://www.w3.org/2001/XMLSchema#string');\n}\n\nexports.getLiteralType = getLiteralType;\n/**\n * Get the language of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The language of the literal.\n */\n\nfunction getLiteralLanguage(literalValue) {\n  const match = /^\"[^]*\"(?:@([^@\"]+)|\\^\\^[^\"]+)?$/.exec(literalValue);\n\n  if (!match) {\n    throw new Error(literalValue + ' is not a literal');\n  }\n\n  return match[1] ? match[1].toLowerCase() : '';\n}\n\nexports.getLiteralLanguage = getLiteralLanguage;\n/**\n * Transform a string-based RDF term to an RDFJS term.\n * @param {string} value A string-based RDF-term.\n * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.\n * @return {RDF.Term} An RDF-JS term.\n */\n\nfunction stringToTerm(value, dataFactory) {\n  dataFactory = dataFactory || FACTORY;\n\n  if (!value || !value.length) {\n    return dataFactory.defaultGraph();\n  }\n\n  switch (value[0]) {\n    case '_':\n      return dataFactory.blankNode(value.substr(2));\n\n    case '?':\n      if (!dataFactory.variable) {\n        throw new Error(`Missing 'variable()' method on the given DataFactory`);\n      }\n\n      return dataFactory.variable(value.substr(1));\n\n    case '\"':\n      const language = getLiteralLanguage(value);\n      const type = dataFactory.namedNode(getLiteralType(value));\n      return dataFactory.literal(getLiteralValue(value), language || type);\n\n    case '<':\n    default:\n      if (value.startsWith('<<') && value.endsWith('>>')) {\n        // Iterate character-by-character to detect spaces that are *not* wrapped in <<>>\n        const terms = value.slice(2, -2);\n        const stringTerms = [];\n        let ignoreTags = 0;\n        let lastIndex = 0;\n\n        for (let i = 0; i < terms.length; i++) {\n          const char = terms[i];\n          if (char === '<') ignoreTags++;\n\n          if (char === '>') {\n            if (ignoreTags === 0) {\n              throw new Error('Found closing tag without opening tag in ' + value);\n            } else {\n              ignoreTags--;\n            }\n          }\n\n          if (char === ' ' && ignoreTags === 0) {\n            stringTerms.push(terms.slice(lastIndex, i));\n            lastIndex = i + 1;\n          }\n        }\n\n        if (ignoreTags !== 0) {\n          throw new Error('Found opening tag without closing tag in ' + value);\n        }\n\n        stringTerms.push(terms.slice(lastIndex, terms.length)); // We require 3 or 4 components\n\n        if (stringTerms.length !== 3 && stringTerms.length !== 4) {\n          throw new Error('Nested quad syntax error ' + value);\n        }\n\n        return dataFactory.quad(stringToTerm(stringTerms[0]), stringToTerm(stringTerms[1]), stringToTerm(stringTerms[2]), stringTerms[3] ? stringToTerm(stringTerms[3]) : undefined);\n      }\n\n      if (value.charAt(0) !== '<' || value.charAt(value.length - 1) !== '>') {\n        throw new Error(`Detected invalid iri for named node (must be wrapped in <>): ${value}`);\n      }\n\n      return dataFactory.namedNode(value.substring(1, value.length - 1));\n  }\n}\n\nexports.stringToTerm = stringToTerm;\n/**\n * Convert an RDFJS quad to a string-based quad representation.\n * @param {Quad} q An RDFJS quad.\n * @return {IStringQuad} A hash with string-based quad terms.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\n\nfunction quadToStringQuad(q) {\n  // tslint:disable:object-literal-sort-keys\n  return {\n    subject: termToString(q.subject),\n    predicate: termToString(q.predicate),\n    object: termToString(q.object),\n    graph: termToString(q.graph)\n  }; // tslint:enable:object-literal-sort-keys\n}\n\nexports.quadToStringQuad = quadToStringQuad;\n/**\n * Convert a string-based quad representation to an RDFJS quad.\n * @param {IStringQuad} stringQuad A hash with string-based quad terms.\n * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.\n * @return {Q} An RDFJS quad.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\n\nfunction stringQuadToQuad(stringQuad, dataFactory) {\n  dataFactory = dataFactory || FACTORY;\n  return dataFactory.quad(stringToTerm(stringQuad.subject, dataFactory), stringToTerm(stringQuad.predicate, dataFactory), stringToTerm(stringQuad.object, dataFactory), stringToTerm(stringQuad.graph, dataFactory));\n}\n\nexports.stringQuadToQuad = stringQuadToQuad;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/rdf-string-ttl/lib/TermUtil.js"],"names":["Object","defineProperty","exports","value","stringQuadToQuad","quadToStringQuad","stringToTerm","getLiteralLanguage","getLiteralType","getLiteralValue","termToString","rdf_data_factory_1","require","FACTORY","DataFactory","term","undefined","termType","literalValue","replace","datatype","language","subject","predicate","object","graph","match","exec","Error","toLowerCase","dataFactory","length","defaultGraph","blankNode","substr","variable","type","namedNode","literal","startsWith","endsWith","terms","slice","stringTerms","ignoreTags","lastIndex","i","char","push","quad","charAt","substring","q","stringQuad"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringQuadToQuad = exports.quadToStringQuad = exports.stringToTerm = exports.getLiteralLanguage = exports.getLiteralType = exports.getLiteralValue = exports.termToString = void 0;\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst FACTORY = new rdf_data_factory_1.DataFactory();\n/**\n * Utility methods for converting between string-based RDF representations and RDFJS objects.\n *\n * RDF Terms are represented as follows:\n * * Blank nodes: '_:myBlankNode'\n * * Variables:   '_myVariable'\n * * Literals:    '\"myString\"', '\"myLanguageString\"@en-us', '\"<p>e</p>\"^^<http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML>'\n * * URIs:        '<http://example.org>'\n *\n * Quads/triples are represented as hashes with 'subject', 'predicate', 'object' and 'graph' (optional)\n * as keys, and string-based RDF terms as values.\n */\n/**\n * Convert an RDFJS term to a string-based representation.\n * @param {RDF.Term} term An RDFJS term.\n * @return {string} A string-based term representation.\n */\nfunction termToString(term) {\n    // TODO: remove nasty any casts when this TS bug has been fixed: https://github.com/microsoft/TypeScript/issues/26933\n    if (!term) {\n        return undefined;\n    }\n    switch (term.termType) {\n        case 'NamedNode': return ('<' + term.value + '>');\n        case 'BlankNode': return ('_:' + term.value);\n        case 'Literal':\n            const literalValue = term;\n            return ('\"' + literalValue.value.replace(/\"/ug, '\\\\\"') + '\"' +\n                (literalValue.datatype &&\n                    literalValue.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string' &&\n                    literalValue.datatype.value !== 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' ?\n                    '^^<' + literalValue.datatype.value + '>' : '') +\n                (literalValue.language ? '@' + literalValue.language : ''));\n        case 'Quad': return `<<${termToString(term.subject)} ${termToString(term.predicate)} ${termToString(term.object)}${term.graph.termType === 'DefaultGraph' ? '' : ' ' + termToString(term.graph)}>>`;\n        case 'Variable': return ('?' + term.value);\n        case 'DefaultGraph': return term.value;\n    }\n}\nexports.termToString = termToString;\n/**\n * Get the string value of a literal.\n * @param {string} literalValue An RDF literal enclosed by '\"'.\n * @return {string} The literal value inside the '\"'.\n */\nfunction getLiteralValue(literalValue) {\n    const match = /^\"([^]*)\"((\\^\\^.*)|(@.*))?$/.exec(literalValue);\n    if (!match) {\n        throw new Error(literalValue + ' is not a literal');\n    }\n    return match[1].replace(/\\\\\"/ug, '\"');\n}\nexports.getLiteralValue = getLiteralValue;\n/**\n * Get the datatype of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The datatype of the literal.\n */\nfunction getLiteralType(literalValue) {\n    const match = /^\"[^]*\"(?:\\^\\^<([^\"]+)>|(@)[^@\"]+)?$/.exec(literalValue);\n    if (!match) {\n        throw new Error(literalValue + ' is not a literal');\n    }\n    return match[1] || (match[2]\n        ? 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' : 'http://www.w3.org/2001/XMLSchema#string');\n}\nexports.getLiteralType = getLiteralType;\n/**\n * Get the language of the given literal.\n * @param {string} literalValue An RDF literal.\n * @return {string} The language of the literal.\n */\nfunction getLiteralLanguage(literalValue) {\n    const match = /^\"[^]*\"(?:@([^@\"]+)|\\^\\^[^\"]+)?$/.exec(literalValue);\n    if (!match) {\n        throw new Error(literalValue + ' is not a literal');\n    }\n    return match[1] ? match[1].toLowerCase() : '';\n}\nexports.getLiteralLanguage = getLiteralLanguage;\n/**\n * Transform a string-based RDF term to an RDFJS term.\n * @param {string} value A string-based RDF-term.\n * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.\n * @return {RDF.Term} An RDF-JS term.\n */\nfunction stringToTerm(value, dataFactory) {\n    dataFactory = dataFactory || FACTORY;\n    if (!value || !value.length) {\n        return dataFactory.defaultGraph();\n    }\n    switch (value[0]) {\n        case '_': return dataFactory.blankNode(value.substr(2));\n        case '?':\n            if (!dataFactory.variable) {\n                throw new Error(`Missing 'variable()' method on the given DataFactory`);\n            }\n            return dataFactory.variable(value.substr(1));\n        case '\"':\n            const language = getLiteralLanguage(value);\n            const type = dataFactory.namedNode(getLiteralType(value));\n            return dataFactory.literal(getLiteralValue(value), language || type);\n        case '<':\n        default:\n            if (value.startsWith('<<') && value.endsWith('>>')) {\n                // Iterate character-by-character to detect spaces that are *not* wrapped in <<>>\n                const terms = value.slice(2, -2);\n                const stringTerms = [];\n                let ignoreTags = 0;\n                let lastIndex = 0;\n                for (let i = 0; i < terms.length; i++) {\n                    const char = terms[i];\n                    if (char === '<')\n                        ignoreTags++;\n                    if (char === '>') {\n                        if (ignoreTags === 0) {\n                            throw new Error('Found closing tag without opening tag in ' + value);\n                        }\n                        else {\n                            ignoreTags--;\n                        }\n                    }\n                    if (char === ' ' && ignoreTags === 0) {\n                        stringTerms.push(terms.slice(lastIndex, i));\n                        lastIndex = i + 1;\n                    }\n                }\n                if (ignoreTags !== 0) {\n                    throw new Error('Found opening tag without closing tag in ' + value);\n                }\n                stringTerms.push(terms.slice(lastIndex, terms.length));\n                // We require 3 or 4 components\n                if (stringTerms.length !== 3 && stringTerms.length !== 4) {\n                    throw new Error('Nested quad syntax error ' + value);\n                }\n                return dataFactory.quad(stringToTerm(stringTerms[0]), stringToTerm(stringTerms[1]), stringToTerm(stringTerms[2]), stringTerms[3] ? stringToTerm(stringTerms[3]) : undefined);\n            }\n            if (value.charAt(0) !== '<' || value.charAt(value.length - 1) !== '>') {\n                throw new Error(`Detected invalid iri for named node (must be wrapped in <>): ${value}`);\n            }\n            return dataFactory.namedNode(value.substring(1, value.length - 1));\n    }\n}\nexports.stringToTerm = stringToTerm;\n/**\n * Convert an RDFJS quad to a string-based quad representation.\n * @param {Quad} q An RDFJS quad.\n * @return {IStringQuad} A hash with string-based quad terms.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nfunction quadToStringQuad(q) {\n    // tslint:disable:object-literal-sort-keys\n    return {\n        subject: termToString(q.subject),\n        predicate: termToString(q.predicate),\n        object: termToString(q.object),\n        graph: termToString(q.graph),\n    };\n    // tslint:enable:object-literal-sort-keys\n}\nexports.quadToStringQuad = quadToStringQuad;\n/**\n * Convert a string-based quad representation to an RDFJS quad.\n * @param {IStringQuad} stringQuad A hash with string-based quad terms.\n * @param {RDF.DataFactory} dataFactory An optional datafactory to create terms with.\n * @return {Q} An RDFJS quad.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nfunction stringQuadToQuad(stringQuad, dataFactory) {\n    dataFactory = dataFactory || FACTORY;\n    return dataFactory.quad(stringToTerm(stringQuad.subject, dataFactory), stringToTerm(stringQuad.predicate, dataFactory), stringToTerm(stringQuad.object, dataFactory), stringToTerm(stringQuad.graph, dataFactory));\n}\nexports.stringQuadToQuad = stringQuadToQuad;\n//# sourceMappingURL=TermUtil.js.map"]},"metadata":{},"sourceType":"script"}