{"ast":null,"code":"/**\n * An asynchronous iterator library for advanced object pipelines\n * @module asynciterator\n */\nimport { EventEmitter } from 'events';\nimport createTaskScheduler from './taskscheduler.js';\nlet taskScheduler = createTaskScheduler();\n/** Schedules the given ask for asynchronous execution. */\n\nexport function scheduleTask(task) {\n  taskScheduler(task);\n}\n/** Returns the asynchronous task scheduler. */\n\nexport function getTaskScheduler() {\n  return taskScheduler;\n}\n/** Sets the asynchronous task scheduler. */\n\nexport function setTaskScheduler(scheduler) {\n  taskScheduler = scheduler;\n}\n/**\n  ID of the INIT state.\n  An iterator is initializing if it is preparing main item generation.\n  It can already produce items.\n  @type integer\n*/\n\nexport const INIT = 1 << 0;\n/**\n  ID of the OPEN state.\n  An iterator is open if it can generate new items.\n  @type integer\n*/\n\nexport const OPEN = 1 << 1;\n/**\n  ID of the CLOSING state.\n  An iterator is closing if item generation is pending but will not be scheduled again.\n  @type integer\n*/\n\nexport const CLOSING = 1 << 2;\n/**\n  ID of the CLOSED state.\n  An iterator is closed if it no longer actively generates new items.\n  Items might still be available.\n  @type integer\n*/\n\nexport const CLOSED = 1 << 3;\n/**\n  ID of the ENDED state.\n  An iterator has ended if no further items will become available.\n  The 'end' event is guaranteed to have been called when in this state.\n  @type integer\n*/\n\nexport const ENDED = 1 << 4;\n/**\n  ID of the DESTROYED state.\n  An iterator has been destroyed\n  after calling {@link module:asynciterator.AsyncIterator#destroy}.\n  The 'end' event has not been called, as pending elements were voided.\n  @type integer\n*/\n\nexport const DESTROYED = 1 << 5;\n/**\n  An asynchronous iterator provides pull-based access to a stream of objects.\n  @extends module:asynciterator.EventEmitter\n*/\n\nexport class AsyncIterator extends EventEmitter {\n  /** Creates a new `AsyncIterator`. */\n  constructor(initialState = OPEN) {\n    super();\n    this._readable = false;\n    this._state = initialState;\n    this.on('newListener', waitForDataListener);\n  }\n  /**\n    Changes the iterator to the given state if possible and necessary,\n    possibly emitting events to signal that change.\n    @protected\n    @param {integer} newState The ID of the new state\n    @param {boolean} [eventAsync=false] Whether resulting events should be emitted asynchronously\n    @returns {boolean} Whether the state was changed\n    @emits module:asynciterator.AsyncIterator.end\n  */\n\n\n  _changeState(newState, eventAsync = false) {\n    // Validate the state change\n    const valid = newState > this._state && this._state < ENDED;\n\n    if (valid) {\n      this._state = newState; // Emit the `end` event when changing to ENDED\n\n      if (newState === ENDED) {\n        if (!eventAsync) this.emit('end');else taskScheduler(() => this.emit('end'));\n      }\n    }\n\n    return valid;\n  }\n  /**\n    Tries to read the next item from the iterator.\n    This is the main method for reading the iterator in _on-demand mode_,\n    where new items are only created when needed by consumers.\n    If no items are currently available, this methods returns `null`.\n    The {@link module:asynciterator.event:readable} event\n    will then signal when new items might be ready.\n    To read all items from the iterator,\n    switch to _flow mode_ by subscribing\n    to the {@link module:asynciterator.event:data} event.\n    When in flow mode, do not use the `read` method.\n    @returns {object?} The next item, or `null` if none is available\n  */\n\n\n  read() {\n    return null;\n  }\n  /**\n    The iterator emits a `readable` event when it might have new items available\n    after having had no items available right before this event.\n    If the iterator is not in flow mode, items can be retrieved\n    by calling {@link module:asynciterator.AsyncIterator#read}.\n    @event module:asynciterator.readable\n  */\n\n  /**\n    The iterator emits a `data` event with a new item as soon as it becomes available.\n    When one or more listeners are attached to the `data` event,\n    the iterator switches to _flow mode_,\n    generating and emitting new items as fast as possible.\n    This drains the source and might create backpressure on the consumers,\n    so only subscribe to this event if this behavior is intended.\n    In flow mode, don't use {@link module:asynciterator.AsyncIterator#read}.\n    To switch back to _on-demand mode_, remove all listeners from the `data` event.\n    You can then obtain items through `read` again.\n    @event module:asynciterator.data\n    @param {object} item The new item\n  */\n\n  /**\n    Invokes the callback for each remaining item in the iterator.\n    Switches the iterator to flow mode.\n    @param {Function} callback A function that will be called with each item\n    @param {object?} self The `this` pointer for the callback\n  */\n\n\n  forEach(callback, self) {\n    this.on('data', self ? callback.bind(self) : callback);\n  }\n  /**\n    Stops the iterator from generating new items.\n    Already generated items or terminating items can still be emitted.\n    After this, the iterator will end asynchronously.\n    @emits module:asynciterator.AsyncIterator.end\n  */\n\n\n  close() {\n    if (this._changeState(CLOSED)) this._endAsync();\n  }\n  /**\n    Destroy the iterator and stop it from generating new items.\n    This will not do anything if the iterator was already ended or destroyed.\n    All internal resources will be released an no new items will be emitted,\n    even not already generated items.\n    Implementors should not override this method,\n    but instead implement {@link module:asynciterator.AsyncIterator#_destroy}.\n    @param {Error} [cause] An optional error to emit.\n    @emits module:asynciterator.AsyncIterator.end\n    @emits module:asynciterator.AsyncIterator.error Only if an error is passed.\n  */\n\n\n  destroy(cause) {\n    if (!this.done) {\n      this._destroy(cause, error => {\n        cause = cause || error;\n        if (cause) this.emit('error', cause);\n\n        this._end(true);\n      });\n    }\n  }\n  /**\n    Called by {@link module:asynciterator.AsyncIterator#destroy}.\n    Implementers can override this, but this should not be called directly.\n    @param {?Error} cause The reason why the iterator is destroyed.\n    @param {Function} callback A callback function with an optional error argument.\n  */\n\n\n  _destroy(cause, callback) {\n    callback();\n  }\n  /**\n    Ends the iterator and cleans up.\n    Should never be called before {@link module:asynciterator.AsyncIterator#close};\n    typically, `close` is responsible for calling `_end`.\n    @param {boolean} [destroy] If the iterator should be forcefully destroyed.\n    @protected\n    @emits module:asynciterator.AsyncIterator.end\n  */\n\n\n  _end(destroy = false) {\n    if (this._changeState(destroy ? DESTROYED : ENDED)) {\n      this._readable = false;\n      this.removeAllListeners('readable');\n      this.removeAllListeners('data');\n      this.removeAllListeners('end');\n    }\n  }\n  /**\n    Asynchronously calls `_end`.\n    @protected\n  */\n\n\n  _endAsync() {\n    taskScheduler(() => this._end());\n  }\n  /**\n    The `end` event is emitted after the last item of the iterator has been read.\n    @event module:asynciterator.end\n  */\n\n  /**\n    Gets or sets whether this iterator might have items available for read.\n    A value of `false` means there are _definitely_ no items available;\n    a value of `true` means items _might_ be available.\n    @type boolean\n    @emits module:asynciterator.AsyncIterator.readable\n  */\n\n\n  get readable() {\n    return this._readable;\n  }\n\n  set readable(readable) {\n    readable = Boolean(readable) && !this.done; // Set the readable value only if it has changed\n\n    if (this._readable !== readable) {\n      this._readable = readable; // If the iterator became readable, emit the `readable` event\n\n      if (readable) taskScheduler(() => this.emit('readable'));\n    }\n  }\n  /**\n    Gets whether the iterator has stopped generating new items.\n    @type boolean\n    @readonly\n  */\n\n\n  get closed() {\n    return this._state >= CLOSING;\n  }\n  /**\n    Gets whether the iterator has finished emitting items.\n    @type boolean\n    @readonly\n  */\n\n\n  get ended() {\n    return this._state === ENDED;\n  }\n  /**\n    Gets whether the iterator has been destroyed.\n    @type boolean\n    @readonly\n  */\n\n\n  get destroyed() {\n    return this._state === DESTROYED;\n  }\n  /**\n    Gets whether the iterator will not emit anymore items,\n    either due to being closed or due to being destroyed.\n    @type boolean\n    @readonly\n  */\n\n\n  get done() {\n    return this._state >= ENDED;\n  }\n  /* Generates a textual representation of the iterator. */\n\n\n  toString() {\n    const details = this._toStringDetails();\n\n    return `[${this.constructor.name}${details ? ` ${details}` : ''}]`;\n  }\n  /**\n    Generates details for a textual representation of the iterator.\n    @protected\n  */\n\n\n  _toStringDetails() {\n    return '';\n  }\n  /**\n    Retrieves the property with the given name from the iterator.\n    If no callback is passed, it returns the value of the property\n    or `undefined` if the property is not set.\n    If a callback is passed, it returns `undefined`\n    and calls the callback with the property the moment it is set.\n    @param {string} propertyName The name of the property to retrieve\n    @param {Function?} [callback] A one-argument callback to receive the property value\n    @returns {object?} The value of the property (if set and no callback is given)\n  */\n\n\n  getProperty(propertyName, callback) {\n    const properties = this._properties; // If no callback was passed, return the property value\n\n    if (!callback) return properties && properties[propertyName]; // If the value has been set, send it through the callback\n\n    if (properties && propertyName in properties) {\n      taskScheduler(() => callback(properties[propertyName]));\n    } // If the value was not set, store the callback for when the value will be set\n    else {\n      let propertyCallbacks;\n      if (!(propertyCallbacks = this._propertyCallbacks)) this._propertyCallbacks = propertyCallbacks = Object.create(null);\n      if (propertyName in propertyCallbacks) propertyCallbacks[propertyName].push(callback);else propertyCallbacks[propertyName] = [callback];\n    }\n\n    return undefined;\n  }\n  /**\n    Sets the property with the given name to the value.\n    @param {string} propertyName The name of the property to set\n    @param {object?} value The new value of the property\n  */\n\n\n  setProperty(propertyName, value) {\n    const properties = this._properties || (this._properties = Object.create(null));\n    properties[propertyName] = value; // Execute getter callbacks that were waiting for this property to be set\n\n    const propertyCallbacks = this._propertyCallbacks || {};\n    const callbacks = propertyCallbacks[propertyName];\n\n    if (callbacks) {\n      delete propertyCallbacks[propertyName];\n      taskScheduler(() => {\n        for (const callback of callbacks) callback(value);\n      }); // Remove _propertyCallbacks if no pending callbacks are left\n\n      for (propertyName in propertyCallbacks) return;\n\n      delete this._propertyCallbacks;\n    }\n  }\n  /**\n    Retrieves all properties of the iterator.\n    @returns {object} An object with property names as keys.\n  */\n\n\n  getProperties() {\n    const properties = this._properties;\n    const copy = {};\n\n    for (const name in properties) copy[name] = properties[name];\n\n    return copy;\n  }\n  /**\n    Sets all of the given properties.\n    @param {object} properties Key/value pairs of properties to set\n  */\n\n\n  setProperties(properties) {\n    for (const propertyName in properties) this.setProperty(propertyName, properties[propertyName]);\n  }\n  /**\n    Copies the given properties from the source iterator.\n    @param {module:asynciterator.AsyncIterator} source The iterator to copy from\n    @param {Array} propertyNames List of property names to copy\n  */\n\n\n  copyProperties(source, propertyNames) {\n    for (const propertyName of propertyNames) {\n      source.getProperty(propertyName, value => this.setProperty(propertyName, value));\n    }\n  }\n  /**\n    Transforms items from this iterator.\n    After this operation, only read the returned iterator instead of the current one.\n    @param {object|Function} [options] Settings of the iterator, or the transformation function\n    @param {integer} [options.maxbufferSize=4] The maximum number of items to keep in the buffer\n    @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction\n    @param {integer} [options.offset] The number of items to skip\n    @param {integer} [options.limit] The maximum number of items\n    @param {Function} [options.filter] A function to synchronously filter items from the source\n    @param {Function} [options.map] A function to synchronously transform items from the source\n    @param {Function} [options.transform] A function to asynchronously transform items from the source\n    @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its mapping yields `null` or its transformation yields no items\n    @param {Array|module:asynciterator.AsyncIterator} [options.prepend] Items to insert before the source items\n    @param {Array|module:asynciterator.AsyncIterator} [options.append]  Items to insert after the source items\n    @returns {module:asynciterator.AsyncIterator} A new iterator that maps the items from this iterator\n  */\n\n\n  transform(options) {\n    return new SimpleTransformIterator(this, options);\n  }\n  /**\n    Maps items from this iterator using the given function.\n    After this operation, only read the returned iterator instead of the current one.\n    @param {Function} map A mapping function to call on this iterator's (remaining) items\n    @param {object?} self The `this` pointer for the mapping function\n    @returns {module:asynciterator.AsyncIterator} A new iterator that maps the items from this iterator\n  */\n\n\n  map(map, self) {\n    return this.transform({\n      map: self ? map.bind(self) : map\n    });\n  }\n\n  filter(filter, self) {\n    return this.transform({\n      filter: self ? filter.bind(self) : filter\n    });\n  }\n  /**\n    Prepends the items after those of the current iterator.\n    After this operation, only read the returned iterator instead of the current one.\n    @param {Array|module:asynciterator.AsyncIterator} items Items to insert before this iterator's (remaining) items\n    @returns {module:asynciterator.AsyncIterator} A new iterator that prepends items to this iterator\n  */\n\n\n  prepend(items) {\n    return this.transform({\n      prepend: items\n    });\n  }\n  /**\n    Appends the items after those of the current iterator.\n    After this operation, only read the returned iterator instead of the current one.\n    @param {Array|module:asynciterator.AsyncIterator} items Items to insert after this iterator's (remaining) items\n    @returns {module:asynciterator.AsyncIterator} A new iterator that appends items to this iterator\n  */\n\n\n  append(items) {\n    return this.transform({\n      append: items\n    });\n  }\n  /**\n    Surrounds items of the current iterator with the given items.\n    After this operation, only read the returned iterator instead of the current one.\n    @param {Array|module:asynciterator.AsyncIterator} prepend Items to insert before this iterator's (remaining) items\n    @param {Array|module:asynciterator.AsyncIterator} append Items to insert after this iterator's (remaining) items\n    @returns {module:asynciterator.AsyncIterator} A new iterator that appends and prepends items to this iterator\n  */\n\n\n  surround(prepend, append) {\n    return this.transform({\n      prepend,\n      append\n    });\n  }\n  /**\n    Skips the given number of items from the current iterator.\n    The current iterator may not be read anymore until the returned iterator ends.\n    @param {integer} offset The number of items to skip\n    @returns {module:asynciterator.AsyncIterator} A new iterator that skips the given number of items\n  */\n\n\n  skip(offset) {\n    return this.transform({\n      offset\n    });\n  }\n  /**\n    Limits the current iterator to the given number of items.\n    The current iterator may not be read anymore until the returned iterator ends.\n    @param {integer} limit The maximum number of items\n    @returns {module:asynciterator.AsyncIterator} A new iterator with at most the given number of items\n  */\n\n\n  take(limit) {\n    return this.transform({\n      limit\n    });\n  }\n  /**\n    Limits the current iterator to the given range.\n    The current iterator may not be read anymore until the returned iterator ends.\n    @param {integer} start Index of the first item to return\n    @param {integer} end Index of the last item to return\n    @returns {module:asynciterator.AsyncIterator} A new iterator with items in the given range\n  */\n\n\n  range(start, end) {\n    return this.transform({\n      offset: start,\n      limit: Math.max(end - start + 1, 0)\n    });\n  }\n  /**\n    Creates a copy of the current iterator,\n    containing all items emitted from this point onward.\n    Further copies can be created; they will all start from this same point.\n    After this operation, only read the returned copies instead of the original iterator.\n    @returns {module:asynciterator.AsyncIterator} A new iterator that contains all future items of this iterator\n  */\n\n\n  clone() {\n    return new ClonedIterator(this);\n  }\n\n} // Starts emitting `data` events when `data` listeners are added\n\nfunction waitForDataListener(eventName) {\n  if (eventName === 'data') {\n    this.removeListener('newListener', waitForDataListener);\n    addSingleListener(this, 'readable', emitData);\n    if (this.readable) taskScheduler(() => emitData.call(this));\n  }\n} // Emits new items though `data` events as long as there are `data` listeners\n\n\nfunction emitData() {\n  // While there are `data` listeners and items, emit them\n  let item;\n\n  while (this.listenerCount('data') !== 0 && (item = this.read()) !== null) this.emit('data', item); // Stop draining the source if there are no more `data` listeners\n\n\n  if (this.listenerCount('data') === 0 && !this.done) {\n    this.removeListener('readable', emitData);\n    addSingleListener(this, 'newListener', waitForDataListener);\n  }\n} // Adds the listener to the event, if it has not been added previously.\n\n\nfunction addSingleListener(source, eventName, listener) {\n  if (!source.listeners(eventName).includes(listener)) source.on(eventName, listener);\n}\n/**\n  An iterator that doesn't emit any items.\n  @extends module:asynciterator.AsyncIterator\n*/\n\n\nexport class EmptyIterator extends AsyncIterator {\n  /** Creates a new `EmptyIterator`. */\n  constructor() {\n    super();\n\n    this._changeState(ENDED, true);\n  }\n\n}\n/**\n  An iterator that emits a single item.\n  @extends module:asynciterator.AsyncIterator\n*/\n\nexport class SingletonIterator extends AsyncIterator {\n  /**\n    Creates a new `SingletonIterator`.\n    @param {object} item The item that will be emitted.\n  */\n  constructor(item) {\n    super();\n    this._item = item;\n    if (item === null) this.close();else this.readable = true;\n  }\n  /* Reads the item from the iterator. */\n\n\n  read() {\n    const item = this._item;\n    this._item = null;\n    this.close();\n    return item;\n  }\n  /* Generates details for a textual representation of the iterator. */\n\n\n  _toStringDetails() {\n    return this._item === null ? '' : `(${this._item})`;\n  }\n\n}\n/**\n  An iterator that emits the items of a given array.\n  @extends module:asynciterator.AsyncIterator\n*/\n\nexport class ArrayIterator extends AsyncIterator {\n  /**\n    Creates a new `ArrayIterator`.\n    @param {Array} items The items that will be emitted.\n  */\n  constructor(items, {\n    autoStart = true\n  } = {}) {\n    super();\n    const buffer = items ? [...items] : [];\n    this._sourceStarted = autoStart !== false;\n    if (this._sourceStarted && buffer.length === 0) this.close();else this._buffer = buffer;\n    this.readable = true;\n  }\n  /* Reads an item from the iterator. */\n\n\n  read() {\n    if (!this._sourceStarted) this._sourceStarted = true;\n    let item = null;\n    const buffer = this._buffer;\n\n    if (buffer) {\n      if (buffer.length !== 0) item = buffer.shift();\n\n      if (buffer.length === 0) {\n        delete this._buffer;\n        this.close();\n      }\n    }\n\n    return item;\n  }\n  /* Generates details for a textual representation of the iterator. */\n\n\n  _toStringDetails() {\n    return `(${this._buffer && this._buffer.length || 0})`;\n  }\n  /* Called by {@link module:asynciterator.AsyncIterator#destroy} */\n\n\n  _destroy(cause, callback) {\n    delete this._buffer;\n    callback();\n  }\n\n}\n/**\n  An iterator that enumerates integers in a certain range.\n  @extends module:asynciterator.AsyncIterator\n*/\n\nexport class IntegerIterator extends AsyncIterator {\n  /**\n    Creates a new `IntegerIterator`.\n    @param {object} [options] Settings of the iterator\n    @param {integer} [options.start=0] The first number to emit\n    @param {integer} [options.end=Infinity] The last number to emit\n    @param {integer} [options.step=1] The increment between two numbers\n  */\n  constructor({\n    start = 0,\n    step = 1,\n    end\n  } = {}) {\n    super(); // Determine the first number\n\n    if (Number.isFinite(start)) start = Math.trunc(start);\n    this._next = start; // Determine step size\n\n    if (Number.isFinite(step)) step = Math.trunc(step);\n    this._step = step; // Determine the last number\n\n    const ascending = step >= 0;\n    const direction = ascending ? Infinity : -Infinity;\n    if (Number.isFinite(end)) end = Math.trunc(end);else if (end !== -direction) end = direction;\n    this._last = end; // Start iteration if there is at least one item; close otherwise\n\n    if (!Number.isFinite(start) || (ascending ? start > end : start < end)) this.close();else this.readable = true;\n  }\n  /* Reads an item from the iterator. */\n\n\n  read() {\n    if (this.closed) return null;\n    const current = this._next,\n          step = this._step,\n          last = this._last,\n          next = this._next += step;\n    if (step >= 0 ? next > last : next < last) this.close();\n    return current;\n  }\n  /* Generates details for a textual representation of the iterator. */\n\n\n  _toStringDetails() {\n    return `(${this._next}...${this._last})`;\n  }\n\n}\n/**\n  A iterator that maintains an internal buffer of items.\n  This class serves as a base class for other iterators\n  with a typically complex item generation process.\n  @extends module:asynciterator.AsyncIterator\n*/\n\nexport class BufferedIterator extends AsyncIterator {\n  /**\n    Creates a new `BufferedIterator`.\n    @param {object} [options] Settings of the iterator\n    @param {integer} [options.maxBufferSize=4] The number of items to preload in the internal buffer\n    @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction\n  */\n  constructor({\n    maxBufferSize = 4,\n    autoStart = true\n  } = {}) {\n    super(INIT);\n    this._buffer = [];\n    this._maxBufferSize = 4;\n    this._reading = true;\n    this._pushedCount = 0;\n    this.maxBufferSize = maxBufferSize;\n    taskScheduler(() => this._init(autoStart));\n    this._sourceStarted = autoStart !== false;\n  }\n  /**\n    The maximum number of items to preload in the internal buffer.\n    A `BufferedIterator` tries to fill its buffer as far as possible.\n    Set to `Infinity` to fully drain the source.\n    @type number\n  */\n\n\n  get maxBufferSize() {\n    return this._maxBufferSize;\n  }\n\n  set maxBufferSize(maxBufferSize) {\n    // Allow only positive integers and infinity\n    if (maxBufferSize !== Infinity) {\n      maxBufferSize = !Number.isFinite(maxBufferSize) ? 4 : Math.max(Math.trunc(maxBufferSize), 1);\n    } // Only set the maximum buffer size if it changes\n\n\n    if (this._maxBufferSize !== maxBufferSize) {\n      this._maxBufferSize = maxBufferSize; // Ensure sufficient elements are buffered\n\n      if (this._state === OPEN) this._fillBuffer();\n    }\n  }\n  /**\n    Initializing the iterator by calling {@link BufferedIterator#_begin}\n    and changing state from INIT to OPEN.\n    @protected\n    @param {boolean} autoStart Whether reading of items should immediately start after OPEN.\n  */\n\n\n  _init(autoStart) {\n    // Perform initialization tasks\n    let doneCalled = false;\n    this._reading = true;\n\n    this._begin(() => {\n      if (doneCalled) throw new Error('done callback called multiple times');\n      doneCalled = true; // Open the iterator and start buffering\n\n      this._reading = false;\n\n      this._changeState(OPEN);\n\n      if (autoStart) this._fillBufferAsync(); // If reading should not start automatically, the iterator doesn't become readable.\n      // Therefore, mark the iterator as (potentially) readable so consumers know it might be read.\n      else this.readable = true;\n    });\n  }\n  /**\n    Writes beginning items and opens iterator resources.\n    Should never be called before {@link BufferedIterator#_init};\n    typically, `_init` is responsible for calling `_begin`.\n    @protected\n    @param {function} done To be called when initialization is complete\n  */\n\n\n  _begin(done) {\n    done();\n  }\n  /**\n    Tries to read the next item from the iterator.\n    If the buffer is empty,\n    this method calls {@link BufferedIterator#_read} to fetch items.\n    @returns {object?} The next item, or `null` if none is available\n  */\n\n\n  read() {\n    if (this.done) return null; // An explicit read kickstarts the source\n\n    if (!this._sourceStarted) this._sourceStarted = true; // Try to retrieve an item from the buffer\n\n    const buffer = this._buffer;\n    let item;\n\n    if (buffer.length !== 0) {\n      item = buffer.shift();\n    } else {\n      item = null;\n      this.readable = false;\n    } // If the buffer is becoming empty, either fill it or end the iterator\n\n\n    if (!this._reading && buffer.length < this._maxBufferSize) {\n      // If the iterator is not closed and thus may still generate new items, fill the buffer\n      if (!this.closed) this._fillBufferAsync(); // No new items will be generated, so if none are buffered, the iterator ends here\n      else if (!buffer.length) this._endAsync();\n    }\n\n    return item;\n  }\n  /**\n    Tries to generate the given number of items.\n    Implementers should add `count` items through {@link BufferedIterator#_push}.\n    @protected\n    @param {integer} count The number of items to generate\n    @param {function} done To be called when reading is complete\n  */\n\n\n  _read(count, done) {\n    done();\n  }\n  /**\n    Adds an item to the internal buffer.\n    @protected\n    @param {object} item The item to add\n    @emits module:asynciterator.AsyncIterator.readable\n  */\n\n\n  _push(item) {\n    if (!this.done) {\n      this._pushedCount++;\n\n      this._buffer.push(item);\n\n      this.readable = true;\n    }\n  }\n  /**\n    Fills the internal buffer until `this._maxBufferSize` items are present.\n    This method calls {@link BufferedIterator#_read} to fetch items.\n    @protected\n    @emits module:asynciterator.AsyncIterator.readable\n  */\n\n\n  _fillBuffer() {\n    let neededItems; // Avoid recursive reads\n\n    if (this._reading) {// Do nothing\n    } // If iterator closing started in the meantime, don't generate new items anymore\n    else if (this.closed) {\n      this._completeClose();\n    } // Otherwise, try to fill empty spaces in the buffer by generating new items\n    else if ((neededItems = Math.min(this._maxBufferSize - this._buffer.length, 128)) > 0) {\n      // Acquire reading lock and start reading, counting pushed items\n      this._pushedCount = 0;\n      this._reading = true;\n\n      this._read(neededItems, () => {\n        // Verify the callback is only called once\n        if (!neededItems) throw new Error('done callback called multiple times');\n        neededItems = 0; // Release reading lock\n\n        this._reading = false; // If the iterator was closed while reading, complete closing\n\n        if (this.closed) {\n          this._completeClose();\n        } // If the iterator pushed one or more items,\n        // it might currently be able to generate additional items\n        // (even though all pushed items might already have been read)\n        else if (this._pushedCount) {\n          this.readable = true; // If the buffer is insufficiently full, continue filling\n\n          if (this._buffer.length < this._maxBufferSize / 2) this._fillBufferAsync();\n        }\n      });\n    }\n  }\n  /**\n    Schedules `_fillBuffer` asynchronously.\n  */\n\n\n  _fillBufferAsync() {\n    // Acquire reading lock to avoid recursive reads\n    if (!this._reading) {\n      this._reading = true;\n      taskScheduler(() => {\n        // Release reading lock so _fillBuffer` can take it\n        this._reading = false;\n\n        this._fillBuffer();\n      });\n    }\n  }\n  /**\n    Stops the iterator from generating new items\n    after a possible pending read operation has finished.\n    Already generated, pending, or terminating items can still be emitted.\n    After this, the iterator will end asynchronously.\n    @emits module:asynciterator.AsyncIterator.end\n  */\n\n\n  close() {\n    // If the iterator is not currently reading, we can close immediately\n    if (!this._reading) this._completeClose(); // Closing cannot complete when reading, so temporarily assume CLOSING state\n    // `_fillBuffer` becomes responsible for calling `_completeClose`\n    else this._changeState(CLOSING);\n  }\n  /**\n    Stops the iterator from generating new items,\n    switching from `CLOSING` state into `CLOSED` state.\n    @protected\n    @emits module:asynciterator.AsyncIterator.end\n  */\n\n\n  _completeClose() {\n    if (this._changeState(CLOSED)) {\n      // Write possible terminating items\n      this._reading = true;\n\n      this._flush(() => {\n        if (!this._reading) throw new Error('done callback called multiple times');\n        this._reading = false; // If no items are left, end the iterator\n        // Otherwise, `read` becomes responsible for ending the iterator\n\n        if (!this._buffer.length) this._endAsync();\n      });\n    }\n  }\n  /* Called by {@link module:asynciterator.AsyncIterator#destroy} */\n\n\n  _destroy(cause, callback) {\n    this._buffer = [];\n    callback();\n  }\n  /**\n    Writes terminating items and closes iterator resources.\n    Should never be called before {@link BufferedIterator#close};\n    typically, `close` is responsible for calling `_flush`.\n    @protected\n    @param {function} done To be called when termination is complete\n  */\n\n\n  _flush(done) {\n    done();\n  }\n  /**\n    Generates details for a textual representation of the iterator.\n    @protected\n   */\n\n\n  _toStringDetails() {\n    const buffer = this._buffer,\n          {\n      length\n    } = buffer;\n    return `{${length ? `next: ${buffer[0]}, ` : ''}buffer: ${length}}`;\n  }\n\n}\n/**\n  An iterator that generates items based on a source iterator.\n  This class serves as a base class for other iterators.\n  @extends module:asynciterator.BufferedIterator\n*/\n\nexport class TransformIterator extends BufferedIterator {\n  /**\n    Creates a new `TransformIterator`.\n    @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from\n    @param {object} [options] Settings of the iterator\n    @param {integer} [options.maxBufferSize=4] The maximum number of items to keep in the buffer\n    @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction\n    @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its transformation yields no items\n    @param {boolean} [options.destroySource=true] Whether the source should be destroyed when this transformed iterator is closed or destroyed\n    @param {module:asynciterator.AsyncIterator} [options.source] The source this iterator generates items from\n  */\n  constructor(source, options = source || {}) {\n    super(options);\n\n    this._boundPush = item => this._push(item); // Shift parameters if needed\n\n\n    if (!isSourceExpression(source)) source = options.source; // The passed source is an AsyncIterator or readable stream\n\n    if (isEventEmitter(source)) {\n      this.source = source;\n    } // The passed value is a promise or source creation function\n    else if (source) {\n      this._createSource = isPromise(source) ? () => source : source;\n      if (this._sourceStarted) this._loadSourceAsync();\n    } // Set other options\n\n\n    this._optional = Boolean(options.optional);\n    this._destroySource = options.destroySource !== false;\n  }\n  /**\n    The source this iterator generates items from.\n    @type module:asynciterator.AsyncIterator\n  */\n\n\n  get source() {\n    if (isFunction(this._createSource)) this._loadSourceAsync();\n    return this._source;\n  }\n\n  set source(value) {\n    // Validate and set source\n    const source = this._source = this._validateSource(value);\n\n    source._destination = this; // Close this iterator if the source has already ended\n\n    if (source.done) {\n      this.close();\n    } // Otherwise, react to source events\n    else {\n      source.on('end', destinationCloseWhenDone);\n      source.on('readable', destinationFillBuffer);\n      source.on('error', destinationEmitError);\n    }\n  }\n  /**\n    Initializes a source that was set through a promise\n    @protected\n  */\n\n\n  _loadSourceAsync() {\n    if (isFunction(this._createSource)) {\n      // Assign the source after resolving\n      Promise.resolve(this._createSource()).then(source => {\n        delete this._createSource;\n        this.source = source;\n\n        this._fillBuffer();\n      }, error => this.emit('error', error)); // Signal that source creation is pending\n\n      this._createSource = null;\n    }\n  }\n  /**\n    Validates whether the given iterator can be used as a source.\n    @protected\n    @param {object} source The source to validate\n    @param {boolean} allowDestination Whether the source can already have a destination\n  */\n\n\n  _validateSource(source, allowDestination = false) {\n    if (this._source || typeof this._createSource !== 'undefined') throw new Error('The source cannot be changed after it has been set');\n    if (!source || !isFunction(source.read) || !isFunction(source.on)) throw new Error(`Invalid source: ${source}`);\n    if (!allowDestination && source._destination) throw new Error('The source already has a destination');\n    return source;\n  }\n  /**\n    Tries to read transformed items.\n  */\n\n\n  _read(count, done) {\n    const next = () => {\n      // Continue transforming until at least `count` items have been pushed\n      if (this._pushedCount < count && !this.closed) taskScheduler(() => this._readAndTransform(next, done));else done();\n    };\n\n    this._readAndTransform(next, done);\n  }\n  /**\n    Reads a transforms an item\n  */\n\n\n  _readAndTransform(next, done) {\n    // If the source exists and still can read items,\n    // try to read and transform the next item.\n    let item;\n    const source = this.source;\n    if (!source || source.done || (item = source.read()) === null) done();else if (!this._optional) this._transform(item, next, this._boundPush);else this._optionalTransform(item, next);\n  }\n  /**\n    Tries to transform the item;\n    if the transformation yields no items, pushes the original item.\n  */\n\n\n  _optionalTransform(item, done) {\n    const pushedCount = this._pushedCount;\n\n    this._transform(item, () => {\n      if (pushedCount === this._pushedCount) this._push(item);\n      done();\n    }, this._boundPush);\n  }\n  /**\n    Generates items based on the item from the source.\n    Implementers should add items through {@link BufferedIterator#_push}.\n    The default implementation pushes the source item as-is.\n    @protected\n    @param {object} item The last read item from the source\n    @param {function} done To be called when reading is complete\n    @param {function} push A callback to push zero or more transformation results.\n  */\n\n\n  _transform(item, done, push) {\n    push(item);\n    done();\n  }\n  /**\n    Closes the iterator when pending items are transformed.\n    @protected\n  */\n\n\n  _closeWhenDone() {\n    this.close();\n  }\n  /* Cleans up the source iterator and ends. */\n\n\n  _end(destroy) {\n    const source = this._source;\n\n    if (source) {\n      source.removeListener('end', destinationCloseWhenDone);\n      source.removeListener('error', destinationEmitError);\n      source.removeListener('readable', destinationFillBuffer);\n      delete source._destination;\n      if (this._destroySource) source.destroy();\n    }\n\n    super._end(destroy);\n  }\n\n}\n\nfunction destinationEmitError(error) {\n  this._destination.emit('error', error);\n}\n\nfunction destinationCloseWhenDone() {\n  this._destination._closeWhenDone();\n}\n\nfunction destinationFillBuffer() {\n  if (this._destination._sourceStarted !== false) this._destination._fillBuffer();\n}\n/**\n  An iterator that generates items based on a source iterator\n  and simple transformation steps passed as arguments.\n  @extends module:asynciterator.TransformIterator\n*/\n\n\nexport class SimpleTransformIterator extends TransformIterator {\n  /**\n    Creates a new `SimpleTransformIterator`.\n    @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from\n    @param {object|Function} [options] Settings of the iterator, or the transformation function\n    @param {integer} [options.maxbufferSize=4] The maximum number of items to keep in the buffer\n    @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction\n    @param {module:asynciterator.AsyncIterator} [options.source] The source this iterator generates items from\n    @param {integer} [options.offset] The number of items to skip\n    @param {integer} [options.limit] The maximum number of items\n    @param {Function} [options.filter] A function to synchronously filter items from the source\n    @param {Function} [options.map] A function to synchronously transform items from the source\n    @param {Function} [options.transform] A function to asynchronously transform items from the source\n    @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its mapping yields `null` or its transformation yields no items\n    @param {Array|module:asynciterator.AsyncIterator} [options.prepend] Items to insert before the source items\n    @param {Array|module:asynciterator.AsyncIterator} [options.append]  Items to insert after the source items\n  */\n  constructor(source, options) {\n    super(source, options);\n    this._offset = 0;\n    this._limit = Infinity;\n\n    this._filter = item => true; // Set transformation steps from the options\n\n\n    options = options || (!isSourceExpression(source) ? source : null);\n\n    if (options) {\n      const transform = isFunction(options) ? options : options.transform;\n      const {\n        limit,\n        offset,\n        filter,\n        map,\n        prepend,\n        append\n      } = options; // Don't emit any items when bounds are unreachable\n\n      if (offset === Infinity || limit === -Infinity) {\n        this._limit = 0;\n      } else {\n        if (Number.isFinite(offset)) this._offset = Math.max(Math.trunc(offset), 0);\n        if (Number.isFinite(limit)) this._limit = Math.max(Math.trunc(limit), 0);\n        if (isFunction(filter)) this._filter = filter;\n        if (isFunction(map)) this._map = map;\n        this._transform = isFunction(transform) ? transform : null;\n      }\n\n      if (prepend) this._prepender = isEventEmitter(prepend) ? prepend : fromArray(prepend);\n      if (append) this._appender = isEventEmitter(append) ? append : fromArray(append);\n    }\n  }\n  /* Tries to read and transform items */\n\n\n  _read(count, done) {\n    const next = () => this._readAndTransformSimple(count, nextAsync, done);\n\n    this._readAndTransformSimple(count, nextAsync, done);\n\n    function nextAsync() {\n      taskScheduler(next);\n    }\n  }\n  /* Reads and transform items */\n\n\n  _readAndTransformSimple(count, next, done) {\n    // Verify we have a readable source\n    let item;\n    const {\n      source\n    } = this;\n\n    if (!source || source.done) {\n      done();\n      return;\n    } // Verify we are still below the limit\n\n\n    if (this._limit === 0) this.close(); // Try to read the next item until at least `count` items have been pushed\n\n    while (!this.closed && this._pushedCount < count && (item = source.read()) !== null) {\n      // Verify the item passes the filter and we've reached the offset\n      if (!this._filter(item) || this._offset !== 0 && this._offset--) continue; // Synchronously map the item\n\n      const mappedItem = typeof this._map === 'undefined' ? item : this._map(item); // Skip `null` items, pushing the original item if the mapping was optional\n\n      if (mappedItem === null) {\n        if (this._optional) this._push(item);\n      } // Skip the asynchronous phase if no transformation was specified\n      else if (!isFunction(this._transform)) {\n        this._push(mappedItem);\n      } // Asynchronously transform the item, and wait for `next` to call back\n      else {\n        if (!this._optional) this._transform(mappedItem, next, this._boundPush);else this._optionalTransform(mappedItem, next);\n        return;\n      } // Stop when we've reached the limit\n\n\n      if (--this._limit === 0) this.close();\n    }\n\n    done();\n  } // Prepends items to the iterator\n\n\n  _begin(done) {\n    this._insert(this._prepender, done);\n\n    delete this._prepender;\n  } // Appends items to the iterator\n\n\n  _flush(done) {\n    this._insert(this._appender, done);\n\n    delete this._appender;\n  } // Inserts items in the iterator\n\n\n  _insert(inserter, done) {\n    const push = item => this._push(item);\n\n    if (!inserter || inserter.done) {\n      done();\n    } else {\n      inserter.on('data', push);\n      inserter.on('end', end);\n    }\n\n    function end() {\n      inserter.removeListener('data', push);\n      inserter.removeListener('end', end);\n      done();\n    }\n  }\n\n}\n/**\n  An iterator that generates items by transforming each item of a source\n  with a different iterator.\n  @extends module:asynciterator.TransformIterator\n*/\n\nexport class MultiTransformIterator extends TransformIterator {\n  /**\n   Creates a new `MultiTransformIterator`.\n   @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from\n   @param {object|Function} [options] Settings of the iterator, or the transformation function\n   @param {integer} [options.maxbufferSize=4] The maximum number of items to keep in the buffer\n   @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction\n   @param {module:asynciterator.AsyncIterator} [options.source] The source this iterator generates items from\n   @param {integer} [options.offset] The number of items to skip\n   @param {integer} [options.limit] The maximum number of items\n   @param {Function} [options.filter] A function to synchronously filter items from the source\n   @param {Function} [options.map] A function to synchronously transform items from the source\n   @param {Function} [options.transform] A function to asynchronously transform items from the source\n   @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its mapping yields `null` or its transformation yields no items\n   @param {Function} [options.multiTransform] A function to asynchronously transform items to iterators from the source\n   @param {Array|module:asynciterator.AsyncIterator} [options.prepend] Items to insert before the source items\n   @param {Array|module:asynciterator.AsyncIterator} [options.append]  Items to insert after the source items\n   */\n  constructor(source, options) {\n    super(source, options);\n    this._transformerQueue = []; // Set transformation steps from the options\n\n    if (options) {\n      const multiTransform = isFunction(options) ? options : options.multiTransform;\n      if (multiTransform) this._createTransformer = multiTransform;\n    }\n  }\n  /* Tries to read and transform items */\n\n\n  _read(count, done) {\n    // Remove transformers that have ended\n    const transformerQueue = this._transformerQueue,\n          optional = this._optional;\n    let head, item;\n\n    while ((head = transformerQueue[0]) && head.transformer.done) {\n      // If transforming is optional, push the original item if none was pushed\n      if (optional && head.item !== null) {\n        count--;\n\n        this._push(head.item);\n      } // Remove listeners from the transformer\n\n\n      transformerQueue.shift();\n      const {\n        transformer\n      } = head;\n      transformer.removeListener('end', destinationFillBuffer);\n      transformer.removeListener('readable', destinationFillBuffer);\n      transformer.removeListener('error', destinationEmitError);\n    } // Create new transformers if there are less than the maximum buffer size\n\n\n    const {\n      source\n    } = this;\n\n    while (source && !source.done && transformerQueue.length < this.maxBufferSize) {\n      // Read an item to create the next transformer\n      item = source.read();\n      if (item === null) break; // Create the transformer and listen to its events\n\n      const transformer = this._createTransformer(item) || new EmptyIterator();\n      transformer._destination = this;\n      transformer.on('end', destinationFillBuffer);\n      transformer.on('readable', destinationFillBuffer);\n      transformer.on('error', destinationEmitError);\n      transformerQueue.push({\n        transformer,\n        item\n      });\n    } // Try to read `count` items from the transformer\n\n\n    head = transformerQueue[0];\n\n    if (head) {\n      const {\n        transformer\n      } = head;\n\n      while (count-- > 0 && (item = transformer.read()) !== null) {\n        this._push(item); // If a transformed item was pushed, no need to push the original anymore\n\n\n        if (optional) head.item = null;\n      }\n    } // End the iterator if the source has ended\n    else if (source && source.done) {\n      this.close();\n    }\n\n    done();\n  }\n  /**\n    Creates a transformer for the given item.\n    @param {object} item The last read item from the source\n    @returns {module:asynciterator.AsyncIterator} An iterator that transforms the given item\n  */\n\n\n  _createTransformer(item) {\n    return new SingletonIterator(item);\n  }\n  /* Closes the iterator when pending items are transformed. */\n\n\n  _closeWhenDone() {\n    // Only close if all transformers are read\n    if (!this._transformerQueue.length) this.close();\n  }\n\n}\n/**\n  An iterator that generates items by reading from multiple other iterators.\n  @extends module:asynciterator.BufferedIterator\n*/\n\nexport class UnionIterator extends BufferedIterator {\n  /**\n    Creates a new `UnionIterator`.\n    @param {module:asynciterator.AsyncIterator|Array} [sources] The sources to read from\n    @param {object} [options] Settings of the iterator\n  */\n  constructor(sources, options = {}) {\n    super(options);\n    this._sources = [];\n    this._currentSource = -1;\n    const autoStart = options.autoStart !== false; // Sources have been passed as an iterator\n\n    if (isEventEmitter(sources)) {\n      sources.on('error', error => this.emit('error', error));\n      this._pending = {\n        sources\n      };\n      if (autoStart) this._loadSources();\n    } // Sources have been passed as a non-empty array\n    else if (Array.isArray(sources) && sources.length > 0) {\n      for (const source of sources) this._addSource(source);\n    } // Sources are an empty list\n    else if (autoStart) {\n      this.close();\n    }\n  } // Loads sources passed as an iterator\n\n\n  _loadSources() {\n    // Obtain sources iterator\n    const sources = this._pending.sources;\n    delete this._pending.sources; // Close immediately if done\n\n    if (sources.done) {\n      delete this._pending;\n      this.close();\n    } // Otherwise, set up source reading\n    else {\n      sources.on('data', source => {\n        this._addSource(source);\n\n        this._fillBufferAsync();\n      });\n      sources.on('end', () => {\n        delete this._pending;\n\n        this._fillBuffer();\n      });\n    }\n  } // Adds the given source to the internal sources array\n\n\n  _addSource(source) {\n    if (!source.done) {\n      this._sources.push(source);\n\n      source._destination = this;\n      source.on('error', destinationEmitError);\n      source.on('readable', destinationFillBuffer);\n      source.on('end', destinationRemoveEmptySources);\n    }\n  } // Removes sources that will no longer emit items\n\n\n  _removeEmptySources() {\n    this._sources = this._sources.filter((source, index) => {\n      // Adjust the index of the current source if needed\n      if (source.done && index <= this._currentSource) this._currentSource--;\n      return !source.done;\n    });\n\n    this._fillBuffer();\n  } // Reads items from the next sources\n\n\n  _read(count, done) {\n    var _a; // Start source loading if needed\n\n\n    if ((_a = this._pending) === null || _a === void 0 ? void 0 : _a.sources) this._loadSources(); // Try to read `count` items\n\n    let lastCount = 0,\n        item;\n\n    while (lastCount !== (lastCount = count)) {\n      // Try every source at least once\n      for (let i = 0; i < this._sources.length && count > 0; i++) {\n        // Pick the next source\n        this._currentSource = (this._currentSource + 1) % this._sources.length;\n        const source = this._sources[this._currentSource]; // Attempt to read an item from that source\n\n        if ((item = source.read()) !== null) {\n          count--;\n\n          this._push(item);\n        }\n      }\n    } // Close this iterator if all of its sources have been read\n\n\n    if (!this._pending && this._sources.length === 0) this.close();\n    done();\n  }\n\n}\n\nfunction destinationRemoveEmptySources() {\n  this._destination._removeEmptySources();\n}\n/**\n  An iterator that copies items from another iterator.\n  @extends module:asynciterator.TransformIterator\n*/\n\n\nexport class ClonedIterator extends TransformIterator {\n  /**\n    Creates a new `ClonedIterator`.\n    @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator copies items from\n  */\n  constructor(source) {\n    super(source, {\n      autoStart: false\n    });\n    this._readPosition = 0;\n    this._reading = false;\n  }\n\n  _init() {// skip buffered iterator initialization, since we read from history\n  }\n\n  close() {\n    // skip buffered iterator cleanup\n    AsyncIterator.prototype.close.call(this);\n  } // The source this iterator copies items from\n\n\n  get source() {\n    return super.source;\n  }\n\n  set source(value) {\n    // Validate and set the source\n    const source = this._source = this._validateSource(value); // Create a history reader for the source if none already existed\n\n\n    const history = source && source._destination || (source._destination = new HistoryReader(source)); // Close this clone if history is empty and the source has ended\n\n    if (history.endsAt(0)) {\n      this.close();\n    } else {\n      // Subscribe to history events\n      history.register(this); // If there are already items in history, this clone is readable\n      // If the source has a lazy start, always mark this iterator as readable without eagerly triggering a read.\n\n      if (source._sourceStarted === false || history.readAt(0) !== null) this.readable = true;\n    } // Hook pending property callbacks to the source\n\n\n    const propertyCallbacks = this._propertyCallbacks;\n\n    for (const propertyName in propertyCallbacks) {\n      const callbacks = propertyCallbacks[propertyName];\n\n      for (const callback of callbacks) this._getSourceProperty(propertyName, callback);\n    }\n  }\n  /**\n    Validates whether the given iterator can be used as a source.\n    @protected\n    @param {object} source The source to validate\n    @param {boolean} allowDestination Whether the source can already have a destination\n  */\n\n\n  _validateSource(source, allowDestination = false) {\n    const history = source && source._destination;\n    return super._validateSource(source, !history || history instanceof HistoryReader);\n  } // Retrieves the property with the given name from the clone or its source.\n\n\n  getProperty(propertyName, callback) {\n    const {\n      source\n    } = this,\n          properties = this._properties,\n          hasProperty = properties && propertyName in properties; // If no callback was passed, return the property value\n\n    if (!callback) {\n      return hasProperty ? properties && properties[propertyName] : source && source.getProperty(propertyName);\n    } // Try to look up the property in this clone\n\n\n    super.getProperty(propertyName, callback); // If the property is not set on this clone, it might become set on the source first\n\n    if (source && !hasProperty) this._getSourceProperty(propertyName, callback);\n    return undefined;\n  } // Retrieves the property with the given name from the source\n\n\n  _getSourceProperty(propertyName, callback) {\n    this.source.getProperty(propertyName, value => {\n      // Only send the source's property if it was not set on the clone in the meantime\n      if (!this._properties || !(propertyName in this._properties)) callback(value);\n    });\n  } // Retrieves all properties of the iterator and its source.\n\n\n  getProperties() {\n    const base = this.source ? this.source.getProperties() : {},\n          properties = this._properties;\n\n    for (const name in properties) base[name] = properties[name];\n\n    return base;\n  }\n  /* Generates details for a textual representation of the iterator. */\n\n\n  _toStringDetails() {\n    return `{source: ${this.source ? this.source.toString() : 'none'}}`;\n  }\n  /* Tries to read an item */\n\n\n  read() {\n    // An explicit read kickstarts the source\n    if (!this._sourceStarted) this._sourceStarted = true;\n    const source = this.source;\n    let item = null;\n\n    if (!this.done && source) {\n      // Try to read an item at the current point in history\n      const history = source._destination;\n      if ((item = history.readAt(this._readPosition)) !== null) this._readPosition++;else this.readable = false; // Close the iterator if we are at the end of the source\n\n      if (history.endsAt(this._readPosition)) this.close();\n    }\n\n    return item;\n  }\n  /* End the iterator and cleans up. */\n\n\n  _end(destroy) {\n    // Unregister from a possible history reader\n    const source = this.source;\n    const history = source === null || source === void 0 ? void 0 : source._destination;\n    if (history) history.unregister(this); // Don't call TransformIterator#_end,\n    // as it would make the source inaccessible for other clones\n\n    BufferedIterator.prototype._end.call(this, destroy);\n  }\n\n} // Stores the history of a source, so it can be cloned\n\nclass HistoryReader {\n  constructor(source) {\n    this._clones = null;\n    this._history = []; // If the source can still emit items, set up cloning\n\n    this._source = source;\n\n    if (!source.done) {\n      // When the source becomes readable, makes all clones readable\n      const setReadable = () => {\n        for (const clone of this._clones) clone.readable = true;\n      }; // When the source errors, re-emits the error\n\n\n      const emitError = error => {\n        for (const clone of this._clones) clone.emit('error', error);\n      }; // When the source ends, closes all clones that are fully read\n\n\n      const end = () => {\n        // Close the clone if all items had been emitted\n        for (const clone of this._clones) {\n          if (clone._sourceStarted !== false && clone._readPosition === this._history.length) clone.close();\n        }\n\n        this._clones = null; // Remove source listeners, since no further events will be emitted\n\n        source.removeListener('end', end);\n        source.removeListener('error', emitError);\n        source.removeListener('readable', setReadable);\n      }; // Listen to source events to trigger events in subscribed clones\n\n\n      this._clones = [];\n      source.on('end', end);\n      source.on('error', emitError);\n      source.on('readable', setReadable);\n    }\n  } // Registers a clone for history updates\n\n\n  register(clone) {\n    if (this._clones !== null) this._clones.push(clone);\n  } // Unregisters a clone for history updates\n\n\n  unregister(clone) {\n    if (this._clones !== null) this._clones = this._clones.filter(c => c !== clone);\n  } // Tries to read the item at the given history position\n\n\n  readAt(pos) {\n    let item = null; // Retrieve an item from history when available\n\n    if (pos < this._history.length) item = this._history[pos]; // Read a new item from the source when possible\n    else if (!this._source.done && (item = this._source.read()) !== null) this._history[pos] = item;\n    return item;\n  } // Determines whether the given position is the end of the source\n\n\n  endsAt(pos) {\n    return this._source.done && this._history.length === pos;\n  }\n\n}\n/**\n  Creates an iterator that wraps around a given iterator or readable stream.\n  Use this to convert an iterator-like object into a full-featured AsyncIterator.\n  After this operation, only read the returned iterator instead of the given one.\n  @function\n  @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from\n  @param {object} [options] Settings of the iterator\n  @returns {module:asynciterator.AsyncIterator} A new iterator with the items from the given iterator\n*/\n\n\nexport function wrap(source, options) {\n  return new TransformIterator(source, options);\n}\n/**\n  Creates an empty iterator.\n */\n\nexport function empty() {\n  return new EmptyIterator();\n}\n/**\n  Creates an iterator with a single item.\n  @param {object} item the item\n */\n\nexport function single(item) {\n  return new SingletonIterator(item);\n}\n/**\n  Creates an iterator for the given array.\n  @param {Array} items the items\n */\n\nexport function fromArray(items) {\n  return new ArrayIterator(items);\n}\n/**\n  Creates an iterator containing all items from the given iterators.\n  @param {Array} items the items\n */\n\nexport function union(sources) {\n  return new UnionIterator(sources);\n}\n/**\n  Creates an iterator of integers for the given numeric range.\n  @param {Array} items the items\n */\n\nexport function range(start, end, step) {\n  return new IntegerIterator({\n    start,\n    end,\n    step\n  });\n} // Determines whether the given object is a function\n\nfunction isFunction(object) {\n  return typeof object === 'function';\n} // Determines whether the given object is an EventEmitter\n\n\nfunction isEventEmitter(object) {\n  return object && typeof object.on === 'function';\n} // Determines whether the given object is a promise\n\n\nfunction isPromise(object) {\n  return object && typeof object.then === 'function';\n} // Determines whether the given object is a source expression\n\n\nfunction isSourceExpression(object) {\n  return object && (isEventEmitter(object) || isPromise(object) || isFunction(object));\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/asynciterator/dist/asynciterator.js"],"names":["EventEmitter","createTaskScheduler","taskScheduler","scheduleTask","task","getTaskScheduler","setTaskScheduler","scheduler","INIT","OPEN","CLOSING","CLOSED","ENDED","DESTROYED","AsyncIterator","constructor","initialState","_readable","_state","on","waitForDataListener","_changeState","newState","eventAsync","valid","emit","read","forEach","callback","self","bind","close","_endAsync","destroy","cause","done","_destroy","error","_end","removeAllListeners","readable","Boolean","closed","ended","destroyed","toString","details","_toStringDetails","name","getProperty","propertyName","properties","_properties","propertyCallbacks","_propertyCallbacks","Object","create","push","undefined","setProperty","value","callbacks","getProperties","copy","setProperties","copyProperties","source","propertyNames","transform","options","SimpleTransformIterator","map","filter","prepend","items","append","surround","skip","offset","take","limit","range","start","end","Math","max","clone","ClonedIterator","eventName","removeListener","addSingleListener","emitData","call","item","listenerCount","listener","listeners","includes","EmptyIterator","SingletonIterator","_item","ArrayIterator","autoStart","buffer","_sourceStarted","length","_buffer","shift","IntegerIterator","step","Number","isFinite","trunc","_next","_step","ascending","direction","Infinity","_last","current","last","next","BufferedIterator","maxBufferSize","_maxBufferSize","_reading","_pushedCount","_init","_fillBuffer","doneCalled","_begin","Error","_fillBufferAsync","_read","count","_push","neededItems","_completeClose","min","_flush","TransformIterator","_boundPush","isSourceExpression","isEventEmitter","_createSource","isPromise","_loadSourceAsync","_optional","optional","_destroySource","destroySource","isFunction","_source","_validateSource","_destination","destinationCloseWhenDone","destinationFillBuffer","destinationEmitError","Promise","resolve","then","allowDestination","_readAndTransform","_transform","_optionalTransform","pushedCount","_closeWhenDone","_offset","_limit","_filter","_map","_prepender","fromArray","_appender","_readAndTransformSimple","nextAsync","mappedItem","_insert","inserter","MultiTransformIterator","_transformerQueue","multiTransform","_createTransformer","transformerQueue","head","transformer","UnionIterator","sources","_sources","_currentSource","_pending","_loadSources","Array","isArray","_addSource","destinationRemoveEmptySources","_removeEmptySources","index","_a","lastCount","i","_readPosition","prototype","history","HistoryReader","endsAt","register","readAt","_getSourceProperty","hasProperty","base","unregister","_clones","_history","setReadable","emitError","c","pos","wrap","empty","single","union","object"],"mappings":"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","sourcesContent":["/**\n * An asynchronous iterator library for advanced object pipelines\n * @module asynciterator\n */\nimport { EventEmitter } from 'events';\nimport createTaskScheduler from './taskscheduler.js';\nlet taskScheduler = createTaskScheduler();\n/** Schedules the given ask for asynchronous execution. */\nexport function scheduleTask(task) {\n    taskScheduler(task);\n}\n/** Returns the asynchronous task scheduler. */\nexport function getTaskScheduler() {\n    return taskScheduler;\n}\n/** Sets the asynchronous task scheduler. */\nexport function setTaskScheduler(scheduler) {\n    taskScheduler = scheduler;\n}\n/**\n  ID of the INIT state.\n  An iterator is initializing if it is preparing main item generation.\n  It can already produce items.\n  @type integer\n*/\nexport const INIT = 1 << 0;\n/**\n  ID of the OPEN state.\n  An iterator is open if it can generate new items.\n  @type integer\n*/\nexport const OPEN = 1 << 1;\n/**\n  ID of the CLOSING state.\n  An iterator is closing if item generation is pending but will not be scheduled again.\n  @type integer\n*/\nexport const CLOSING = 1 << 2;\n/**\n  ID of the CLOSED state.\n  An iterator is closed if it no longer actively generates new items.\n  Items might still be available.\n  @type integer\n*/\nexport const CLOSED = 1 << 3;\n/**\n  ID of the ENDED state.\n  An iterator has ended if no further items will become available.\n  The 'end' event is guaranteed to have been called when in this state.\n  @type integer\n*/\nexport const ENDED = 1 << 4;\n/**\n  ID of the DESTROYED state.\n  An iterator has been destroyed\n  after calling {@link module:asynciterator.AsyncIterator#destroy}.\n  The 'end' event has not been called, as pending elements were voided.\n  @type integer\n*/\nexport const DESTROYED = 1 << 5;\n/**\n  An asynchronous iterator provides pull-based access to a stream of objects.\n  @extends module:asynciterator.EventEmitter\n*/\nexport class AsyncIterator extends EventEmitter {\n    /** Creates a new `AsyncIterator`. */\n    constructor(initialState = OPEN) {\n        super();\n        this._readable = false;\n        this._state = initialState;\n        this.on('newListener', waitForDataListener);\n    }\n    /**\n      Changes the iterator to the given state if possible and necessary,\n      possibly emitting events to signal that change.\n      @protected\n      @param {integer} newState The ID of the new state\n      @param {boolean} [eventAsync=false] Whether resulting events should be emitted asynchronously\n      @returns {boolean} Whether the state was changed\n      @emits module:asynciterator.AsyncIterator.end\n    */\n    _changeState(newState, eventAsync = false) {\n        // Validate the state change\n        const valid = newState > this._state && this._state < ENDED;\n        if (valid) {\n            this._state = newState;\n            // Emit the `end` event when changing to ENDED\n            if (newState === ENDED) {\n                if (!eventAsync)\n                    this.emit('end');\n                else\n                    taskScheduler(() => this.emit('end'));\n            }\n        }\n        return valid;\n    }\n    /**\n      Tries to read the next item from the iterator.\n      This is the main method for reading the iterator in _on-demand mode_,\n      where new items are only created when needed by consumers.\n      If no items are currently available, this methods returns `null`.\n      The {@link module:asynciterator.event:readable} event\n      will then signal when new items might be ready.\n      To read all items from the iterator,\n      switch to _flow mode_ by subscribing\n      to the {@link module:asynciterator.event:data} event.\n      When in flow mode, do not use the `read` method.\n      @returns {object?} The next item, or `null` if none is available\n    */\n    read() {\n        return null;\n    }\n    /**\n      The iterator emits a `readable` event when it might have new items available\n      after having had no items available right before this event.\n      If the iterator is not in flow mode, items can be retrieved\n      by calling {@link module:asynciterator.AsyncIterator#read}.\n      @event module:asynciterator.readable\n    */\n    /**\n      The iterator emits a `data` event with a new item as soon as it becomes available.\n      When one or more listeners are attached to the `data` event,\n      the iterator switches to _flow mode_,\n      generating and emitting new items as fast as possible.\n      This drains the source and might create backpressure on the consumers,\n      so only subscribe to this event if this behavior is intended.\n      In flow mode, don't use {@link module:asynciterator.AsyncIterator#read}.\n      To switch back to _on-demand mode_, remove all listeners from the `data` event.\n      You can then obtain items through `read` again.\n      @event module:asynciterator.data\n      @param {object} item The new item\n    */\n    /**\n      Invokes the callback for each remaining item in the iterator.\n      Switches the iterator to flow mode.\n      @param {Function} callback A function that will be called with each item\n      @param {object?} self The `this` pointer for the callback\n    */\n    forEach(callback, self) {\n        this.on('data', self ? callback.bind(self) : callback);\n    }\n    /**\n      Stops the iterator from generating new items.\n      Already generated items or terminating items can still be emitted.\n      After this, the iterator will end asynchronously.\n      @emits module:asynciterator.AsyncIterator.end\n    */\n    close() {\n        if (this._changeState(CLOSED))\n            this._endAsync();\n    }\n    /**\n      Destroy the iterator and stop it from generating new items.\n      This will not do anything if the iterator was already ended or destroyed.\n      All internal resources will be released an no new items will be emitted,\n      even not already generated items.\n      Implementors should not override this method,\n      but instead implement {@link module:asynciterator.AsyncIterator#_destroy}.\n      @param {Error} [cause] An optional error to emit.\n      @emits module:asynciterator.AsyncIterator.end\n      @emits module:asynciterator.AsyncIterator.error Only if an error is passed.\n    */\n    destroy(cause) {\n        if (!this.done) {\n            this._destroy(cause, error => {\n                cause = cause || error;\n                if (cause)\n                    this.emit('error', cause);\n                this._end(true);\n            });\n        }\n    }\n    /**\n      Called by {@link module:asynciterator.AsyncIterator#destroy}.\n      Implementers can override this, but this should not be called directly.\n      @param {?Error} cause The reason why the iterator is destroyed.\n      @param {Function} callback A callback function with an optional error argument.\n    */\n    _destroy(cause, callback) {\n        callback();\n    }\n    /**\n      Ends the iterator and cleans up.\n      Should never be called before {@link module:asynciterator.AsyncIterator#close};\n      typically, `close` is responsible for calling `_end`.\n      @param {boolean} [destroy] If the iterator should be forcefully destroyed.\n      @protected\n      @emits module:asynciterator.AsyncIterator.end\n    */\n    _end(destroy = false) {\n        if (this._changeState(destroy ? DESTROYED : ENDED)) {\n            this._readable = false;\n            this.removeAllListeners('readable');\n            this.removeAllListeners('data');\n            this.removeAllListeners('end');\n        }\n    }\n    /**\n      Asynchronously calls `_end`.\n      @protected\n    */\n    _endAsync() {\n        taskScheduler(() => this._end());\n    }\n    /**\n      The `end` event is emitted after the last item of the iterator has been read.\n      @event module:asynciterator.end\n    */\n    /**\n      Gets or sets whether this iterator might have items available for read.\n      A value of `false` means there are _definitely_ no items available;\n      a value of `true` means items _might_ be available.\n      @type boolean\n      @emits module:asynciterator.AsyncIterator.readable\n    */\n    get readable() {\n        return this._readable;\n    }\n    set readable(readable) {\n        readable = Boolean(readable) && !this.done;\n        // Set the readable value only if it has changed\n        if (this._readable !== readable) {\n            this._readable = readable;\n            // If the iterator became readable, emit the `readable` event\n            if (readable)\n                taskScheduler(() => this.emit('readable'));\n        }\n    }\n    /**\n      Gets whether the iterator has stopped generating new items.\n      @type boolean\n      @readonly\n    */\n    get closed() {\n        return this._state >= CLOSING;\n    }\n    /**\n      Gets whether the iterator has finished emitting items.\n      @type boolean\n      @readonly\n    */\n    get ended() {\n        return this._state === ENDED;\n    }\n    /**\n      Gets whether the iterator has been destroyed.\n      @type boolean\n      @readonly\n    */\n    get destroyed() {\n        return this._state === DESTROYED;\n    }\n    /**\n      Gets whether the iterator will not emit anymore items,\n      either due to being closed or due to being destroyed.\n      @type boolean\n      @readonly\n    */\n    get done() {\n        return this._state >= ENDED;\n    }\n    /* Generates a textual representation of the iterator. */\n    toString() {\n        const details = this._toStringDetails();\n        return `[${this.constructor.name}${details ? ` ${details}` : ''}]`;\n    }\n    /**\n      Generates details for a textual representation of the iterator.\n      @protected\n    */\n    _toStringDetails() {\n        return '';\n    }\n    /**\n      Retrieves the property with the given name from the iterator.\n      If no callback is passed, it returns the value of the property\n      or `undefined` if the property is not set.\n      If a callback is passed, it returns `undefined`\n      and calls the callback with the property the moment it is set.\n      @param {string} propertyName The name of the property to retrieve\n      @param {Function?} [callback] A one-argument callback to receive the property value\n      @returns {object?} The value of the property (if set and no callback is given)\n    */\n    getProperty(propertyName, callback) {\n        const properties = this._properties;\n        // If no callback was passed, return the property value\n        if (!callback)\n            return properties && properties[propertyName];\n        // If the value has been set, send it through the callback\n        if (properties && (propertyName in properties)) {\n            taskScheduler(() => callback(properties[propertyName]));\n        }\n        // If the value was not set, store the callback for when the value will be set\n        else {\n            let propertyCallbacks;\n            if (!(propertyCallbacks = this._propertyCallbacks))\n                this._propertyCallbacks = propertyCallbacks = Object.create(null);\n            if (propertyName in propertyCallbacks)\n                propertyCallbacks[propertyName].push(callback);\n            else\n                propertyCallbacks[propertyName] = [callback];\n        }\n        return undefined;\n    }\n    /**\n      Sets the property with the given name to the value.\n      @param {string} propertyName The name of the property to set\n      @param {object?} value The new value of the property\n    */\n    setProperty(propertyName, value) {\n        const properties = this._properties || (this._properties = Object.create(null));\n        properties[propertyName] = value;\n        // Execute getter callbacks that were waiting for this property to be set\n        const propertyCallbacks = this._propertyCallbacks || {};\n        const callbacks = propertyCallbacks[propertyName];\n        if (callbacks) {\n            delete propertyCallbacks[propertyName];\n            taskScheduler(() => {\n                for (const callback of callbacks)\n                    callback(value);\n            });\n            // Remove _propertyCallbacks if no pending callbacks are left\n            for (propertyName in propertyCallbacks)\n                return;\n            delete this._propertyCallbacks;\n        }\n    }\n    /**\n      Retrieves all properties of the iterator.\n      @returns {object} An object with property names as keys.\n    */\n    getProperties() {\n        const properties = this._properties;\n        const copy = {};\n        for (const name in properties)\n            copy[name] = properties[name];\n        return copy;\n    }\n    /**\n      Sets all of the given properties.\n      @param {object} properties Key/value pairs of properties to set\n    */\n    setProperties(properties) {\n        for (const propertyName in properties)\n            this.setProperty(propertyName, properties[propertyName]);\n    }\n    /**\n      Copies the given properties from the source iterator.\n      @param {module:asynciterator.AsyncIterator} source The iterator to copy from\n      @param {Array} propertyNames List of property names to copy\n    */\n    copyProperties(source, propertyNames) {\n        for (const propertyName of propertyNames) {\n            source.getProperty(propertyName, value => this.setProperty(propertyName, value));\n        }\n    }\n    /**\n      Transforms items from this iterator.\n      After this operation, only read the returned iterator instead of the current one.\n      @param {object|Function} [options] Settings of the iterator, or the transformation function\n      @param {integer} [options.maxbufferSize=4] The maximum number of items to keep in the buffer\n      @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction\n      @param {integer} [options.offset] The number of items to skip\n      @param {integer} [options.limit] The maximum number of items\n      @param {Function} [options.filter] A function to synchronously filter items from the source\n      @param {Function} [options.map] A function to synchronously transform items from the source\n      @param {Function} [options.transform] A function to asynchronously transform items from the source\n      @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its mapping yields `null` or its transformation yields no items\n      @param {Array|module:asynciterator.AsyncIterator} [options.prepend] Items to insert before the source items\n      @param {Array|module:asynciterator.AsyncIterator} [options.append]  Items to insert after the source items\n      @returns {module:asynciterator.AsyncIterator} A new iterator that maps the items from this iterator\n    */\n    transform(options) {\n        return new SimpleTransformIterator(this, options);\n    }\n    /**\n      Maps items from this iterator using the given function.\n      After this operation, only read the returned iterator instead of the current one.\n      @param {Function} map A mapping function to call on this iterator's (remaining) items\n      @param {object?} self The `this` pointer for the mapping function\n      @returns {module:asynciterator.AsyncIterator} A new iterator that maps the items from this iterator\n    */\n    map(map, self) {\n        return this.transform({ map: self ? map.bind(self) : map });\n    }\n    filter(filter, self) {\n        return this.transform({ filter: self ? filter.bind(self) : filter });\n    }\n    /**\n      Prepends the items after those of the current iterator.\n      After this operation, only read the returned iterator instead of the current one.\n      @param {Array|module:asynciterator.AsyncIterator} items Items to insert before this iterator's (remaining) items\n      @returns {module:asynciterator.AsyncIterator} A new iterator that prepends items to this iterator\n    */\n    prepend(items) {\n        return this.transform({ prepend: items });\n    }\n    /**\n      Appends the items after those of the current iterator.\n      After this operation, only read the returned iterator instead of the current one.\n      @param {Array|module:asynciterator.AsyncIterator} items Items to insert after this iterator's (remaining) items\n      @returns {module:asynciterator.AsyncIterator} A new iterator that appends items to this iterator\n    */\n    append(items) {\n        return this.transform({ append: items });\n    }\n    /**\n      Surrounds items of the current iterator with the given items.\n      After this operation, only read the returned iterator instead of the current one.\n      @param {Array|module:asynciterator.AsyncIterator} prepend Items to insert before this iterator's (remaining) items\n      @param {Array|module:asynciterator.AsyncIterator} append Items to insert after this iterator's (remaining) items\n      @returns {module:asynciterator.AsyncIterator} A new iterator that appends and prepends items to this iterator\n    */\n    surround(prepend, append) {\n        return this.transform({ prepend, append });\n    }\n    /**\n      Skips the given number of items from the current iterator.\n      The current iterator may not be read anymore until the returned iterator ends.\n      @param {integer} offset The number of items to skip\n      @returns {module:asynciterator.AsyncIterator} A new iterator that skips the given number of items\n    */\n    skip(offset) {\n        return this.transform({ offset });\n    }\n    /**\n      Limits the current iterator to the given number of items.\n      The current iterator may not be read anymore until the returned iterator ends.\n      @param {integer} limit The maximum number of items\n      @returns {module:asynciterator.AsyncIterator} A new iterator with at most the given number of items\n    */\n    take(limit) {\n        return this.transform({ limit });\n    }\n    /**\n      Limits the current iterator to the given range.\n      The current iterator may not be read anymore until the returned iterator ends.\n      @param {integer} start Index of the first item to return\n      @param {integer} end Index of the last item to return\n      @returns {module:asynciterator.AsyncIterator} A new iterator with items in the given range\n    */\n    range(start, end) {\n        return this.transform({ offset: start, limit: Math.max(end - start + 1, 0) });\n    }\n    /**\n      Creates a copy of the current iterator,\n      containing all items emitted from this point onward.\n      Further copies can be created; they will all start from this same point.\n      After this operation, only read the returned copies instead of the original iterator.\n      @returns {module:asynciterator.AsyncIterator} A new iterator that contains all future items of this iterator\n    */\n    clone() {\n        return new ClonedIterator(this);\n    }\n}\n// Starts emitting `data` events when `data` listeners are added\nfunction waitForDataListener(eventName) {\n    if (eventName === 'data') {\n        this.removeListener('newListener', waitForDataListener);\n        addSingleListener(this, 'readable', emitData);\n        if (this.readable)\n            taskScheduler(() => emitData.call(this));\n    }\n}\n// Emits new items though `data` events as long as there are `data` listeners\nfunction emitData() {\n    // While there are `data` listeners and items, emit them\n    let item;\n    while (this.listenerCount('data') !== 0 && (item = this.read()) !== null)\n        this.emit('data', item);\n    // Stop draining the source if there are no more `data` listeners\n    if (this.listenerCount('data') === 0 && !this.done) {\n        this.removeListener('readable', emitData);\n        addSingleListener(this, 'newListener', waitForDataListener);\n    }\n}\n// Adds the listener to the event, if it has not been added previously.\nfunction addSingleListener(source, eventName, listener) {\n    if (!source.listeners(eventName).includes(listener))\n        source.on(eventName, listener);\n}\n/**\n  An iterator that doesn't emit any items.\n  @extends module:asynciterator.AsyncIterator\n*/\nexport class EmptyIterator extends AsyncIterator {\n    /** Creates a new `EmptyIterator`. */\n    constructor() {\n        super();\n        this._changeState(ENDED, true);\n    }\n}\n/**\n  An iterator that emits a single item.\n  @extends module:asynciterator.AsyncIterator\n*/\nexport class SingletonIterator extends AsyncIterator {\n    /**\n      Creates a new `SingletonIterator`.\n      @param {object} item The item that will be emitted.\n    */\n    constructor(item) {\n        super();\n        this._item = item;\n        if (item === null)\n            this.close();\n        else\n            this.readable = true;\n    }\n    /* Reads the item from the iterator. */\n    read() {\n        const item = this._item;\n        this._item = null;\n        this.close();\n        return item;\n    }\n    /* Generates details for a textual representation of the iterator. */\n    _toStringDetails() {\n        return this._item === null ? '' : `(${this._item})`;\n    }\n}\n/**\n  An iterator that emits the items of a given array.\n  @extends module:asynciterator.AsyncIterator\n*/\nexport class ArrayIterator extends AsyncIterator {\n    /**\n      Creates a new `ArrayIterator`.\n      @param {Array} items The items that will be emitted.\n    */\n    constructor(items, { autoStart = true } = {}) {\n        super();\n        const buffer = items ? [...items] : [];\n        this._sourceStarted = autoStart !== false;\n        if (this._sourceStarted && buffer.length === 0)\n            this.close();\n        else\n            this._buffer = buffer;\n        this.readable = true;\n    }\n    /* Reads an item from the iterator. */\n    read() {\n        if (!this._sourceStarted)\n            this._sourceStarted = true;\n        let item = null;\n        const buffer = this._buffer;\n        if (buffer) {\n            if (buffer.length !== 0)\n                item = buffer.shift();\n            if (buffer.length === 0) {\n                delete this._buffer;\n                this.close();\n            }\n        }\n        return item;\n    }\n    /* Generates details for a textual representation of the iterator. */\n    _toStringDetails() {\n        return `(${this._buffer && this._buffer.length || 0})`;\n    }\n    /* Called by {@link module:asynciterator.AsyncIterator#destroy} */\n    _destroy(cause, callback) {\n        delete this._buffer;\n        callback();\n    }\n}\n/**\n  An iterator that enumerates integers in a certain range.\n  @extends module:asynciterator.AsyncIterator\n*/\nexport class IntegerIterator extends AsyncIterator {\n    /**\n      Creates a new `IntegerIterator`.\n      @param {object} [options] Settings of the iterator\n      @param {integer} [options.start=0] The first number to emit\n      @param {integer} [options.end=Infinity] The last number to emit\n      @param {integer} [options.step=1] The increment between two numbers\n    */\n    constructor({ start = 0, step = 1, end } = {}) {\n        super();\n        // Determine the first number\n        if (Number.isFinite(start))\n            start = Math.trunc(start);\n        this._next = start;\n        // Determine step size\n        if (Number.isFinite(step))\n            step = Math.trunc(step);\n        this._step = step;\n        // Determine the last number\n        const ascending = step >= 0;\n        const direction = ascending ? Infinity : -Infinity;\n        if (Number.isFinite(end))\n            end = Math.trunc(end);\n        else if (end !== -direction)\n            end = direction;\n        this._last = end;\n        // Start iteration if there is at least one item; close otherwise\n        if (!Number.isFinite(start) || (ascending ? start > end : start < end))\n            this.close();\n        else\n            this.readable = true;\n    }\n    /* Reads an item from the iterator. */\n    read() {\n        if (this.closed)\n            return null;\n        const current = this._next, step = this._step, last = this._last, next = this._next += step;\n        if (step >= 0 ? next > last : next < last)\n            this.close();\n        return current;\n    }\n    /* Generates details for a textual representation of the iterator. */\n    _toStringDetails() {\n        return `(${this._next}...${this._last})`;\n    }\n}\n/**\n  A iterator that maintains an internal buffer of items.\n  This class serves as a base class for other iterators\n  with a typically complex item generation process.\n  @extends module:asynciterator.AsyncIterator\n*/\nexport class BufferedIterator extends AsyncIterator {\n    /**\n      Creates a new `BufferedIterator`.\n      @param {object} [options] Settings of the iterator\n      @param {integer} [options.maxBufferSize=4] The number of items to preload in the internal buffer\n      @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction\n    */\n    constructor({ maxBufferSize = 4, autoStart = true } = {}) {\n        super(INIT);\n        this._buffer = [];\n        this._maxBufferSize = 4;\n        this._reading = true;\n        this._pushedCount = 0;\n        this.maxBufferSize = maxBufferSize;\n        taskScheduler(() => this._init(autoStart));\n        this._sourceStarted = autoStart !== false;\n    }\n    /**\n      The maximum number of items to preload in the internal buffer.\n      A `BufferedIterator` tries to fill its buffer as far as possible.\n      Set to `Infinity` to fully drain the source.\n      @type number\n    */\n    get maxBufferSize() {\n        return this._maxBufferSize;\n    }\n    set maxBufferSize(maxBufferSize) {\n        // Allow only positive integers and infinity\n        if (maxBufferSize !== Infinity) {\n            maxBufferSize = !Number.isFinite(maxBufferSize) ? 4 :\n                Math.max(Math.trunc(maxBufferSize), 1);\n        }\n        // Only set the maximum buffer size if it changes\n        if (this._maxBufferSize !== maxBufferSize) {\n            this._maxBufferSize = maxBufferSize;\n            // Ensure sufficient elements are buffered\n            if (this._state === OPEN)\n                this._fillBuffer();\n        }\n    }\n    /**\n      Initializing the iterator by calling {@link BufferedIterator#_begin}\n      and changing state from INIT to OPEN.\n      @protected\n      @param {boolean} autoStart Whether reading of items should immediately start after OPEN.\n    */\n    _init(autoStart) {\n        // Perform initialization tasks\n        let doneCalled = false;\n        this._reading = true;\n        this._begin(() => {\n            if (doneCalled)\n                throw new Error('done callback called multiple times');\n            doneCalled = true;\n            // Open the iterator and start buffering\n            this._reading = false;\n            this._changeState(OPEN);\n            if (autoStart)\n                this._fillBufferAsync();\n            // If reading should not start automatically, the iterator doesn't become readable.\n            // Therefore, mark the iterator as (potentially) readable so consumers know it might be read.\n            else\n                this.readable = true;\n        });\n    }\n    /**\n      Writes beginning items and opens iterator resources.\n      Should never be called before {@link BufferedIterator#_init};\n      typically, `_init` is responsible for calling `_begin`.\n      @protected\n      @param {function} done To be called when initialization is complete\n    */\n    _begin(done) {\n        done();\n    }\n    /**\n      Tries to read the next item from the iterator.\n      If the buffer is empty,\n      this method calls {@link BufferedIterator#_read} to fetch items.\n      @returns {object?} The next item, or `null` if none is available\n    */\n    read() {\n        if (this.done)\n            return null;\n        // An explicit read kickstarts the source\n        if (!this._sourceStarted)\n            this._sourceStarted = true;\n        // Try to retrieve an item from the buffer\n        const buffer = this._buffer;\n        let item;\n        if (buffer.length !== 0) {\n            item = buffer.shift();\n        }\n        else {\n            item = null;\n            this.readable = false;\n        }\n        // If the buffer is becoming empty, either fill it or end the iterator\n        if (!this._reading && buffer.length < this._maxBufferSize) {\n            // If the iterator is not closed and thus may still generate new items, fill the buffer\n            if (!this.closed)\n                this._fillBufferAsync();\n            // No new items will be generated, so if none are buffered, the iterator ends here\n            else if (!buffer.length)\n                this._endAsync();\n        }\n        return item;\n    }\n    /**\n      Tries to generate the given number of items.\n      Implementers should add `count` items through {@link BufferedIterator#_push}.\n      @protected\n      @param {integer} count The number of items to generate\n      @param {function} done To be called when reading is complete\n    */\n    _read(count, done) {\n        done();\n    }\n    /**\n      Adds an item to the internal buffer.\n      @protected\n      @param {object} item The item to add\n      @emits module:asynciterator.AsyncIterator.readable\n    */\n    _push(item) {\n        if (!this.done) {\n            this._pushedCount++;\n            this._buffer.push(item);\n            this.readable = true;\n        }\n    }\n    /**\n      Fills the internal buffer until `this._maxBufferSize` items are present.\n      This method calls {@link BufferedIterator#_read} to fetch items.\n      @protected\n      @emits module:asynciterator.AsyncIterator.readable\n    */\n    _fillBuffer() {\n        let neededItems;\n        // Avoid recursive reads\n        if (this._reading) {\n            // Do nothing\n        }\n        // If iterator closing started in the meantime, don't generate new items anymore\n        else if (this.closed) {\n            this._completeClose();\n        }\n        // Otherwise, try to fill empty spaces in the buffer by generating new items\n        else if ((neededItems = Math.min(this._maxBufferSize - this._buffer.length, 128)) > 0) {\n            // Acquire reading lock and start reading, counting pushed items\n            this._pushedCount = 0;\n            this._reading = true;\n            this._read(neededItems, () => {\n                // Verify the callback is only called once\n                if (!neededItems)\n                    throw new Error('done callback called multiple times');\n                neededItems = 0;\n                // Release reading lock\n                this._reading = false;\n                // If the iterator was closed while reading, complete closing\n                if (this.closed) {\n                    this._completeClose();\n                }\n                // If the iterator pushed one or more items,\n                // it might currently be able to generate additional items\n                // (even though all pushed items might already have been read)\n                else if (this._pushedCount) {\n                    this.readable = true;\n                    // If the buffer is insufficiently full, continue filling\n                    if (this._buffer.length < this._maxBufferSize / 2)\n                        this._fillBufferAsync();\n                }\n            });\n        }\n    }\n    /**\n      Schedules `_fillBuffer` asynchronously.\n    */\n    _fillBufferAsync() {\n        // Acquire reading lock to avoid recursive reads\n        if (!this._reading) {\n            this._reading = true;\n            taskScheduler(() => {\n                // Release reading lock so _fillBuffer` can take it\n                this._reading = false;\n                this._fillBuffer();\n            });\n        }\n    }\n    /**\n      Stops the iterator from generating new items\n      after a possible pending read operation has finished.\n      Already generated, pending, or terminating items can still be emitted.\n      After this, the iterator will end asynchronously.\n      @emits module:asynciterator.AsyncIterator.end\n    */\n    close() {\n        // If the iterator is not currently reading, we can close immediately\n        if (!this._reading)\n            this._completeClose();\n        // Closing cannot complete when reading, so temporarily assume CLOSING state\n        // `_fillBuffer` becomes responsible for calling `_completeClose`\n        else\n            this._changeState(CLOSING);\n    }\n    /**\n      Stops the iterator from generating new items,\n      switching from `CLOSING` state into `CLOSED` state.\n      @protected\n      @emits module:asynciterator.AsyncIterator.end\n    */\n    _completeClose() {\n        if (this._changeState(CLOSED)) {\n            // Write possible terminating items\n            this._reading = true;\n            this._flush(() => {\n                if (!this._reading)\n                    throw new Error('done callback called multiple times');\n                this._reading = false;\n                // If no items are left, end the iterator\n                // Otherwise, `read` becomes responsible for ending the iterator\n                if (!this._buffer.length)\n                    this._endAsync();\n            });\n        }\n    }\n    /* Called by {@link module:asynciterator.AsyncIterator#destroy} */\n    _destroy(cause, callback) {\n        this._buffer = [];\n        callback();\n    }\n    /**\n      Writes terminating items and closes iterator resources.\n      Should never be called before {@link BufferedIterator#close};\n      typically, `close` is responsible for calling `_flush`.\n      @protected\n      @param {function} done To be called when termination is complete\n    */\n    _flush(done) {\n        done();\n    }\n    /**\n      Generates details for a textual representation of the iterator.\n      @protected\n     */\n    _toStringDetails() {\n        const buffer = this._buffer, { length } = buffer;\n        return `{${length ? `next: ${buffer[0]}, ` : ''}buffer: ${length}}`;\n    }\n}\n/**\n  An iterator that generates items based on a source iterator.\n  This class serves as a base class for other iterators.\n  @extends module:asynciterator.BufferedIterator\n*/\nexport class TransformIterator extends BufferedIterator {\n    /**\n      Creates a new `TransformIterator`.\n      @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from\n      @param {object} [options] Settings of the iterator\n      @param {integer} [options.maxBufferSize=4] The maximum number of items to keep in the buffer\n      @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction\n      @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its transformation yields no items\n      @param {boolean} [options.destroySource=true] Whether the source should be destroyed when this transformed iterator is closed or destroyed\n      @param {module:asynciterator.AsyncIterator} [options.source] The source this iterator generates items from\n    */\n    constructor(source, options = source || {}) {\n        super(options);\n        this._boundPush = (item) => this._push(item);\n        // Shift parameters if needed\n        if (!isSourceExpression(source))\n            source = options.source;\n        // The passed source is an AsyncIterator or readable stream\n        if (isEventEmitter(source)) {\n            this.source = source;\n        }\n        // The passed value is a promise or source creation function\n        else if (source) {\n            this._createSource = isPromise(source) ? () => source : source;\n            if (this._sourceStarted)\n                this._loadSourceAsync();\n        }\n        // Set other options\n        this._optional = Boolean(options.optional);\n        this._destroySource = options.destroySource !== false;\n    }\n    /**\n      The source this iterator generates items from.\n      @type module:asynciterator.AsyncIterator\n    */\n    get source() {\n        if (isFunction(this._createSource))\n            this._loadSourceAsync();\n        return this._source;\n    }\n    set source(value) {\n        // Validate and set source\n        const source = this._source = this._validateSource(value);\n        source._destination = this;\n        // Close this iterator if the source has already ended\n        if (source.done) {\n            this.close();\n        }\n        // Otherwise, react to source events\n        else {\n            source.on('end', destinationCloseWhenDone);\n            source.on('readable', destinationFillBuffer);\n            source.on('error', destinationEmitError);\n        }\n    }\n    /**\n      Initializes a source that was set through a promise\n      @protected\n    */\n    _loadSourceAsync() {\n        if (isFunction(this._createSource)) {\n            // Assign the source after resolving\n            Promise.resolve(this._createSource()).then(source => {\n                delete this._createSource;\n                this.source = source;\n                this._fillBuffer();\n            }, error => this.emit('error', error));\n            // Signal that source creation is pending\n            this._createSource = null;\n        }\n    }\n    /**\n      Validates whether the given iterator can be used as a source.\n      @protected\n      @param {object} source The source to validate\n      @param {boolean} allowDestination Whether the source can already have a destination\n    */\n    _validateSource(source, allowDestination = false) {\n        if (this._source || typeof this._createSource !== 'undefined')\n            throw new Error('The source cannot be changed after it has been set');\n        if (!source || !isFunction(source.read) || !isFunction(source.on))\n            throw new Error(`Invalid source: ${source}`);\n        if (!allowDestination && source._destination)\n            throw new Error('The source already has a destination');\n        return source;\n    }\n    /**\n      Tries to read transformed items.\n    */\n    _read(count, done) {\n        const next = () => {\n            // Continue transforming until at least `count` items have been pushed\n            if (this._pushedCount < count && !this.closed)\n                taskScheduler(() => this._readAndTransform(next, done));\n            else\n                done();\n        };\n        this._readAndTransform(next, done);\n    }\n    /**\n      Reads a transforms an item\n    */\n    _readAndTransform(next, done) {\n        // If the source exists and still can read items,\n        // try to read and transform the next item.\n        let item;\n        const source = this.source;\n        if (!source || source.done || (item = source.read()) === null)\n            done();\n        else if (!this._optional)\n            this._transform(item, next, this._boundPush);\n        else\n            this._optionalTransform(item, next);\n    }\n    /**\n      Tries to transform the item;\n      if the transformation yields no items, pushes the original item.\n    */\n    _optionalTransform(item, done) {\n        const pushedCount = this._pushedCount;\n        this._transform(item, () => {\n            if (pushedCount === this._pushedCount)\n                this._push(item);\n            done();\n        }, this._boundPush);\n    }\n    /**\n      Generates items based on the item from the source.\n      Implementers should add items through {@link BufferedIterator#_push}.\n      The default implementation pushes the source item as-is.\n      @protected\n      @param {object} item The last read item from the source\n      @param {function} done To be called when reading is complete\n      @param {function} push A callback to push zero or more transformation results.\n    */\n    _transform(item, done, push) {\n        push(item);\n        done();\n    }\n    /**\n      Closes the iterator when pending items are transformed.\n      @protected\n    */\n    _closeWhenDone() {\n        this.close();\n    }\n    /* Cleans up the source iterator and ends. */\n    _end(destroy) {\n        const source = this._source;\n        if (source) {\n            source.removeListener('end', destinationCloseWhenDone);\n            source.removeListener('error', destinationEmitError);\n            source.removeListener('readable', destinationFillBuffer);\n            delete source._destination;\n            if (this._destroySource)\n                source.destroy();\n        }\n        super._end(destroy);\n    }\n}\nfunction destinationEmitError(error) {\n    this._destination.emit('error', error);\n}\nfunction destinationCloseWhenDone() {\n    this._destination._closeWhenDone();\n}\nfunction destinationFillBuffer() {\n    if (this._destination._sourceStarted !== false)\n        this._destination._fillBuffer();\n}\n/**\n  An iterator that generates items based on a source iterator\n  and simple transformation steps passed as arguments.\n  @extends module:asynciterator.TransformIterator\n*/\nexport class SimpleTransformIterator extends TransformIterator {\n    /**\n      Creates a new `SimpleTransformIterator`.\n      @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from\n      @param {object|Function} [options] Settings of the iterator, or the transformation function\n      @param {integer} [options.maxbufferSize=4] The maximum number of items to keep in the buffer\n      @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction\n      @param {module:asynciterator.AsyncIterator} [options.source] The source this iterator generates items from\n      @param {integer} [options.offset] The number of items to skip\n      @param {integer} [options.limit] The maximum number of items\n      @param {Function} [options.filter] A function to synchronously filter items from the source\n      @param {Function} [options.map] A function to synchronously transform items from the source\n      @param {Function} [options.transform] A function to asynchronously transform items from the source\n      @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its mapping yields `null` or its transformation yields no items\n      @param {Array|module:asynciterator.AsyncIterator} [options.prepend] Items to insert before the source items\n      @param {Array|module:asynciterator.AsyncIterator} [options.append]  Items to insert after the source items\n    */\n    constructor(source, options) {\n        super(source, options);\n        this._offset = 0;\n        this._limit = Infinity;\n        this._filter = (item) => true;\n        // Set transformation steps from the options\n        options = options || (!isSourceExpression(source) ? source : null);\n        if (options) {\n            const transform = isFunction(options) ? options : options.transform;\n            const { limit, offset, filter, map, prepend, append } = options;\n            // Don't emit any items when bounds are unreachable\n            if (offset === Infinity || limit === -Infinity) {\n                this._limit = 0;\n            }\n            else {\n                if (Number.isFinite(offset))\n                    this._offset = Math.max(Math.trunc(offset), 0);\n                if (Number.isFinite(limit))\n                    this._limit = Math.max(Math.trunc(limit), 0);\n                if (isFunction(filter))\n                    this._filter = filter;\n                if (isFunction(map))\n                    this._map = map;\n                this._transform = isFunction(transform) ? transform : null;\n            }\n            if (prepend)\n                this._prepender = isEventEmitter(prepend) ? prepend : fromArray(prepend);\n            if (append)\n                this._appender = isEventEmitter(append) ? append : fromArray(append);\n        }\n    }\n    /* Tries to read and transform items */\n    _read(count, done) {\n        const next = () => this._readAndTransformSimple(count, nextAsync, done);\n        this._readAndTransformSimple(count, nextAsync, done);\n        function nextAsync() {\n            taskScheduler(next);\n        }\n    }\n    /* Reads and transform items */\n    _readAndTransformSimple(count, next, done) {\n        // Verify we have a readable source\n        let item;\n        const { source } = this;\n        if (!source || source.done) {\n            done();\n            return;\n        }\n        // Verify we are still below the limit\n        if (this._limit === 0)\n            this.close();\n        // Try to read the next item until at least `count` items have been pushed\n        while (!this.closed && this._pushedCount < count && (item = source.read()) !== null) {\n            // Verify the item passes the filter and we've reached the offset\n            if (!this._filter(item) || this._offset !== 0 && this._offset--)\n                continue;\n            // Synchronously map the item\n            const mappedItem = typeof this._map === 'undefined' ? item : this._map(item);\n            // Skip `null` items, pushing the original item if the mapping was optional\n            if (mappedItem === null) {\n                if (this._optional)\n                    this._push(item);\n            }\n            // Skip the asynchronous phase if no transformation was specified\n            else if (!isFunction(this._transform)) {\n                this._push(mappedItem);\n            }\n            // Asynchronously transform the item, and wait for `next` to call back\n            else {\n                if (!this._optional)\n                    this._transform(mappedItem, next, this._boundPush);\n                else\n                    this._optionalTransform(mappedItem, next);\n                return;\n            }\n            // Stop when we've reached the limit\n            if (--this._limit === 0)\n                this.close();\n        }\n        done();\n    }\n    // Prepends items to the iterator\n    _begin(done) {\n        this._insert(this._prepender, done);\n        delete this._prepender;\n    }\n    // Appends items to the iterator\n    _flush(done) {\n        this._insert(this._appender, done);\n        delete this._appender;\n    }\n    // Inserts items in the iterator\n    _insert(inserter, done) {\n        const push = (item) => this._push(item);\n        if (!inserter || inserter.done) {\n            done();\n        }\n        else {\n            inserter.on('data', push);\n            inserter.on('end', end);\n        }\n        function end() {\n            inserter.removeListener('data', push);\n            inserter.removeListener('end', end);\n            done();\n        }\n    }\n}\n/**\n  An iterator that generates items by transforming each item of a source\n  with a different iterator.\n  @extends module:asynciterator.TransformIterator\n*/\nexport class MultiTransformIterator extends TransformIterator {\n    /**\n     Creates a new `MultiTransformIterator`.\n     @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from\n     @param {object|Function} [options] Settings of the iterator, or the transformation function\n     @param {integer} [options.maxbufferSize=4] The maximum number of items to keep in the buffer\n     @param {boolean} [options.autoStart=true] Whether buffering starts directly after construction\n     @param {module:asynciterator.AsyncIterator} [options.source] The source this iterator generates items from\n     @param {integer} [options.offset] The number of items to skip\n     @param {integer} [options.limit] The maximum number of items\n     @param {Function} [options.filter] A function to synchronously filter items from the source\n     @param {Function} [options.map] A function to synchronously transform items from the source\n     @param {Function} [options.transform] A function to asynchronously transform items from the source\n     @param {boolean} [options.optional=false] If transforming is optional, the original item is pushed when its mapping yields `null` or its transformation yields no items\n     @param {Function} [options.multiTransform] A function to asynchronously transform items to iterators from the source\n     @param {Array|module:asynciterator.AsyncIterator} [options.prepend] Items to insert before the source items\n     @param {Array|module:asynciterator.AsyncIterator} [options.append]  Items to insert after the source items\n     */\n    constructor(source, options) {\n        super(source, options);\n        this._transformerQueue = [];\n        // Set transformation steps from the options\n        if (options) {\n            const multiTransform = isFunction(options) ? options : options.multiTransform;\n            if (multiTransform)\n                this._createTransformer = multiTransform;\n        }\n    }\n    /* Tries to read and transform items */\n    _read(count, done) {\n        // Remove transformers that have ended\n        const transformerQueue = this._transformerQueue, optional = this._optional;\n        let head, item;\n        while ((head = transformerQueue[0]) && head.transformer.done) {\n            // If transforming is optional, push the original item if none was pushed\n            if (optional && head.item !== null) {\n                count--;\n                this._push(head.item);\n            }\n            // Remove listeners from the transformer\n            transformerQueue.shift();\n            const { transformer } = head;\n            transformer.removeListener('end', destinationFillBuffer);\n            transformer.removeListener('readable', destinationFillBuffer);\n            transformer.removeListener('error', destinationEmitError);\n        }\n        // Create new transformers if there are less than the maximum buffer size\n        const { source } = this;\n        while (source && !source.done && transformerQueue.length < this.maxBufferSize) {\n            // Read an item to create the next transformer\n            item = source.read();\n            if (item === null)\n                break;\n            // Create the transformer and listen to its events\n            const transformer = (this._createTransformer(item) ||\n                new EmptyIterator());\n            transformer._destination = this;\n            transformer.on('end', destinationFillBuffer);\n            transformer.on('readable', destinationFillBuffer);\n            transformer.on('error', destinationEmitError);\n            transformerQueue.push({ transformer, item });\n        }\n        // Try to read `count` items from the transformer\n        head = transformerQueue[0];\n        if (head) {\n            const { transformer } = head;\n            while (count-- > 0 && (item = transformer.read()) !== null) {\n                this._push(item);\n                // If a transformed item was pushed, no need to push the original anymore\n                if (optional)\n                    head.item = null;\n            }\n        }\n        // End the iterator if the source has ended\n        else if (source && source.done) {\n            this.close();\n        }\n        done();\n    }\n    /**\n      Creates a transformer for the given item.\n      @param {object} item The last read item from the source\n      @returns {module:asynciterator.AsyncIterator} An iterator that transforms the given item\n    */\n    _createTransformer(item) {\n        return new SingletonIterator(item);\n    }\n    /* Closes the iterator when pending items are transformed. */\n    _closeWhenDone() {\n        // Only close if all transformers are read\n        if (!this._transformerQueue.length)\n            this.close();\n    }\n}\n/**\n  An iterator that generates items by reading from multiple other iterators.\n  @extends module:asynciterator.BufferedIterator\n*/\nexport class UnionIterator extends BufferedIterator {\n    /**\n      Creates a new `UnionIterator`.\n      @param {module:asynciterator.AsyncIterator|Array} [sources] The sources to read from\n      @param {object} [options] Settings of the iterator\n    */\n    constructor(sources, options = {}) {\n        super(options);\n        this._sources = [];\n        this._currentSource = -1;\n        const autoStart = options.autoStart !== false;\n        // Sources have been passed as an iterator\n        if (isEventEmitter(sources)) {\n            sources.on('error', error => this.emit('error', error));\n            this._pending = { sources };\n            if (autoStart)\n                this._loadSources();\n        }\n        // Sources have been passed as a non-empty array\n        else if (Array.isArray(sources) && sources.length > 0) {\n            for (const source of sources)\n                this._addSource(source);\n        }\n        // Sources are an empty list\n        else if (autoStart) {\n            this.close();\n        }\n    }\n    // Loads sources passed as an iterator\n    _loadSources() {\n        // Obtain sources iterator\n        const sources = this._pending.sources;\n        delete this._pending.sources;\n        // Close immediately if done\n        if (sources.done) {\n            delete this._pending;\n            this.close();\n        }\n        // Otherwise, set up source reading\n        else {\n            sources.on('data', source => {\n                this._addSource(source);\n                this._fillBufferAsync();\n            });\n            sources.on('end', () => {\n                delete this._pending;\n                this._fillBuffer();\n            });\n        }\n    }\n    // Adds the given source to the internal sources array\n    _addSource(source) {\n        if (!source.done) {\n            this._sources.push(source);\n            source._destination = this;\n            source.on('error', destinationEmitError);\n            source.on('readable', destinationFillBuffer);\n            source.on('end', destinationRemoveEmptySources);\n        }\n    }\n    // Removes sources that will no longer emit items\n    _removeEmptySources() {\n        this._sources = this._sources.filter((source, index) => {\n            // Adjust the index of the current source if needed\n            if (source.done && index <= this._currentSource)\n                this._currentSource--;\n            return !source.done;\n        });\n        this._fillBuffer();\n    }\n    // Reads items from the next sources\n    _read(count, done) {\n        var _a;\n        // Start source loading if needed\n        if ((_a = this._pending) === null || _a === void 0 ? void 0 : _a.sources)\n            this._loadSources();\n        // Try to read `count` items\n        let lastCount = 0, item;\n        while (lastCount !== (lastCount = count)) {\n            // Try every source at least once\n            for (let i = 0; i < this._sources.length && count > 0; i++) {\n                // Pick the next source\n                this._currentSource = (this._currentSource + 1) % this._sources.length;\n                const source = this._sources[this._currentSource];\n                // Attempt to read an item from that source\n                if ((item = source.read()) !== null) {\n                    count--;\n                    this._push(item);\n                }\n            }\n        }\n        // Close this iterator if all of its sources have been read\n        if (!this._pending && this._sources.length === 0)\n            this.close();\n        done();\n    }\n}\nfunction destinationRemoveEmptySources() {\n    this._destination._removeEmptySources();\n}\n/**\n  An iterator that copies items from another iterator.\n  @extends module:asynciterator.TransformIterator\n*/\nexport class ClonedIterator extends TransformIterator {\n    /**\n      Creates a new `ClonedIterator`.\n      @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator copies items from\n    */\n    constructor(source) {\n        super(source, { autoStart: false });\n        this._readPosition = 0;\n        this._reading = false;\n    }\n    _init() {\n        // skip buffered iterator initialization, since we read from history\n    }\n    close() {\n        // skip buffered iterator cleanup\n        AsyncIterator.prototype.close.call(this);\n    }\n    // The source this iterator copies items from\n    get source() {\n        return super.source;\n    }\n    set source(value) {\n        // Validate and set the source\n        const source = this._source = this._validateSource(value);\n        // Create a history reader for the source if none already existed\n        const history = (source && source._destination) ||\n            (source._destination = new HistoryReader(source));\n        // Close this clone if history is empty and the source has ended\n        if (history.endsAt(0)) {\n            this.close();\n        }\n        else {\n            // Subscribe to history events\n            history.register(this);\n            // If there are already items in history, this clone is readable\n            // If the source has a lazy start, always mark this iterator as readable without eagerly triggering a read.\n            if (source._sourceStarted === false || history.readAt(0) !== null)\n                this.readable = true;\n        }\n        // Hook pending property callbacks to the source\n        const propertyCallbacks = this._propertyCallbacks;\n        for (const propertyName in propertyCallbacks) {\n            const callbacks = propertyCallbacks[propertyName];\n            for (const callback of callbacks)\n                this._getSourceProperty(propertyName, callback);\n        }\n    }\n    /**\n      Validates whether the given iterator can be used as a source.\n      @protected\n      @param {object} source The source to validate\n      @param {boolean} allowDestination Whether the source can already have a destination\n    */\n    _validateSource(source, allowDestination = false) {\n        const history = (source && source._destination);\n        return super._validateSource(source, !history || history instanceof HistoryReader);\n    }\n    // Retrieves the property with the given name from the clone or its source.\n    getProperty(propertyName, callback) {\n        const { source } = this, properties = this._properties, hasProperty = properties && (propertyName in properties);\n        // If no callback was passed, return the property value\n        if (!callback) {\n            return hasProperty ? properties && properties[propertyName] :\n                source && source.getProperty(propertyName);\n        }\n        // Try to look up the property in this clone\n        super.getProperty(propertyName, callback);\n        // If the property is not set on this clone, it might become set on the source first\n        if (source && !hasProperty)\n            this._getSourceProperty(propertyName, callback);\n        return undefined;\n    }\n    // Retrieves the property with the given name from the source\n    _getSourceProperty(propertyName, callback) {\n        this.source.getProperty(propertyName, value => {\n            // Only send the source's property if it was not set on the clone in the meantime\n            if (!this._properties || !(propertyName in this._properties))\n                callback(value);\n        });\n    }\n    // Retrieves all properties of the iterator and its source.\n    getProperties() {\n        const base = this.source ? this.source.getProperties() : {}, properties = this._properties;\n        for (const name in properties)\n            base[name] = properties[name];\n        return base;\n    }\n    /* Generates details for a textual representation of the iterator. */\n    _toStringDetails() {\n        return `{source: ${this.source ? this.source.toString() : 'none'}}`;\n    }\n    /* Tries to read an item */\n    read() {\n        // An explicit read kickstarts the source\n        if (!this._sourceStarted)\n            this._sourceStarted = true;\n        const source = this.source;\n        let item = null;\n        if (!this.done && source) {\n            // Try to read an item at the current point in history\n            const history = source._destination;\n            if ((item = history.readAt(this._readPosition)) !== null)\n                this._readPosition++;\n            else\n                this.readable = false;\n            // Close the iterator if we are at the end of the source\n            if (history.endsAt(this._readPosition))\n                this.close();\n        }\n        return item;\n    }\n    /* End the iterator and cleans up. */\n    _end(destroy) {\n        // Unregister from a possible history reader\n        const source = this.source;\n        const history = source === null || source === void 0 ? void 0 : source._destination;\n        if (history)\n            history.unregister(this);\n        // Don't call TransformIterator#_end,\n        // as it would make the source inaccessible for other clones\n        BufferedIterator.prototype._end.call(this, destroy);\n    }\n}\n// Stores the history of a source, so it can be cloned\nclass HistoryReader {\n    constructor(source) {\n        this._clones = null;\n        this._history = [];\n        // If the source can still emit items, set up cloning\n        this._source = source;\n        if (!source.done) {\n            // When the source becomes readable, makes all clones readable\n            const setReadable = () => {\n                for (const clone of this._clones)\n                    clone.readable = true;\n            };\n            // When the source errors, re-emits the error\n            const emitError = (error) => {\n                for (const clone of this._clones)\n                    clone.emit('error', error);\n            };\n            // When the source ends, closes all clones that are fully read\n            const end = () => {\n                // Close the clone if all items had been emitted\n                for (const clone of this._clones) {\n                    if (clone._sourceStarted !== false &&\n                        clone._readPosition === this._history.length)\n                        clone.close();\n                }\n                this._clones = null;\n                // Remove source listeners, since no further events will be emitted\n                source.removeListener('end', end);\n                source.removeListener('error', emitError);\n                source.removeListener('readable', setReadable);\n            };\n            // Listen to source events to trigger events in subscribed clones\n            this._clones = [];\n            source.on('end', end);\n            source.on('error', emitError);\n            source.on('readable', setReadable);\n        }\n    }\n    // Registers a clone for history updates\n    register(clone) {\n        if (this._clones !== null)\n            this._clones.push(clone);\n    }\n    // Unregisters a clone for history updates\n    unregister(clone) {\n        if (this._clones !== null)\n            this._clones = this._clones.filter(c => c !== clone);\n    }\n    // Tries to read the item at the given history position\n    readAt(pos) {\n        let item = null;\n        // Retrieve an item from history when available\n        if (pos < this._history.length)\n            item = this._history[pos];\n        // Read a new item from the source when possible\n        else if (!this._source.done && (item = this._source.read()) !== null)\n            this._history[pos] = item;\n        return item;\n    }\n    // Determines whether the given position is the end of the source\n    endsAt(pos) {\n        return this._source.done && this._history.length === pos;\n    }\n}\n/**\n  Creates an iterator that wraps around a given iterator or readable stream.\n  Use this to convert an iterator-like object into a full-featured AsyncIterator.\n  After this operation, only read the returned iterator instead of the given one.\n  @function\n  @param {module:asynciterator.AsyncIterator|Readable} [source] The source this iterator generates items from\n  @param {object} [options] Settings of the iterator\n  @returns {module:asynciterator.AsyncIterator} A new iterator with the items from the given iterator\n*/\nexport function wrap(source, options) {\n    return new TransformIterator(source, options);\n}\n/**\n  Creates an empty iterator.\n */\nexport function empty() {\n    return new EmptyIterator();\n}\n/**\n  Creates an iterator with a single item.\n  @param {object} item the item\n */\nexport function single(item) {\n    return new SingletonIterator(item);\n}\n/**\n  Creates an iterator for the given array.\n  @param {Array} items the items\n */\nexport function fromArray(items) {\n    return new ArrayIterator(items);\n}\n/**\n  Creates an iterator containing all items from the given iterators.\n  @param {Array} items the items\n */\nexport function union(sources) {\n    return new UnionIterator(sources);\n}\n/**\n  Creates an iterator of integers for the given numeric range.\n  @param {Array} items the items\n */\nexport function range(start, end, step) {\n    return new IntegerIterator({ start, end, step });\n}\n// Determines whether the given object is a function\nfunction isFunction(object) {\n    return typeof object === 'function';\n}\n// Determines whether the given object is an EventEmitter\nfunction isEventEmitter(object) {\n    return object && typeof object.on === 'function';\n}\n// Determines whether the given object is a promise\nfunction isPromise(object) {\n    return object && typeof object.then === 'function';\n}\n// Determines whether the given object is a source expression\nfunction isSourceExpression(object) {\n    return object && (isEventEmitter(object) || isPromise(object) || isFunction(object));\n}\n"]},"metadata":{},"sourceType":"module"}