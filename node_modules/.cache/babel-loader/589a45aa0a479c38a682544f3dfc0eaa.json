{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorSparqlSerializeSparqlCsv = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst bus_sparql_serialize_1 = require(\"@comunica/bus-sparql-serialize\");\n/**\n * A comunica SPARQL CSV SPARQL Serialize Actor.\n */\n\n\nclass ActorSparqlSerializeSparqlCsv extends bus_sparql_serialize_1.ActorSparqlSerializeFixedMediaTypes {\n  constructor(args) {\n    super(args);\n  }\n  /**\n   * Converts an RDF term to its CSV representation.\n   * @param {RDF.Term} value An RDF term.\n   * @return {string} A string representation of the given value.\n   */\n\n\n  static bindingToCsvBindings(value) {\n    if (!value) {\n      return '';\n    }\n\n    let stringValue = value.value;\n\n    if (value.termType === 'Literal') {\n      // This is a lossy representation, since language and datatype are not encoded in here.\n      stringValue = `${stringValue}`;\n    } else if (value.termType === 'BlankNode') {\n      stringValue = `_:${stringValue}`;\n    } else {\n      stringValue = `<${stringValue}>`;\n    } // If a value contains certain characters, put it between double quotes\n\n\n    if (/[\",\\n\\r]/u.test(stringValue)) {\n      // Within quote strings, \" is written using a pair of quotation marks \"\".\n      stringValue = `\"${stringValue.replace(/\"/gu, '\"\"')}\"`;\n    }\n\n    return stringValue;\n  }\n\n  async testHandleChecked(action, context) {\n    if (action.type !== 'bindings') {\n      throw new Error('This actor can only handle bindings streams.');\n    }\n\n    return true;\n  }\n\n  async runHandle(action, mediaType, context) {\n    const bindingsAction = action;\n    const data = new stream_1.Readable();\n\n    data._read = () => {// Do nothing\n    }; // Write head\n\n\n    data.push(`${bindingsAction.variables.map(variable => variable.slice(1)).join(',')}\\r\\n`); // Write bindings\n\n    bindingsAction.bindingsStream.on('error', error => {\n      data.emit('error', error);\n    });\n    bindingsAction.bindingsStream.on('data', bindings => {\n      data.push(`${bindingsAction.variables.map(key => ActorSparqlSerializeSparqlCsv.bindingToCsvBindings(bindings.get(key))).join(',')}\\r\\n`);\n    });\n    bindingsAction.bindingsStream.on('end', () => {\n      data.push(null);\n    });\n    return {\n      data\n    };\n  }\n\n}\n\nexports.ActorSparqlSerializeSparqlCsv = ActorSparqlSerializeSparqlCsv;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-sparql-serialize-sparql-csv/lib/ActorSparqlSerializeSparqlCsv.js"],"names":["Object","defineProperty","exports","value","ActorSparqlSerializeSparqlCsv","stream_1","require","bus_sparql_serialize_1","ActorSparqlSerializeFixedMediaTypes","constructor","args","bindingToCsvBindings","stringValue","termType","test","replace","testHandleChecked","action","context","type","Error","runHandle","mediaType","bindingsAction","data","Readable","_read","push","variables","map","variable","slice","join","bindingsStream","on","error","emit","bindings","key","get"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorSparqlSerializeSparqlCsv = void 0;\nconst stream_1 = require(\"stream\");\nconst bus_sparql_serialize_1 = require(\"@comunica/bus-sparql-serialize\");\n/**\n * A comunica SPARQL CSV SPARQL Serialize Actor.\n */\nclass ActorSparqlSerializeSparqlCsv extends bus_sparql_serialize_1.ActorSparqlSerializeFixedMediaTypes {\n    constructor(args) {\n        super(args);\n    }\n    /**\n     * Converts an RDF term to its CSV representation.\n     * @param {RDF.Term} value An RDF term.\n     * @return {string} A string representation of the given value.\n     */\n    static bindingToCsvBindings(value) {\n        if (!value) {\n            return '';\n        }\n        let stringValue = value.value;\n        if (value.termType === 'Literal') {\n            // This is a lossy representation, since language and datatype are not encoded in here.\n            stringValue = `${stringValue}`;\n        }\n        else if (value.termType === 'BlankNode') {\n            stringValue = `_:${stringValue}`;\n        }\n        else {\n            stringValue = `<${stringValue}>`;\n        }\n        // If a value contains certain characters, put it between double quotes\n        if (/[\",\\n\\r]/u.test(stringValue)) {\n            // Within quote strings, \" is written using a pair of quotation marks \"\".\n            stringValue = `\"${stringValue.replace(/\"/gu, '\"\"')}\"`;\n        }\n        return stringValue;\n    }\n    async testHandleChecked(action, context) {\n        if (action.type !== 'bindings') {\n            throw new Error('This actor can only handle bindings streams.');\n        }\n        return true;\n    }\n    async runHandle(action, mediaType, context) {\n        const bindingsAction = action;\n        const data = new stream_1.Readable();\n        data._read = () => {\n            // Do nothing\n        };\n        // Write head\n        data.push(`${bindingsAction.variables.map((variable) => variable.slice(1)).join(',')}\\r\\n`);\n        // Write bindings\n        bindingsAction.bindingsStream.on('error', (error) => {\n            data.emit('error', error);\n        });\n        bindingsAction.bindingsStream.on('data', (bindings) => {\n            data.push(`${bindingsAction.variables\n                .map((key) => ActorSparqlSerializeSparqlCsv\n                .bindingToCsvBindings(bindings.get(key)))\n                .join(',')}\\r\\n`);\n        });\n        bindingsAction.bindingsStream.on('end', () => {\n            data.push(null);\n        });\n        return { data };\n    }\n}\nexports.ActorSparqlSerializeSparqlCsv = ActorSparqlSerializeSparqlCsv;\n//# sourceMappingURL=ActorSparqlSerializeSparqlCsv.js.map"]},"metadata":{},"sourceType":"script"}