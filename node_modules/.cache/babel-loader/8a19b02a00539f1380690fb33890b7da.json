{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationGroup = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst sparqlee_1 = require(\"sparqlee\");\n\nconst GroupsState_1 = require(\"./GroupsState\");\n/**\n * A comunica Group Query Operation Actor.\n */\n\n\nclass ActorQueryOperationGroup extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n  constructor(args) {\n    super(args, 'group');\n  }\n\n  async testOperation(pattern, context) {\n    for (const aggregate of pattern.aggregates) {\n      // Will throw for unsupported expressions\n      const _ = new sparqlee_1.SyncEvaluator(aggregate.expression);\n    }\n\n    return true;\n  }\n\n  async runOperation(pattern, context) {\n    // Get result stream for the input query\n    const {\n      input,\n      aggregates\n    } = pattern;\n    const outputRaw = await this.mediatorQueryOperation.mediate({\n      operation: input,\n      context\n    });\n    const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(outputRaw); // The variables in scope are the variables on which we group, i.e. pattern.variables.\n    // For 'GROUP BY ?x, ?z', this is [?x, ?z], for 'GROUP by expr(?x) as ?e' this is [?e].\n    // But also in scope are the variables defined by the aggregations, since GROUP has to handle this.\n\n    const variables = [...pattern.variables.map(x => rdf_string_1.termToString(x)), ...aggregates.map(agg => rdf_string_1.termToString(agg.variable))];\n    const sparqleeConfig = Object.assign({}, bus_query_operation_1.ActorQueryOperation.getExpressionContext(context)); // Return a new promise that completes when the stream has ended or when\n    // an error occurs\n\n    return new Promise((resolve, reject) => {\n      const groups = new GroupsState_1.GroupsState(pattern, sparqleeConfig); // Phase 2: Collect aggregator results\n      // We can only return when the binding stream ends, when that happens\n      // we return the identified groups. Which are nothing more than Bindings\n      // of the grouping variables merged with the aggregate variables\n\n      output.bindingsStream.on('end', () => {\n        try {\n          const bindingsStream = new asynciterator_1.ArrayIterator(groups.collectResults(), {\n            autoStart: false\n          });\n          const {\n            metadata\n          } = output;\n          resolve({\n            type: 'bindings',\n            bindingsStream,\n            metadata,\n            variables,\n            canContainUndefs: output.canContainUndefs\n          });\n        } catch (error) {\n          reject(error);\n        }\n      }); // Make sure to propagate any errors in the binding stream\n\n      output.bindingsStream.on('error', reject); // Phase 1: Consume the stream, identify the groups and populate the aggregators.\n      // We need to bind this after the 'error' and 'end' listeners to avoid the\n      // stream having ended before those listeners are bound.\n\n      output.bindingsStream.on('data', bindings => {\n        try {\n          groups.consumeBindings(bindings);\n        } catch (error) {\n          reject(error);\n        }\n      });\n    });\n  }\n\n}\n\nexports.ActorQueryOperationGroup = ActorQueryOperationGroup;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-group/lib/ActorQueryOperationGroup.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationGroup","bus_query_operation_1","require","asynciterator_1","rdf_string_1","sparqlee_1","GroupsState_1","ActorQueryOperationTypedMediated","constructor","args","testOperation","pattern","context","aggregate","aggregates","_","SyncEvaluator","expression","runOperation","input","outputRaw","mediatorQueryOperation","mediate","operation","output","ActorQueryOperation","getSafeBindings","variables","map","x","termToString","agg","variable","sparqleeConfig","assign","getExpressionContext","Promise","resolve","reject","groups","GroupsState","bindingsStream","on","ArrayIterator","collectResults","autoStart","metadata","type","canContainUndefs","error","bindings","consumeBindings"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationGroup = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst sparqlee_1 = require(\"sparqlee\");\nconst GroupsState_1 = require(\"./GroupsState\");\n/**\n * A comunica Group Query Operation Actor.\n */\nclass ActorQueryOperationGroup extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n    constructor(args) {\n        super(args, 'group');\n    }\n    async testOperation(pattern, context) {\n        for (const aggregate of pattern.aggregates) {\n            // Will throw for unsupported expressions\n            const _ = new sparqlee_1.SyncEvaluator(aggregate.expression);\n        }\n        return true;\n    }\n    async runOperation(pattern, context) {\n        // Get result stream for the input query\n        const { input, aggregates } = pattern;\n        const outputRaw = await this.mediatorQueryOperation.mediate({ operation: input, context });\n        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(outputRaw);\n        // The variables in scope are the variables on which we group, i.e. pattern.variables.\n        // For 'GROUP BY ?x, ?z', this is [?x, ?z], for 'GROUP by expr(?x) as ?e' this is [?e].\n        // But also in scope are the variables defined by the aggregations, since GROUP has to handle this.\n        const variables = [\n            ...pattern.variables.map(x => rdf_string_1.termToString(x)),\n            ...aggregates.map(agg => rdf_string_1.termToString(agg.variable)),\n        ];\n        const sparqleeConfig = Object.assign({}, bus_query_operation_1.ActorQueryOperation.getExpressionContext(context));\n        // Return a new promise that completes when the stream has ended or when\n        // an error occurs\n        return new Promise((resolve, reject) => {\n            const groups = new GroupsState_1.GroupsState(pattern, sparqleeConfig);\n            // Phase 2: Collect aggregator results\n            // We can only return when the binding stream ends, when that happens\n            // we return the identified groups. Which are nothing more than Bindings\n            // of the grouping variables merged with the aggregate variables\n            output.bindingsStream.on('end', () => {\n                try {\n                    const bindingsStream = new asynciterator_1.ArrayIterator(groups.collectResults(), { autoStart: false });\n                    const { metadata } = output;\n                    resolve({ type: 'bindings', bindingsStream, metadata, variables, canContainUndefs: output.canContainUndefs });\n                }\n                catch (error) {\n                    reject(error);\n                }\n            });\n            // Make sure to propagate any errors in the binding stream\n            output.bindingsStream.on('error', reject);\n            // Phase 1: Consume the stream, identify the groups and populate the aggregators.\n            // We need to bind this after the 'error' and 'end' listeners to avoid the\n            // stream having ended before those listeners are bound.\n            output.bindingsStream.on('data', bindings => {\n                try {\n                    groups.consumeBindings(bindings);\n                }\n                catch (error) {\n                    reject(error);\n                }\n            });\n        });\n    }\n}\nexports.ActorQueryOperationGroup = ActorQueryOperationGroup;\n//# sourceMappingURL=ActorQueryOperationGroup.js.map"]},"metadata":{},"sourceType":"script"}