{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeHandlerSelectionFragmentSpread = void 0;\n\nconst NodeHandlerSelectionAdapter_1 = require(\"./NodeHandlerSelectionAdapter\");\n/**\n * Converts GraphQL fragment spread to one or more quad patterns with a given type within an optional.\n */\n\n\nclass NodeHandlerSelectionFragmentSpread extends NodeHandlerSelectionAdapter_1.NodeHandlerSelectionAdapter {\n  constructor(util, settings) {\n    super('FragmentSpread', util, settings);\n  }\n\n  handle(fragmentSpreadNode, convertContext) {\n    const fragmentDefinitionNode = convertContext.fragmentDefinitions[fragmentSpreadNode.name.value];\n\n    if (!fragmentDefinitionNode) {\n      throw new Error('Undefined fragment definition: ' + fragmentSpreadNode.name.value);\n    } // Wrap in an OPTIONAL, as this pattern should only apply if the type applies\n\n\n    const fieldNode = {\n      alias: null,\n      arguments: null,\n      directives: fragmentDefinitionNode.directives,\n      kind: 'Field',\n      name: fragmentSpreadNode.name,\n      selectionSet: fragmentDefinitionNode.selectionSet\n    };\n    const auxiliaryPatterns = [this.util.newTypePattern(convertContext.subject, fragmentDefinitionNode.typeCondition, convertContext)];\n    return this.util.operationFactory.createLeftJoin(this.util.operationFactory.createBgp([]), this.fieldToOperation(convertContext, fieldNode, false, auxiliaryPatterns));\n  }\n\n}\n\nexports.NodeHandlerSelectionFragmentSpread = NodeHandlerSelectionFragmentSpread;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/graphql-to-sparql/lib/handler/NodeHandlerSelectionFragmentSpread.js"],"names":["Object","defineProperty","exports","value","NodeHandlerSelectionFragmentSpread","NodeHandlerSelectionAdapter_1","require","NodeHandlerSelectionAdapter","constructor","util","settings","handle","fragmentSpreadNode","convertContext","fragmentDefinitionNode","fragmentDefinitions","name","Error","fieldNode","alias","arguments","directives","kind","selectionSet","auxiliaryPatterns","newTypePattern","subject","typeCondition","operationFactory","createLeftJoin","createBgp","fieldToOperation"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,kCAAR,GAA6C,KAAK,CAAlD;;AACA,MAAMC,6BAA6B,GAAGC,OAAO,CAAC,+BAAD,CAA7C;AACA;AACA;AACA;;;AACA,MAAMF,kCAAN,SAAiDC,6BAA6B,CAACE,2BAA/E,CAA2G;AACvGC,EAAAA,WAAW,CAACC,IAAD,EAAOC,QAAP,EAAiB;AACxB,UAAM,gBAAN,EAAwBD,IAAxB,EAA8BC,QAA9B;AACH;;AACDC,EAAAA,MAAM,CAACC,kBAAD,EAAqBC,cAArB,EAAqC;AACvC,UAAMC,sBAAsB,GAAGD,cAAc,CACxCE,mBAD0B,CACNH,kBAAkB,CAACI,IAAnB,CAAwBb,KADlB,CAA/B;;AAEA,QAAI,CAACW,sBAAL,EAA6B;AACzB,YAAM,IAAIG,KAAJ,CAAU,oCAAoCL,kBAAkB,CAACI,IAAnB,CAAwBb,KAAtE,CAAN;AACH,KALsC,CAMvC;;;AACA,UAAMe,SAAS,GAAG;AACdC,MAAAA,KAAK,EAAE,IADO;AAEdC,MAAAA,SAAS,EAAE,IAFG;AAGdC,MAAAA,UAAU,EAAEP,sBAAsB,CAACO,UAHrB;AAIdC,MAAAA,IAAI,EAAE,OAJQ;AAKdN,MAAAA,IAAI,EAAEJ,kBAAkB,CAACI,IALX;AAMdO,MAAAA,YAAY,EAAET,sBAAsB,CAACS;AANvB,KAAlB;AAQA,UAAMC,iBAAiB,GAAG,CACtB,KAAKf,IAAL,CAAUgB,cAAV,CAAyBZ,cAAc,CAACa,OAAxC,EAAiDZ,sBAAsB,CAACa,aAAxE,EAAuFd,cAAvF,CADsB,CAA1B;AAGA,WAAO,KAAKJ,IAAL,CAAUmB,gBAAV,CAA2BC,cAA3B,CAA0C,KAAKpB,IAAL,CAAUmB,gBAAV,CAA2BE,SAA3B,CAAqC,EAArC,CAA1C,EAAoF,KAAKC,gBAAL,CAAsBlB,cAAtB,EAAsCK,SAAtC,EAAiD,KAAjD,EAAwDM,iBAAxD,CAApF,CAAP;AACH;;AAvBsG;;AAyB3GtB,OAAO,CAACE,kCAAR,GAA6CA,kCAA7C","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NodeHandlerSelectionFragmentSpread = void 0;\nconst NodeHandlerSelectionAdapter_1 = require(\"./NodeHandlerSelectionAdapter\");\n/**\n * Converts GraphQL fragment spread to one or more quad patterns with a given type within an optional.\n */\nclass NodeHandlerSelectionFragmentSpread extends NodeHandlerSelectionAdapter_1.NodeHandlerSelectionAdapter {\n    constructor(util, settings) {\n        super('FragmentSpread', util, settings);\n    }\n    handle(fragmentSpreadNode, convertContext) {\n        const fragmentDefinitionNode = convertContext\n            .fragmentDefinitions[fragmentSpreadNode.name.value];\n        if (!fragmentDefinitionNode) {\n            throw new Error('Undefined fragment definition: ' + fragmentSpreadNode.name.value);\n        }\n        // Wrap in an OPTIONAL, as this pattern should only apply if the type applies\n        const fieldNode = {\n            alias: null,\n            arguments: null,\n            directives: fragmentDefinitionNode.directives,\n            kind: 'Field',\n            name: fragmentSpreadNode.name,\n            selectionSet: fragmentDefinitionNode.selectionSet,\n        };\n        const auxiliaryPatterns = [\n            this.util.newTypePattern(convertContext.subject, fragmentDefinitionNode.typeCondition, convertContext),\n        ];\n        return this.util.operationFactory.createLeftJoin(this.util.operationFactory.createBgp([]), this.fieldToOperation(convertContext, fieldNode, false, auxiliaryPatterns));\n    }\n}\nexports.NodeHandlerSelectionFragmentSpread = NodeHandlerSelectionFragmentSpread;\n//# sourceMappingURL=NodeHandlerSelectionFragmentSpread.js.map"]},"metadata":{},"sourceType":"script"}