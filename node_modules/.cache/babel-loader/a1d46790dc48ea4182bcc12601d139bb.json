{"ast":null,"code":"import { translate, toSparql } from 'sparqlalgebrajs';\nimport AbstractPathResolver from './AbstractPathResolver';\nimport { namedNode } from '@rdfjs/data-model';\n/**\n * Writes SPARQL algebra a complex SPARQL path\n */\n\nfunction writePathAlgebra(algebra) {\n  if (algebra.type === 'join') return `${writePathAlgebra(algebra.left)}/${writePathAlgebra(algebra.right)}`; // The algebra library turns sequential path expressions like\n  // foaf:friend/foaf:givenName into a bgp token rather than a path token\n\n  if (algebra.type === 'bgp' && algebra.patterns.every(quad => quad.predicate.termType === 'NamedNode') && algebra.patterns.length >= 0) {\n    let lastObject = 's';\n    return algebra.patterns.map(quad => {\n      const predicate = `<${quad.predicate.value}>`;\n\n      if (quad.object.value === lastObject) {\n        lastObject = quad.subject.value;\n        return `^${predicate}`;\n      }\n\n      lastObject = quad.object.value;\n      return predicate;\n    }).join('/');\n  }\n\n  if (algebra.type === 'path') {\n    // Note - this could be made cleaner if sparqlalgebrajs exported\n    // the translatePathComponent function\n    let query = toSparql({\n      type: 'project',\n      input: algebra\n    });\n    query = query.replace(/^SELECT WHERE \\{ \\?[0-9a-z]+ \\(|\\) \\?[0-9a-z]+\\. \\}$/ig, '');\n    return query;\n  }\n\n  throw new Error(`Unhandled algebra ${algebra.type}`);\n}\n\nexport default class ComplexPathResolver extends AbstractPathResolver {\n  /**\n   * Supports all strings that contain path modifiers. The regular\n   * expression is testing for 4 main properties:\n   * 1. /(^|[/|])[\\^]/\n   *    Tests for reverse (^) key at start of string or after '/', '|'\n   * 2. /([a-z:>)])[\\*\\+\\?]/i\n   *    Tests for length modifier\n   *    e.g. ex:test*, <http://example.org/test>?, (ex:test)+\n   * 3. /([)>\\*\\+\\?]|[a-z]*[:][a-z]*)[|/]([<(\\^]|[a-z]*[:][a-z]*)/i\n   *    Tests for '/' and '|' operators *in* a path\n   * 4. /((^[(<])|([)>]$))/\n   *    Tests for '(', '<', at the start of a string and ')', '>' at the end of a string\n   */\n  supports(property) {\n    return super.supports(property) && /((^|[/|])[\\^])|(([a-z:>)])[*+?])|([)>*+?]|[a-z]*[:][a-z]*)[|/]([<(^]|[a-z]*[:][a-z]*)|(((^[(<])|([)>]$)))/i.test(property);\n  }\n  /**\n   * Takes string and resolves it to a predicate or SPARQL path\n   */\n\n\n  async lookupProperty(property) {\n    // Expand the property to a full IRI\n    const context = await this._context;\n    const prefixes = {};\n\n    for (const key in context.contextRaw) {\n      if (typeof context.contextRaw[key] === 'string') prefixes[key] = context.contextRaw[key];\n    } // Wrap inside try/catch as 'translate' throws error on invalid paths\n\n\n    let algebra;\n\n    try {\n      algebra = translate(`SELECT ?s ?o WHERE { ?s ${property} ?o. }`, {\n        prefixes\n      });\n    } catch (e) {\n      throw new Error(`The Complex Path Resolver cannot expand the '${property}' path`);\n    }\n\n    if (algebra.input.type === 'bgp' && algebra.input.patterns.length === 1 && algebra.input.patterns[0].predicate.termType === 'NamedNode' && // Test to make sure the path is not an inverse path\n    // in which case the subject and object would be switched\n    algebra.input.patterns[0].subject.value === 's') return namedNode(algebra.input.patterns[0].predicate.value);\n\n    try {\n      return {\n        termType: 'path',\n        value: writePathAlgebra(algebra.input)\n      };\n    } catch (e) {\n      throw new Error(`The Complex Path Resolver cannot expand the '${property}' path`);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/ComplexPathResolver.js"],"names":["translate","toSparql","AbstractPathResolver","namedNode","writePathAlgebra","algebra","type","left","right","patterns","every","quad","predicate","termType","length","lastObject","map","value","object","subject","join","query","input","replace","Error","ComplexPathResolver","supports","property","test","lookupProperty","context","_context","prefixes","key","contextRaw","e"],"mappings":"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","sourcesContent":["import { translate, toSparql } from 'sparqlalgebrajs';\nimport AbstractPathResolver from './AbstractPathResolver';\nimport { namedNode } from '@rdfjs/data-model';\n/**\n * Writes SPARQL algebra a complex SPARQL path\n */\n\nfunction writePathAlgebra(algebra) {\n  if (algebra.type === 'join') return `${writePathAlgebra(algebra.left)}/${writePathAlgebra(algebra.right)}`; // The algebra library turns sequential path expressions like\n  // foaf:friend/foaf:givenName into a bgp token rather than a path token\n\n  if (algebra.type === 'bgp' && algebra.patterns.every(quad => quad.predicate.termType === 'NamedNode') && algebra.patterns.length >= 0) {\n    let lastObject = 's';\n    return algebra.patterns.map(quad => {\n      const predicate = `<${quad.predicate.value}>`;\n\n      if (quad.object.value === lastObject) {\n        lastObject = quad.subject.value;\n        return `^${predicate}`;\n      }\n\n      lastObject = quad.object.value;\n      return predicate;\n    }).join('/');\n  }\n\n  if (algebra.type === 'path') {\n    // Note - this could be made cleaner if sparqlalgebrajs exported\n    // the translatePathComponent function\n    let query = toSparql({\n      type: 'project',\n      input: algebra\n    });\n    query = query.replace(/^SELECT WHERE \\{ \\?[0-9a-z]+ \\(|\\) \\?[0-9a-z]+\\. \\}$/ig, '');\n    return query;\n  }\n\n  throw new Error(`Unhandled algebra ${algebra.type}`);\n}\n\nexport default class ComplexPathResolver extends AbstractPathResolver {\n  /**\n   * Supports all strings that contain path modifiers. The regular\n   * expression is testing for 4 main properties:\n   * 1. /(^|[/|])[\\^]/\n   *    Tests for reverse (^) key at start of string or after '/', '|'\n   * 2. /([a-z:>)])[\\*\\+\\?]/i\n   *    Tests for length modifier\n   *    e.g. ex:test*, <http://example.org/test>?, (ex:test)+\n   * 3. /([)>\\*\\+\\?]|[a-z]*[:][a-z]*)[|/]([<(\\^]|[a-z]*[:][a-z]*)/i\n   *    Tests for '/' and '|' operators *in* a path\n   * 4. /((^[(<])|([)>]$))/\n   *    Tests for '(', '<', at the start of a string and ')', '>' at the end of a string\n   */\n  supports(property) {\n    return super.supports(property) && /((^|[/|])[\\^])|(([a-z:>)])[*+?])|([)>*+?]|[a-z]*[:][a-z]*)[|/]([<(^]|[a-z]*[:][a-z]*)|(((^[(<])|([)>]$)))/i.test(property);\n  }\n  /**\n   * Takes string and resolves it to a predicate or SPARQL path\n   */\n\n\n  async lookupProperty(property) {\n    // Expand the property to a full IRI\n    const context = await this._context;\n    const prefixes = {};\n\n    for (const key in context.contextRaw) {\n      if (typeof context.contextRaw[key] === 'string') prefixes[key] = context.contextRaw[key];\n    } // Wrap inside try/catch as 'translate' throws error on invalid paths\n\n\n    let algebra;\n\n    try {\n      algebra = translate(`SELECT ?s ?o WHERE { ?s ${property} ?o. }`, {\n        prefixes\n      });\n    } catch (e) {\n      throw new Error(`The Complex Path Resolver cannot expand the '${property}' path`);\n    }\n\n    if (algebra.input.type === 'bgp' && algebra.input.patterns.length === 1 && algebra.input.patterns[0].predicate.termType === 'NamedNode' && // Test to make sure the path is not an inverse path\n    // in which case the subject and object would be switched\n    algebra.input.patterns[0].subject.value === 's') return namedNode(algebra.input.patterns[0].predicate.value);\n\n    try {\n      return {\n        termType: 'path',\n        value: writePathAlgebra(algebra.input)\n      };\n    } catch (e) {\n      throw new Error(`The Complex Path Resolver cannot expand the '${property}' path`);\n    }\n  }\n\n}"]},"metadata":{},"sourceType":"module"}