{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationDescribeSubject = void 0;\n\nconst actor_query_operation_union_1 = require(\"@comunica/actor-query-operation-union\");\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * A comunica Describe Subject Query Operation Actor.\n */\n\nclass ActorQueryOperationDescribeSubject extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n  constructor(args) {\n    super(args, 'describe');\n  }\n\n  async testOperation(pattern, context) {\n    return true;\n  }\n\n  async runOperation(pattern, context) {\n    // Create separate construct queries for all non-variable terms\n    const operations = pattern.terms.filter(term => term.termType !== 'Variable').map(term => {\n      // Transform each term to a separate construct operation with S ?p ?o patterns (BGP) for all terms\n      const patterns = [DF.quad(term, DF.variable('__predicate'), DF.variable('__object'))]; // eslint-disable-next-line no-return-assign\n\n      patterns.forEach(templatePattern => templatePattern.type = 'pattern');\n      const templateOperation = {\n        type: 'bgp',\n        patterns: patterns\n      }; // Create a construct query\n\n      return {\n        input: templateOperation,\n        template: patterns,\n        type: 'construct'\n      };\n    }); // If we have variables in the term list,\n    // create one separate construct operation to determine these variables using the input pattern.\n\n    if (operations.length !== pattern.terms.length) {\n      let variablePatterns = [];\n      pattern.terms.filter(term => term.termType === 'Variable').forEach((term, i) => {\n        // Transform each term to an S ?p ?o pattern in a non-conflicting way\n        const patterns = [DF.quad(term, DF.variable(`__predicate${i}`), DF.variable(`__object${i}`))]; // eslint-disable-next-line no-return-assign\n\n        patterns.forEach(templatePattern => templatePattern.type = 'pattern');\n        variablePatterns = [...variablePatterns, ...patterns];\n      }); // Add a single construct for the variables\n      // This requires a join between the input pattern and our variable patterns that form a simple BGP\n\n      operations.push({\n        input: {\n          type: 'join',\n          left: pattern.input,\n          right: {\n            type: 'bgp',\n            patterns: variablePatterns\n          }\n        },\n        template: variablePatterns,\n        type: 'construct'\n      });\n    } // Evaluate the construct queries\n\n\n    const outputs = (await Promise.all(operations.map(operation => this.mediatorQueryOperation.mediate({\n      operation,\n      context\n    })))).map(bus_query_operation_1.ActorQueryOperation.getSafeQuads); // Take the union of all quad streams\n\n    const quadStream = new asynciterator_1.UnionIterator(outputs.map(output => output.quadStream), {\n      autoStart: false\n    }); // Take union of metadata\n\n    const metadata = () => Promise.all(outputs.map(x => bus_query_operation_1.getMetadata(x))).then(actor_query_operation_union_1.ActorQueryOperationUnion.unionMetadata);\n\n    return {\n      type: 'quads',\n      quadStream,\n      metadata\n    };\n  }\n\n}\n\nexports.ActorQueryOperationDescribeSubject = ActorQueryOperationDescribeSubject;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-describe-subject/lib/ActorQueryOperationDescribeSubject.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationDescribeSubject","actor_query_operation_union_1","require","bus_query_operation_1","asynciterator_1","rdf_data_factory_1","DF","DataFactory","ActorQueryOperationTypedMediated","constructor","args","testOperation","pattern","context","runOperation","operations","terms","filter","term","termType","map","patterns","quad","variable","forEach","templatePattern","type","templateOperation","input","template","length","variablePatterns","i","push","left","right","outputs","Promise","all","operation","mediatorQueryOperation","mediate","ActorQueryOperation","getSafeQuads","quadStream","UnionIterator","output","autoStart","metadata","x","getMetadata","then","ActorQueryOperationUnion","unionMetadata"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationDescribeSubject = void 0;\nconst actor_query_operation_union_1 = require(\"@comunica/actor-query-operation-union\");\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * A comunica Describe Subject Query Operation Actor.\n */\nclass ActorQueryOperationDescribeSubject extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n    constructor(args) {\n        super(args, 'describe');\n    }\n    async testOperation(pattern, context) {\n        return true;\n    }\n    async runOperation(pattern, context) {\n        // Create separate construct queries for all non-variable terms\n        const operations = pattern.terms\n            .filter(term => term.termType !== 'Variable')\n            .map((term) => {\n            // Transform each term to a separate construct operation with S ?p ?o patterns (BGP) for all terms\n            const patterns = [\n                DF.quad(term, DF.variable('__predicate'), DF.variable('__object')),\n            ];\n            // eslint-disable-next-line no-return-assign\n            patterns.forEach((templatePattern) => templatePattern.type = 'pattern');\n            const templateOperation = { type: 'bgp', patterns: patterns };\n            // Create a construct query\n            return {\n                input: templateOperation,\n                template: patterns,\n                type: 'construct',\n            };\n        });\n        // If we have variables in the term list,\n        // create one separate construct operation to determine these variables using the input pattern.\n        if (operations.length !== pattern.terms.length) {\n            let variablePatterns = [];\n            pattern.terms\n                .filter(term => term.termType === 'Variable')\n                .forEach((term, i) => {\n                // Transform each term to an S ?p ?o pattern in a non-conflicting way\n                const patterns = [\n                    DF.quad(term, DF.variable(`__predicate${i}`), DF.variable(`__object${i}`)),\n                ];\n                // eslint-disable-next-line no-return-assign\n                patterns.forEach((templatePattern) => templatePattern.type = 'pattern');\n                variablePatterns = [...variablePatterns, ...patterns];\n            });\n            // Add a single construct for the variables\n            // This requires a join between the input pattern and our variable patterns that form a simple BGP\n            operations.push({\n                input: { type: 'join', left: pattern.input, right: { type: 'bgp', patterns: variablePatterns } },\n                template: variablePatterns,\n                type: 'construct',\n            });\n        }\n        // Evaluate the construct queries\n        const outputs = (await Promise.all(operations.map(operation => this.mediatorQueryOperation.mediate({ operation, context }))))\n            .map(bus_query_operation_1.ActorQueryOperation.getSafeQuads);\n        // Take the union of all quad streams\n        const quadStream = new asynciterator_1.UnionIterator(outputs.map(output => output.quadStream), { autoStart: false });\n        // Take union of metadata\n        const metadata = () => Promise.all(outputs\n            .map(x => bus_query_operation_1.getMetadata(x)))\n            .then(actor_query_operation_union_1.ActorQueryOperationUnion.unionMetadata);\n        return { type: 'quads', quadStream, metadata };\n    }\n}\nexports.ActorQueryOperationDescribeSubject = ActorQueryOperationDescribeSubject;\n//# sourceMappingURL=ActorQueryOperationDescribeSubject.js.map"]},"metadata":{},"sourceType":"script"}