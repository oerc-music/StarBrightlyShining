{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KEY_CONTEXT_DATETIME = exports.ActorHttpMemento = void 0;\n\nconst bus_http_1 = require(\"@comunica/bus-http\");\n\nconst context_entries_1 = require(\"@comunica/context-entries\");\n\nrequire(\"cross-fetch/polyfill\");\n\nconst parseLink = require(\"parse-link-header\");\n/**\n * A comunica Memento Http Actor.\n */\n\n\nclass ActorHttpMemento extends bus_http_1.ActorHttp {\n  constructor(args) {\n    super(args);\n  }\n\n  async test(action) {\n    var _a;\n\n    if (!(action.context && action.context.has(context_entries_1.KeysHttpMemento.datetime) && action.context.get(context_entries_1.KeysHttpMemento.datetime) instanceof Date)) {\n      throw new Error('This actor only handles request with a set valid datetime.');\n    }\n\n    if (action.init && new Headers((_a = action.init.headers) !== null && _a !== void 0 ? _a : {}).has('accept-datetime')) {\n      throw new Error('The request already has a set datetime.');\n    }\n\n    return true;\n  }\n\n  async run(action) {\n    var _a; // Duplicate the ActionHttp to append a datetime header to the request.\n\n\n    const init = action.init ? Object.assign({}, action.init) : {};\n    const headers = init.headers = new Headers((_a = init.headers) !== null && _a !== void 0 ? _a : {});\n\n    if (action.context && action.context.has(context_entries_1.KeysHttpMemento.datetime)) {\n      headers.append('accept-datetime', action.context.get(context_entries_1.KeysHttpMemento.datetime).toUTCString());\n    }\n\n    const httpAction = {\n      context: action.context,\n      input: action.input,\n      init\n    }; // Execute the request and follow the timegate in the response (if any).\n\n    const result = await this.mediatorHttp.mediate(httpAction); // Did we ask for a time-negotiated response, but haven't received one?\n\n    if (headers.has('accept-datetime') && result.headers && !result.headers.has('memento-datetime')) {\n      // The links might have a timegate that can help us\n      const links = result.headers.has('link') && parseLink(result.headers.get('link'));\n\n      if (links && links.timegate) {\n        if (result.body) {\n          await result.body.cancel();\n        } // Respond with a time-negotiated response from the timegate instead\n\n\n        const followLink = {\n          context: action.context,\n          input: links.timegate.url,\n          init\n        };\n        return this.mediatorHttp.mediate(followLink);\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexports.ActorHttpMemento = ActorHttpMemento;\n/**\n * @type {string} Context entry for the desired datetime.\n * @deprecated Import this constant from @comunica/context-entries.\n */\n\nexports.KEY_CONTEXT_DATETIME = context_entries_1.KeysHttpMemento.datetime;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-http-memento/lib/ActorHttpMemento.js"],"names":["Object","defineProperty","exports","value","KEY_CONTEXT_DATETIME","ActorHttpMemento","bus_http_1","require","context_entries_1","parseLink","ActorHttp","constructor","args","test","action","_a","context","has","KeysHttpMemento","datetime","get","Date","Error","init","Headers","headers","run","assign","append","toUTCString","httpAction","input","result","mediatorHttp","mediate","links","timegate","body","cancel","followLink","url"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KEY_CONTEXT_DATETIME = exports.ActorHttpMemento = void 0;\nconst bus_http_1 = require(\"@comunica/bus-http\");\nconst context_entries_1 = require(\"@comunica/context-entries\");\nrequire(\"cross-fetch/polyfill\");\nconst parseLink = require(\"parse-link-header\");\n/**\n * A comunica Memento Http Actor.\n */\nclass ActorHttpMemento extends bus_http_1.ActorHttp {\n    constructor(args) {\n        super(args);\n    }\n    async test(action) {\n        var _a;\n        if (!(action.context && action.context.has(context_entries_1.KeysHttpMemento.datetime) &&\n            action.context.get(context_entries_1.KeysHttpMemento.datetime) instanceof Date)) {\n            throw new Error('This actor only handles request with a set valid datetime.');\n        }\n        if (action.init && new Headers((_a = action.init.headers) !== null && _a !== void 0 ? _a : {}).has('accept-datetime')) {\n            throw new Error('The request already has a set datetime.');\n        }\n        return true;\n    }\n    async run(action) {\n        var _a;\n        // Duplicate the ActionHttp to append a datetime header to the request.\n        const init = action.init ? Object.assign({}, action.init) : {};\n        const headers = init.headers = new Headers((_a = init.headers) !== null && _a !== void 0 ? _a : {});\n        if (action.context && action.context.has(context_entries_1.KeysHttpMemento.datetime)) {\n            headers.append('accept-datetime', action.context.get(context_entries_1.KeysHttpMemento.datetime).toUTCString());\n        }\n        const httpAction = { context: action.context, input: action.input, init };\n        // Execute the request and follow the timegate in the response (if any).\n        const result = await this.mediatorHttp.mediate(httpAction);\n        // Did we ask for a time-negotiated response, but haven't received one?\n        if (headers.has('accept-datetime') && result.headers && !result.headers.has('memento-datetime')) {\n            // The links might have a timegate that can help us\n            const links = result.headers.has('link') && parseLink(result.headers.get('link'));\n            if (links && links.timegate) {\n                if (result.body) {\n                    await result.body.cancel();\n                }\n                // Respond with a time-negotiated response from the timegate instead\n                const followLink = { context: action.context, input: links.timegate.url, init };\n                return this.mediatorHttp.mediate(followLink);\n            }\n        }\n        return result;\n    }\n}\nexports.ActorHttpMemento = ActorHttpMemento;\n/**\n * @type {string} Context entry for the desired datetime.\n * @deprecated Import this constant from @comunica/context-entries.\n */\nexports.KEY_CONTEXT_DATETIME = context_entries_1.KeysHttpMemento.datetime;\n//# sourceMappingURL=ActorHttpMemento.js.map"]},"metadata":{},"sourceType":"script"}