{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RdfJsQuadDestination = void 0;\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * A quad destination that wraps around an {@link RDF.Store}.\n */\n\nclass RdfJsQuadDestination {\n  constructor(store) {\n    this.store = store;\n  }\n\n  promisifyEventEmitter(eventEmitter) {\n    return new Promise((resolve, reject) => {\n      eventEmitter.on('end', resolve);\n      eventEmitter.on('error', reject);\n    });\n  }\n\n  delete(quads) {\n    return this.promisifyEventEmitter(this.store.remove(quads));\n  }\n\n  insert(quads) {\n    return this.promisifyEventEmitter(this.store.import(quads));\n  }\n\n  async deleteGraphs(graphs, requireExistence, dropGraphs) {\n    switch (graphs) {\n      case 'ALL':\n        // Remove the default graph\n        await this.promisifyEventEmitter(this.store.deleteGraph(DF.defaultGraph()));\n      // Drop through to remove all named graphs\n      // eslint-disable-next-line no-fallthrough\n\n      case 'NAMED':\n        // Warning: this is sub-optimal!\n        // Query ALL quads to determine all named graphs\n        const allQuads = this.store.match();\n        const namedGraphs = {};\n        allQuads.on('data', quad => {\n          if (quad.graph.termType !== 'DefaultGraph') {\n            namedGraphs[rdf_string_1.termToString(quad.graph)] = true;\n          }\n        });\n        await this.promisifyEventEmitter(allQuads); // Delete all named graphs\n\n        await Promise.all(Object.keys(namedGraphs).map(namedGraph => this.promisifyEventEmitter(this.store.deleteGraph(rdf_string_1.stringToTerm(namedGraph)))));\n        break;\n\n      default:\n        // Delete the default graph or a named graph\n        for (const graph of Array.isArray(graphs) ? graphs : [graphs]) {\n          await this.promisifyEventEmitter(this.store.deleteGraph(graph));\n        }\n\n    }\n  }\n\n  async createGraphs(graphs, requireNonExistence) {\n    // We don't have to create anything, since RDF/JS stores don't record empty graphs.\n    // The only check we have to do is error on existence\n    if (requireNonExistence) {\n      for (const graph of graphs) {\n        const eventEmitter = this.store.match(undefined, undefined, undefined, graph);\n        await new Promise((resolve, reject) => {\n          eventEmitter.once('data', () => {\n            reject(new Error(`Unable to create graph ${graph.value} as it already exists`));\n          });\n          eventEmitter.on('end', resolve);\n          eventEmitter.on('error', reject);\n        });\n      }\n    }\n  }\n\n}\n\nexports.RdfJsQuadDestination = RdfJsQuadDestination;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-rdf-update-quads-rdfjs-store/lib/RdfJsQuadDestination.js"],"names":["Object","defineProperty","exports","value","RdfJsQuadDestination","rdf_data_factory_1","require","rdf_string_1","DF","DataFactory","constructor","store","promisifyEventEmitter","eventEmitter","Promise","resolve","reject","on","delete","quads","remove","insert","import","deleteGraphs","graphs","requireExistence","dropGraphs","deleteGraph","defaultGraph","allQuads","match","namedGraphs","quad","graph","termType","termToString","all","keys","map","namedGraph","stringToTerm","Array","isArray","createGraphs","requireNonExistence","undefined","once","Error"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RdfJsQuadDestination = void 0;\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * A quad destination that wraps around an {@link RDF.Store}.\n */\nclass RdfJsQuadDestination {\n    constructor(store) {\n        this.store = store;\n    }\n    promisifyEventEmitter(eventEmitter) {\n        return new Promise((resolve, reject) => {\n            eventEmitter.on('end', resolve);\n            eventEmitter.on('error', reject);\n        });\n    }\n    delete(quads) {\n        return this.promisifyEventEmitter(this.store.remove(quads));\n    }\n    insert(quads) {\n        return this.promisifyEventEmitter(this.store.import(quads));\n    }\n    async deleteGraphs(graphs, requireExistence, dropGraphs) {\n        switch (graphs) {\n            case 'ALL':\n                // Remove the default graph\n                await this.promisifyEventEmitter(this.store.deleteGraph(DF.defaultGraph()));\n            // Drop through to remove all named graphs\n            // eslint-disable-next-line no-fallthrough\n            case 'NAMED':\n                // Warning: this is sub-optimal!\n                // Query ALL quads to determine all named graphs\n                const allQuads = this.store.match();\n                const namedGraphs = {};\n                allQuads.on('data', (quad) => {\n                    if (quad.graph.termType !== 'DefaultGraph') {\n                        namedGraphs[rdf_string_1.termToString(quad.graph)] = true;\n                    }\n                });\n                await this.promisifyEventEmitter(allQuads);\n                // Delete all named graphs\n                await Promise.all(Object.keys(namedGraphs)\n                    .map(namedGraph => this.promisifyEventEmitter(this.store\n                    .deleteGraph(rdf_string_1.stringToTerm(namedGraph)))));\n                break;\n            default:\n                // Delete the default graph or a named graph\n                for (const graph of Array.isArray(graphs) ? graphs : [graphs]) {\n                    await this.promisifyEventEmitter(this.store.deleteGraph(graph));\n                }\n        }\n    }\n    async createGraphs(graphs, requireNonExistence) {\n        // We don't have to create anything, since RDF/JS stores don't record empty graphs.\n        // The only check we have to do is error on existence\n        if (requireNonExistence) {\n            for (const graph of graphs) {\n                const eventEmitter = this.store.match(undefined, undefined, undefined, graph);\n                await new Promise((resolve, reject) => {\n                    eventEmitter.once('data', () => {\n                        reject(new Error(`Unable to create graph ${graph.value} as it already exists`));\n                    });\n                    eventEmitter.on('end', resolve);\n                    eventEmitter.on('error', reject);\n                });\n            }\n        }\n    }\n}\nexports.RdfJsQuadDestination = RdfJsQuadDestination;\n//# sourceMappingURL=RdfJsQuadDestination.js.map"]},"metadata":{},"sourceType":"script"}