{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorAbstractPath = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst core_1 = require(\"@comunica/core\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * An abstract actor that handles Path operations.\n *\n * Provides multiple helper functions used by the Path operation actors.\n */\n\nclass ActorAbstractPath extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n  constructor(args, predicateType) {\n    super(args, 'path');\n    this.predicateType = predicateType;\n  }\n\n  async testOperation(pattern, context) {\n    if (pattern.predicate.type !== this.predicateType) {\n      throw new Error(`This Actor only supports ${this.predicateType} Path operations.`);\n    }\n\n    return true;\n  } // Generates a variable that does not yet occur in the path\n\n\n  generateVariable(path, name) {\n    if (!name) {\n      return this.generateVariable(path, 'b');\n    } // Path predicates can't contain variables\n\n\n    if (path && (path.subject.value === name || path.object.value === name)) {\n      return this.generateVariable(path, `${name}b`);\n    }\n\n    return DF.variable(name);\n  } // Such connectivity matching does not introduce duplicates (it does not incorporate any count of the number\n  // of ways the connection can be made) even if the repeated path itself would otherwise result in duplicates.\n  // https://www.w3.org/TR/sparql11-query/#propertypaths\n\n\n  async isPathArbitraryLengthDistinct(context, path) {\n    if (!context || !context.get(ActorAbstractPath.isPathArbitraryLengthDistinctKey)) {\n      context = context ? context.set(ActorAbstractPath.isPathArbitraryLengthDistinctKey, true) : core_1.ActionContext({\n        [ActorAbstractPath.isPathArbitraryLengthDistinctKey]: true\n      });\n      return {\n        context,\n        operation: bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n          operation: ActorAbstractPath.FACTORY.createDistinct(path),\n          context\n        }))\n      };\n    }\n\n    context = context.set(ActorAbstractPath.isPathArbitraryLengthDistinctKey, false);\n    return {\n      context,\n      operation: undefined\n    };\n  }\n\n  async predicateStarGraphVariable(subject, object, predicate, graph, context) {\n    // Construct path to obtain all graphs where subject exists\n    const predVar = this.generateVariable(ActorAbstractPath.FACTORY.createPath(subject, predicate, object, graph));\n    const findGraphs = ActorAbstractPath.FACTORY.createUnion(ActorAbstractPath.FACTORY.createPattern(subject, predVar, object, graph), ActorAbstractPath.FACTORY.createPattern(object, predVar, subject, graph));\n    const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n      context,\n      operation: findGraphs\n    }));\n    const objectString = rdf_string_1.termToString(object);\n    const passedGraphs = new Set();\n    return new asynciterator_1.MultiTransformIterator(results.bindingsStream, {\n      multiTransform: bindings => {\n        // Extract the graph and start a predicate* search starting from subject in each graph\n        const graphValue = bindings.get(rdf_string_1.termToString(graph));\n\n        if (passedGraphs.has(rdf_string_1.termToString(graphValue))) {\n          return new asynciterator_1.EmptyIterator();\n        }\n\n        passedGraphs.add(rdf_string_1.termToString(graphValue));\n        return new asynciterator_1.TransformIterator(async () => {\n          const it = new asynciterator_1.BufferedIterator();\n          await this.getObjectsPredicateStar(subject, predicate, graphValue, context, {}, it, {\n            count: 0\n          });\n          return it.transform({\n            transform(item, next, push) {\n              push(bus_query_operation_1.Bindings({\n                [objectString]: item,\n                [rdf_string_1.termToString(graph)]: graphValue\n              }));\n              next();\n            }\n\n          });\n        }, {\n          maxBufferSize: 128\n        });\n      },\n      autoStart: false\n    });\n  }\n  /**\n     * Returns an iterator with Bindings of the query subject predicate* ?o\n     * If graph is a variable, it will also be in those bindings\n     * @param {Term} subject Term of where we start the predicate* search.\n     * @param {Variable} object Variable of the zeroOrMore-query.\n     * @param {Term} objectVal\n     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n     * @param {Term} graph The graph in which we search for the pattern. (Possibly a variable)\n     * @param {ActionContext} context\n     * @return {Promise<AsyncIterator<Bindings>} Iterator to where all bindings of query should have been pushed.\n     */\n\n\n  async getObjectsPredicateStarEval(subject, object, predicate, graph, context) {\n    if (graph.termType === 'Variable') {\n      return this.predicateStarGraphVariable(subject, object, predicate, graph, context);\n    }\n\n    const it = new asynciterator_1.BufferedIterator();\n    await this.getObjectsPredicateStar(subject, predicate, graph, context, {}, it, {\n      count: 0\n    });\n    return it.transform({\n      transform(item, next, push) {\n        push(bus_query_operation_1.Bindings({\n          [rdf_string_1.termToString(object)]: item\n        }));\n        next();\n      }\n\n    });\n  }\n  /**\n     * Pushes all terms to iterator `it` that are a solution of object predicate* ?o.\n     * @param {Term} object Term of where we start the predicate* search.\n     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n     * @param {Term} graph The graph in which we search for the pattern.\n     * @param {ActionContext} context\n     * @param {{[id: string]: Term}} termHashes Remembers the objects we've already searched for.\n     * @param {BufferedIterator<Term>} it Iterator to push terms to.\n     * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).\n     * @return {Promise<void>} All solutions of query should have been pushed to it by then.\n     */\n\n\n  async getObjectsPredicateStar(object, predicate, graph, context, termHashes, it, counter) {\n    const termString = rdf_string_1.termToString(object);\n\n    if (termHashes[termString]) {\n      return;\n    }\n\n    it._push(object);\n\n    termHashes[termString] = object;\n    counter.count++;\n    const thisVariable = this.generateVariable();\n    const vString = rdf_string_1.termToString(thisVariable);\n    const path = ActorAbstractPath.FACTORY.createPath(object, predicate, thisVariable, graph);\n    const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n      operation: path,\n      context\n    }));\n    results.bindingsStream.on('data', async bindings => {\n      const result = bindings.get(vString);\n      await this.getObjectsPredicateStar(result, predicate, graph, context, termHashes, it, counter);\n    });\n    results.bindingsStream.on('end', () => {\n      if (--counter.count === 0) {\n        it.close();\n      }\n    });\n  }\n  /**\n     * Pushes all terms to iterator `it` that are a solution of ?s predicate* ?o.\n     * @param {string} subjectString String representation of subjectVariable\n     * @param {string} objectString String representation of objectVariable\n     * @param {Term} subjectVal Term of where we start the predicate* search.\n     * @param {Term} objectVal Found solution for an object, start for the new step.\n     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n     * @param {Term} graph The graph in which we search for the pattern.\n     * @param {ActionContext} context\n     * @param {{[id: string]: Promise<Term[]>}} termHashesGlobal\n     * Remembers solutions for when objectVal is already been calculated, can be reused when same objectVal occurs\n     * @param {{[id: string]: Term}} termHashesCurrentSubject\n     * Remembers the pairs we've already searched for, can stop searching if so.\n     * @param {BufferedIterator<Bindings>} it Iterator to push terms to.\n     * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).\n     * @return {Promise<void>} All solutions of query should have been pushed to it by then.\n     */\n  // Let the iterator `it` emit all bindings of size 2, with subjectStringVariable as value subjectVal\n  // and objectStringVariable as value all nodes reachable through predicate* beginning at objectVal\n\n\n  async getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, subjectVal, objectVal, predicate, graph, context, termHashesGlobal, termHashesCurrentSubject, it, counter) {\n    const termString = rdf_string_1.termToString(objectVal) + rdf_string_1.termToString(graph); // If this combination of subject and object already done, return nothing\n\n    if (termHashesCurrentSubject[termString]) {\n      return;\n    }\n\n    counter.count++;\n    termHashesCurrentSubject[termString] = true;\n\n    it._push(bus_query_operation_1.Bindings({\n      [subjectString]: subjectVal,\n      [objectString]: objectVal\n    })); // If every reachable node from object has already been calculated, use these for current subject too\n\n\n    if (termString in termHashesGlobal) {\n      const objects = await termHashesGlobal[termString];\n\n      for (const object of objects) {\n        await this.getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, subjectVal, object, predicate, graph, context, termHashesGlobal, termHashesCurrentSubject, it, counter);\n      }\n\n      if (--counter.count === 0) {\n        it.close();\n      }\n\n      return;\n    } // Construct promise to calculate all reachable nodes from this object\n\n\n    const promise = new Promise(async (resolve, reject) => {\n      const objectsArray = []; // Construct path that leads us one step through predicate\n\n      const thisVariable = this.generateVariable();\n      const vString = rdf_string_1.termToString(thisVariable);\n      const path = ActorAbstractPath.FACTORY.createPath(objectVal, predicate, thisVariable, graph);\n      const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n        operation: path,\n        context\n      })); // Recursive call on all neighbours\n\n      results.bindingsStream.on('data', async bindings => {\n        const result = bindings.get(vString);\n        objectsArray.push(result);\n        await this.getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, subjectVal, result, predicate, graph, context, termHashesGlobal, termHashesCurrentSubject, it, counter);\n      });\n      results.bindingsStream.on('error', reject);\n      results.bindingsStream.on('end', () => {\n        if (--counter.count === 0) {\n          it.close();\n        }\n\n        resolve(objectsArray);\n      });\n    }); // Set it in the termHashesGlobal when this object occurs again they can wait for this promise\n\n    termHashesGlobal[termString] = promise;\n  }\n\n}\n\nexports.ActorAbstractPath = ActorAbstractPath;\nActorAbstractPath.FACTORY = new sparqlalgebrajs_1.Factory();\nActorAbstractPath.isPathArbitraryLengthDistinctKey = 'isPathArbitraryLengthDistinct';","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-abstract-path/lib/ActorAbstractPath.js"],"names":["Object","defineProperty","exports","value","ActorAbstractPath","bus_query_operation_1","require","core_1","asynciterator_1","rdf_data_factory_1","rdf_string_1","sparqlalgebrajs_1","DF","DataFactory","ActorQueryOperationTypedMediated","constructor","args","predicateType","testOperation","pattern","context","predicate","type","Error","generateVariable","path","name","subject","object","variable","isPathArbitraryLengthDistinct","get","isPathArbitraryLengthDistinctKey","set","ActionContext","operation","ActorQueryOperation","getSafeBindings","mediatorQueryOperation","mediate","FACTORY","createDistinct","undefined","predicateStarGraphVariable","graph","predVar","createPath","findGraphs","createUnion","createPattern","results","objectString","termToString","passedGraphs","Set","MultiTransformIterator","bindingsStream","multiTransform","bindings","graphValue","has","EmptyIterator","add","TransformIterator","it","BufferedIterator","getObjectsPredicateStar","count","transform","item","next","push","Bindings","maxBufferSize","autoStart","getObjectsPredicateStarEval","termType","termHashes","counter","termString","_push","thisVariable","vString","on","result","close","getSubjectAndObjectBindingsPredicateStar","subjectString","subjectVal","objectVal","termHashesGlobal","termHashesCurrentSubject","objects","promise","Promise","resolve","reject","objectsArray","Factory"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorAbstractPath = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst core_1 = require(\"@comunica/core\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * An abstract actor that handles Path operations.\n *\n * Provides multiple helper functions used by the Path operation actors.\n */\nclass ActorAbstractPath extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n    constructor(args, predicateType) {\n        super(args, 'path');\n        this.predicateType = predicateType;\n    }\n    async testOperation(pattern, context) {\n        if (pattern.predicate.type !== this.predicateType) {\n            throw new Error(`This Actor only supports ${this.predicateType} Path operations.`);\n        }\n        return true;\n    }\n    // Generates a variable that does not yet occur in the path\n    generateVariable(path, name) {\n        if (!name) {\n            return this.generateVariable(path, 'b');\n        }\n        // Path predicates can't contain variables\n        if (path && (path.subject.value === name || path.object.value === name)) {\n            return this.generateVariable(path, `${name}b`);\n        }\n        return DF.variable(name);\n    }\n    // Such connectivity matching does not introduce duplicates (it does not incorporate any count of the number\n    // of ways the connection can be made) even if the repeated path itself would otherwise result in duplicates.\n    // https://www.w3.org/TR/sparql11-query/#propertypaths\n    async isPathArbitraryLengthDistinct(context, path) {\n        if (!context || !context.get(ActorAbstractPath.isPathArbitraryLengthDistinctKey)) {\n            context = context ?\n                context.set(ActorAbstractPath.isPathArbitraryLengthDistinctKey, true) :\n                core_1.ActionContext({ [ActorAbstractPath.isPathArbitraryLengthDistinctKey]: true });\n            return { context,\n                operation: bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n                    operation: ActorAbstractPath.FACTORY.createDistinct(path),\n                    context,\n                })) };\n        }\n        context = context.set(ActorAbstractPath.isPathArbitraryLengthDistinctKey, false);\n        return { context, operation: undefined };\n    }\n    async predicateStarGraphVariable(subject, object, predicate, graph, context) {\n        // Construct path to obtain all graphs where subject exists\n        const predVar = this.generateVariable(ActorAbstractPath.FACTORY.createPath(subject, predicate, object, graph));\n        const findGraphs = ActorAbstractPath.FACTORY.createUnion(ActorAbstractPath.FACTORY.createPattern(subject, predVar, object, graph), ActorAbstractPath.FACTORY.createPattern(object, predVar, subject, graph));\n        const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ context, operation: findGraphs }));\n        const objectString = rdf_string_1.termToString(object);\n        const passedGraphs = new Set();\n        return new asynciterator_1.MultiTransformIterator(results.bindingsStream, {\n            multiTransform: (bindings) => {\n                // Extract the graph and start a predicate* search starting from subject in each graph\n                const graphValue = bindings.get(rdf_string_1.termToString(graph));\n                if (passedGraphs.has(rdf_string_1.termToString(graphValue))) {\n                    return new asynciterator_1.EmptyIterator();\n                }\n                passedGraphs.add(rdf_string_1.termToString(graphValue));\n                return new asynciterator_1.TransformIterator(async () => {\n                    const it = new asynciterator_1.BufferedIterator();\n                    await this.getObjectsPredicateStar(subject, predicate, graphValue, context, {}, it, { count: 0 });\n                    return it.transform({\n                        transform(item, next, push) {\n                            push(bus_query_operation_1.Bindings({ [objectString]: item, [rdf_string_1.termToString(graph)]: graphValue }));\n                            next();\n                        },\n                    });\n                }, { maxBufferSize: 128 });\n            },\n            autoStart: false,\n        });\n    }\n    /**\n       * Returns an iterator with Bindings of the query subject predicate* ?o\n       * If graph is a variable, it will also be in those bindings\n       * @param {Term} subject Term of where we start the predicate* search.\n       * @param {Variable} object Variable of the zeroOrMore-query.\n       * @param {Term} objectVal\n       * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n       * @param {Term} graph The graph in which we search for the pattern. (Possibly a variable)\n       * @param {ActionContext} context\n       * @return {Promise<AsyncIterator<Bindings>} Iterator to where all bindings of query should have been pushed.\n       */\n    async getObjectsPredicateStarEval(subject, object, predicate, graph, context) {\n        if (graph.termType === 'Variable') {\n            return this.predicateStarGraphVariable(subject, object, predicate, graph, context);\n        }\n        const it = new asynciterator_1.BufferedIterator();\n        await this.getObjectsPredicateStar(subject, predicate, graph, context, {}, it, { count: 0 });\n        return it.transform({\n            transform(item, next, push) {\n                push(bus_query_operation_1.Bindings({ [rdf_string_1.termToString(object)]: item }));\n                next();\n            },\n        });\n    }\n    /**\n       * Pushes all terms to iterator `it` that are a solution of object predicate* ?o.\n       * @param {Term} object Term of where we start the predicate* search.\n       * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n       * @param {Term} graph The graph in which we search for the pattern.\n       * @param {ActionContext} context\n       * @param {{[id: string]: Term}} termHashes Remembers the objects we've already searched for.\n       * @param {BufferedIterator<Term>} it Iterator to push terms to.\n       * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).\n       * @return {Promise<void>} All solutions of query should have been pushed to it by then.\n       */\n    async getObjectsPredicateStar(object, predicate, graph, context, termHashes, it, counter) {\n        const termString = rdf_string_1.termToString(object);\n        if (termHashes[termString]) {\n            return;\n        }\n        it._push(object);\n        termHashes[termString] = object;\n        counter.count++;\n        const thisVariable = this.generateVariable();\n        const vString = rdf_string_1.termToString(thisVariable);\n        const path = ActorAbstractPath.FACTORY.createPath(object, predicate, thisVariable, graph);\n        const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: path, context }));\n        results.bindingsStream.on('data', async (bindings) => {\n            const result = bindings.get(vString);\n            await this.getObjectsPredicateStar(result, predicate, graph, context, termHashes, it, counter);\n        });\n        results.bindingsStream.on('end', () => {\n            if (--counter.count === 0) {\n                it.close();\n            }\n        });\n    }\n    /**\n       * Pushes all terms to iterator `it` that are a solution of ?s predicate* ?o.\n       * @param {string} subjectString String representation of subjectVariable\n       * @param {string} objectString String representation of objectVariable\n       * @param {Term} subjectVal Term of where we start the predicate* search.\n       * @param {Term} objectVal Found solution for an object, start for the new step.\n       * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n       * @param {Term} graph The graph in which we search for the pattern.\n       * @param {ActionContext} context\n       * @param {{[id: string]: Promise<Term[]>}} termHashesGlobal\n       * Remembers solutions for when objectVal is already been calculated, can be reused when same objectVal occurs\n       * @param {{[id: string]: Term}} termHashesCurrentSubject\n       * Remembers the pairs we've already searched for, can stop searching if so.\n       * @param {BufferedIterator<Bindings>} it Iterator to push terms to.\n       * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).\n       * @return {Promise<void>} All solutions of query should have been pushed to it by then.\n       */\n    // Let the iterator `it` emit all bindings of size 2, with subjectStringVariable as value subjectVal\n    // and objectStringVariable as value all nodes reachable through predicate* beginning at objectVal\n    async getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, subjectVal, objectVal, predicate, graph, context, termHashesGlobal, termHashesCurrentSubject, it, counter) {\n        const termString = rdf_string_1.termToString(objectVal) + rdf_string_1.termToString(graph);\n        // If this combination of subject and object already done, return nothing\n        if (termHashesCurrentSubject[termString]) {\n            return;\n        }\n        counter.count++;\n        termHashesCurrentSubject[termString] = true;\n        it._push(bus_query_operation_1.Bindings({ [subjectString]: subjectVal, [objectString]: objectVal }));\n        // If every reachable node from object has already been calculated, use these for current subject too\n        if (termString in termHashesGlobal) {\n            const objects = await termHashesGlobal[termString];\n            for (const object of objects) {\n                await this.getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, subjectVal, object, predicate, graph, context, termHashesGlobal, termHashesCurrentSubject, it, counter);\n            }\n            if (--counter.count === 0) {\n                it.close();\n            }\n            return;\n        }\n        // Construct promise to calculate all reachable nodes from this object\n        const promise = new Promise(async (resolve, reject) => {\n            const objectsArray = [];\n            // Construct path that leads us one step through predicate\n            const thisVariable = this.generateVariable();\n            const vString = rdf_string_1.termToString(thisVariable);\n            const path = ActorAbstractPath.FACTORY.createPath(objectVal, predicate, thisVariable, graph);\n            const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: path, context }));\n            // Recursive call on all neighbours\n            results.bindingsStream.on('data', async (bindings) => {\n                const result = bindings.get(vString);\n                objectsArray.push(result);\n                await this.getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, subjectVal, result, predicate, graph, context, termHashesGlobal, termHashesCurrentSubject, it, counter);\n            });\n            results.bindingsStream.on('error', reject);\n            results.bindingsStream.on('end', () => {\n                if (--counter.count === 0) {\n                    it.close();\n                }\n                resolve(objectsArray);\n            });\n        });\n        // Set it in the termHashesGlobal when this object occurs again they can wait for this promise\n        termHashesGlobal[termString] = promise;\n    }\n}\nexports.ActorAbstractPath = ActorAbstractPath;\nActorAbstractPath.FACTORY = new sparqlalgebrajs_1.Factory();\nActorAbstractPath.isPathArbitraryLengthDistinctKey = 'isPathArbitraryLengthDistinct';\n//# sourceMappingURL=ActorAbstractPath.js.map"]},"metadata":{},"sourceType":"script"}