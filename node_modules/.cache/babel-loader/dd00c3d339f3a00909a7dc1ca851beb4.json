{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Util = void 0;\n\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst EntryHandlerContainer_1 = require(\"./entryhandler/EntryHandlerContainer\"); // tslint:disable-next-line:no-var-requires\n\n\nconst canonicalizeJson = require('canonicalize');\n/**\n * Utility functions and methods.\n */\n\n\nclass Util {\n  constructor(options) {\n    this.parsingContext = options.parsingContext;\n    this.dataFactory = options.dataFactory || new rdf_data_factory_1.DataFactory();\n    this.rdfFirst = this.dataFactory.namedNode(Util.RDF + 'first');\n    this.rdfRest = this.dataFactory.namedNode(Util.RDF + 'rest');\n    this.rdfNil = this.dataFactory.namedNode(Util.RDF + 'nil');\n    this.rdfType = this.dataFactory.namedNode(Util.RDF + 'type');\n    this.rdfJson = this.dataFactory.namedNode(Util.RDF + 'JSON');\n  }\n  /**\n   * Helper function to get the value of a context entry,\n   * or fallback to a certain value.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} contextKey A pre-defined JSON-LD key in context entries.\n   * @param {string} key A context entry key.\n   * @param {string} fallback A fallback value for when the given contextKey\n   *                          could not be found in the value with the given key.\n   * @return {string} The value of the given contextKey in the entry behind key in the given context,\n   *                  or the given fallback value.\n   */\n\n\n  static getContextValue(context, contextKey, key, fallback) {\n    const entry = context.getContextRaw()[key];\n\n    if (!entry) {\n      return fallback;\n    }\n\n    const type = entry[contextKey];\n    return type === undefined ? fallback : type;\n  }\n  /**\n   * Get the container type of the given key in the context.\n   *\n   * Should any context-scoping bugs should occur related to this in the future,\n   * it may be required to increase the offset from the depth at which the context is retrieved by one (to 2).\n   * This is because containers act 2 levels deep.\n   *\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {string} The container type.\n   */\n\n\n  static getContextValueContainer(context, key) {\n    return Util.getContextValue(context, '@container', key, {\n      '@set': true\n    });\n  }\n  /**\n   * Get the value type of the given key in the context.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {string} The node type.\n   */\n\n\n  static getContextValueType(context, key) {\n    const valueType = Util.getContextValue(context, '@type', key, null);\n\n    if (valueType === '@none') {\n      return null;\n    }\n\n    return valueType;\n  }\n  /**\n   * Get the language of the given key in the context.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {string} The node type.\n   */\n\n\n  static getContextValueLanguage(context, key) {\n    return Util.getContextValue(context, '@language', key, context.getContextRaw()['@language'] || null);\n  }\n  /**\n   * Get the direction of the given key in the context.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {string} The node type.\n   */\n\n\n  static getContextValueDirection(context, key) {\n    return Util.getContextValue(context, '@direction', key, context.getContextRaw()['@direction'] || null);\n  }\n  /**\n   * Check if the given key in the context is a reversed property.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {boolean} If the context value has a @reverse key.\n   */\n\n\n  static isContextValueReverse(context, key) {\n    return !!Util.getContextValue(context, '@reverse', key, null);\n  }\n  /**\n   * Get the @index of the given key in the context.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key A context entry key.\n   * @return {string} The index.\n   */\n\n\n  static getContextValueIndex(context, key) {\n    return Util.getContextValue(context, '@index', key, context.getContextRaw()['@index'] || null);\n  }\n  /**\n   * Check if the given key refers to a reversed property.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key The property key.\n   * @param {string} parentKey The parent key.\n   * @return {boolean} If the property must be reversed.\n   */\n\n\n  static isPropertyReverse(context, key, parentKey) {\n    // '!==' is needed because reversed properties in a @reverse container should cancel each other out.\n    return parentKey === '@reverse' !== Util.isContextValueReverse(context, key);\n  }\n  /**\n   * Check if the given IRI is valid.\n   * @param {string} iri A potential IRI.\n   * @return {boolean} If the given IRI is valid.\n   */\n\n\n  static isValidIri(iri) {\n    return iri !== null && jsonld_context_parser_1.Util.isValidIri(iri);\n  }\n  /**\n   * Check if the given first array (needle) is a prefix of the given second array (haystack).\n   * @param needle An array to check if it is a prefix.\n   * @param haystack An array to look in.\n   */\n\n\n  static isPrefixArray(needle, haystack) {\n    if (needle.length > haystack.length) {\n      return false;\n    }\n\n    for (let i = 0; i < needle.length; i++) {\n      if (needle[i] !== haystack[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Make sure that @id-@index pairs are equal over all array values.\n   * Reject otherwise.\n   * @param {any[]} value An array value.\n   * @return {Promise<void>} A promise rejecting if conflicts are present.\n   */\n\n\n  async validateValueIndexes(value) {\n    if (this.parsingContext.validateValueIndexes) {\n      const indexHashes = {};\n\n      for (const entry of value) {\n        if (entry && typeof entry === 'object') {\n          const id = entry['@id'];\n          const index = entry['@index'];\n\n          if (id && index) {\n            const existingIndexValue = indexHashes[id];\n\n            if (existingIndexValue && existingIndexValue !== index) {\n              throw new jsonld_context_parser_1.ErrorCoded(`Conflicting @index value for ${id}`, jsonld_context_parser_1.ERROR_CODES.CONFLICTING_INDEXES);\n            }\n\n            indexHashes[id] = index;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Convert a given JSON value to an RDF term.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key The current JSON key.\n   * @param value A JSON value.\n   * @param {number} depth The depth the value is at.\n   * @param {string[]} keys The path of keys.\n   * @return {Promise<RDF.Term[]>} An RDF term array.\n   */\n\n\n  async valueToTerm(context, key, value, depth, keys) {\n    // Skip further processing if we have an @type: @json\n    if (Util.getContextValueType(context, key) === '@json') {\n      return [this.dataFactory.literal(this.valueToJsonString(value), this.rdfJson)];\n    }\n\n    const type = typeof value;\n\n    switch (type) {\n      case 'object':\n        // Skip if we have a null or undefined object\n        if (value === null || value === undefined) {\n          return [];\n        } // Special case for arrays\n\n\n        if (Array.isArray(value)) {\n          // We handle arrays at value level so we can emit earlier, so this is handled already when we get here.\n          // Empty context-based lists are emitted at this place, because our streaming algorithm doesn't detect those.\n          if ('@list' in Util.getContextValueContainer(context, key)) {\n            if (value.length === 0) {\n              return [this.rdfNil];\n            } else {\n              return this.parsingContext.idStack[depth + 1] || [];\n            }\n          }\n\n          await this.validateValueIndexes(value);\n          return [];\n        } // Handle property-scoped contexts\n\n\n        context = await this.getContextSelfOrPropertyScoped(context, key); // Handle local context in the value\n\n        if ('@context' in value) {\n          context = await this.parsingContext.parseContext(value['@context'], (await this.parsingContext.getContext(keys, 0)).getContextRaw());\n        } // In all other cases, we have a hash\n\n\n        value = await this.unaliasKeywords(value, keys, depth, context); // Un-alias potential keywords in this hash\n\n        if ('@value' in value) {\n          let val;\n          let valueLanguage;\n          let valueDirection;\n          let valueType;\n          let valueIndex; // We don't use the index, but we need to check its type for spec-compliance\n\n          for (key in value) {\n            const subValue = value[key];\n\n            switch (key) {\n              case '@value':\n                val = subValue;\n                break;\n\n              case '@language':\n                valueLanguage = subValue;\n                break;\n\n              case '@direction':\n                valueDirection = subValue;\n                break;\n\n              case '@type':\n                valueType = subValue;\n                break;\n\n              case '@index':\n                valueIndex = subValue;\n                break;\n\n              default:\n                throw new jsonld_context_parser_1.ErrorCoded(`Unknown value entry '${key}' in @value: ${JSON.stringify(value)}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n            }\n          } // Skip further processing if we have an @type: @json\n\n\n          if ((await this.unaliasKeyword(valueType, keys, depth, true, context)) === '@json') {\n            return [this.dataFactory.literal(this.valueToJsonString(val), this.rdfJson)];\n          } // Validate @value\n\n\n          if (val === null) {\n            return [];\n          }\n\n          if (typeof val === 'object') {\n            throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@value' can not be an object, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT_VALUE);\n          } // Validate @index\n\n\n          if (this.parsingContext.validateValueIndexes && valueIndex && typeof valueIndex !== 'string') {\n            throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@index' must be a string, got '${JSON.stringify(valueIndex)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INDEX_VALUE);\n          } // Validate @language and @direction\n\n\n          if (valueLanguage) {\n            if (typeof val !== 'string') {\n              throw new jsonld_context_parser_1.ErrorCoded(`When an '@language' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_VALUE);\n            }\n\n            if (!jsonld_context_parser_1.ContextParser.validateLanguage(valueLanguage, this.parsingContext.strictValues, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_STRING)) {\n              return [];\n            } // Language tags are always normalized to lowercase in 1.0.\n\n\n            if (this.parsingContext.normalizeLanguageTags || this.parsingContext.activeProcessingMode === 1.0) {\n              valueLanguage = valueLanguage.toLowerCase();\n            }\n          }\n\n          if (valueDirection) {\n            if (typeof val !== 'string') {\n              throw new Error(`When an '@direction' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`);\n            }\n\n            if (!jsonld_context_parser_1.ContextParser.validateDirection(valueDirection, this.parsingContext.strictValues)) {\n              return [];\n            }\n          } // Check @language and @direction\n\n\n          if (valueLanguage && valueDirection && this.parsingContext.rdfDirection) {\n            if (valueType) {\n              throw new jsonld_context_parser_1.ErrorCoded(`Can not have '@language', '@direction' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n            }\n\n            return this.nullableTermToArray(this.createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));\n          } else if (valueLanguage) {\n            // Check @language\n            if (valueType) {\n              throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@language' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n            }\n\n            return [this.dataFactory.literal(val, valueLanguage)];\n          } else if (valueDirection && this.parsingContext.rdfDirection) {\n            // Check @direction\n            if (valueType) {\n              throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@direction' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n            }\n\n            return this.nullableTermToArray(this.createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));\n          } else if (valueType) {\n            // Validate @type\n            if (typeof valueType !== 'string') {\n              throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n            }\n\n            const typeTerm = this.createVocabOrBaseTerm(context, valueType);\n\n            if (!typeTerm) {\n              throw new jsonld_context_parser_1.ErrorCoded(`Invalid '@type' value, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n            }\n\n            if (typeTerm.termType !== 'NamedNode') {\n              throw new jsonld_context_parser_1.ErrorCoded(`Illegal value type (${typeTerm.termType}): ${valueType}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n            }\n\n            return [this.dataFactory.literal(val, typeTerm)];\n          } // We don't pass the context, because context-based things like @language should be ignored\n\n\n          return await this.valueToTerm(new jsonld_context_parser_1.JsonLdContextNormalized({}), key, val, depth, keys);\n        } else if ('@set' in value) {\n          // No other entries are allow in this value\n          if (Object.keys(value).length > 1) {\n            throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @set for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);\n          } // No need to do anything here, this is handled at the deeper level.\n\n\n          return [];\n        } else if ('@list' in value) {\n          // No other entries are allowed in this value\n          if (Object.keys(value).length > 1) {\n            throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);\n          }\n\n          const listValue = value[\"@list\"]; // We handle lists at value level so we can emit earlier, so this is handled already when we get here.\n          // Empty anonymous lists are emitted at this place, because our streaming algorithm doesn't detect those.\n\n          if (Array.isArray(listValue)) {\n            if (listValue.length === 0) {\n              return [this.rdfNil];\n            } else {\n              return this.parsingContext.idStack[depth + 1] || [];\n            }\n          } else {\n            // We only have a single list element here, so emit this directly as single element\n            return await this.valueToTerm(await this.parsingContext.getContext(keys), key, listValue, depth - 1, keys.slice(0, -1));\n          }\n        } else if ('@reverse' in value && typeof value['@reverse'] === 'boolean') {\n          // We handle reverse properties at value level so we can emit earlier,\n          // so this is handled already when we get here.\n          return [];\n        } else if ('@graph' in Util.getContextValueContainer(await this.parsingContext.getContext(keys), key)) {\n          // We are processing a graph container\n          const graphContainerEntries = this.parsingContext.graphContainerTermStack[depth + 1];\n          return graphContainerEntries ? Object.values(graphContainerEntries) : [this.dataFactory.blankNode()];\n        } else if (\"@id\" in value) {\n          // Use deeper context if the value node contains other properties next to @id.\n          if (Object.keys(value).length > 1) {\n            context = await this.parsingContext.getContext(keys, 0);\n          } // Handle local context in the value\n\n\n          if ('@context' in value) {\n            context = await this.parsingContext.parseContext(value['@context'], context.getContextRaw());\n          }\n\n          if (value[\"@type\"] === '@vocab') {\n            return this.nullableTermToArray(this.createVocabOrBaseTerm(context, value[\"@id\"]));\n          } else {\n            return this.nullableTermToArray(this.resourceToTerm(context, value[\"@id\"]));\n          }\n        } else {\n          // Only make a blank node if at least one triple was emitted at the value's level.\n          if (this.parsingContext.emittedStack[depth + 1] || value && typeof value === 'object' && Object.keys(value).length === 0) {\n            return this.parsingContext.idStack[depth + 1] || (this.parsingContext.idStack[depth + 1] = [this.dataFactory.blankNode()]);\n          } else {\n            return [];\n          }\n        }\n\n      case 'string':\n        return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, null));\n\n      case 'boolean':\n        return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, Boolean(value).toString(), this.dataFactory.namedNode(Util.XSD_BOOLEAN)));\n\n      case 'number':\n        return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, this.dataFactory.namedNode(value % 1 === 0 && value < 1e21 ? Util.XSD_INTEGER : Util.XSD_DOUBLE)));\n\n      default:\n        this.parsingContext.emitError(new Error(`Could not determine the RDF type of a ${type}`));\n        return [];\n    }\n  }\n  /**\n   * If the context defines a property-scoped context for the given key,\n   * that context will be returned.\n   * Otherwise, the given context will be returned as-is.\n   *\n   * This should be used for valueToTerm cases that are not objects.\n   * @param context A context.\n   * @param key A JSON key.\n   */\n\n\n  async getContextSelfOrPropertyScoped(context, key) {\n    const contextKeyEntry = context.getContextRaw()[key];\n\n    if (contextKeyEntry && typeof contextKeyEntry === 'object' && '@context' in contextKeyEntry) {\n      context = await this.parsingContext.parseContext(contextKeyEntry, context.getContextRaw(), true);\n    }\n\n    return context;\n  }\n  /**\n   * If the given term is null, return an empty array, otherwise return an array with the single given term.\n   * @param term A term.\n   */\n\n\n  nullableTermToArray(term) {\n    return term ? [term] : [];\n  }\n  /**\n   * Convert a given JSON key to an RDF predicate term,\n   * based on @vocab.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param key A JSON key.\n   * @return {RDF.NamedNode} An RDF named node.\n   */\n\n\n  predicateToTerm(context, key) {\n    const expanded = context.expandTerm(key, true, this.parsingContext.getExpandOptions()); // Immediately return if the predicate was disabled in the context\n\n    if (!expanded) {\n      return null;\n    } // Check if the predicate is a blank node\n\n\n    if (expanded[0] === '_' && expanded[1] === ':') {\n      if (this.parsingContext.produceGeneralizedRdf) {\n        return this.dataFactory.blankNode(expanded.substr(2));\n      } else {\n        return null;\n      }\n    } // Check if the predicate is a valid IRI\n\n\n    if (Util.isValidIri(expanded)) {\n      return this.dataFactory.namedNode(expanded);\n    } else {\n      if (expanded && this.parsingContext.strictValues) {\n        this.parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid predicate IRI: ${expanded}`, jsonld_context_parser_1.ERROR_CODES.INVALID_IRI_MAPPING));\n      } else {\n        return null;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Convert a given JSON key to an RDF resource term or blank node,\n   * based on @base.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param key A JSON key.\n   * @return {RDF.NamedNode} An RDF named node or null.\n   */\n\n\n  resourceToTerm(context, key) {\n    if (key.startsWith('_:')) {\n      return this.dataFactory.blankNode(key.substr(2));\n    }\n\n    const iri = context.expandTerm(key, false, this.parsingContext.getExpandOptions());\n\n    if (!Util.isValidIri(iri)) {\n      if (iri && this.parsingContext.strictValues) {\n        this.parsingContext.emitError(new Error(`Invalid resource IRI: ${iri}`));\n      } else {\n        return null;\n      }\n    }\n\n    return this.dataFactory.namedNode(iri);\n  }\n  /**\n   * Convert a given JSON key to an RDF resource term.\n   * It will do this based on the @vocab,\n   * and fallback to @base.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param key A JSON key.\n   * @return {RDF.NamedNode} An RDF named node or null.\n   */\n\n\n  createVocabOrBaseTerm(context, key) {\n    if (key.startsWith('_:')) {\n      return this.dataFactory.blankNode(key.substr(2));\n    }\n\n    const expandOptions = this.parsingContext.getExpandOptions();\n    let expanded = context.expandTerm(key, true, expandOptions);\n\n    if (expanded === key) {\n      expanded = context.expandTerm(key, false, expandOptions);\n    }\n\n    if (!Util.isValidIri(expanded)) {\n      if (expanded && this.parsingContext.strictValues) {\n        this.parsingContext.emitError(new Error(`Invalid term IRI: ${expanded}`));\n      } else {\n        return null;\n      }\n    }\n\n    return this.dataFactory.namedNode(expanded);\n  }\n  /**\n   * Ensure that the given value becomes a string.\n   * @param {string | number} value A string or number.\n   * @param {NamedNode} datatype The intended datatype.\n   * @return {string} The returned string.\n   */\n\n\n  intToString(value, datatype) {\n    if (typeof value === 'number') {\n      if (Number.isFinite(value)) {\n        const isInteger = value % 1 === 0;\n\n        if (isInteger && (!datatype || datatype.value !== Util.XSD_DOUBLE)) {\n          return Number(value).toString();\n        } else {\n          return value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n        }\n      } else {\n        return value > 0 ? 'INF' : '-INF';\n      }\n    } else {\n      return value;\n    }\n  }\n  /**\n   * Convert a given JSON string value to an RDF term.\n   * @param {number} depth The current stack depth.\n   * @param {JsonLdContextNormalized} context A JSON-LD context.\n   * @param {string} key The current JSON key.\n   * @param {string} value A JSON value.\n   * @param {NamedNode} defaultDatatype The default datatype for the given value.\n   * @return {RDF.Term} An RDF term or null.\n   */\n\n\n  stringValueToTerm(depth, context, key, value, defaultDatatype) {\n    // Check the datatype from the context\n    const contextType = Util.getContextValueType(context, key);\n\n    if (contextType) {\n      if (contextType === '@id') {\n        if (!defaultDatatype) {\n          return this.resourceToTerm(context, this.intToString(value, defaultDatatype));\n        }\n      } else if (contextType === '@vocab') {\n        if (!defaultDatatype) {\n          return this.createVocabOrBaseTerm(context, this.intToString(value, defaultDatatype));\n        }\n      } else {\n        defaultDatatype = this.dataFactory.namedNode(contextType);\n      }\n    } // If we don't find such a datatype, check the language from the context\n\n\n    if (!defaultDatatype) {\n      const contextLanguage = Util.getContextValueLanguage(context, key);\n      const contextDirection = Util.getContextValueDirection(context, key);\n\n      if (contextDirection && this.parsingContext.rdfDirection) {\n        return this.createLanguageDirectionLiteral(depth, this.intToString(value, defaultDatatype), contextLanguage, contextDirection);\n      } else {\n        return this.dataFactory.literal(this.intToString(value, defaultDatatype), contextLanguage);\n      }\n    } // If all else fails, make a literal based on the default content type\n\n\n    return this.dataFactory.literal(this.intToString(value, defaultDatatype), defaultDatatype);\n  }\n  /**\n   * Create a literal for the given value with the given language and direction.\n   * Auxiliary quads may be emitted.\n   * @param {number} depth The current stack depth.\n   * @param {string} value A string value.\n   * @param {string} language A language tag.\n   * @param {string} direction A direction.\n   * @return {Term} An RDF term.\n   */\n\n\n  createLanguageDirectionLiteral(depth, value, language, direction) {\n    if (this.parsingContext.rdfDirection === 'i18n-datatype') {\n      // Create a datatyped literal, by encoding the language and direction into https://www.w3.org/ns/i18n#.\n      if (!language) {\n        language = '';\n      }\n\n      return this.dataFactory.literal(value, this.dataFactory.namedNode(`https://www.w3.org/ns/i18n#${language}_${direction}`));\n    } else {\n      // Reify the literal.\n      const valueNode = this.dataFactory.blankNode();\n      const graph = this.getDefaultGraph();\n      this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'value'), this.dataFactory.literal(value), graph));\n\n      if (language) {\n        this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'language'), this.dataFactory.literal(language), graph));\n      }\n\n      this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'direction'), this.dataFactory.literal(direction), graph));\n      return valueNode;\n    }\n  }\n  /**\n   * Stringify the given JSON object to a canonical JSON string.\n   * @param value Any valid JSON value.\n   * @return {string} A canonical JSON string.\n   */\n\n\n  valueToJsonString(value) {\n    return canonicalizeJson(value);\n  }\n  /**\n   * If the key is not a keyword, try to check if it is an alias for a keyword,\n   * and if so, un-alias it.\n   * @param {string} key A key, can be falsy.\n   * @param {string[]} keys The path of keys.\n   * @param {number} depth The depth to\n   * @param {boolean} disableCache If the cache should be disabled\n   * @param {JsonLdContextNormalized} context A context to unalias with,\n   *                                           will fallback to retrieving the context for the given keys.\n   * @return {Promise<string>} A promise resolving to the key itself, or another key.\n   */\n\n\n  async unaliasKeyword(key, keys, depth, disableCache, context) {\n    // Numbers can not be an alias\n    if (Number.isInteger(key)) {\n      return key;\n    } // Try to grab from cache if it was already un-aliased before.\n\n\n    if (!disableCache) {\n      const cachedUnaliasedKeyword = this.parsingContext.unaliasedKeywordCacheStack[depth];\n\n      if (cachedUnaliasedKeyword) {\n        return cachedUnaliasedKeyword;\n      }\n    }\n\n    if (!jsonld_context_parser_1.Util.isPotentialKeyword(key)) {\n      context = context || (await this.parsingContext.getContext(keys));\n      let unliased = context.getContextRaw()[key];\n\n      if (unliased && typeof unliased === 'object') {\n        unliased = unliased['@id'];\n      }\n\n      if (jsonld_context_parser_1.Util.isValidKeyword(unliased)) {\n        key = unliased;\n      }\n    }\n\n    return disableCache ? key : this.parsingContext.unaliasedKeywordCacheStack[depth] = key;\n  }\n  /**\n   * Unalias the keyword of the parent.\n   * This adds a safety check if no parent exist.\n   * @param {any[]} keys A stack of keys.\n   * @param {number} depth The current depth.\n   * @return {Promise<any>} A promise resolving to the parent key, or another key.\n   */\n\n\n  async unaliasKeywordParent(keys, depth) {\n    return await this.unaliasKeyword(depth > 0 && keys[depth - 1], keys, depth - 1);\n  }\n  /**\n   * Un-alias all keywords in the given hash.\n   * @param {{[p: string]: any}} hash A hash object.\n   * @param {string[]} keys The path of keys.\n   * @param {number} depth The depth.\n   * @param {JsonLdContextNormalized} context A context to unalias with,\n   *                                           will fallback to retrieving the context for the given keys.\n   * @return {Promise<{[p: string]: any}>} A promise resolving to the new hash.\n   */\n\n\n  async unaliasKeywords(hash, keys, depth, context) {\n    const newHash = {};\n\n    for (const key in hash) {\n      newHash[await this.unaliasKeyword(key, keys, depth + 1, true, context)] = hash[key];\n    }\n\n    return newHash;\n  }\n  /**\n   * Check if we are processing a literal (including JSON literals) at the given depth.\n   * This will also check higher levels,\n   * because if a parent is a literal,\n   * then the deeper levels are definitely a literal as well.\n   * @param {number} depth The depth.\n   * @return {boolean} If we are processing a literal.\n   */\n\n\n  isLiteral(depth) {\n    for (let i = depth; i >= 0; i--) {\n      if (this.parsingContext.literalStack[i] || this.parsingContext.jsonLiteralStack[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Check how many parents should be skipped for checking the @graph for the given node.\n   *\n   * @param {number} depth The depth of the node.\n   * @param {any[]} keys An array of keys.\n   * @return {number} The graph depth offset.\n   */\n\n\n  async getDepthOffsetGraph(depth, keys) {\n    for (let i = depth - 1; i > 0; i--) {\n      if ((await this.unaliasKeyword(keys[i], keys, i)) === '@graph') {\n        // Skip further processing if we are already in an @graph-@id or @graph-@index container\n        const containers = (await EntryHandlerContainer_1.EntryHandlerContainer.getContainerHandler(this.parsingContext, keys, i)).containers;\n\n        if (EntryHandlerContainer_1.EntryHandlerContainer.isComplexGraphContainer(containers)) {\n          return -1;\n        }\n\n        return depth - i - 1;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Check if the given subject is of a valid type.\n   * This should be called when applying @reverse'd properties.\n   * @param {Term} subject A subject.\n   */\n\n\n  validateReverseSubject(subject) {\n    if (subject.termType === 'Literal') {\n      throw new jsonld_context_parser_1.ErrorCoded(`Found illegal literal in subject position: ${subject.value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n    }\n  }\n  /**\n   * Get the default graph.\n   * @return {Term} An RDF term.\n   */\n\n\n  getDefaultGraph() {\n    return this.parsingContext.defaultGraph || this.dataFactory.defaultGraph();\n  }\n  /**\n   * Get the current graph, while taking into account a graph that can be defined via @container: @graph.\n   * If not within a graph container, the default graph will be returned.\n   * @param keys The current keys.\n   * @param depth The current depth.\n   */\n\n\n  async getGraphContainerValue(keys, depth) {\n    // Default to default graph\n    let graph = this.getDefaultGraph(); // Check if we are in an @container: @graph.\n\n    const {\n      containers,\n      depth: depthContainer\n    } = await EntryHandlerContainer_1.EntryHandlerContainer.getContainerHandler(this.parsingContext, keys, depth);\n\n    if ('@graph' in containers) {\n      // Get the graph from the stack.\n      const graphContainerIndex = EntryHandlerContainer_1.EntryHandlerContainer.getContainerGraphIndex(containers, depthContainer, keys);\n      const entry = this.parsingContext.graphContainerTermStack[depthContainer];\n      graph = entry ? entry[graphContainerIndex] : null; // Set the graph in the stack if none has been set yet.\n\n      if (!graph) {\n        let graphId = null;\n\n        if ('@id' in containers) {\n          const keyUnaliased = await this.getContainerKey(keys[depthContainer], keys, depthContainer);\n\n          if (keyUnaliased !== null) {\n            graphId = await this.resourceToTerm(await this.parsingContext.getContext(keys), keyUnaliased);\n          }\n        }\n\n        if (!graphId) {\n          graphId = this.dataFactory.blankNode();\n        }\n\n        if (!this.parsingContext.graphContainerTermStack[depthContainer]) {\n          this.parsingContext.graphContainerTermStack[depthContainer] = {};\n        }\n\n        graph = this.parsingContext.graphContainerTermStack[depthContainer][graphContainerIndex] = graphId;\n      }\n    }\n\n    return graph;\n  }\n  /**\n   * Get the properties depth for retrieving properties.\n   *\n   * Typically, the properties depth will be identical to the given depth.\n   *\n   * The following exceptions apply:\n   * * When the parent is @reverse, the depth is decremented by one.\n   * * When @nest parents are found, the depth is decremented by the number of @nest parents.\n   * If in combination with the exceptions above an intermediary array is discovered,\n   * the depth is also decremented by this number of arrays.\n   *\n   * @param keys The current key chain.\n   * @param depth The current depth.\n   */\n\n\n  async getPropertiesDepth(keys, depth) {\n    let lastValidDepth = depth;\n\n    for (let i = depth - 1; i > 0; i--) {\n      if (typeof keys[i] !== 'number') {\n        // Skip array keys\n        const parentKey = await this.unaliasKeyword(keys[i], keys, i);\n\n        if (parentKey === '@reverse') {\n          return i;\n        } else if (parentKey === '@nest') {\n          lastValidDepth = i;\n        } else {\n          return lastValidDepth;\n        }\n      }\n    }\n\n    return lastValidDepth;\n  }\n  /**\n   * Get the key for the current container entry.\n   * @param key A key, can be falsy.\n   * @param keys The key chain.\n   * @param depth The current depth to get the key from.\n   * @return Promise resolving to the key.\n   *         Null will be returned for @none entries, with aliasing taken into account.\n   */\n\n\n  async getContainerKey(key, keys, depth) {\n    const keyUnaliased = await this.unaliasKeyword(key, keys, depth);\n    return keyUnaliased === '@none' ? null : keyUnaliased;\n  }\n\n}\n\nexports.Util = Util;\nUtil.XSD = 'http://www.w3.org/2001/XMLSchema#';\nUtil.XSD_BOOLEAN = Util.XSD + 'boolean';\nUtil.XSD_INTEGER = Util.XSD + 'integer';\nUtil.XSD_DOUBLE = Util.XSD + 'double';\nUtil.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-parser/lib/Util.js"],"names":["Object","defineProperty","exports","value","Util","jsonld_context_parser_1","require","rdf_data_factory_1","EntryHandlerContainer_1","canonicalizeJson","constructor","options","parsingContext","dataFactory","DataFactory","rdfFirst","namedNode","RDF","rdfRest","rdfNil","rdfType","rdfJson","getContextValue","context","contextKey","key","fallback","entry","getContextRaw","type","undefined","getContextValueContainer","getContextValueType","valueType","getContextValueLanguage","getContextValueDirection","isContextValueReverse","getContextValueIndex","isPropertyReverse","parentKey","isValidIri","iri","isPrefixArray","needle","haystack","length","i","validateValueIndexes","indexHashes","id","index","existingIndexValue","ErrorCoded","ERROR_CODES","CONFLICTING_INDEXES","valueToTerm","depth","keys","literal","valueToJsonString","Array","isArray","idStack","getContextSelfOrPropertyScoped","parseContext","getContext","unaliasKeywords","val","valueLanguage","valueDirection","valueIndex","subValue","JSON","stringify","INVALID_VALUE_OBJECT","unaliasKeyword","INVALID_VALUE_OBJECT_VALUE","INVALID_INDEX_VALUE","INVALID_LANGUAGE_TAGGED_VALUE","ContextParser","validateLanguage","strictValues","INVALID_LANGUAGE_TAGGED_STRING","normalizeLanguageTags","activeProcessingMode","toLowerCase","Error","validateDirection","rdfDirection","nullableTermToArray","createLanguageDirectionLiteral","INVALID_TYPED_VALUE","typeTerm","createVocabOrBaseTerm","termType","JsonLdContextNormalized","INVALID_SET_OR_LIST_OBJECT","listValue","slice","graphContainerEntries","graphContainerTermStack","values","blankNode","resourceToTerm","emittedStack","stringValueToTerm","Boolean","toString","XSD_BOOLEAN","XSD_INTEGER","XSD_DOUBLE","emitError","contextKeyEntry","term","predicateToTerm","expanded","expandTerm","getExpandOptions","produceGeneralizedRdf","substr","INVALID_IRI_MAPPING","startsWith","expandOptions","intToString","datatype","Number","isFinite","isInteger","toExponential","replace","defaultDatatype","contextType","contextLanguage","contextDirection","language","direction","valueNode","graph","getDefaultGraph","emitQuad","quad","disableCache","cachedUnaliasedKeyword","unaliasedKeywordCacheStack","isPotentialKeyword","unliased","isValidKeyword","unaliasKeywordParent","hash","newHash","isLiteral","literalStack","jsonLiteralStack","getDepthOffsetGraph","containers","EntryHandlerContainer","getContainerHandler","isComplexGraphContainer","validateReverseSubject","subject","INVALID_REVERSE_PROPERTY_VALUE","defaultGraph","getGraphContainerValue","depthContainer","graphContainerIndex","getContainerGraphIndex","graphId","keyUnaliased","getContainerKey","getPropertiesDepth","lastValidDepth","XSD"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst EntryHandlerContainer_1 = require(\"./entryhandler/EntryHandlerContainer\");\n// tslint:disable-next-line:no-var-requires\nconst canonicalizeJson = require('canonicalize');\n/**\n * Utility functions and methods.\n */\nclass Util {\n    constructor(options) {\n        this.parsingContext = options.parsingContext;\n        this.dataFactory = options.dataFactory || new rdf_data_factory_1.DataFactory();\n        this.rdfFirst = this.dataFactory.namedNode(Util.RDF + 'first');\n        this.rdfRest = this.dataFactory.namedNode(Util.RDF + 'rest');\n        this.rdfNil = this.dataFactory.namedNode(Util.RDF + 'nil');\n        this.rdfType = this.dataFactory.namedNode(Util.RDF + 'type');\n        this.rdfJson = this.dataFactory.namedNode(Util.RDF + 'JSON');\n    }\n    /**\n     * Helper function to get the value of a context entry,\n     * or fallback to a certain value.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} contextKey A pre-defined JSON-LD key in context entries.\n     * @param {string} key A context entry key.\n     * @param {string} fallback A fallback value for when the given contextKey\n     *                          could not be found in the value with the given key.\n     * @return {string} The value of the given contextKey in the entry behind key in the given context,\n     *                  or the given fallback value.\n     */\n    static getContextValue(context, contextKey, key, fallback) {\n        const entry = context.getContextRaw()[key];\n        if (!entry) {\n            return fallback;\n        }\n        const type = entry[contextKey];\n        return type === undefined ? fallback : type;\n    }\n    /**\n     * Get the container type of the given key in the context.\n     *\n     * Should any context-scoping bugs should occur related to this in the future,\n     * it may be required to increase the offset from the depth at which the context is retrieved by one (to 2).\n     * This is because containers act 2 levels deep.\n     *\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The container type.\n     */\n    static getContextValueContainer(context, key) {\n        return Util.getContextValue(context, '@container', key, { '@set': true });\n    }\n    /**\n     * Get the value type of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The node type.\n     */\n    static getContextValueType(context, key) {\n        const valueType = Util.getContextValue(context, '@type', key, null);\n        if (valueType === '@none') {\n            return null;\n        }\n        return valueType;\n    }\n    /**\n     * Get the language of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The node type.\n     */\n    static getContextValueLanguage(context, key) {\n        return Util.getContextValue(context, '@language', key, context.getContextRaw()['@language'] || null);\n    }\n    /**\n     * Get the direction of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The node type.\n     */\n    static getContextValueDirection(context, key) {\n        return Util.getContextValue(context, '@direction', key, context.getContextRaw()['@direction'] || null);\n    }\n    /**\n     * Check if the given key in the context is a reversed property.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {boolean} If the context value has a @reverse key.\n     */\n    static isContextValueReverse(context, key) {\n        return !!Util.getContextValue(context, '@reverse', key, null);\n    }\n    /**\n     * Get the @index of the given key in the context.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key A context entry key.\n     * @return {string} The index.\n     */\n    static getContextValueIndex(context, key) {\n        return Util.getContextValue(context, '@index', key, context.getContextRaw()['@index'] || null);\n    }\n    /**\n     * Check if the given key refers to a reversed property.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key The property key.\n     * @param {string} parentKey The parent key.\n     * @return {boolean} If the property must be reversed.\n     */\n    static isPropertyReverse(context, key, parentKey) {\n        // '!==' is needed because reversed properties in a @reverse container should cancel each other out.\n        return parentKey === '@reverse' !== Util.isContextValueReverse(context, key);\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return iri !== null && jsonld_context_parser_1.Util.isValidIri(iri);\n    }\n    /**\n     * Check if the given first array (needle) is a prefix of the given second array (haystack).\n     * @param needle An array to check if it is a prefix.\n     * @param haystack An array to look in.\n     */\n    static isPrefixArray(needle, haystack) {\n        if (needle.length > haystack.length) {\n            return false;\n        }\n        for (let i = 0; i < needle.length; i++) {\n            if (needle[i] !== haystack[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Make sure that @id-@index pairs are equal over all array values.\n     * Reject otherwise.\n     * @param {any[]} value An array value.\n     * @return {Promise<void>} A promise rejecting if conflicts are present.\n     */\n    async validateValueIndexes(value) {\n        if (this.parsingContext.validateValueIndexes) {\n            const indexHashes = {};\n            for (const entry of value) {\n                if (entry && typeof entry === 'object') {\n                    const id = entry['@id'];\n                    const index = entry['@index'];\n                    if (id && index) {\n                        const existingIndexValue = indexHashes[id];\n                        if (existingIndexValue && existingIndexValue !== index) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Conflicting @index value for ${id}`, jsonld_context_parser_1.ERROR_CODES.CONFLICTING_INDEXES);\n                        }\n                        indexHashes[id] = index;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Convert a given JSON value to an RDF term.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key The current JSON key.\n     * @param value A JSON value.\n     * @param {number} depth The depth the value is at.\n     * @param {string[]} keys The path of keys.\n     * @return {Promise<RDF.Term[]>} An RDF term array.\n     */\n    async valueToTerm(context, key, value, depth, keys) {\n        // Skip further processing if we have an @type: @json\n        if (Util.getContextValueType(context, key) === '@json') {\n            return [this.dataFactory.literal(this.valueToJsonString(value), this.rdfJson)];\n        }\n        const type = typeof value;\n        switch (type) {\n            case 'object':\n                // Skip if we have a null or undefined object\n                if (value === null || value === undefined) {\n                    return [];\n                }\n                // Special case for arrays\n                if (Array.isArray(value)) {\n                    // We handle arrays at value level so we can emit earlier, so this is handled already when we get here.\n                    // Empty context-based lists are emitted at this place, because our streaming algorithm doesn't detect those.\n                    if ('@list' in Util.getContextValueContainer(context, key)) {\n                        if (value.length === 0) {\n                            return [this.rdfNil];\n                        }\n                        else {\n                            return this.parsingContext.idStack[depth + 1] || [];\n                        }\n                    }\n                    await this.validateValueIndexes(value);\n                    return [];\n                }\n                // Handle property-scoped contexts\n                context = await this.getContextSelfOrPropertyScoped(context, key);\n                // Handle local context in the value\n                if ('@context' in value) {\n                    context = await this.parsingContext.parseContext(value['@context'], (await this.parsingContext.getContext(keys, 0)).getContextRaw());\n                }\n                // In all other cases, we have a hash\n                value = await this.unaliasKeywords(value, keys, depth, context); // Un-alias potential keywords in this hash\n                if ('@value' in value) {\n                    let val;\n                    let valueLanguage;\n                    let valueDirection;\n                    let valueType;\n                    let valueIndex; // We don't use the index, but we need to check its type for spec-compliance\n                    for (key in value) {\n                        const subValue = value[key];\n                        switch (key) {\n                            case '@value':\n                                val = subValue;\n                                break;\n                            case '@language':\n                                valueLanguage = subValue;\n                                break;\n                            case '@direction':\n                                valueDirection = subValue;\n                                break;\n                            case '@type':\n                                valueType = subValue;\n                                break;\n                            case '@index':\n                                valueIndex = subValue;\n                                break;\n                            default:\n                                throw new jsonld_context_parser_1.ErrorCoded(`Unknown value entry '${key}' in @value: ${JSON.stringify(value)}`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                    }\n                    // Skip further processing if we have an @type: @json\n                    if (await this.unaliasKeyword(valueType, keys, depth, true, context) === '@json') {\n                        return [this.dataFactory.literal(this.valueToJsonString(val), this.rdfJson)];\n                    }\n                    // Validate @value\n                    if (val === null) {\n                        return [];\n                    }\n                    if (typeof val === 'object') {\n                        throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@value' can not be an object, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT_VALUE);\n                    }\n                    // Validate @index\n                    if (this.parsingContext.validateValueIndexes && valueIndex && typeof valueIndex !== 'string') {\n                        throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@index' must be a string, got '${JSON.stringify(valueIndex)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_INDEX_VALUE);\n                    }\n                    // Validate @language and @direction\n                    if (valueLanguage) {\n                        if (typeof val !== 'string') {\n                            throw new jsonld_context_parser_1.ErrorCoded(`When an '@language' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_VALUE);\n                        }\n                        if (!jsonld_context_parser_1.ContextParser.validateLanguage(valueLanguage, this.parsingContext.strictValues, jsonld_context_parser_1.ERROR_CODES.INVALID_LANGUAGE_TAGGED_STRING)) {\n                            return [];\n                        }\n                        // Language tags are always normalized to lowercase in 1.0.\n                        if (this.parsingContext.normalizeLanguageTags || this.parsingContext.activeProcessingMode === 1.0) {\n                            valueLanguage = valueLanguage.toLowerCase();\n                        }\n                    }\n                    if (valueDirection) {\n                        if (typeof val !== 'string') {\n                            throw new Error(`When an '@direction' is set, the value of '@value' must be a string, got '${JSON.stringify(val)}'`);\n                        }\n                        if (!jsonld_context_parser_1.ContextParser.validateDirection(valueDirection, this.parsingContext.strictValues)) {\n                            return [];\n                        }\n                    }\n                    // Check @language and @direction\n                    if (valueLanguage && valueDirection && this.parsingContext.rdfDirection) {\n                        if (valueType) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Can not have '@language', '@direction' and '@type' in a value: '${JSON\n                                .stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                        return this.nullableTermToArray(this\n                            .createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));\n                    }\n                    else if (valueLanguage) { // Check @language\n                        if (valueType) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@language' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                        return [this.dataFactory.literal(val, valueLanguage)];\n                    }\n                    else if (valueDirection && this.parsingContext.rdfDirection) { // Check @direction\n                        if (valueType) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Can not have both '@direction' and '@type' in a value: '${JSON.stringify(value)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_VALUE_OBJECT);\n                        }\n                        return this.nullableTermToArray(this\n                            .createLanguageDirectionLiteral(depth, val, valueLanguage, valueDirection));\n                    }\n                    else if (valueType) { // Validate @type\n                        if (typeof valueType !== 'string') {\n                            throw new jsonld_context_parser_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n                        }\n                        const typeTerm = this.createVocabOrBaseTerm(context, valueType);\n                        if (!typeTerm) {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Invalid '@type' value, got '${JSON.stringify(valueType)}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n                        }\n                        if (typeTerm.termType !== 'NamedNode') {\n                            throw new jsonld_context_parser_1.ErrorCoded(`Illegal value type (${typeTerm.termType}): ${valueType}`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPED_VALUE);\n                        }\n                        return [this.dataFactory.literal(val, typeTerm)];\n                    }\n                    // We don't pass the context, because context-based things like @language should be ignored\n                    return await this.valueToTerm(new jsonld_context_parser_1.JsonLdContextNormalized({}), key, val, depth, keys);\n                }\n                else if ('@set' in value) {\n                    // No other entries are allow in this value\n                    if (Object.keys(value).length > 1) {\n                        throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @set for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);\n                    }\n                    // No need to do anything here, this is handled at the deeper level.\n                    return [];\n                }\n                else if ('@list' in value) {\n                    // No other entries are allowed in this value\n                    if (Object.keys(value).length > 1) {\n                        throw new jsonld_context_parser_1.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${key}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);\n                    }\n                    const listValue = value[\"@list\"];\n                    // We handle lists at value level so we can emit earlier, so this is handled already when we get here.\n                    // Empty anonymous lists are emitted at this place, because our streaming algorithm doesn't detect those.\n                    if (Array.isArray(listValue)) {\n                        if (listValue.length === 0) {\n                            return [this.rdfNil];\n                        }\n                        else {\n                            return this.parsingContext.idStack[depth + 1] || [];\n                        }\n                    }\n                    else {\n                        // We only have a single list element here, so emit this directly as single element\n                        return await this.valueToTerm(await this.parsingContext.getContext(keys), key, listValue, depth - 1, keys.slice(0, -1));\n                    }\n                }\n                else if ('@reverse' in value && typeof value['@reverse'] === 'boolean') {\n                    // We handle reverse properties at value level so we can emit earlier,\n                    // so this is handled already when we get here.\n                    return [];\n                }\n                else if ('@graph' in Util.getContextValueContainer(await this.parsingContext.getContext(keys), key)) {\n                    // We are processing a graph container\n                    const graphContainerEntries = this.parsingContext.graphContainerTermStack[depth + 1];\n                    return graphContainerEntries ? Object.values(graphContainerEntries) : [this.dataFactory.blankNode()];\n                }\n                else if (\"@id\" in value) {\n                    // Use deeper context if the value node contains other properties next to @id.\n                    if (Object.keys(value).length > 1) {\n                        context = await this.parsingContext.getContext(keys, 0);\n                    }\n                    // Handle local context in the value\n                    if ('@context' in value) {\n                        context = await this.parsingContext.parseContext(value['@context'], context.getContextRaw());\n                    }\n                    if (value[\"@type\"] === '@vocab') {\n                        return this.nullableTermToArray(this.createVocabOrBaseTerm(context, value[\"@id\"]));\n                    }\n                    else {\n                        return this.nullableTermToArray(this.resourceToTerm(context, value[\"@id\"]));\n                    }\n                }\n                else {\n                    // Only make a blank node if at least one triple was emitted at the value's level.\n                    if (this.parsingContext.emittedStack[depth + 1]\n                        || (value && typeof value === 'object' && Object.keys(value).length === 0)) {\n                        return (this.parsingContext.idStack[depth + 1]\n                            || (this.parsingContext.idStack[depth + 1] = [this.dataFactory.blankNode()]));\n                    }\n                    else {\n                        return [];\n                    }\n                }\n            case 'string':\n                return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, null));\n            case 'boolean':\n                return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, Boolean(value).toString(), this.dataFactory.namedNode(Util.XSD_BOOLEAN)));\n            case 'number':\n                return this.nullableTermToArray(this.stringValueToTerm(depth, await this.getContextSelfOrPropertyScoped(context, key), key, value, this.dataFactory.namedNode(value % 1 === 0 && value < 1e21 ? Util.XSD_INTEGER : Util.XSD_DOUBLE)));\n            default:\n                this.parsingContext.emitError(new Error(`Could not determine the RDF type of a ${type}`));\n                return [];\n        }\n    }\n    /**\n     * If the context defines a property-scoped context for the given key,\n     * that context will be returned.\n     * Otherwise, the given context will be returned as-is.\n     *\n     * This should be used for valueToTerm cases that are not objects.\n     * @param context A context.\n     * @param key A JSON key.\n     */\n    async getContextSelfOrPropertyScoped(context, key) {\n        const contextKeyEntry = context.getContextRaw()[key];\n        if (contextKeyEntry && typeof contextKeyEntry === 'object' && '@context' in contextKeyEntry) {\n            context = await this.parsingContext.parseContext(contextKeyEntry, context.getContextRaw(), true);\n        }\n        return context;\n    }\n    /**\n     * If the given term is null, return an empty array, otherwise return an array with the single given term.\n     * @param term A term.\n     */\n    nullableTermToArray(term) {\n        return term ? [term] : [];\n    }\n    /**\n     * Convert a given JSON key to an RDF predicate term,\n     * based on @vocab.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param key A JSON key.\n     * @return {RDF.NamedNode} An RDF named node.\n     */\n    predicateToTerm(context, key) {\n        const expanded = context.expandTerm(key, true, this.parsingContext.getExpandOptions());\n        // Immediately return if the predicate was disabled in the context\n        if (!expanded) {\n            return null;\n        }\n        // Check if the predicate is a blank node\n        if (expanded[0] === '_' && expanded[1] === ':') {\n            if (this.parsingContext.produceGeneralizedRdf) {\n                return this.dataFactory.blankNode(expanded.substr(2));\n            }\n            else {\n                return null;\n            }\n        }\n        // Check if the predicate is a valid IRI\n        if (Util.isValidIri(expanded)) {\n            return this.dataFactory.namedNode(expanded);\n        }\n        else {\n            if (expanded && this.parsingContext.strictValues) {\n                this.parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Invalid predicate IRI: ${expanded}`, jsonld_context_parser_1.ERROR_CODES.INVALID_IRI_MAPPING));\n            }\n            else {\n                return null;\n            }\n        }\n        return null;\n    }\n    /**\n     * Convert a given JSON key to an RDF resource term or blank node,\n     * based on @base.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param key A JSON key.\n     * @return {RDF.NamedNode} An RDF named node or null.\n     */\n    resourceToTerm(context, key) {\n        if (key.startsWith('_:')) {\n            return this.dataFactory.blankNode(key.substr(2));\n        }\n        const iri = context.expandTerm(key, false, this.parsingContext.getExpandOptions());\n        if (!Util.isValidIri(iri)) {\n            if (iri && this.parsingContext.strictValues) {\n                this.parsingContext.emitError(new Error(`Invalid resource IRI: ${iri}`));\n            }\n            else {\n                return null;\n            }\n        }\n        return this.dataFactory.namedNode(iri);\n    }\n    /**\n     * Convert a given JSON key to an RDF resource term.\n     * It will do this based on the @vocab,\n     * and fallback to @base.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param key A JSON key.\n     * @return {RDF.NamedNode} An RDF named node or null.\n     */\n    createVocabOrBaseTerm(context, key) {\n        if (key.startsWith('_:')) {\n            return this.dataFactory.blankNode(key.substr(2));\n        }\n        const expandOptions = this.parsingContext.getExpandOptions();\n        let expanded = context.expandTerm(key, true, expandOptions);\n        if (expanded === key) {\n            expanded = context.expandTerm(key, false, expandOptions);\n        }\n        if (!Util.isValidIri(expanded)) {\n            if (expanded && this.parsingContext.strictValues) {\n                this.parsingContext.emitError(new Error(`Invalid term IRI: ${expanded}`));\n            }\n            else {\n                return null;\n            }\n        }\n        return this.dataFactory.namedNode(expanded);\n    }\n    /**\n     * Ensure that the given value becomes a string.\n     * @param {string | number} value A string or number.\n     * @param {NamedNode} datatype The intended datatype.\n     * @return {string} The returned string.\n     */\n    intToString(value, datatype) {\n        if (typeof value === 'number') {\n            if (Number.isFinite(value)) {\n                const isInteger = value % 1 === 0;\n                if (isInteger && (!datatype || datatype.value !== Util.XSD_DOUBLE)) {\n                    return Number(value).toString();\n                }\n                else {\n                    return value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n                }\n            }\n            else {\n                return value > 0 ? 'INF' : '-INF';\n            }\n        }\n        else {\n            return value;\n        }\n    }\n    /**\n     * Convert a given JSON string value to an RDF term.\n     * @param {number} depth The current stack depth.\n     * @param {JsonLdContextNormalized} context A JSON-LD context.\n     * @param {string} key The current JSON key.\n     * @param {string} value A JSON value.\n     * @param {NamedNode} defaultDatatype The default datatype for the given value.\n     * @return {RDF.Term} An RDF term or null.\n     */\n    stringValueToTerm(depth, context, key, value, defaultDatatype) {\n        // Check the datatype from the context\n        const contextType = Util.getContextValueType(context, key);\n        if (contextType) {\n            if (contextType === '@id') {\n                if (!defaultDatatype) {\n                    return this.resourceToTerm(context, this.intToString(value, defaultDatatype));\n                }\n            }\n            else if (contextType === '@vocab') {\n                if (!defaultDatatype) {\n                    return this.createVocabOrBaseTerm(context, this.intToString(value, defaultDatatype));\n                }\n            }\n            else {\n                defaultDatatype = this.dataFactory.namedNode(contextType);\n            }\n        }\n        // If we don't find such a datatype, check the language from the context\n        if (!defaultDatatype) {\n            const contextLanguage = Util.getContextValueLanguage(context, key);\n            const contextDirection = Util.getContextValueDirection(context, key);\n            if (contextDirection && this.parsingContext.rdfDirection) {\n                return this.createLanguageDirectionLiteral(depth, this.intToString(value, defaultDatatype), contextLanguage, contextDirection);\n            }\n            else {\n                return this.dataFactory.literal(this.intToString(value, defaultDatatype), contextLanguage);\n            }\n        }\n        // If all else fails, make a literal based on the default content type\n        return this.dataFactory.literal(this.intToString(value, defaultDatatype), defaultDatatype);\n    }\n    /**\n     * Create a literal for the given value with the given language and direction.\n     * Auxiliary quads may be emitted.\n     * @param {number} depth The current stack depth.\n     * @param {string} value A string value.\n     * @param {string} language A language tag.\n     * @param {string} direction A direction.\n     * @return {Term} An RDF term.\n     */\n    createLanguageDirectionLiteral(depth, value, language, direction) {\n        if (this.parsingContext.rdfDirection === 'i18n-datatype') {\n            // Create a datatyped literal, by encoding the language and direction into https://www.w3.org/ns/i18n#.\n            if (!language) {\n                language = '';\n            }\n            return this.dataFactory.literal(value, this.dataFactory.namedNode(`https://www.w3.org/ns/i18n#${language}_${direction}`));\n        }\n        else {\n            // Reify the literal.\n            const valueNode = this.dataFactory.blankNode();\n            const graph = this.getDefaultGraph();\n            this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'value'), this.dataFactory.literal(value), graph));\n            if (language) {\n                this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'language'), this.dataFactory.literal(language), graph));\n            }\n            this.parsingContext.emitQuad(depth, this.dataFactory.quad(valueNode, this.dataFactory.namedNode(Util.RDF + 'direction'), this.dataFactory.literal(direction), graph));\n            return valueNode;\n        }\n    }\n    /**\n     * Stringify the given JSON object to a canonical JSON string.\n     * @param value Any valid JSON value.\n     * @return {string} A canonical JSON string.\n     */\n    valueToJsonString(value) {\n        return canonicalizeJson(value);\n    }\n    /**\n     * If the key is not a keyword, try to check if it is an alias for a keyword,\n     * and if so, un-alias it.\n     * @param {string} key A key, can be falsy.\n     * @param {string[]} keys The path of keys.\n     * @param {number} depth The depth to\n     * @param {boolean} disableCache If the cache should be disabled\n     * @param {JsonLdContextNormalized} context A context to unalias with,\n     *                                           will fallback to retrieving the context for the given keys.\n     * @return {Promise<string>} A promise resolving to the key itself, or another key.\n     */\n    async unaliasKeyword(key, keys, depth, disableCache, context) {\n        // Numbers can not be an alias\n        if (Number.isInteger(key)) {\n            return key;\n        }\n        // Try to grab from cache if it was already un-aliased before.\n        if (!disableCache) {\n            const cachedUnaliasedKeyword = this.parsingContext.unaliasedKeywordCacheStack[depth];\n            if (cachedUnaliasedKeyword) {\n                return cachedUnaliasedKeyword;\n            }\n        }\n        if (!jsonld_context_parser_1.Util.isPotentialKeyword(key)) {\n            context = context || await this.parsingContext.getContext(keys);\n            let unliased = context.getContextRaw()[key];\n            if (unliased && typeof unliased === 'object') {\n                unliased = unliased['@id'];\n            }\n            if (jsonld_context_parser_1.Util.isValidKeyword(unliased)) {\n                key = unliased;\n            }\n        }\n        return disableCache ? key : (this.parsingContext.unaliasedKeywordCacheStack[depth] = key);\n    }\n    /**\n     * Unalias the keyword of the parent.\n     * This adds a safety check if no parent exist.\n     * @param {any[]} keys A stack of keys.\n     * @param {number} depth The current depth.\n     * @return {Promise<any>} A promise resolving to the parent key, or another key.\n     */\n    async unaliasKeywordParent(keys, depth) {\n        return await this.unaliasKeyword(depth > 0 && keys[depth - 1], keys, depth - 1);\n    }\n    /**\n     * Un-alias all keywords in the given hash.\n     * @param {{[p: string]: any}} hash A hash object.\n     * @param {string[]} keys The path of keys.\n     * @param {number} depth The depth.\n     * @param {JsonLdContextNormalized} context A context to unalias with,\n     *                                           will fallback to retrieving the context for the given keys.\n     * @return {Promise<{[p: string]: any}>} A promise resolving to the new hash.\n     */\n    async unaliasKeywords(hash, keys, depth, context) {\n        const newHash = {};\n        for (const key in hash) {\n            newHash[await this.unaliasKeyword(key, keys, depth + 1, true, context)] = hash[key];\n        }\n        return newHash;\n    }\n    /**\n     * Check if we are processing a literal (including JSON literals) at the given depth.\n     * This will also check higher levels,\n     * because if a parent is a literal,\n     * then the deeper levels are definitely a literal as well.\n     * @param {number} depth The depth.\n     * @return {boolean} If we are processing a literal.\n     */\n    isLiteral(depth) {\n        for (let i = depth; i >= 0; i--) {\n            if (this.parsingContext.literalStack[i] || this.parsingContext.jsonLiteralStack[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check how many parents should be skipped for checking the @graph for the given node.\n     *\n     * @param {number} depth The depth of the node.\n     * @param {any[]} keys An array of keys.\n     * @return {number} The graph depth offset.\n     */\n    async getDepthOffsetGraph(depth, keys) {\n        for (let i = depth - 1; i > 0; i--) {\n            if (await this.unaliasKeyword(keys[i], keys, i) === '@graph') {\n                // Skip further processing if we are already in an @graph-@id or @graph-@index container\n                const containers = (await EntryHandlerContainer_1.EntryHandlerContainer.getContainerHandler(this.parsingContext, keys, i)).containers;\n                if (EntryHandlerContainer_1.EntryHandlerContainer.isComplexGraphContainer(containers)) {\n                    return -1;\n                }\n                return depth - i - 1;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Check if the given subject is of a valid type.\n     * This should be called when applying @reverse'd properties.\n     * @param {Term} subject A subject.\n     */\n    validateReverseSubject(subject) {\n        if (subject.termType === 'Literal') {\n            throw new jsonld_context_parser_1.ErrorCoded(`Found illegal literal in subject position: ${subject.value}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n        }\n    }\n    /**\n     * Get the default graph.\n     * @return {Term} An RDF term.\n     */\n    getDefaultGraph() {\n        return this.parsingContext.defaultGraph || this.dataFactory.defaultGraph();\n    }\n    /**\n     * Get the current graph, while taking into account a graph that can be defined via @container: @graph.\n     * If not within a graph container, the default graph will be returned.\n     * @param keys The current keys.\n     * @param depth The current depth.\n     */\n    async getGraphContainerValue(keys, depth) {\n        // Default to default graph\n        let graph = this.getDefaultGraph();\n        // Check if we are in an @container: @graph.\n        const { containers, depth: depthContainer } = await EntryHandlerContainer_1.EntryHandlerContainer\n            .getContainerHandler(this.parsingContext, keys, depth);\n        if ('@graph' in containers) {\n            // Get the graph from the stack.\n            const graphContainerIndex = EntryHandlerContainer_1.EntryHandlerContainer.getContainerGraphIndex(containers, depthContainer, keys);\n            const entry = this.parsingContext.graphContainerTermStack[depthContainer];\n            graph = entry ? entry[graphContainerIndex] : null;\n            // Set the graph in the stack if none has been set yet.\n            if (!graph) {\n                let graphId = null;\n                if ('@id' in containers) {\n                    const keyUnaliased = await this.getContainerKey(keys[depthContainer], keys, depthContainer);\n                    if (keyUnaliased !== null) {\n                        graphId = await this.resourceToTerm(await this.parsingContext.getContext(keys), keyUnaliased);\n                    }\n                }\n                if (!graphId) {\n                    graphId = this.dataFactory.blankNode();\n                }\n                if (!this.parsingContext.graphContainerTermStack[depthContainer]) {\n                    this.parsingContext.graphContainerTermStack[depthContainer] = {};\n                }\n                graph = this.parsingContext.graphContainerTermStack[depthContainer][graphContainerIndex] = graphId;\n            }\n        }\n        return graph;\n    }\n    /**\n     * Get the properties depth for retrieving properties.\n     *\n     * Typically, the properties depth will be identical to the given depth.\n     *\n     * The following exceptions apply:\n     * * When the parent is @reverse, the depth is decremented by one.\n     * * When @nest parents are found, the depth is decremented by the number of @nest parents.\n     * If in combination with the exceptions above an intermediary array is discovered,\n     * the depth is also decremented by this number of arrays.\n     *\n     * @param keys The current key chain.\n     * @param depth The current depth.\n     */\n    async getPropertiesDepth(keys, depth) {\n        let lastValidDepth = depth;\n        for (let i = depth - 1; i > 0; i--) {\n            if (typeof keys[i] !== 'number') { // Skip array keys\n                const parentKey = await this.unaliasKeyword(keys[i], keys, i);\n                if (parentKey === '@reverse') {\n                    return i;\n                }\n                else if (parentKey === '@nest') {\n                    lastValidDepth = i;\n                }\n                else {\n                    return lastValidDepth;\n                }\n            }\n        }\n        return lastValidDepth;\n    }\n    /**\n     * Get the key for the current container entry.\n     * @param key A key, can be falsy.\n     * @param keys The key chain.\n     * @param depth The current depth to get the key from.\n     * @return Promise resolving to the key.\n     *         Null will be returned for @none entries, with aliasing taken into account.\n     */\n    async getContainerKey(key, keys, depth) {\n        const keyUnaliased = await this.unaliasKeyword(key, keys, depth);\n        return keyUnaliased === '@none' ? null : keyUnaliased;\n    }\n}\nexports.Util = Util;\nUtil.XSD = 'http://www.w3.org/2001/XMLSchema#';\nUtil.XSD_BOOLEAN = Util.XSD + 'boolean';\nUtil.XSD_INTEGER = Util.XSD + 'integer';\nUtil.XSD_DOUBLE = Util.XSD + 'double';\nUtil.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n//# sourceMappingURL=Util.js.map"]},"metadata":{},"sourceType":"script"}