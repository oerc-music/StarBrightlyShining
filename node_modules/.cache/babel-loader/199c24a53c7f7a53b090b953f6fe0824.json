{"ast":null,"code":"/**\n * A src property should be a valid LDflex expression,\n * but it can also be specified as a URL.\n * This function turns URLs into valid LDflex expressions,\n * which is useful if you want to manipulate expressions directly.\n */\nexport function srcToLDflex(src) {\n  if (/^https?:[^\"]+$/.test(src)) src = `[\"${src}\"]`;\n  return src;\n}\n/**\n * Returns an object with only the given keys from the source.\n */\n\nexport function pick(source, keys) {\n  const destination = {};\n\n  for (const key of keys) destination[key] = source[key];\n\n  return destination;\n}\n/**\n * Determines the display name of a component\n * https://reactjs.org/docs/higher-order-components.html\n */\n\nexport function getDisplayName(Component) {\n  return Component.displayName || Component.name || 'Component';\n}\n/**\n * Creates a higher-order component with the given name.\n */\n\nexport function higherOrderComponent(name, createWrapper) {\n  return Component => {\n    const Wrapper = createWrapper(Component);\n    Wrapper.displayName = `${name}(${getDisplayName(Component)})`;\n    return Wrapper;\n  };\n}\n/**\n * Creates a task queue that enforces a minimum time between tasks.\n * Optionally, new tasks can cause any old ones to be dropped.\n */\n\nexport function createTaskQueue({\n  drop = false,\n  timeBetween = 10,\n  concurrent = drop ? 1 : 4\n} = {}) {\n  let queue = [],\n      scheduler = 0; // Runs all queued tasks, with the required minimum time in between\n\n  function runQueuedTasks() {\n    scheduler = queue.length && setTimeout(runQueuedTasks, timeBetween);\n    queue.splice(0, concurrent).forEach(async ({\n      run,\n      resolve,\n      reject\n    }) => {\n      try {\n        resolve(await run());\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  return {\n    /** Schedules the given task(s) */\n    schedule: function schedule(functions, group = null) {\n      // Schedule a single task\n      if (!Array.isArray(functions)) return schedule([functions])[0]; // Create the tasks and their result promises\n\n      const tasks = [];\n      const results = functions.map(run => new Promise((resolve, reject) => tasks.push({\n        run,\n        resolve,\n        reject,\n        group\n      }))); // Schedule the tasks\n\n      if (drop) queue = tasks;else queue.push(...tasks);\n      if (!scheduler) runQueuedTasks();\n      return results;\n    },\n\n    /** Forgets pending tasks (optionally only those in a given group).\n        Returns a boolean indicating whether there were any. */\n    clear: function (group) {\n      const hadPendingTasks = queue.length > 0;\n      queue = queue.filter(task => group !== undefined && task.group !== group);\n      return hadPendingTasks;\n    }\n  };\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@solid/react/module/util.js"],"names":["srcToLDflex","src","test","pick","source","keys","destination","key","getDisplayName","Component","displayName","name","higherOrderComponent","createWrapper","Wrapper","createTaskQueue","drop","timeBetween","concurrent","queue","scheduler","runQueuedTasks","length","setTimeout","splice","forEach","run","resolve","reject","error","schedule","functions","group","Array","isArray","tasks","results","map","Promise","push","clear","hadPendingTasks","filter","task","undefined"],"mappings":"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","sourcesContent":["/**\n * A src property should be a valid LDflex expression,\n * but it can also be specified as a URL.\n * This function turns URLs into valid LDflex expressions,\n * which is useful if you want to manipulate expressions directly.\n */\nexport function srcToLDflex(src) {\n  if (/^https?:[^\"]+$/.test(src)) src = `[\"${src}\"]`;\n  return src;\n}\n/**\n * Returns an object with only the given keys from the source.\n */\n\nexport function pick(source, keys) {\n  const destination = {};\n\n  for (const key of keys) destination[key] = source[key];\n\n  return destination;\n}\n/**\n * Determines the display name of a component\n * https://reactjs.org/docs/higher-order-components.html\n */\n\nexport function getDisplayName(Component) {\n  return Component.displayName || Component.name || 'Component';\n}\n/**\n * Creates a higher-order component with the given name.\n */\n\nexport function higherOrderComponent(name, createWrapper) {\n  return Component => {\n    const Wrapper = createWrapper(Component);\n    Wrapper.displayName = `${name}(${getDisplayName(Component)})`;\n    return Wrapper;\n  };\n}\n/**\n * Creates a task queue that enforces a minimum time between tasks.\n * Optionally, new tasks can cause any old ones to be dropped.\n */\n\nexport function createTaskQueue({\n  drop = false,\n  timeBetween = 10,\n  concurrent = drop ? 1 : 4\n} = {}) {\n  let queue = [],\n      scheduler = 0; // Runs all queued tasks, with the required minimum time in between\n\n  function runQueuedTasks() {\n    scheduler = queue.length && setTimeout(runQueuedTasks, timeBetween);\n    queue.splice(0, concurrent).forEach(async ({\n      run,\n      resolve,\n      reject\n    }) => {\n      try {\n        resolve((await run()));\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  return {\n    /** Schedules the given task(s) */\n    schedule: function schedule(functions, group = null) {\n      // Schedule a single task\n      if (!Array.isArray(functions)) return schedule([functions])[0]; // Create the tasks and their result promises\n\n      const tasks = [];\n      const results = functions.map(run => new Promise((resolve, reject) => tasks.push({\n        run,\n        resolve,\n        reject,\n        group\n      }))); // Schedule the tasks\n\n      if (drop) queue = tasks;else queue.push(...tasks);\n      if (!scheduler) runQueuedTasks();\n      return results;\n    },\n\n    /** Forgets pending tasks (optionally only those in a given group).\n        Returns a boolean indicating whether there were any. */\n    clear: function (group) {\n      const hadPendingTasks = queue.length > 0;\n      queue = queue.filter(task => group !== undefined && task.group !== group);\n      return hadPendingTasks;\n    }\n  };\n}"]},"metadata":{},"sourceType":"module"}