{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatDayTimeDuration = exports.langMatches = exports.replace = exports.matches = void 0; // https://www.w3.org/TR/xpath-functions/#func-matches\n// https://www.w3.org/TR/xpath-functions/#flags\n\nfunction matches(text, pattern, flags) {\n  // TODO: Only flags 'i' and 'm' match between XPath and JS.\n  // 's', 'x', 'q', would need proper implementation.\n  const reg = new RegExp(pattern, flags);\n  return reg.test(text);\n}\n\nexports.matches = matches; // TODO: Fix flags\n// https://www.w3.org/TR/xpath-functions/#func-replace\n\nfunction replace(arg, pattern, replacement, flags) {\n  let reg = new RegExp(pattern, flags);\n\n  if (!reg.global) {\n    const flags_ = flags || '';\n    reg = new RegExp(pattern, flags_ + 'g');\n  }\n\n  return arg.replace(reg, replacement);\n}\n\nexports.replace = replace; // TODO: Not an XPath function\n// TODO: Publish as package\n// https://www.ietf.org/rfc/rfc4647.txt\n// https://www.w3.org/TR/sparql11-query/#func-langMatches\n\nfunction langMatches(tag, range) {\n  const langTags = tag.split('-');\n  const rangeTags = range.split('-');\n\n  if (!_matchLangTag(rangeTags[0], langTags[0]) && !_isWildCard(langTags[0])) {\n    return false;\n  }\n\n  let lI = 1;\n  let rI = 1;\n\n  while (rI < rangeTags.length) {\n    if (_isWildCard(rangeTags[rI])) {\n      rI++;\n      continue;\n    }\n\n    if (lI === langTags.length) {\n      return false;\n    }\n\n    if (_matchLangTag(rangeTags[rI], langTags[lI])) {\n      lI++;\n      rI++;\n      continue;\n    }\n\n    if (langTags[lI].length === 1) {\n      return false;\n    }\n\n    lI++;\n  }\n\n  return true;\n}\n\nexports.langMatches = langMatches;\n\nfunction _isWildCard(tag) {\n  return tag === '*';\n}\n\nfunction _matchLangTag(left, right) {\n  const matchInitial = new RegExp(`/${left}/`, 'i');\n  return matchInitial.test(`/${right}/`);\n}\n/**\n * Formats a timezone string into a XML DayTimeDuration\n *\n * TODO: Test\n * Used in fn:timezone\n * http://www.datypic.com/sc/xsd/t-xsd_dayTimeDuration.html\n */\n\n\nfunction formatDayTimeDuration(timezone) {\n  if (!timezone) {\n    return undefined;\n  }\n\n  if (timezone[0] === 'Z') {\n    return 'PT0S';\n  } else {\n    // Split string\n    const [sign, h1Raw, h2Raw, _, m1Raw, m2Raw] = timezone; // Cut of leading zero, set to empty string if 0, and append H;\n\n    const h1 = h1Raw !== '0' ? h1Raw : '';\n    const h2 = h1 || h2Raw !== '0' ? h2Raw : '';\n    const hours = h1 + h2 ? h1 + h2 + 'H' : ''; // Same as in hours\n\n    const m1 = m1Raw !== '0' ? m1Raw : '';\n    const m2 = m1 || m2Raw !== '0' ? m2Raw : '';\n    const minutes = m1 + m2 ? m1 + m2 + 'M' : ''; // Concat sign and time and mandatory separators\n\n    const time = `${hours}${minutes}`;\n    const signNoPlus = sign === '-' ? '-' : '';\n    return `${signNoPlus}PT${time}`;\n  }\n}\n\nexports.formatDayTimeDuration = formatDayTimeDuration;","map":{"version":3,"sources":["../../../lib/functions/XPathFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["\n// https://www.w3.org/TR/xpath-functions/#func-matches\n// https://www.w3.org/TR/xpath-functions/#flags\nexport function matches(text: string, pattern: string, flags?: string): boolean {\n  // TODO: Only flags 'i' and 'm' match between XPath and JS.\n  // 's', 'x', 'q', would need proper implementation.\n  const reg = new RegExp(pattern, flags);\n  return reg.test(text);\n}\n\n// TODO: Fix flags\n// https://www.w3.org/TR/xpath-functions/#func-replace\nexport function replace(arg: string, pattern: string, replacement: string, flags?: string): string {\n  let reg = new RegExp(pattern, flags);\n  if (!reg.global) {\n    const flags_ = flags || '';\n    reg = new RegExp(pattern, flags_ + 'g');\n  }\n  return arg.replace(reg, replacement);\n}\n\n// TODO: Not an XPath function\n// TODO: Publish as package\n// https://www.ietf.org/rfc/rfc4647.txt\n// https://www.w3.org/TR/sparql11-query/#func-langMatches\nexport function langMatches(tag: string, range: string): boolean {\n  const langTags = tag.split('-');\n  const rangeTags = range.split('-');\n\n  if (!_matchLangTag(rangeTags[0], langTags[0])\n    && !_isWildCard(langTags[0])) { return false; }\n\n  let lI = 1;\n  let rI = 1;\n  while (rI < rangeTags.length) {\n    if (_isWildCard(rangeTags[rI])) { rI++; continue; }\n    if (lI === langTags.length) { return false; }\n    if (_matchLangTag(rangeTags[rI], langTags[lI])) { lI++; rI++; continue; }\n    if (langTags[lI].length === 1) { return false; }\n    lI++;\n  }\n  return true;\n}\n\nfunction _isWildCard(tag: string): boolean {\n  return tag === '*';\n}\n\nfunction _matchLangTag(left: string, right: string): boolean {\n  const matchInitial = new RegExp(`/${left}/`, 'i');\n  return matchInitial.test(`/${right}/`);\n}\n\n/**\n * Formats a timezone string into a XML DayTimeDuration\n *\n * TODO: Test\n * Used in fn:timezone\n * http://www.datypic.com/sc/xsd/t-xsd_dayTimeDuration.html\n */\nexport function formatDayTimeDuration(timezone: string) {\n  if (!timezone) { return undefined; }\n  if (timezone[0] === 'Z') {\n    return 'PT0S';\n  } else {\n    // Split string\n    const [sign, h1Raw, h2Raw, _, m1Raw, m2Raw] = timezone;\n\n    // Cut of leading zero, set to empty string if 0, and append H;\n    const h1 = (h1Raw !== '0') ? h1Raw : '';\n    const h2 = (h1 || h2Raw !== '0') ? h2Raw : '';\n    const hours = (h1 + h2) ? h1 + h2 + 'H' : '';\n\n    // Same as in hours\n    const m1 = (m1Raw !== '0') ? m1Raw : '';\n    const m2 = (m1 || m2Raw !== '0') ? m2Raw : '';\n    const minutes = (m1 + m2) ? m1 + m2 + 'M' : '';\n\n    // Concat sign and time and mandatory separators\n    const time = `${hours}${minutes}`;\n    const signNoPlus = (sign === '-') ? '-' : '';\n    return `${signNoPlus}PT${time}`;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}