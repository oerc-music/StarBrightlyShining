{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParsingContext = void 0;\n\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n\nconst ErrorCoded_1 = require(\"jsonld-context-parser/lib/ErrorCoded\");\n\nconst ContextTree_1 = require(\"./ContextTree\");\n\nconst JsonLdParser_1 = require(\"./JsonLdParser\");\n/**\n * Data holder for parsing information.\n */\n\n\nclass ParsingContext {\n  constructor(options) {\n    // Initialize settings\n    this.contextParser = new jsonld_context_parser_1.ContextParser({\n      documentLoader: options.documentLoader,\n      skipValidation: options.skipContextValidation\n    });\n    this.streamingProfile = !!options.streamingProfile;\n    this.baseIRI = options.baseIRI;\n    this.produceGeneralizedRdf = !!options.produceGeneralizedRdf;\n    this.allowSubjectList = !!options.allowSubjectList;\n    this.processingMode = options.processingMode || JsonLdParser_1.JsonLdParser.DEFAULT_PROCESSING_MODE;\n    this.strictValues = !!options.strictValues;\n    this.validateValueIndexes = !!options.validateValueIndexes;\n    this.defaultGraph = options.defaultGraph;\n    this.rdfDirection = options.rdfDirection;\n    this.normalizeLanguageTags = options.normalizeLanguageTags;\n    this.streamingProfileAllowOutOfOrderPlainType = options.streamingProfileAllowOutOfOrderPlainType;\n    this.topLevelProperties = false;\n    this.activeProcessingMode = parseFloat(this.processingMode); // Initialize stacks\n\n    this.processingStack = [];\n    this.processingType = [];\n    this.emittedStack = [];\n    this.idStack = [];\n    this.graphStack = [];\n    this.graphContainerTermStack = [];\n    this.listPointerStack = [];\n    this.contextTree = new ContextTree_1.ContextTree();\n    this.literalStack = [];\n    this.validationStack = [];\n    this.unaliasedKeywordCacheStack = [];\n    this.jsonLiteralStack = [];\n    this.unidentifiedValuesBuffer = [];\n    this.unidentifiedGraphsBuffer = [];\n    this.pendingContainerFlushBuffers = [];\n    this.parser = options.parser;\n\n    if (options.context) {\n      this.rootContext = this.parseContext(options.context);\n      this.rootContext.then(context => this.validateContext(context));\n    } else {\n      this.rootContext = Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(this.baseIRI ? {\n        '@base': this.baseIRI,\n        '@__baseDocument': true\n      } : {}));\n    }\n  }\n  /**\n   * Parse the given context with the configured options.\n   * @param {JsonLdContext} context A context to parse.\n   * @param {JsonLdContextNormalized} parentContext An optional parent context.\n   * @param {boolean} ignoreProtection If @protected term checks should be ignored.\n   * @return {Promise<JsonLdContextNormalized>} A promise resolving to the parsed context.\n   */\n\n\n  async parseContext(context, parentContext, ignoreProtection) {\n    return this.contextParser.parse(context, {\n      baseIRI: this.baseIRI,\n      ignoreProtection,\n      normalizeLanguageTags: this.normalizeLanguageTags,\n      parentContext,\n      processingMode: this.activeProcessingMode\n    });\n  }\n  /**\n   * Check if the given context is valid.\n   * If not, an error will be thrown.\n   * @param {JsonLdContextNormalized} context A context.\n   */\n\n\n  validateContext(context) {\n    const activeVersion = context.getContextRaw()['@version'];\n\n    if (activeVersion) {\n      if (this.activeProcessingMode && activeVersion > this.activeProcessingMode) {\n        throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD version '${activeVersion}' under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.PROCESSING_MODE_CONFLICT);\n      } else {\n        if (this.activeProcessingMode && activeVersion < this.activeProcessingMode) {\n          throw new ErrorCoded_1.ErrorCoded(`Invalid JSON-LD version ${activeVersion} under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n        }\n\n        this.activeProcessingMode = activeVersion;\n      }\n    }\n  }\n  /**\n   * Get the context at the given path.\n   * @param {keys} keys The path of keys to get the context at.\n   * @param {number} offset The path offset, defaults to 1.\n   * @return {Promise<JsonLdContextNormalized>} A promise resolving to a context.\n   */\n\n\n  async getContext(keys, offset = 1) {\n    const keysOriginal = keys; // Ignore array keys at the end\n\n    while (typeof keys[keys.length - 1] === 'number') {\n      keys = keys.slice(0, keys.length - 1);\n    } // Handle offset on keys\n\n\n    if (offset) {\n      keys = keys.slice(0, -offset);\n    } // Determine the closest context\n\n\n    const contextData = await this.getContextPropagationAware(keys);\n    const context = contextData.context; // Process property-scoped contexts (high-to-low)\n\n    let contextRaw = context.getContextRaw();\n\n    for (let i = contextData.depth; i < keysOriginal.length - offset; i++) {\n      const key = keysOriginal[i];\n      const contextKeyEntry = contextRaw[key];\n\n      if (contextKeyEntry && typeof contextKeyEntry === 'object' && '@context' in contextKeyEntry) {\n        const scopedContext = (await this.parseContext(contextKeyEntry, contextRaw, true)).getContextRaw();\n        const propagate = !(key in scopedContext) || scopedContext[key]['@context']['@propagate']; // Propagation is true by default\n\n        if (propagate !== false || i === keysOriginal.length - 1 - offset) {\n          contextRaw = scopedContext; // Clean up final context\n\n          delete contextRaw['@propagate'];\n          contextRaw[key] = Object.assign({}, contextRaw[key]);\n\n          if ('@id' in contextKeyEntry) {\n            contextRaw[key]['@id'] = contextKeyEntry['@id'];\n          }\n\n          delete contextRaw[key]['@context'];\n\n          if (propagate !== false) {\n            this.contextTree.setContext(keysOriginal.slice(0, i + offset), Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw)));\n          }\n        }\n      }\n    }\n\n    return new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw);\n  }\n  /**\n   * Get the context at the given path.\n   * Non-propagating contexts will be skipped,\n   * unless the context at that exact depth is retrieved.\n   *\n   * This ONLY takes into account context propagation logic,\n   * so this should usually not be called directly,\n   * call {@link #getContext} instead.\n   *\n   * @param keys The path of keys to get the context at.\n   * @return {Promise<{ context: JsonLdContextNormalized, depth: number }>} A context and its depth.\n   */\n\n\n  async getContextPropagationAware(keys) {\n    const originalDepth = keys.length;\n    let contextData = null;\n    let hasApplicablePropertyScopedContext;\n\n    do {\n      hasApplicablePropertyScopedContext = false;\n\n      if (contextData && '@__propagateFallback' in contextData.context.getContextRaw()) {\n        // If a propagation fallback context has been set,\n        // fallback to that context and retry for the same depth.\n        contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized(contextData.context.getContextRaw()['@__propagateFallback']);\n      } else {\n        if (contextData) {\n          // If we had a previous iteration, jump to the parent of context depth.\n          // We must do this because once we get here, last context had propagation disabled,\n          // so we check its first parent instead.\n          keys = keys.slice(0, contextData.depth - 1);\n        }\n\n        contextData = (await this.contextTree.getContext(keys)) || {\n          context: await this.rootContext,\n          depth: 0\n        };\n      } // Allow non-propagating contexts to propagate one level deeper\n      // if it defines a property-scoped context that is applicable for the current key.\n      // @see https://w3c.github.io/json-ld-api/tests/toRdf-manifest#tc012\n\n\n      const lastKey = keys[keys.length - 1];\n\n      if (lastKey in contextData.context.getContextRaw()) {\n        const lastKeyValue = contextData.context.getContextRaw()[lastKey];\n\n        if (lastKeyValue && typeof lastKeyValue === 'object' && '@context' in lastKeyValue) {\n          hasApplicablePropertyScopedContext = true;\n        }\n      }\n    } while (contextData.depth > 0 // Root context has a special case\n    && contextData.context.getContextRaw()['@propagate'] === false // Stop loop if propagation is true\n    && contextData.depth !== originalDepth // Stop loop if requesting exact depth of non-propagating\n    && !hasApplicablePropertyScopedContext); // Special case for root context that does not allow propagation.\n    // Fallback to empty context in that case.\n\n\n    if (contextData.depth === 0 && contextData.context.getContextRaw()['@propagate'] === false && contextData.depth !== originalDepth) {\n      contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized({});\n    }\n\n    return contextData;\n  }\n  /**\n   * Start a new job for parsing the given value.\n   * @param {any[]} keys The stack of keys.\n   * @param value The value to parse.\n   * @param {number} depth The depth to parse at.\n   * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.\n   * @return {Promise<void>} A promise resolving when the job is done.\n   */\n\n\n  async newOnValueJob(keys, value, depth, lastDepthCheck) {\n    await this.parser.newOnValueJob(keys, value, depth, lastDepthCheck);\n  }\n  /**\n   * Flush the pending container flush buffers\n   * @return {boolean} If any pending buffers were flushed.\n   */\n\n\n  async handlePendingContainerFlushBuffers() {\n    if (this.pendingContainerFlushBuffers.length > 0) {\n      for (const pendingFlushBuffer of this.pendingContainerFlushBuffers) {\n        await this.parser.flushBuffer(pendingFlushBuffer.depth, pendingFlushBuffer.keys);\n        this.parser.flushStacks(pendingFlushBuffer.depth);\n      }\n\n      this.pendingContainerFlushBuffers.splice(0, this.pendingContainerFlushBuffers.length);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Emit the given quad into the output stream.\n   * @param {number} depth The depth the quad was generated at.\n   * @param {Quad} quad A quad to emit.\n   */\n\n\n  emitQuad(depth, quad) {\n    if (depth === 1) {\n      this.topLevelProperties = true;\n    }\n\n    this.parser.push(quad);\n  }\n  /**\n   * Emit the given error into the output stream.\n   * @param {Error} error An error to emit.\n   */\n\n\n  emitError(error) {\n    this.parser.emit('error', error);\n  }\n  /**\n   * Emit the given context into the output stream under the 'context' event.\n   * @param {JsonLdContext} context A context to emit.\n   */\n\n\n  emitContext(context) {\n    this.parser.emit('context', context);\n  }\n  /**\n   * Safely get or create the depth value of {@link ParsingContext.unidentifiedValuesBuffer}.\n   * @param {number} depth A depth.\n   * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of\n   *                                                               {@link ParsingContext.unidentifiedValuesBuffer}.\n   */\n\n\n  getUnidentifiedValueBufferSafe(depth) {\n    let buffer = this.unidentifiedValuesBuffer[depth];\n\n    if (!buffer) {\n      buffer = [];\n      this.unidentifiedValuesBuffer[depth] = buffer;\n    }\n\n    return buffer;\n  }\n  /**\n   * Safely get or create the depth value of {@link ParsingContext.unidentifiedGraphsBuffer}.\n   * @param {number} depth A depth.\n   * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of\n   *                                                               {@link ParsingContext.unidentifiedGraphsBuffer}.\n   */\n\n\n  getUnidentifiedGraphBufferSafe(depth) {\n    let buffer = this.unidentifiedGraphsBuffer[depth];\n\n    if (!buffer) {\n      buffer = [];\n      this.unidentifiedGraphsBuffer[depth] = buffer;\n    }\n\n    return buffer;\n  }\n  /**\n   * @return IExpandOptions The expand options for the active processing mode.\n   */\n\n\n  getExpandOptions() {\n    return ParsingContext.EXPAND_OPTIONS[this.activeProcessingMode];\n  }\n  /**\n   * Shift the stack at the given offset to the given depth.\n   *\n   * This will override anything in the stack at `depth`,\n   * and this will remove anything at `depth + depthOffset`\n   *\n   * @param depth The target depth.\n   * @param depthOffset The origin depth, relative to `depth`.\n   */\n\n\n  shiftStack(depth, depthOffset) {\n    // Copy the id stack value up one level so that the next job can access the id.\n    const deeperIdStack = this.idStack[depth + depthOffset];\n\n    if (deeperIdStack) {\n      this.idStack[depth] = deeperIdStack;\n      this.emittedStack[depth] = true;\n      delete this.idStack[depth + depthOffset];\n    } // Shorten key stack\n\n\n    if (this.pendingContainerFlushBuffers.length) {\n      for (const buffer of this.pendingContainerFlushBuffers) {\n        if (buffer.depth >= depth + depthOffset) {\n          buffer.depth -= depthOffset;\n          buffer.keys.splice(depth, depthOffset);\n        }\n      }\n    } // Splice stacks\n\n\n    if (this.unidentifiedValuesBuffer[depth + depthOffset]) {\n      this.unidentifiedValuesBuffer[depth] = this.unidentifiedValuesBuffer[depth + depthOffset];\n      delete this.unidentifiedValuesBuffer[depth + depthOffset];\n    } // TODO: also do the same for other stacks\n\n  }\n\n}\n\nexports.ParsingContext = ParsingContext;\nParsingContext.EXPAND_OPTIONS = {\n  1.0: {\n    allowPrefixForcing: false,\n    allowPrefixNonGenDelims: false,\n    allowVocabRelativeToBase: false\n  },\n  1.1: {\n    allowPrefixForcing: true,\n    allowPrefixNonGenDelims: false,\n    allowVocabRelativeToBase: true\n  }\n};","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-parser/lib/ParsingContext.js"],"names":["Object","defineProperty","exports","value","ParsingContext","jsonld_context_parser_1","require","ErrorCoded_1","ContextTree_1","JsonLdParser_1","constructor","options","contextParser","ContextParser","documentLoader","skipValidation","skipContextValidation","streamingProfile","baseIRI","produceGeneralizedRdf","allowSubjectList","processingMode","JsonLdParser","DEFAULT_PROCESSING_MODE","strictValues","validateValueIndexes","defaultGraph","rdfDirection","normalizeLanguageTags","streamingProfileAllowOutOfOrderPlainType","topLevelProperties","activeProcessingMode","parseFloat","processingStack","processingType","emittedStack","idStack","graphStack","graphContainerTermStack","listPointerStack","contextTree","ContextTree","literalStack","validationStack","unaliasedKeywordCacheStack","jsonLiteralStack","unidentifiedValuesBuffer","unidentifiedGraphsBuffer","pendingContainerFlushBuffers","parser","context","rootContext","parseContext","then","validateContext","Promise","resolve","JsonLdContextNormalized","parentContext","ignoreProtection","parse","activeVersion","getContextRaw","ErrorCoded","ERROR_CODES","PROCESSING_MODE_CONFLICT","INVALID_VERSION_VALUE","getContext","keys","offset","keysOriginal","length","slice","contextData","getContextPropagationAware","contextRaw","i","depth","key","contextKeyEntry","scopedContext","propagate","assign","setContext","originalDepth","hasApplicablePropertyScopedContext","lastKey","lastKeyValue","newOnValueJob","lastDepthCheck","handlePendingContainerFlushBuffers","pendingFlushBuffer","flushBuffer","flushStacks","splice","emitQuad","quad","push","emitError","error","emit","emitContext","getUnidentifiedValueBufferSafe","buffer","getUnidentifiedGraphBufferSafe","getExpandOptions","EXPAND_OPTIONS","shiftStack","depthOffset","deeperIdStack","allowPrefixForcing","allowPrefixNonGenDelims","allowVocabRelativeToBase"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,cAAR,GAAyB,KAAK,CAA9B;;AACA,MAAMC,uBAAuB,GAAGC,OAAO,CAAC,uBAAD,CAAvC;;AACA,MAAMC,YAAY,GAAGD,OAAO,CAAC,sCAAD,CAA5B;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,eAAD,CAA7B;;AACA,MAAMG,cAAc,GAAGH,OAAO,CAAC,gBAAD,CAA9B;AACA;AACA;AACA;;;AACA,MAAMF,cAAN,CAAqB;AACjBM,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB;AACA,SAAKC,aAAL,GAAqB,IAAIP,uBAAuB,CAACQ,aAA5B,CAA0C;AAAEC,MAAAA,cAAc,EAAEH,OAAO,CAACG,cAA1B;AAA0CC,MAAAA,cAAc,EAAEJ,OAAO,CAACK;AAAlE,KAA1C,CAArB;AACA,SAAKC,gBAAL,GAAwB,CAAC,CAACN,OAAO,CAACM,gBAAlC;AACA,SAAKC,OAAL,GAAeP,OAAO,CAACO,OAAvB;AACA,SAAKC,qBAAL,GAA6B,CAAC,CAACR,OAAO,CAACQ,qBAAvC;AACA,SAAKC,gBAAL,GAAwB,CAAC,CAACT,OAAO,CAACS,gBAAlC;AACA,SAAKC,cAAL,GAAsBV,OAAO,CAACU,cAAR,IAA0BZ,cAAc,CAACa,YAAf,CAA4BC,uBAA5E;AACA,SAAKC,YAAL,GAAoB,CAAC,CAACb,OAAO,CAACa,YAA9B;AACA,SAAKC,oBAAL,GAA4B,CAAC,CAACd,OAAO,CAACc,oBAAtC;AACA,SAAKC,YAAL,GAAoBf,OAAO,CAACe,YAA5B;AACA,SAAKC,YAAL,GAAoBhB,OAAO,CAACgB,YAA5B;AACA,SAAKC,qBAAL,GAA6BjB,OAAO,CAACiB,qBAArC;AACA,SAAKC,wCAAL,GAAgDlB,OAAO,CAACkB,wCAAxD;AACA,SAAKC,kBAAL,GAA0B,KAA1B;AACA,SAAKC,oBAAL,GAA4BC,UAAU,CAAC,KAAKX,cAAN,CAAtC,CAfiB,CAgBjB;;AACA,SAAKY,eAAL,GAAuB,EAAvB;AACA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,uBAAL,GAA+B,EAA/B;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKC,WAAL,GAAmB,IAAIhC,aAAa,CAACiC,WAAlB,EAAnB;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,eAAL,GAAuB,EAAvB;AACA,SAAKC,0BAAL,GAAkC,EAAlC;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKC,wBAAL,GAAgC,EAAhC;AACA,SAAKC,wBAAL,GAAgC,EAAhC;AACA,SAAKC,4BAAL,GAAoC,EAApC;AACA,SAAKC,MAAL,GAActC,OAAO,CAACsC,MAAtB;;AACA,QAAItC,OAAO,CAACuC,OAAZ,EAAqB;AACjB,WAAKC,WAAL,GAAmB,KAAKC,YAAL,CAAkBzC,OAAO,CAACuC,OAA1B,CAAnB;AACA,WAAKC,WAAL,CAAiBE,IAAjB,CAAuBH,OAAD,IAAa,KAAKI,eAAL,CAAqBJ,OAArB,CAAnC;AACH,KAHD,MAIK;AACD,WAAKC,WAAL,GAAmBI,OAAO,CAACC,OAAR,CAAgB,IAAInD,uBAAuB,CAACoD,uBAA5B,CAAoD,KAAKvC,OAAL,GAAe;AAAE,iBAAS,KAAKA,OAAhB;AAAyB,2BAAmB;AAA5C,OAAf,GAAoE,EAAxH,CAAhB,CAAnB;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACsB,QAAZkC,YAAY,CAACF,OAAD,EAAUQ,aAAV,EAAyBC,gBAAzB,EAA2C;AACzD,WAAO,KAAK/C,aAAL,CAAmBgD,KAAnB,CAAyBV,OAAzB,EAAkC;AACrChC,MAAAA,OAAO,EAAE,KAAKA,OADuB;AAErCyC,MAAAA,gBAFqC;AAGrC/B,MAAAA,qBAAqB,EAAE,KAAKA,qBAHS;AAIrC8B,MAAAA,aAJqC;AAKrCrC,MAAAA,cAAc,EAAE,KAAKU;AALgB,KAAlC,CAAP;AAOH;AACD;AACJ;AACA;AACA;AACA;;;AACIuB,EAAAA,eAAe,CAACJ,OAAD,EAAU;AACrB,UAAMW,aAAa,GAAGX,OAAO,CAACY,aAAR,GAAwB,UAAxB,CAAtB;;AACA,QAAID,aAAJ,EAAmB;AACf,UAAI,KAAK9B,oBAAL,IAA6B8B,aAAa,GAAG,KAAK9B,oBAAtD,EAA4E;AACxE,cAAM,IAAIxB,YAAY,CAACwD,UAAjB,CAA6B,gCAA+BF,aAAc,kCAAiC,KAAK9B,oBAAqB,GAArI,EAAyIxB,YAAY,CAACyD,WAAb,CAAyBC,wBAAlK,CAAN;AACH,OAFD,MAGK;AACD,YAAI,KAAKlC,oBAAL,IAA6B8B,aAAa,GAAG,KAAK9B,oBAAtD,EAA4E;AACxE,gBAAM,IAAIxB,YAAY,CAACwD,UAAjB,CAA6B,2BAA0BF,aAAc,iCAAgC,KAAK9B,oBAAqB,GAA/H,EAAmIxB,YAAY,CAACyD,WAAb,CAAyBE,qBAA5J,CAAN;AACH;;AACD,aAAKnC,oBAAL,GAA4B8B,aAA5B;AACH;AACJ;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACoB,QAAVM,UAAU,CAACC,IAAD,EAAOC,MAAM,GAAG,CAAhB,EAAmB;AAC/B,UAAMC,YAAY,GAAGF,IAArB,CAD+B,CAE/B;;AACA,WAAO,OAAOA,IAAI,CAACA,IAAI,CAACG,MAAL,GAAc,CAAf,CAAX,KAAiC,QAAxC,EAAkD;AAC9CH,MAAAA,IAAI,GAAGA,IAAI,CAACI,KAAL,CAAW,CAAX,EAAcJ,IAAI,CAACG,MAAL,GAAc,CAA5B,CAAP;AACH,KAL8B,CAM/B;;;AACA,QAAIF,MAAJ,EAAY;AACRD,MAAAA,IAAI,GAAGA,IAAI,CAACI,KAAL,CAAW,CAAX,EAAc,CAACH,MAAf,CAAP;AACH,KAT8B,CAU/B;;;AACA,UAAMI,WAAW,GAAG,MAAM,KAAKC,0BAAL,CAAgCN,IAAhC,CAA1B;AACA,UAAMlB,OAAO,GAAGuB,WAAW,CAACvB,OAA5B,CAZ+B,CAa/B;;AACA,QAAIyB,UAAU,GAAGzB,OAAO,CAACY,aAAR,EAAjB;;AACA,SAAK,IAAIc,CAAC,GAAGH,WAAW,CAACI,KAAzB,EAAgCD,CAAC,GAAGN,YAAY,CAACC,MAAb,GAAsBF,MAA1D,EAAkEO,CAAC,EAAnE,EAAuE;AACnE,YAAME,GAAG,GAAGR,YAAY,CAACM,CAAD,CAAxB;AACA,YAAMG,eAAe,GAAGJ,UAAU,CAACG,GAAD,CAAlC;;AACA,UAAIC,eAAe,IAAI,OAAOA,eAAP,KAA2B,QAA9C,IAA0D,cAAcA,eAA5E,EAA6F;AACzF,cAAMC,aAAa,GAAG,CAAC,MAAM,KAAK5B,YAAL,CAAkB2B,eAAlB,EAAmCJ,UAAnC,EAA+C,IAA/C,CAAP,EAA6Db,aAA7D,EAAtB;AACA,cAAMmB,SAAS,GAAG,EAAEH,GAAG,IAAIE,aAAT,KACXA,aAAa,CAACF,GAAD,CAAb,CAAmB,UAAnB,EAA+B,YAA/B,CADP,CAFyF,CAGpC;;AACrD,YAAIG,SAAS,KAAK,KAAd,IAAuBL,CAAC,KAAKN,YAAY,CAACC,MAAb,GAAsB,CAAtB,GAA0BF,MAA3D,EAAmE;AAC/DM,UAAAA,UAAU,GAAGK,aAAb,CAD+D,CAE/D;;AACA,iBAAOL,UAAU,CAAC,YAAD,CAAjB;AACAA,UAAAA,UAAU,CAACG,GAAD,CAAV,GAAkB9E,MAAM,CAACkF,MAAP,CAAc,EAAd,EAAkBP,UAAU,CAACG,GAAD,CAA5B,CAAlB;;AACA,cAAI,SAASC,eAAb,EAA8B;AAC1BJ,YAAAA,UAAU,CAACG,GAAD,CAAV,CAAgB,KAAhB,IAAyBC,eAAe,CAAC,KAAD,CAAxC;AACH;;AACD,iBAAOJ,UAAU,CAACG,GAAD,CAAV,CAAgB,UAAhB,CAAP;;AACA,cAAIG,SAAS,KAAK,KAAlB,EAAyB;AACrB,iBAAKzC,WAAL,CAAiB2C,UAAjB,CAA4Bb,YAAY,CAACE,KAAb,CAAmB,CAAnB,EAAsBI,CAAC,GAAGP,MAA1B,CAA5B,EAA+Dd,OAAO,CAACC,OAAR,CAAgB,IAAInD,uBAAuB,CAACoD,uBAA5B,CAAoDkB,UAApD,CAAhB,CAA/D;AACH;AACJ;AACJ;AACJ;;AACD,WAAO,IAAItE,uBAAuB,CAACoD,uBAA5B,CAAoDkB,UAApD,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACoC,QAA1BD,0BAA0B,CAACN,IAAD,EAAO;AACnC,UAAMgB,aAAa,GAAGhB,IAAI,CAACG,MAA3B;AACA,QAAIE,WAAW,GAAG,IAAlB;AACA,QAAIY,kCAAJ;;AACA,OAAG;AACCA,MAAAA,kCAAkC,GAAG,KAArC;;AACA,UAAIZ,WAAW,IAAI,0BAA0BA,WAAW,CAACvB,OAAZ,CAAoBY,aAApB,EAA7C,EAAkF;AAC9E;AACA;AACAW,QAAAA,WAAW,CAACvB,OAAZ,GAAsB,IAAI7C,uBAAuB,CAACoD,uBAA5B,CAAoDgB,WAAW,CAACvB,OAAZ,CAAoBY,aAApB,GAAoC,sBAApC,CAApD,CAAtB;AACH,OAJD,MAKK;AACD,YAAIW,WAAJ,EAAiB;AACb;AACA;AACA;AACAL,UAAAA,IAAI,GAAGA,IAAI,CAACI,KAAL,CAAW,CAAX,EAAcC,WAAW,CAACI,KAAZ,GAAoB,CAAlC,CAAP;AACH;;AACDJ,QAAAA,WAAW,GAAG,OAAM,KAAKjC,WAAL,CAAiB2B,UAAjB,CAA4BC,IAA5B,CAAN,KAA2C;AAAElB,UAAAA,OAAO,EAAE,MAAM,KAAKC,WAAtB;AAAmC0B,UAAAA,KAAK,EAAE;AAA1C,SAAzD;AACH,OAfF,CAgBC;AACA;AACA;;;AACA,YAAMS,OAAO,GAAGlB,IAAI,CAACA,IAAI,CAACG,MAAL,GAAc,CAAf,CAApB;;AACA,UAAIe,OAAO,IAAIb,WAAW,CAACvB,OAAZ,CAAoBY,aAApB,EAAf,EAAoD;AAChD,cAAMyB,YAAY,GAAGd,WAAW,CAACvB,OAAZ,CAAoBY,aAApB,GAAoCwB,OAApC,CAArB;;AACA,YAAIC,YAAY,IAAI,OAAOA,YAAP,KAAwB,QAAxC,IAAoD,cAAcA,YAAtE,EAAoF;AAChFF,UAAAA,kCAAkC,GAAG,IAArC;AACH;AACJ;AACJ,KA1BD,QA0BSZ,WAAW,CAACI,KAAZ,GAAoB,CAApB,CAAsB;AAAtB,OACFJ,WAAW,CAACvB,OAAZ,CAAoBY,aAApB,GAAoC,YAApC,MAAsD,KADpD,CAC0D;AAD1D,OAEFW,WAAW,CAACI,KAAZ,KAAsBO,aAFpB,CAEkC;AAFlC,OAGF,CAACC,kCA7BR,EAJmC,CAkCnC;AACA;;;AACA,QAAIZ,WAAW,CAACI,KAAZ,KAAsB,CAAtB,IACGJ,WAAW,CAACvB,OAAZ,CAAoBY,aAApB,GAAoC,YAApC,MAAsD,KADzD,IAEGW,WAAW,CAACI,KAAZ,KAAsBO,aAF7B,EAE4C;AACxCX,MAAAA,WAAW,CAACvB,OAAZ,GAAsB,IAAI7C,uBAAuB,CAACoD,uBAA5B,CAAoD,EAApD,CAAtB;AACH;;AACD,WAAOgB,WAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACuB,QAAbe,aAAa,CAACpB,IAAD,EAAOjE,KAAP,EAAc0E,KAAd,EAAqBY,cAArB,EAAqC;AACpD,UAAM,KAAKxC,MAAL,CAAYuC,aAAZ,CAA0BpB,IAA1B,EAAgCjE,KAAhC,EAAuC0E,KAAvC,EAA8CY,cAA9C,CAAN;AACH;AACD;AACJ;AACA;AACA;;;AAC4C,QAAlCC,kCAAkC,GAAG;AACvC,QAAI,KAAK1C,4BAAL,CAAkCuB,MAAlC,GAA2C,CAA/C,EAAkD;AAC9C,WAAK,MAAMoB,kBAAX,IAAiC,KAAK3C,4BAAtC,EAAoE;AAChE,cAAM,KAAKC,MAAL,CAAY2C,WAAZ,CAAwBD,kBAAkB,CAACd,KAA3C,EAAkDc,kBAAkB,CAACvB,IAArE,CAAN;AACA,aAAKnB,MAAL,CAAY4C,WAAZ,CAAwBF,kBAAkB,CAACd,KAA3C;AACH;;AACD,WAAK7B,4BAAL,CAAkC8C,MAAlC,CAAyC,CAAzC,EAA4C,KAAK9C,4BAAL,CAAkCuB,MAA9E;AACA,aAAO,IAAP;AACH,KAPD,MAQK;AACD,aAAO,KAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACIwB,EAAAA,QAAQ,CAAClB,KAAD,EAAQmB,IAAR,EAAc;AAClB,QAAInB,KAAK,KAAK,CAAd,EAAiB;AACb,WAAK/C,kBAAL,GAA0B,IAA1B;AACH;;AACD,SAAKmB,MAAL,CAAYgD,IAAZ,CAAiBD,IAAjB;AACH;AACD;AACJ;AACA;AACA;;;AACIE,EAAAA,SAAS,CAACC,KAAD,EAAQ;AACb,SAAKlD,MAAL,CAAYmD,IAAZ,CAAiB,OAAjB,EAA0BD,KAA1B;AACH;AACD;AACJ;AACA;AACA;;;AACIE,EAAAA,WAAW,CAACnD,OAAD,EAAU;AACjB,SAAKD,MAAL,CAAYmD,IAAZ,CAAiB,SAAjB,EAA4BlD,OAA5B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIoD,EAAAA,8BAA8B,CAACzB,KAAD,EAAQ;AAClC,QAAI0B,MAAM,GAAG,KAAKzD,wBAAL,CAA8B+B,KAA9B,CAAb;;AACA,QAAI,CAAC0B,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,EAAT;AACA,WAAKzD,wBAAL,CAA8B+B,KAA9B,IAAuC0B,MAAvC;AACH;;AACD,WAAOA,MAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,8BAA8B,CAAC3B,KAAD,EAAQ;AAClC,QAAI0B,MAAM,GAAG,KAAKxD,wBAAL,CAA8B8B,KAA9B,CAAb;;AACA,QAAI,CAAC0B,MAAL,EAAa;AACTA,MAAAA,MAAM,GAAG,EAAT;AACA,WAAKxD,wBAAL,CAA8B8B,KAA9B,IAAuC0B,MAAvC;AACH;;AACD,WAAOA,MAAP;AACH;AACD;AACJ;AACA;;;AACIE,EAAAA,gBAAgB,GAAG;AACf,WAAOrG,cAAc,CAACsG,cAAf,CAA8B,KAAK3E,oBAAnC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI4E,EAAAA,UAAU,CAAC9B,KAAD,EAAQ+B,WAAR,EAAqB;AAC3B;AACA,UAAMC,aAAa,GAAG,KAAKzE,OAAL,CAAayC,KAAK,GAAG+B,WAArB,CAAtB;;AACA,QAAIC,aAAJ,EAAmB;AACf,WAAKzE,OAAL,CAAayC,KAAb,IAAsBgC,aAAtB;AACA,WAAK1E,YAAL,CAAkB0C,KAAlB,IAA2B,IAA3B;AACA,aAAO,KAAKzC,OAAL,CAAayC,KAAK,GAAG+B,WAArB,CAAP;AACH,KAP0B,CAQ3B;;;AACA,QAAI,KAAK5D,4BAAL,CAAkCuB,MAAtC,EAA8C;AAC1C,WAAK,MAAMgC,MAAX,IAAqB,KAAKvD,4BAA1B,EAAwD;AACpD,YAAIuD,MAAM,CAAC1B,KAAP,IAAgBA,KAAK,GAAG+B,WAA5B,EAAyC;AACrCL,UAAAA,MAAM,CAAC1B,KAAP,IAAgB+B,WAAhB;AACAL,UAAAA,MAAM,CAACnC,IAAP,CAAY0B,MAAZ,CAAmBjB,KAAnB,EAA0B+B,WAA1B;AACH;AACJ;AACJ,KAhB0B,CAiB3B;;;AACA,QAAI,KAAK9D,wBAAL,CAA8B+B,KAAK,GAAG+B,WAAtC,CAAJ,EAAwD;AACpD,WAAK9D,wBAAL,CAA8B+B,KAA9B,IAAuC,KAAK/B,wBAAL,CAA8B+B,KAAK,GAAG+B,WAAtC,CAAvC;AACA,aAAO,KAAK9D,wBAAL,CAA8B+B,KAAK,GAAG+B,WAAtC,CAAP;AACH,KArB0B,CAsB3B;;AACH;;AAxSgB;;AA0SrB1G,OAAO,CAACE,cAAR,GAAyBA,cAAzB;AACAA,cAAc,CAACsG,cAAf,GAAgC;AAC5B,OAAK;AACDI,IAAAA,kBAAkB,EAAE,KADnB;AAEDC,IAAAA,uBAAuB,EAAE,KAFxB;AAGDC,IAAAA,wBAAwB,EAAE;AAHzB,GADuB;AAM5B,OAAK;AACDF,IAAAA,kBAAkB,EAAE,IADnB;AAEDC,IAAAA,uBAAuB,EAAE,KAFxB;AAGDC,IAAAA,wBAAwB,EAAE;AAHzB;AANuB,CAAhC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParsingContext = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst ErrorCoded_1 = require(\"jsonld-context-parser/lib/ErrorCoded\");\nconst ContextTree_1 = require(\"./ContextTree\");\nconst JsonLdParser_1 = require(\"./JsonLdParser\");\n/**\n * Data holder for parsing information.\n */\nclass ParsingContext {\n    constructor(options) {\n        // Initialize settings\n        this.contextParser = new jsonld_context_parser_1.ContextParser({ documentLoader: options.documentLoader, skipValidation: options.skipContextValidation });\n        this.streamingProfile = !!options.streamingProfile;\n        this.baseIRI = options.baseIRI;\n        this.produceGeneralizedRdf = !!options.produceGeneralizedRdf;\n        this.allowSubjectList = !!options.allowSubjectList;\n        this.processingMode = options.processingMode || JsonLdParser_1.JsonLdParser.DEFAULT_PROCESSING_MODE;\n        this.strictValues = !!options.strictValues;\n        this.validateValueIndexes = !!options.validateValueIndexes;\n        this.defaultGraph = options.defaultGraph;\n        this.rdfDirection = options.rdfDirection;\n        this.normalizeLanguageTags = options.normalizeLanguageTags;\n        this.streamingProfileAllowOutOfOrderPlainType = options.streamingProfileAllowOutOfOrderPlainType;\n        this.topLevelProperties = false;\n        this.activeProcessingMode = parseFloat(this.processingMode);\n        // Initialize stacks\n        this.processingStack = [];\n        this.processingType = [];\n        this.emittedStack = [];\n        this.idStack = [];\n        this.graphStack = [];\n        this.graphContainerTermStack = [];\n        this.listPointerStack = [];\n        this.contextTree = new ContextTree_1.ContextTree();\n        this.literalStack = [];\n        this.validationStack = [];\n        this.unaliasedKeywordCacheStack = [];\n        this.jsonLiteralStack = [];\n        this.unidentifiedValuesBuffer = [];\n        this.unidentifiedGraphsBuffer = [];\n        this.pendingContainerFlushBuffers = [];\n        this.parser = options.parser;\n        if (options.context) {\n            this.rootContext = this.parseContext(options.context);\n            this.rootContext.then((context) => this.validateContext(context));\n        }\n        else {\n            this.rootContext = Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(this.baseIRI ? { '@base': this.baseIRI, '@__baseDocument': true } : {}));\n        }\n    }\n    /**\n     * Parse the given context with the configured options.\n     * @param {JsonLdContext} context A context to parse.\n     * @param {JsonLdContextNormalized} parentContext An optional parent context.\n     * @param {boolean} ignoreProtection If @protected term checks should be ignored.\n     * @return {Promise<JsonLdContextNormalized>} A promise resolving to the parsed context.\n     */\n    async parseContext(context, parentContext, ignoreProtection) {\n        return this.contextParser.parse(context, {\n            baseIRI: this.baseIRI,\n            ignoreProtection,\n            normalizeLanguageTags: this.normalizeLanguageTags,\n            parentContext,\n            processingMode: this.activeProcessingMode,\n        });\n    }\n    /**\n     * Check if the given context is valid.\n     * If not, an error will be thrown.\n     * @param {JsonLdContextNormalized} context A context.\n     */\n    validateContext(context) {\n        const activeVersion = context.getContextRaw()['@version'];\n        if (activeVersion) {\n            if (this.activeProcessingMode && activeVersion > this.activeProcessingMode) {\n                throw new ErrorCoded_1.ErrorCoded(`Unsupported JSON-LD version '${activeVersion}' under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.PROCESSING_MODE_CONFLICT);\n            }\n            else {\n                if (this.activeProcessingMode && activeVersion < this.activeProcessingMode) {\n                    throw new ErrorCoded_1.ErrorCoded(`Invalid JSON-LD version ${activeVersion} under active processing mode ${this.activeProcessingMode}.`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n                }\n                this.activeProcessingMode = activeVersion;\n            }\n        }\n    }\n    /**\n     * Get the context at the given path.\n     * @param {keys} keys The path of keys to get the context at.\n     * @param {number} offset The path offset, defaults to 1.\n     * @return {Promise<JsonLdContextNormalized>} A promise resolving to a context.\n     */\n    async getContext(keys, offset = 1) {\n        const keysOriginal = keys;\n        // Ignore array keys at the end\n        while (typeof keys[keys.length - 1] === 'number') {\n            keys = keys.slice(0, keys.length - 1);\n        }\n        // Handle offset on keys\n        if (offset) {\n            keys = keys.slice(0, -offset);\n        }\n        // Determine the closest context\n        const contextData = await this.getContextPropagationAware(keys);\n        const context = contextData.context;\n        // Process property-scoped contexts (high-to-low)\n        let contextRaw = context.getContextRaw();\n        for (let i = contextData.depth; i < keysOriginal.length - offset; i++) {\n            const key = keysOriginal[i];\n            const contextKeyEntry = contextRaw[key];\n            if (contextKeyEntry && typeof contextKeyEntry === 'object' && '@context' in contextKeyEntry) {\n                const scopedContext = (await this.parseContext(contextKeyEntry, contextRaw, true)).getContextRaw();\n                const propagate = !(key in scopedContext)\n                    || scopedContext[key]['@context']['@propagate']; // Propagation is true by default\n                if (propagate !== false || i === keysOriginal.length - 1 - offset) {\n                    contextRaw = scopedContext;\n                    // Clean up final context\n                    delete contextRaw['@propagate'];\n                    contextRaw[key] = Object.assign({}, contextRaw[key]);\n                    if ('@id' in contextKeyEntry) {\n                        contextRaw[key]['@id'] = contextKeyEntry['@id'];\n                    }\n                    delete contextRaw[key]['@context'];\n                    if (propagate !== false) {\n                        this.contextTree.setContext(keysOriginal.slice(0, i + offset), Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw)));\n                    }\n                }\n            }\n        }\n        return new jsonld_context_parser_1.JsonLdContextNormalized(contextRaw);\n    }\n    /**\n     * Get the context at the given path.\n     * Non-propagating contexts will be skipped,\n     * unless the context at that exact depth is retrieved.\n     *\n     * This ONLY takes into account context propagation logic,\n     * so this should usually not be called directly,\n     * call {@link #getContext} instead.\n     *\n     * @param keys The path of keys to get the context at.\n     * @return {Promise<{ context: JsonLdContextNormalized, depth: number }>} A context and its depth.\n     */\n    async getContextPropagationAware(keys) {\n        const originalDepth = keys.length;\n        let contextData = null;\n        let hasApplicablePropertyScopedContext;\n        do {\n            hasApplicablePropertyScopedContext = false;\n            if (contextData && '@__propagateFallback' in contextData.context.getContextRaw()) {\n                // If a propagation fallback context has been set,\n                // fallback to that context and retry for the same depth.\n                contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized(contextData.context.getContextRaw()['@__propagateFallback']);\n            }\n            else {\n                if (contextData) {\n                    // If we had a previous iteration, jump to the parent of context depth.\n                    // We must do this because once we get here, last context had propagation disabled,\n                    // so we check its first parent instead.\n                    keys = keys.slice(0, contextData.depth - 1);\n                }\n                contextData = await this.contextTree.getContext(keys) || { context: await this.rootContext, depth: 0 };\n            }\n            // Allow non-propagating contexts to propagate one level deeper\n            // if it defines a property-scoped context that is applicable for the current key.\n            // @see https://w3c.github.io/json-ld-api/tests/toRdf-manifest#tc012\n            const lastKey = keys[keys.length - 1];\n            if (lastKey in contextData.context.getContextRaw()) {\n                const lastKeyValue = contextData.context.getContextRaw()[lastKey];\n                if (lastKeyValue && typeof lastKeyValue === 'object' && '@context' in lastKeyValue) {\n                    hasApplicablePropertyScopedContext = true;\n                }\n            }\n        } while (contextData.depth > 0 // Root context has a special case\n            && contextData.context.getContextRaw()['@propagate'] === false // Stop loop if propagation is true\n            && contextData.depth !== originalDepth // Stop loop if requesting exact depth of non-propagating\n            && !hasApplicablePropertyScopedContext);\n        // Special case for root context that does not allow propagation.\n        // Fallback to empty context in that case.\n        if (contextData.depth === 0\n            && contextData.context.getContextRaw()['@propagate'] === false\n            && contextData.depth !== originalDepth) {\n            contextData.context = new jsonld_context_parser_1.JsonLdContextNormalized({});\n        }\n        return contextData;\n    }\n    /**\n     * Start a new job for parsing the given value.\n     * @param {any[]} keys The stack of keys.\n     * @param value The value to parse.\n     * @param {number} depth The depth to parse at.\n     * @param {boolean} lastDepthCheck If the lastDepth check should be done for buffer draining.\n     * @return {Promise<void>} A promise resolving when the job is done.\n     */\n    async newOnValueJob(keys, value, depth, lastDepthCheck) {\n        await this.parser.newOnValueJob(keys, value, depth, lastDepthCheck);\n    }\n    /**\n     * Flush the pending container flush buffers\n     * @return {boolean} If any pending buffers were flushed.\n     */\n    async handlePendingContainerFlushBuffers() {\n        if (this.pendingContainerFlushBuffers.length > 0) {\n            for (const pendingFlushBuffer of this.pendingContainerFlushBuffers) {\n                await this.parser.flushBuffer(pendingFlushBuffer.depth, pendingFlushBuffer.keys);\n                this.parser.flushStacks(pendingFlushBuffer.depth);\n            }\n            this.pendingContainerFlushBuffers.splice(0, this.pendingContainerFlushBuffers.length);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * Emit the given quad into the output stream.\n     * @param {number} depth The depth the quad was generated at.\n     * @param {Quad} quad A quad to emit.\n     */\n    emitQuad(depth, quad) {\n        if (depth === 1) {\n            this.topLevelProperties = true;\n        }\n        this.parser.push(quad);\n    }\n    /**\n     * Emit the given error into the output stream.\n     * @param {Error} error An error to emit.\n     */\n    emitError(error) {\n        this.parser.emit('error', error);\n    }\n    /**\n     * Emit the given context into the output stream under the 'context' event.\n     * @param {JsonLdContext} context A context to emit.\n     */\n    emitContext(context) {\n        this.parser.emit('context', context);\n    }\n    /**\n     * Safely get or create the depth value of {@link ParsingContext.unidentifiedValuesBuffer}.\n     * @param {number} depth A depth.\n     * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of\n     *                                                               {@link ParsingContext.unidentifiedValuesBuffer}.\n     */\n    getUnidentifiedValueBufferSafe(depth) {\n        let buffer = this.unidentifiedValuesBuffer[depth];\n        if (!buffer) {\n            buffer = [];\n            this.unidentifiedValuesBuffer[depth] = buffer;\n        }\n        return buffer;\n    }\n    /**\n     * Safely get or create the depth value of {@link ParsingContext.unidentifiedGraphsBuffer}.\n     * @param {number} depth A depth.\n     * @return {{predicate: Term; object: Term; reverse: boolean}[]} An element of\n     *                                                               {@link ParsingContext.unidentifiedGraphsBuffer}.\n     */\n    getUnidentifiedGraphBufferSafe(depth) {\n        let buffer = this.unidentifiedGraphsBuffer[depth];\n        if (!buffer) {\n            buffer = [];\n            this.unidentifiedGraphsBuffer[depth] = buffer;\n        }\n        return buffer;\n    }\n    /**\n     * @return IExpandOptions The expand options for the active processing mode.\n     */\n    getExpandOptions() {\n        return ParsingContext.EXPAND_OPTIONS[this.activeProcessingMode];\n    }\n    /**\n     * Shift the stack at the given offset to the given depth.\n     *\n     * This will override anything in the stack at `depth`,\n     * and this will remove anything at `depth + depthOffset`\n     *\n     * @param depth The target depth.\n     * @param depthOffset The origin depth, relative to `depth`.\n     */\n    shiftStack(depth, depthOffset) {\n        // Copy the id stack value up one level so that the next job can access the id.\n        const deeperIdStack = this.idStack[depth + depthOffset];\n        if (deeperIdStack) {\n            this.idStack[depth] = deeperIdStack;\n            this.emittedStack[depth] = true;\n            delete this.idStack[depth + depthOffset];\n        }\n        // Shorten key stack\n        if (this.pendingContainerFlushBuffers.length) {\n            for (const buffer of this.pendingContainerFlushBuffers) {\n                if (buffer.depth >= depth + depthOffset) {\n                    buffer.depth -= depthOffset;\n                    buffer.keys.splice(depth, depthOffset);\n                }\n            }\n        }\n        // Splice stacks\n        if (this.unidentifiedValuesBuffer[depth + depthOffset]) {\n            this.unidentifiedValuesBuffer[depth] = this.unidentifiedValuesBuffer[depth + depthOffset];\n            delete this.unidentifiedValuesBuffer[depth + depthOffset];\n        }\n        // TODO: also do the same for other stacks\n    }\n}\nexports.ParsingContext = ParsingContext;\nParsingContext.EXPAND_OPTIONS = {\n    1.0: {\n        allowPrefixForcing: false,\n        allowPrefixNonGenDelims: false,\n        allowVocabRelativeToBase: false,\n    },\n    1.1: {\n        allowPrefixForcing: true,\n        allowPrefixNonGenDelims: false,\n        allowVocabRelativeToBase: true,\n    },\n};\n//# sourceMappingURL=ParsingContext.js.map"]},"metadata":{},"sourceType":"script"}