{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bus = void 0;\n/**\n * A publish-subscribe bus for sending actions to actors\n * to test whether or not they can run an action.\n *\n * This bus does not run the action itself,\n * for that a {@link Mediator} can be used.\n *\n * @see Actor\n * @see Mediator\n *\n * @template A The actor type that can subscribe to the sub.\n * @template I The input type of an actor.\n * @template T The test type of an actor.\n * @template O The output type of an actor.\n */\n\nclass Bus {\n  /**\n   * All enumerable properties from the `args` object are inherited to this bus.\n   *\n   * @param {IBusArgs} args Arguments object\n   * @param {string} args.name The name for the bus\n   * @throws When required arguments are missing.\n   */\n  constructor(args) {\n    this.actors = [];\n    this.observers = []; // Mapping from dependency (after) to dependents (before)\n\n    this.dependencyLinks = new Map();\n    Object.assign(this, args);\n  }\n  /**\n   * Subscribe the given actor to the bus.\n   * After this, the given actor can be unsubscribed from the bus by calling {@link Bus#unsubscribe}.\n   *\n   * An actor that is subscribed multiple times will exist that amount of times in the bus.\n   *\n   * @param {A} actor The actor to subscribe.\n   */\n\n\n  subscribe(actor) {\n    this.actors.push(actor);\n    this.reorderForDependencies();\n  }\n  /**\n   * Subscribe the given observer to the bus.\n   * After this, the given observer can be unsubscribed from the bus by calling {@link Bus#unsubscribeObserver}.\n   *\n   * An observer that is subscribed multiple times will exist that amount of times in the bus.\n   *\n   * @param {ActionObserver<I, O>} observer The observer to subscribe.\n   */\n\n\n  subscribeObserver(observer) {\n    this.observers.push(observer);\n  }\n  /**\n   * Unsubscribe the given actor from the bus.\n   *\n   * An actor that is subscribed multiple times will be unsubscribed only once.\n   *\n   * @param {A} actor The actor to unsubscribe\n   * @return {boolean} If the given actor was successfully unsubscribed,\n   *         otherwise it was not subscribed before.\n   */\n\n\n  unsubscribe(actor) {\n    const index = this.actors.indexOf(actor);\n\n    if (index >= 0) {\n      this.actors.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Unsubscribe the given observer from the bus.\n   *\n   * An observer that is subscribed multiple times will be unsubscribed only once.\n   *\n   * @param {ActionObserver<I, O>} observer The observer to unsubscribe.\n   * @return {boolean} If the given observer was successfully unsubscribed,\n   *         otherwise it was not subscribed before.\n   */\n\n\n  unsubscribeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n\n    if (index >= 0) {\n      this.observers.splice(index, 1);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Publish an action to all actors in the bus to test if they can run the action.\n   *\n   * @param {I} action An action to publish\n   * @return {IActorReply<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,\n   *         O extends IActorOutput>[]}\n   *         An array of reply objects. Each object contains a reference to the actor,\n   *         and a promise to its {@link Actor#test} result.\n   */\n\n\n  publish(action) {\n    return this.actors.map(actor => ({\n      actor,\n      reply: actor.test(action)\n    }));\n  }\n  /**\n   * Invoked when an action was run by an actor.\n   *\n   * @param actor               The action on which the {@link Actor#run} method was invoked.\n   * @param {I}          action The original action input.\n   * @param {Promise<O>} output A promise resolving to the final action output.\n   */\n\n\n  onRun(actor, action, output) {\n    for (const observer of this.observers) {\n      observer.onRun(actor, action, output);\n    }\n  }\n  /**\n   * Indicate that the given actor has the given actor dependencies.\n   *\n   * This will ensure that the given actor will be present in the bus *before* the given dependencies.\n   *\n   * @param {A} dependent A dependent actor that will be placed before the given actors.\n   * @param {A[]} dependencies Actor dependencies that will be placed after the given actor.\n   */\n\n\n  addDependencies(dependent, dependencies) {\n    for (const dependency of dependencies) {\n      let existingDependencies = this.dependencyLinks.get(dependency);\n\n      if (!existingDependencies) {\n        existingDependencies = [];\n        this.dependencyLinks.set(dependency, existingDependencies);\n      }\n\n      existingDependencies.push(dependent);\n    }\n\n    this.reorderForDependencies();\n  }\n  /**\n   * Reorder the bus based on all present dependencies.\n   */\n\n\n  reorderForDependencies() {\n    if (this.dependencyLinks.size > 0) {\n      const actorsAfter = []; // Temporarily remove all actors that have dependencies\n\n      for (const actorAfter of this.dependencyLinks.keys()) {\n        const dependentPos = this.actors.indexOf(actorAfter);\n\n        if (dependentPos >= 0) {\n          this.actors.splice(dependentPos, 1);\n          actorsAfter.push(actorAfter);\n        }\n      } // Iteratively append actors based on the first dependency link\n      // that has all of its dependencies available in the array\n\n\n      while (actorsAfter.length > 0) {\n        // Find the first actor that has all of its dependencies available.\n        let activeActorAfterId = -1;\n\n        for (let i = 0; i < actorsAfter.length; i++) {\n          let validLink = true;\n\n          for (const dependency of this.dependencyLinks.get(actorsAfter[i])) {\n            if (!this.actors.includes(dependency) && actorsAfter.includes(dependency)) {\n              validLink = false;\n              break;\n            }\n          }\n\n          if (validLink) {\n            activeActorAfterId = i;\n            break;\n          }\n        } // If none of the pending links are possible, there must be a cyclic dependency\n\n\n        if (activeActorAfterId < 0) {\n          throw new Error(`Cyclic dependency links detected in bus ${this.name}`);\n        } // The dependent may not be available (yet), so we don't add it to the array (yet).\n\n\n        const activeActorAfter = actorsAfter.splice(activeActorAfterId, 1)[0];\n        this.actors.push(activeActorAfter);\n      }\n    }\n  }\n\n}\n\nexports.Bus = Bus;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/core/lib/Bus.js"],"names":["Object","defineProperty","exports","value","Bus","constructor","args","actors","observers","dependencyLinks","Map","assign","subscribe","actor","push","reorderForDependencies","subscribeObserver","observer","unsubscribe","index","indexOf","splice","unsubscribeObserver","publish","action","map","reply","test","onRun","output","addDependencies","dependent","dependencies","dependency","existingDependencies","get","set","size","actorsAfter","actorAfter","keys","dependentPos","length","activeActorAfterId","i","validLink","includes","Error","name","activeActorAfter"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Bus = void 0;\n/**\n * A publish-subscribe bus for sending actions to actors\n * to test whether or not they can run an action.\n *\n * This bus does not run the action itself,\n * for that a {@link Mediator} can be used.\n *\n * @see Actor\n * @see Mediator\n *\n * @template A The actor type that can subscribe to the sub.\n * @template I The input type of an actor.\n * @template T The test type of an actor.\n * @template O The output type of an actor.\n */\nclass Bus {\n    /**\n     * All enumerable properties from the `args` object are inherited to this bus.\n     *\n     * @param {IBusArgs} args Arguments object\n     * @param {string} args.name The name for the bus\n     * @throws When required arguments are missing.\n     */\n    constructor(args) {\n        this.actors = [];\n        this.observers = [];\n        // Mapping from dependency (after) to dependents (before)\n        this.dependencyLinks = new Map();\n        Object.assign(this, args);\n    }\n    /**\n     * Subscribe the given actor to the bus.\n     * After this, the given actor can be unsubscribed from the bus by calling {@link Bus#unsubscribe}.\n     *\n     * An actor that is subscribed multiple times will exist that amount of times in the bus.\n     *\n     * @param {A} actor The actor to subscribe.\n     */\n    subscribe(actor) {\n        this.actors.push(actor);\n        this.reorderForDependencies();\n    }\n    /**\n     * Subscribe the given observer to the bus.\n     * After this, the given observer can be unsubscribed from the bus by calling {@link Bus#unsubscribeObserver}.\n     *\n     * An observer that is subscribed multiple times will exist that amount of times in the bus.\n     *\n     * @param {ActionObserver<I, O>} observer The observer to subscribe.\n     */\n    subscribeObserver(observer) {\n        this.observers.push(observer);\n    }\n    /**\n     * Unsubscribe the given actor from the bus.\n     *\n     * An actor that is subscribed multiple times will be unsubscribed only once.\n     *\n     * @param {A} actor The actor to unsubscribe\n     * @return {boolean} If the given actor was successfully unsubscribed,\n     *         otherwise it was not subscribed before.\n     */\n    unsubscribe(actor) {\n        const index = this.actors.indexOf(actor);\n        if (index >= 0) {\n            this.actors.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Unsubscribe the given observer from the bus.\n     *\n     * An observer that is subscribed multiple times will be unsubscribed only once.\n     *\n     * @param {ActionObserver<I, O>} observer The observer to unsubscribe.\n     * @return {boolean} If the given observer was successfully unsubscribed,\n     *         otherwise it was not subscribed before.\n     */\n    unsubscribeObserver(observer) {\n        const index = this.observers.indexOf(observer);\n        if (index >= 0) {\n            this.observers.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Publish an action to all actors in the bus to test if they can run the action.\n     *\n     * @param {I} action An action to publish\n     * @return {IActorReply<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest,\n     *         O extends IActorOutput>[]}\n     *         An array of reply objects. Each object contains a reference to the actor,\n     *         and a promise to its {@link Actor#test} result.\n     */\n    publish(action) {\n        return this.actors.map((actor) => ({ actor, reply: actor.test(action) }));\n    }\n    /**\n     * Invoked when an action was run by an actor.\n     *\n     * @param actor               The action on which the {@link Actor#run} method was invoked.\n     * @param {I}          action The original action input.\n     * @param {Promise<O>} output A promise resolving to the final action output.\n     */\n    onRun(actor, action, output) {\n        for (const observer of this.observers) {\n            observer.onRun(actor, action, output);\n        }\n    }\n    /**\n     * Indicate that the given actor has the given actor dependencies.\n     *\n     * This will ensure that the given actor will be present in the bus *before* the given dependencies.\n     *\n     * @param {A} dependent A dependent actor that will be placed before the given actors.\n     * @param {A[]} dependencies Actor dependencies that will be placed after the given actor.\n     */\n    addDependencies(dependent, dependencies) {\n        for (const dependency of dependencies) {\n            let existingDependencies = this.dependencyLinks.get(dependency);\n            if (!existingDependencies) {\n                existingDependencies = [];\n                this.dependencyLinks.set(dependency, existingDependencies);\n            }\n            existingDependencies.push(dependent);\n        }\n        this.reorderForDependencies();\n    }\n    /**\n     * Reorder the bus based on all present dependencies.\n     */\n    reorderForDependencies() {\n        if (this.dependencyLinks.size > 0) {\n            const actorsAfter = [];\n            // Temporarily remove all actors that have dependencies\n            for (const actorAfter of this.dependencyLinks.keys()) {\n                const dependentPos = this.actors.indexOf(actorAfter);\n                if (dependentPos >= 0) {\n                    this.actors.splice(dependentPos, 1);\n                    actorsAfter.push(actorAfter);\n                }\n            }\n            // Iteratively append actors based on the first dependency link\n            // that has all of its dependencies available in the array\n            while (actorsAfter.length > 0) {\n                // Find the first actor that has all of its dependencies available.\n                let activeActorAfterId = -1;\n                for (let i = 0; i < actorsAfter.length; i++) {\n                    let validLink = true;\n                    for (const dependency of this.dependencyLinks.get(actorsAfter[i])) {\n                        if (!this.actors.includes(dependency) && actorsAfter.includes(dependency)) {\n                            validLink = false;\n                            break;\n                        }\n                    }\n                    if (validLink) {\n                        activeActorAfterId = i;\n                        break;\n                    }\n                }\n                // If none of the pending links are possible, there must be a cyclic dependency\n                if (activeActorAfterId < 0) {\n                    throw new Error(`Cyclic dependency links detected in bus ${this.name}`);\n                }\n                // The dependent may not be available (yet), so we don't add it to the array (yet).\n                const activeActorAfter = actorsAfter.splice(activeActorAfterId, 1)[0];\n                this.actors.push(activeActorAfter);\n            }\n        }\n    }\n}\nexports.Bus = Bus;\n//# sourceMappingURL=Bus.js.map"]},"metadata":{},"sourceType":"script"}