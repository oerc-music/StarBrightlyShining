{"ast":null,"code":"\"use strict\"; // tslint:disable:object-literal-sort-keys\n// tslint:disable:max-classes-per-file\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.aggregators = exports.AggregateEvaluator = void 0;\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst E = require(\"../expressions\");\n\nconst C = require(\"../util/Consts\");\n\nconst Err = require(\"../util/Errors\");\n\nconst functions_1 = require(\"../functions\");\n\nconst Helpers_1 = require(\"../functions/Helpers\");\n\nconst Parsing_1 = require(\"../util/Parsing\");\n\nconst Consts_1 = require(\"./../util/Consts\");\n\nconst SyncEvaluator_1 = require(\"./SyncEvaluator\");\n\nconst Transformation_1 = require(\"../Transformation\");\n\nconst DF = new rdf_data_factory_1.DataFactory(); // TODO: Support hooks\n\nclass AggregateEvaluator {\n  constructor(expr, config, throwError) {\n    this.throwError = false;\n    this.expression = expr;\n    this.evaluator = new SyncEvaluator_1.SyncEvaluator(expr.expression, config);\n    this.aggregator = new exports.aggregators[expr.aggregator](expr);\n    this.throwError = throwError;\n  }\n  /**\n   * The spec says to throw an error when a set function is called on an empty\n   * set (unless explicitly mentioned otherwise like COUNT).\n   * However, aggregate error handling says to not bind the result in case of an\n   * error. So to simplify logic in the caller, we return undefined by default.\n   *\n   * @param throwError wether this function should respect the spec and throw an error if no empty value is defined\n   */\n\n\n  static emptyValue(expr, throwError = false) {\n    const val = exports.aggregators[expr.aggregator].emptyValue();\n\n    if (val === undefined && throwError) {\n      throw new Err.EmptyAggregateError();\n    }\n\n    return val;\n  }\n  /**\n   * Put a binding from the result stream in the aggregate state.\n   *\n   * If any binding evaluation errors, the corresponding aggregate variable should be unbound.\n   * If this happens, calling @see result() will return @constant undefined\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n\n\n  put(bindings) {\n    this.init(bindings);\n\n    if (this.state) {\n      this.put = this.__put;\n      this.result = this.__result;\n    }\n  }\n\n  result() {\n    return this.aggregator.constructor.emptyValue();\n  }\n  /**\n   * The actual put method. When the first binding has been given, and the state\n   * of the evaluators initialised. The .put API function will be replaced with this\n   * function, which implements the behaviour we want.\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n\n\n  __put(bindings) {\n    try {\n      const term = this.evaluator.evaluate(bindings);\n      this.state = this.aggregator.put(this.state, term);\n    } catch (err) {\n      this.safeThrow(err);\n    }\n  }\n  /**\n   * The actual result method. When the first binding has been given, and the state\n   * of the evaluators initialised. The .result API function will be replaced with this\n   * function, which implements the behaviour we want.\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n\n\n  __result() {\n    return this.aggregator.result(this.state);\n  }\n\n  init(start) {\n    try {\n      const startTerm = this.evaluator.evaluate(start);\n      this.state = this.aggregator.init(startTerm);\n    } catch (err) {\n      this.safeThrow(err);\n    }\n  }\n\n  safeThrow(err) {\n    if (this.throwError) {\n      throw err;\n    } else {\n      this.put = () => {\n        return;\n      };\n\n      this.result = () => undefined;\n    }\n  }\n\n}\n\nexports.AggregateEvaluator = AggregateEvaluator;\n\nclass BaseAggregator {\n  constructor(expr) {\n    this.distinct = expr.distinct;\n    this.separator = expr.separator || ' ';\n  }\n\n  static emptyValue() {\n    return undefined;\n  }\n\n}\n\nclass Count extends BaseAggregator {\n  static emptyValue() {\n    return Helpers_1.number(0, Consts_1.TypeURL.XSD_INTEGER).toRDF();\n  }\n\n  init(start) {\n    return 1;\n  }\n\n  put(state, term) {\n    return state + 1;\n  }\n\n  result(state) {\n    return Helpers_1.number(state, Consts_1.TypeURL.XSD_INTEGER).toRDF();\n  }\n\n}\n\nclass Sum extends BaseAggregator {\n  constructor() {\n    super(...arguments);\n    this.summer = functions_1.regularFunctions.get(C.RegularOperator.ADDITION);\n  }\n\n  static emptyValue() {\n    return Helpers_1.number(0, Consts_1.TypeURL.XSD_INTEGER).toRDF();\n  }\n\n  init(start) {\n    const {\n      value,\n      type\n    } = extractNumericValueAndTypeOrError(start);\n    return new E.NumericLiteral(value, DF.namedNode(type));\n  }\n\n  put(state, term) {\n    const {\n      value,\n      type\n    } = extractNumericValueAndTypeOrError(term);\n    const internalTerm = new E.NumericLiteral(value, DF.namedNode(type));\n    const sum = this.summer.apply([state, internalTerm]);\n    return sum;\n  }\n\n  result(state) {\n    return state.toRDF();\n  }\n\n}\n\nclass Min extends BaseAggregator {\n  init(start) {\n    const {\n      value\n    } = extractValue(null, start);\n\n    if (start.termType === 'Literal') {\n      return {\n        extremeValue: value,\n        term: start\n      };\n    }\n  }\n\n  put(state, term) {\n    const extracted = extractValue(state.term, term);\n\n    if (extracted.value < state.extremeValue && term.termType === 'Literal') {\n      return {\n        extremeValue: extracted.value,\n        term\n      };\n    }\n\n    return state;\n  }\n\n  result(state) {\n    return state.term;\n  }\n\n}\n\nclass Max extends BaseAggregator {\n  init(start) {\n    const {\n      value\n    } = extractValue(null, start);\n\n    if (start.termType === 'Literal') {\n      return {\n        extremeValue: value,\n        term: start\n      };\n    }\n  }\n\n  put(state, term) {\n    const extracted = extractValue(state.term, term);\n\n    if (extracted.value > state.extremeValue && term.termType === 'Literal') {\n      return {\n        extremeValue: extracted.value,\n        term\n      };\n    }\n\n    return state;\n  }\n\n  result(state) {\n    return state.term;\n  }\n\n}\n\nclass Average extends BaseAggregator {\n  constructor() {\n    super(...arguments);\n    this.summer = functions_1.regularFunctions.get(C.RegularOperator.ADDITION);\n    this.divider = functions_1.regularFunctions.get(C.RegularOperator.DIVISION);\n  }\n\n  static emptyValue() {\n    return Helpers_1.number(0, Consts_1.TypeURL.XSD_INTEGER).toRDF();\n  }\n\n  init(start) {\n    const {\n      value,\n      type\n    } = extractNumericValueAndTypeOrError(start);\n    const sum = new E.NumericLiteral(value, DF.namedNode(type));\n    return {\n      sum,\n      count: 1\n    };\n  }\n\n  put(state, term) {\n    const {\n      value,\n      type\n    } = extractNumericValueAndTypeOrError(term);\n    const internalTerm = new E.NumericLiteral(value, DF.namedNode(type));\n    const sum = this.summer.apply([state.sum, internalTerm]);\n    return {\n      sum,\n      count: state.count + 1\n    };\n  }\n\n  result(state) {\n    const count = new E.NumericLiteral(state.count, DF.namedNode(C.TypeURL.XSD_INTEGER));\n    const result = this.divider.apply([state.sum, count]);\n    return result.toRDF();\n  }\n\n}\n\nclass GroupConcat extends BaseAggregator {\n  static emptyValue() {\n    return Helpers_1.string('').toRDF();\n  }\n\n  init(start) {\n    return start.value;\n  }\n\n  put(state, term) {\n    return state + this.separator + term.value;\n  }\n\n  result(state) {\n    return Helpers_1.string(state).toRDF();\n  }\n\n}\n\nclass Sample extends BaseAggregator {\n  init(start) {\n    return start;\n  }\n\n  put(state, term) {\n    return state; // First value is our sample\n  }\n\n  result(state) {\n    return state;\n  }\n\n}\n\nexports.aggregators = {\n  count: Count,\n  sum: Sum,\n  min: Min,\n  max: Max,\n  avg: Average,\n  group_concat: GroupConcat,\n  sample: Sample\n};\n\nfunction extractNumericValueAndTypeOrError(term) {\n  // TODO: Check behaviour\n  if (term.termType !== 'Literal') {\n    throw new Error('Term with value ' + term.value + ' has type ' + term.termType + ' and is not a numeric literal');\n  } else if (!C.NumericTypeURLs.contains(term.datatype.value)) {\n    throw new Error('Term datatype ' + term.datatype.value + ' with value ' + term.value + ' has type ' + term.termType + ' and is not a numeric literal');\n  }\n\n  const type = term.datatype.value;\n  const value = Parsing_1.parseXSDFloat(term.value);\n  return {\n    type,\n    value\n  };\n}\n\nfunction extractValue(extremeTerm, term) {\n  if (term.termType !== 'Literal') {\n    throw new Error('Term with value ' + term.value + ' has type ' + term.termType + ' and is not a literal');\n  }\n\n  const transformedLit = Transformation_1.transformLiteral(term);\n  return {\n    type: transformedLit.typeURL.value,\n    value: transformedLit.typedValue\n  };\n}","map":{"version":3,"sources":["../../../lib/evaluators/AggregateEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["// tslint:disable:object-literal-sort-keys\n// tslint:disable:max-classes-per-file\n\nimport {DataFactory} from 'rdf-data-factory';\nimport * as RDF from 'rdf-js';\n\nimport { Algebra } from 'sparqlalgebrajs';\n\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport { regularFunctions } from '../functions';\nimport { number, string } from '../functions/Helpers';\nimport { Bindings } from '../Types';\nimport { parseXSDFloat } from '../util/Parsing';\nimport { SetFunction, TypeURL } from './../util/Consts';\nimport { SyncEvaluator, SyncEvaluatorConfig } from './SyncEvaluator';\nimport { transformLiteral } from '../Transformation';\n\nconst DF = new DataFactory();\n\n// TODO: Support hooks\nexport class AggregateEvaluator {\n  private expression: Algebra.AggregateExpression;\n  private aggregator: BaseAggregator<any>;\n  private evaluator: SyncEvaluator;\n  private throwError = false;\n  private state: any;\n\n  constructor(expr: Algebra.AggregateExpression, config?: SyncEvaluatorConfig, throwError?: boolean) {\n    this.expression = expr;\n    this.evaluator = new SyncEvaluator(expr.expression, config);\n    this.aggregator = new aggregators[expr.aggregator as SetFunction](expr);\n    this.throwError = throwError;\n  }\n\n  /**\n   * The spec says to throw an error when a set function is called on an empty\n   * set (unless explicitly mentioned otherwise like COUNT).\n   * However, aggregate error handling says to not bind the result in case of an\n   * error. So to simplify logic in the caller, we return undefined by default.\n   *\n   * @param throwError wether this function should respect the spec and throw an error if no empty value is defined\n   */\n  static emptyValue(expr: Algebra.AggregateExpression, throwError = false): RDF.Term {\n    const val = aggregators[expr.aggregator as SetFunction].emptyValue();\n    if (val === undefined && throwError) {\n      throw new Err.EmptyAggregateError();\n    }\n    return val;\n  }\n\n  /**\n   * Put a binding from the result stream in the aggregate state.\n   *\n   * If any binding evaluation errors, the corresponding aggregate variable should be unbound.\n   * If this happens, calling @see result() will return @constant undefined\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n  put(bindings: Bindings): void {\n    this.init(bindings);\n    if (this.state) {\n      this.put = this.__put;\n      this.result = this.__result;\n    }\n  }\n\n  result(): RDF.Term {\n    return (this.aggregator.constructor as AggregatorClass).emptyValue();\n  }\n\n  /**\n   * The actual put method. When the first binding has been given, and the state\n   * of the evaluators initialised. The .put API function will be replaced with this\n   * function, which implements the behaviour we want.\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n  private __put(bindings: Bindings): void {\n    try {\n      const term = this.evaluator.evaluate(bindings);\n      this.state = this.aggregator.put(this.state, term);\n    } catch (err) {\n      this.safeThrow(err);\n    }\n  }\n\n  /**\n   * The actual result method. When the first binding has been given, and the state\n   * of the evaluators initialised. The .result API function will be replaced with this\n   * function, which implements the behaviour we want.\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n  private __result(): RDF.Term {\n    return this.aggregator.result(this.state);\n  }\n\n  private init(start: Bindings): void {\n    try {\n      const startTerm = this.evaluator.evaluate(start);\n      this.state = this.aggregator.init(startTerm);\n    } catch (err) {\n      this.safeThrow(err);\n    }\n  }\n\n  private safeThrow(err: Error): void {\n    if (this.throwError) {\n      throw err;\n    } else {\n      this.put = () => { return; };\n      this.result = () => undefined;\n    }\n  }\n}\n\nabstract class BaseAggregator<State> {\n  protected distinct: boolean;\n  protected separator: string;\n\n  constructor(expr: Algebra.AggregateExpression) {\n    this.distinct = expr.distinct;\n    this.separator = expr.separator || ' ';\n  }\n\n  static emptyValue(): RDF.Term {\n    return undefined;\n  }\n\n  abstract init(start: RDF.Term): State;\n\n  abstract result(state: State): RDF.Term;\n\n  abstract put(state: State, bindings: RDF.Term): State;\n\n}\n\nclass Count extends BaseAggregator<number> {\n  static emptyValue() {\n    return number(0, TypeURL.XSD_INTEGER).toRDF();\n  }\n\n  init(start: RDF.Term): number {\n    return 1;\n  }\n\n  put(state: number, term: RDF.Term): number {\n    return state + 1;\n  }\n\n  result(state: number): RDF.Term {\n    return number(state, TypeURL.XSD_INTEGER).toRDF();\n  }\n}\n\ntype SumState = E.NumericLiteral;\nclass Sum extends BaseAggregator<SumState> {\n  summer = regularFunctions.get(C.RegularOperator.ADDITION);\n\n  static emptyValue() {\n    return number(0, TypeURL.XSD_INTEGER).toRDF();\n  }\n\n  init(start: RDF.Term): SumState {\n    const { value, type } = extractNumericValueAndTypeOrError(start);\n    return new E.NumericLiteral(value, DF.namedNode(type));\n  }\n\n  put(state: SumState, term: RDF.Term): SumState {\n    const { value, type } = extractNumericValueAndTypeOrError(term);\n    const internalTerm = new E.NumericLiteral(value, DF.namedNode(type));\n    const sum = this.summer.apply([state, internalTerm]) as E.NumericLiteral;\n    return sum;\n  }\n\n  result(state: SumState): RDF.Term {\n    return state.toRDF();\n  }\n}\n\ntype ExtremeState = { extremeValue: number, term: RDF.Literal };\nclass Min extends BaseAggregator<ExtremeState> {\n  init(start: RDF.Term): ExtremeState {\n    const {value} = extractValue(null, start);\n    if (start.termType === 'Literal') {\n      return { extremeValue:value, term: start };\n    }\n  }\n\n  put(state: ExtremeState, term: RDF.Term): ExtremeState {\n    const extracted = extractValue(state.term, term);\n    if (extracted.value < state.extremeValue && term.termType === 'Literal') {\n      return {\n        extremeValue: extracted.value ,\n        term,\n      };\n    }\n    return state;\n  }\n\n  result(state: ExtremeState): RDF.Term {\n    return state.term;\n  }\n}\n\nclass Max extends BaseAggregator<ExtremeState> {\n  init(start: RDF.Term): ExtremeState {\n    const {value} = extractValue(null, start);\n    if (start.termType === 'Literal') {\n      return { extremeValue:value, term: start };\n    }\n  }\n\n  put(state: ExtremeState, term: RDF.Term): ExtremeState {\n    const extracted = extractValue(state.term, term);\n    if (extracted.value > state.extremeValue && term.termType === 'Literal') {\n      return {\n        extremeValue: extracted.value ,\n        term,\n      };\n    }\n    return state;\n  }\n\n  result(state: ExtremeState): RDF.Term {\n    return state.term;\n  }\n}\n\ntype AverageState = { sum: E.NumericLiteral, count: number };\nclass Average extends BaseAggregator<AverageState> {\n  summer = regularFunctions.get(C.RegularOperator.ADDITION);\n  divider = regularFunctions.get(C.RegularOperator.DIVISION);\n\n  static emptyValue() {\n    return number(0, TypeURL.XSD_INTEGER).toRDF();\n  }\n\n  init(start: RDF.Term): AverageState {\n    const { value, type } = extractNumericValueAndTypeOrError(start);\n    const sum = new E.NumericLiteral(value, DF.namedNode(type));\n    return { sum, count: 1 };\n  }\n\n  put(state: AverageState, term: RDF.Term): AverageState {\n    const { value, type } = extractNumericValueAndTypeOrError(term);\n    const internalTerm = new E.NumericLiteral(value, DF.namedNode(type));\n    const sum = this.summer.apply([state.sum, internalTerm]) as E.NumericLiteral;\n    return {\n      sum,\n      count: state.count + 1,\n    };\n  }\n\n  result(state: AverageState): RDF.Term {\n    const count = new E.NumericLiteral(state.count, DF.namedNode(C.TypeURL.XSD_INTEGER));\n    const result = this.divider.apply([state.sum, count]);\n    return result.toRDF();\n  }\n\n}\n\nclass GroupConcat extends BaseAggregator<string> {\n  static emptyValue() {\n    return string('').toRDF();\n  }\n\n  init(start: RDF.Term): string {\n    return start.value;\n  }\n\n  put(state: string, term: RDF.Term): string {\n    return state + this.separator + term.value;\n  }\n\n  result(state: string): RDF.Term {\n    return string(state).toRDF();\n  }\n}\n\nclass Sample extends BaseAggregator<RDF.Term> {\n  init(start: RDF.Term): RDF.Term {\n    return start;\n  }\n\n  put(state: RDF.Term, term: RDF.Term): RDF.Term {\n    return state; // First value is our sample\n  }\n\n  result(state: RDF.Term): RDF.Term {\n    return state;\n  }\n}\n\nexport interface AggregatorClass {\n  new(expr: Algebra.AggregateExpression): BaseAggregator<any>;\n  emptyValue(): RDF.Term;\n}\nexport const aggregators: Readonly<{ [key in SetFunction]: AggregatorClass }> = {\n  count: Count,\n  sum: Sum,\n  min: Min,\n  max: Max,\n  avg: Average,\n  group_concat: GroupConcat,\n  sample: Sample,\n};\n\nfunction extractNumericValueAndTypeOrError(term: RDF.Term): { value: number, type: C.NumericTypeURL } {\n  // TODO: Check behaviour\n  if (term.termType !== 'Literal') {\n    throw new Error('Term with value ' + term.value + ' has type ' + term.termType +' and is not a numeric literal');\n  } else if (!C.NumericTypeURLs.contains(term.datatype.value)) {\n    throw new Error('Term datatype '+ term.datatype.value +' with value ' + term.value + ' has type ' + term.termType +' and is not a numeric literal');\n  }\n\n  const type: C.NumericTypeURL = term.datatype.value as unknown as C.NumericTypeURL;\n  const value = parseXSDFloat(term.value);\n  return { type, value };\n}\n\nfunction extractValue(extremeTerm: RDF.Literal, term: RDF.Term): {value: any, type:string}  {\n  if (term.termType !== 'Literal') {\n    throw new Error('Term with value ' + term.value + ' has type ' + term.termType +' and is not a literal');\n  }\n\n  const transformedLit = transformLiteral(term);\n  return {type: transformedLit.typeURL.value, value: transformedLit.typedValue};\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}