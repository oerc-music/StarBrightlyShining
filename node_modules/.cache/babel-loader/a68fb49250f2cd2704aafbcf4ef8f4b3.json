{"ast":null,"code":"// **N3StreamParser** parses a text stream into a quad stream.\nimport N3Parser from './N3Parser';\nimport { Transform } from 'readable-stream'; // ## Constructor\n\nexport default class N3StreamParser extends Transform {\n  constructor(options) {\n    super({\n      decodeStrings: true\n    });\n    this._readableState.objectMode = true; // Set up parser with dummy stream to obtain `data` and `end` callbacks\n\n    const parser = new N3Parser(options);\n    let onData, onEnd;\n    parser.parse({\n      on: (event, callback) => {\n        switch (event) {\n          case 'data':\n            onData = callback;\n            break;\n\n          case 'end':\n            onEnd = callback;\n            break;\n        }\n      }\n    }, // Handle quads by pushing them down the pipeline\n    (error, quad) => {\n      error && this.emit('error', error) || quad && this.push(quad);\n    }, // Emit prefixes through the `prefix` event\n    (prefix, uri) => {\n      this.emit('prefix', prefix, uri);\n    }); // Implement Transform methods through parser callbacks\n\n    this._transform = (chunk, encoding, done) => {\n      onData(chunk);\n      done();\n    };\n\n    this._flush = done => {\n      onEnd();\n      done();\n    };\n  } // ### Parses a stream of strings\n\n\n  import(stream) {\n    stream.on('data', chunk => {\n      this.write(chunk);\n    });\n    stream.on('end', () => {\n      this.end();\n    });\n    stream.on('error', error => {\n      this.emit('error', error);\n    });\n    return this;\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/n3/src/N3StreamParser.js"],"names":["N3Parser","Transform","N3StreamParser","constructor","options","decodeStrings","_readableState","objectMode","parser","onData","onEnd","parse","on","event","callback","error","quad","emit","push","prefix","uri","_transform","chunk","encoding","done","_flush","import","stream","write","end"],"mappings":"AAAA;AACA,OAAOA,QAAP,MAAqB,YAArB;AACA,SAASC,SAAT,QAA0B,iBAA1B,C,CAEA;;AACA,eAAe,MAAMC,cAAN,SAA6BD,SAA7B,CAAuC;AACpDE,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,UAAM;AAAEC,MAAAA,aAAa,EAAE;AAAjB,KAAN;AACA,SAAKC,cAAL,CAAoBC,UAApB,GAAiC,IAAjC,CAFmB,CAInB;;AACA,UAAMC,MAAM,GAAG,IAAIR,QAAJ,CAAaI,OAAb,CAAf;AACA,QAAIK,MAAJ,EAAYC,KAAZ;AACAF,IAAAA,MAAM,CAACG,KAAP,CAAa;AACXC,MAAAA,EAAE,EAAE,CAACC,KAAD,EAAQC,QAAR,KAAqB;AACvB,gBAAQD,KAAR;AACA,eAAK,MAAL;AAAaJ,YAAAA,MAAM,GAAGK,QAAT;AAAmB;;AAChC,eAAK,KAAL;AAAcJ,YAAAA,KAAK,GAAGI,QAAR;AAAkB;AAFhC;AAID;AANU,KAAb,EAQE;AACA,KAACC,KAAD,EAAQC,IAAR,KAAiB;AAAED,MAAAA,KAAK,IAAI,KAAKE,IAAL,CAAU,OAAV,EAAmBF,KAAnB,CAAT,IAAsCC,IAAI,IAAI,KAAKE,IAAL,CAAUF,IAAV,CAA9C;AAAgE,KATrF,EAUE;AACA,KAACG,MAAD,EAASC,GAAT,KAAiB;AAAE,WAAKH,IAAL,CAAU,QAAV,EAAoBE,MAApB,EAA4BC,GAA5B;AAAmC,KAXxD,EAPmB,CAqBnB;;AACA,SAAKC,UAAL,GAAkB,CAACC,KAAD,EAAQC,QAAR,EAAkBC,IAAlB,KAA2B;AAAEf,MAAAA,MAAM,CAACa,KAAD,CAAN;AAAeE,MAAAA,IAAI;AAAK,KAAvE;;AACA,SAAKC,MAAL,GAAcD,IAAI,IAAI;AAAEd,MAAAA,KAAK;AAAIc,MAAAA,IAAI;AAAK,KAA1C;AACD,GAzBmD,CA2BpD;;;AACAE,EAAAA,MAAM,CAACC,MAAD,EAAS;AACbA,IAAAA,MAAM,CAACf,EAAP,CAAU,MAAV,EAAmBU,KAAK,IAAI;AAAE,WAAKM,KAAL,CAAWN,KAAX;AAAoB,KAAlD;AACAK,IAAAA,MAAM,CAACf,EAAP,CAAU,KAAV,EAAmB,MAAW;AAAE,WAAKiB,GAAL;AAAa,KAA7C;AACAF,IAAAA,MAAM,CAACf,EAAP,CAAU,OAAV,EAAmBG,KAAK,IAAI;AAAE,WAAKE,IAAL,CAAU,OAAV,EAAmBF,KAAnB;AAA4B,KAA1D;AACA,WAAO,IAAP;AACD;;AAjCmD","sourcesContent":["// **N3StreamParser** parses a text stream into a quad stream.\nimport N3Parser from './N3Parser';\nimport { Transform } from 'readable-stream';\n\n// ## Constructor\nexport default class N3StreamParser extends Transform {\n  constructor(options) {\n    super({ decodeStrings: true });\n    this._readableState.objectMode = true;\n\n    // Set up parser with dummy stream to obtain `data` and `end` callbacks\n    const parser = new N3Parser(options);\n    let onData, onEnd;\n    parser.parse({\n      on: (event, callback) => {\n        switch (event) {\n        case 'data': onData = callback; break;\n        case 'end':   onEnd = callback; break;\n        }\n      },\n    },\n      // Handle quads by pushing them down the pipeline\n      (error, quad) => { error && this.emit('error', error) || quad && this.push(quad); },\n      // Emit prefixes through the `prefix` event\n      (prefix, uri) => { this.emit('prefix', prefix, uri); }\n    );\n\n    // Implement Transform methods through parser callbacks\n    this._transform = (chunk, encoding, done) => { onData(chunk); done(); };\n    this._flush = done => { onEnd(); done(); };\n  }\n\n  // ### Parses a stream of strings\n  import(stream) {\n    stream.on('data',  chunk => { this.write(chunk); });\n    stream.on('end',   ()      => { this.end(); });\n    stream.on('error', error => { this.emit('error', error); });\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}