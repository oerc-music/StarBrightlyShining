{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExpressionType = void 0;\nvar ExpressionType;\n\n(function (ExpressionType) {\n  ExpressionType[\"Aggregate\"] = \"aggregate\";\n  ExpressionType[\"Existence\"] = \"existence\";\n  ExpressionType[\"Named\"] = \"named\";\n  ExpressionType[\"Operator\"] = \"operator\";\n  ExpressionType[\"SpecialOperator\"] = \"specialOperator\";\n  ExpressionType[\"Term\"] = \"term\";\n  ExpressionType[\"Variable\"] = \"variable\";\n})(ExpressionType = exports.ExpressionType || (exports.ExpressionType = {}));","map":{"version":3,"sources":["../../../lib/expressions/Expressions.ts"],"names":[],"mappings":";;;;;;AAKA,IAAY,cAAZ;;AAAA,CAAA,UAAY,cAAZ,EAA0B;AACxB,EAAA,cAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACA,EAAA,cAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACA,EAAA,cAAA,CAAA,OAAA,CAAA,GAAA,OAAA;AACA,EAAA,cAAA,CAAA,UAAA,CAAA,GAAA,UAAA;AACA,EAAA,cAAA,CAAA,iBAAA,CAAA,GAAA,iBAAA;AACA,EAAA,cAAA,CAAA,MAAA,CAAA,GAAA,MAAA;AACA,EAAA,cAAA,CAAA,UAAA,CAAA,GAAA,UAAA;AACD,CARD,EAAY,cAAc,GAAd,OAAA,CAAA,cAAA,KAAA,OAAA,CAAA,cAAA,GAAc,EAAd,CAAZ","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra } from 'sparqlalgebrajs';\n\nimport { Bindings } from '../Types';\n\nexport enum ExpressionType {\n  Aggregate = 'aggregate',\n  Existence = 'existence',\n  Named = 'named',\n  Operator = 'operator',\n  SpecialOperator = 'specialOperator',\n  Term = 'term',\n  Variable = 'variable',\n}\n\nexport type Expression =\n  AggregateExpression |\n  ExistenceExpression |\n  NamedExpression |\n  OperatorExpression |\n  SpecialOperatorExpression |\n  TermExpression |\n  VariableExpression;\n\nexport interface ExpressionProps {\n  expressionType: ExpressionType;\n}\n\nexport type AggregateExpression = ExpressionProps & {\n  expressionType: ExpressionType.Aggregate;\n  name: string;\n  expression: Algebra.AggregateExpression;\n};\n\nexport type ExistenceExpression = ExpressionProps & {\n  expressionType: ExpressionType.Existence;\n  expression: Algebra.ExistenceExpression;\n};\n\nexport type NamedExpression = ExpressionProps & {\n  expressionType: ExpressionType.Named;\n  name: RDF.NamedNode;\n  apply: SimpleApplication;\n  args: Expression[];\n};\n\n// export type Application = SimpleApplication | SpecialApplication;\nexport type SimpleApplication = (args: TermExpression[]) => TermExpression;\n\nexport type OperatorExpression = ExpressionProps & {\n  expressionType: ExpressionType.Operator;\n  args: Expression[];\n  apply: SimpleApplication;\n};\n\nexport type SpecialApplication<Term, BNode> = (context: EvalContext<Term, BNode>) => Term;\n\nexport type SpecialApplicationAsync = SpecialApplication<Promise<TermExpression>, Promise<RDF.BlankNode>>;\nexport type EvalContextAsync = EvalContext<Promise<TermExpression>, Promise<RDF.BlankNode>>;\n\nexport type SpecialApplicationSync = SpecialApplication<TermExpression, RDF.BlankNode>;\nexport type EvalContextSync = EvalContext<TermExpression, RDF.BlankNode>;\n\nexport type EvalContext<Term, BNode> = {\n  args: Expression[],\n  mapping: Bindings,\n  context: {\n    now: Date,\n    baseIRI?: string,\n    bnode(input?: string): BNode,\n  },\n  evaluate(expr: Expression, mapping: Bindings): Term,\n};\n\nexport type SpecialOperatorExpression = ExpressionProps & {\n  expressionType: ExpressionType.SpecialOperator,\n  args: Expression[],\n  applyAsync: SpecialApplicationAsync,\n  applySync: SpecialApplicationSync,\n};\n\n// TODO: Create alias Term = TermExpression\nexport type TermType = 'namedNode' | 'literal' | 'blankNode';\nexport type TermExpression = ExpressionProps & {\n  expressionType: ExpressionType.Term;\n  termType: TermType;\n  str(): string;\n  coerceEBV(): boolean;\n  toRDF(): RDF.Term;\n};\n\nexport type VariableExpression = ExpressionProps & {\n  expressionType: ExpressionType.Variable;\n  name: string;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}