{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationPathNps = void 0;\n\nconst actor_abstract_path_1 = require(\"@comunica/actor-abstract-path\");\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica Path Nps Query Operation Actor.\n */\n\n\nclass ActorQueryOperationPathNps extends actor_abstract_path_1.ActorAbstractPath {\n  constructor(args) {\n    super(args, sparqlalgebrajs_1.Algebra.types.NPS);\n  }\n\n  async runOperation(path, context) {\n    const predicate = path.predicate;\n    const blank = this.generateVariable(path);\n    const blankName = rdf_string_1.termToString(blank);\n    const pattern = actor_abstract_path_1.ActorAbstractPath.FACTORY.createPattern(path.subject, blank, path.object, path.graph);\n    const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n      operation: pattern,\n      context\n    })); // Remove the generated blank nodes from the bindings\n\n    const bindingsStream = output.bindingsStream.transform({\n      filter(bindings) {\n        return !predicate.iris.some(iri => iri.equals(bindings.get(blankName)));\n      },\n\n      transform(item, next, push) {\n        push(item.delete(blankName));\n        next();\n      }\n\n    });\n    return {\n      type: 'bindings',\n      bindingsStream,\n      variables: output.variables,\n      canContainUndefs: false\n    };\n  }\n\n}\n\nexports.ActorQueryOperationPathNps = ActorQueryOperationPathNps;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-path-nps/lib/ActorQueryOperationPathNps.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationPathNps","actor_abstract_path_1","require","bus_query_operation_1","rdf_string_1","sparqlalgebrajs_1","ActorAbstractPath","constructor","args","Algebra","types","NPS","runOperation","path","context","predicate","blank","generateVariable","blankName","termToString","pattern","FACTORY","createPattern","subject","object","graph","output","ActorQueryOperation","getSafeBindings","mediatorQueryOperation","mediate","operation","bindingsStream","transform","filter","bindings","iris","some","iri","equals","get","item","next","push","delete","type","variables","canContainUndefs"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,0BAAR,GAAqC,KAAK,CAA1C;;AACA,MAAMC,qBAAqB,GAAGC,OAAO,CAAC,+BAAD,CAArC;;AACA,MAAMC,qBAAqB,GAAGD,OAAO,CAAC,+BAAD,CAArC;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,YAAD,CAA5B;;AACA,MAAMG,iBAAiB,GAAGH,OAAO,CAAC,iBAAD,CAAjC;AACA;AACA;AACA;;;AACA,MAAMF,0BAAN,SAAyCC,qBAAqB,CAACK,iBAA/D,CAAiF;AAC7EC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAMA,IAAN,EAAYH,iBAAiB,CAACI,OAAlB,CAA0BC,KAA1B,CAAgCC,GAA5C;AACH;;AACiB,QAAZC,YAAY,CAACC,IAAD,EAAOC,OAAP,EAAgB;AAC9B,UAAMC,SAAS,GAAGF,IAAI,CAACE,SAAvB;AACA,UAAMC,KAAK,GAAG,KAAKC,gBAAL,CAAsBJ,IAAtB,CAAd;AACA,UAAMK,SAAS,GAAGd,YAAY,CAACe,YAAb,CAA0BH,KAA1B,CAAlB;AACA,UAAMI,OAAO,GAAGnB,qBAAqB,CAACK,iBAAtB,CAAwCe,OAAxC,CAAgDC,aAAhD,CAA8DT,IAAI,CAACU,OAAnE,EAA4EP,KAA5E,EAAmFH,IAAI,CAACW,MAAxF,EAAgGX,IAAI,CAACY,KAArG,CAAhB;AACA,UAAMC,MAAM,GAAGvB,qBAAqB,CAACwB,mBAAtB,CAA0CC,eAA1C,CAA0D,MAAM,KAAKC,sBAAL,CAA4BC,OAA5B,CAAoC;AAAEC,MAAAA,SAAS,EAAEX,OAAb;AAAsBN,MAAAA;AAAtB,KAApC,CAAhE,CAAf,CAL8B,CAM9B;;AACA,UAAMkB,cAAc,GAAGN,MAAM,CAACM,cAAP,CAAsBC,SAAtB,CAAgC;AACnDC,MAAAA,MAAM,CAACC,QAAD,EAAW;AACb,eAAO,CAACpB,SAAS,CAACqB,IAAV,CAAeC,IAAf,CAAoBC,GAAG,IAAIA,GAAG,CAACC,MAAJ,CAAWJ,QAAQ,CAACK,GAAT,CAAatB,SAAb,CAAX,CAA3B,CAAR;AACH,OAHkD;;AAInDe,MAAAA,SAAS,CAACQ,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmB;AACxBA,QAAAA,IAAI,CAACF,IAAI,CAACG,MAAL,CAAY1B,SAAZ,CAAD,CAAJ;AACAwB,QAAAA,IAAI;AACP;;AAPkD,KAAhC,CAAvB;AASA,WAAO;AAAEG,MAAAA,IAAI,EAAE,UAAR;AAAoBb,MAAAA,cAApB;AAAoCc,MAAAA,SAAS,EAAEpB,MAAM,CAACoB,SAAtD;AAAiEC,MAAAA,gBAAgB,EAAE;AAAnF,KAAP;AACH;;AArB4E;;AAuBjFjD,OAAO,CAACE,0BAAR,GAAqCA,0BAArC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationPathNps = void 0;\nconst actor_abstract_path_1 = require(\"@comunica/actor-abstract-path\");\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica Path Nps Query Operation Actor.\n */\nclass ActorQueryOperationPathNps extends actor_abstract_path_1.ActorAbstractPath {\n    constructor(args) {\n        super(args, sparqlalgebrajs_1.Algebra.types.NPS);\n    }\n    async runOperation(path, context) {\n        const predicate = path.predicate;\n        const blank = this.generateVariable(path);\n        const blankName = rdf_string_1.termToString(blank);\n        const pattern = actor_abstract_path_1.ActorAbstractPath.FACTORY.createPattern(path.subject, blank, path.object, path.graph);\n        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: pattern, context }));\n        // Remove the generated blank nodes from the bindings\n        const bindingsStream = output.bindingsStream.transform({\n            filter(bindings) {\n                return !predicate.iris.some(iri => iri.equals(bindings.get(blankName)));\n            },\n            transform(item, next, push) {\n                push(item.delete(blankName));\n                next();\n            },\n        });\n        return { type: 'bindings', bindingsStream, variables: output.variables, canContainUndefs: false };\n    }\n}\nexports.ActorQueryOperationPathNps = ActorQueryOperationPathNps;\n//# sourceMappingURL=ActorQueryOperationPathNps.js.map"]},"metadata":{},"sourceType":"script"}