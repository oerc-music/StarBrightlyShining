{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EntryHandlerArrayValue = void 0;\n\nconst Util_1 = require(\"../Util\");\n/**\n * Handles values that are part of an array.\n */\n\n\nclass EntryHandlerArrayValue {\n  isPropertyHandler() {\n    return false;\n  }\n\n  isStackProcessor() {\n    return true;\n  }\n\n  async validate(parsingContext, util, keys, depth, inProperty) {\n    return this.test(parsingContext, util, null, keys, depth);\n  }\n\n  async test(parsingContext, util, key, keys, depth) {\n    return typeof keys[depth] === 'number';\n  }\n\n  async handle(parsingContext, util, key, keys, value, depth) {\n    let parentKey = await util.unaliasKeywordParent(keys, depth); // Check if we have an anonymous list\n\n    if (parentKey === '@list') {\n      // Our value is part of an array\n      // Determine the list root key\n      let listRootKey = null;\n      let listRootDepth = 0;\n\n      for (let i = depth - 2; i > 0; i--) {\n        const keyOption = keys[i];\n\n        if (typeof keyOption === 'string' || typeof keyOption === 'number') {\n          listRootDepth = i;\n          listRootKey = keyOption;\n          break;\n        }\n      }\n\n      if (listRootKey !== null) {\n        // Emit the given objects as list elements\n        const values = await util.valueToTerm(await parsingContext.getContext(keys), listRootKey, value, depth, keys);\n\n        for (const object of values) {\n          await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, listRootDepth), listRootDepth);\n        } // If no values were found, emit a falsy list element to force an empty RDF list to be emitted.\n\n\n        if (values.length === 0) {\n          await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, listRootDepth), listRootDepth);\n        }\n      }\n    } else if (parentKey === '@set') {\n      // Our value is part of a set, so we just add it to the parent-parent\n      await parsingContext.newOnValueJob(keys.slice(0, -2), value, depth - 2, false);\n    } else if (parentKey !== undefined && parentKey !== '@type') {\n      // Buffer our value using the parent key as predicate\n      // Determine the first parent key that is *not* an array key\n      // This is needed in case we have an @list container with nested arrays,\n      // where each of them should produce nested RDF lists.\n      for (let i = depth - 1; i > 0; i--) {\n        if (typeof keys[i] !== 'number') {\n          parentKey = await util.unaliasKeyword(keys[i], keys, i);\n          break;\n        }\n      } // Check if the predicate is marked as an @list in the context\n\n\n      const parentContext = await parsingContext.getContext(keys.slice(0, -1));\n\n      if ('@list' in Util_1.Util.getContextValueContainer(parentContext, parentKey)) {\n        // Our value is part of an array\n        // Emit the given objects as list elements\n        parsingContext.emittedStack[depth + 1] = true; // Ensure the creation of bnodes for empty nodes\n\n        const values = await util.valueToTerm(await parsingContext.getContext(keys), parentKey, value, depth, keys);\n\n        for (const object of values) {\n          await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, -1), depth - 1);\n        } // If no values were found, emit a falsy list element to force an empty RDF list to be emitted.\n\n\n        if (values.length === 0) {\n          await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, -1), depth - 1);\n        }\n      } else {\n        // Copy the stack values up one level so that the next job can access them.\n        parsingContext.shiftStack(depth, 1); // Execute the job one level higher\n\n        await parsingContext.newOnValueJob(keys.slice(0, -1), value, depth - 1, false); // Remove any defined contexts at this level to avoid it to propagate to the next array element.\n\n        parsingContext.contextTree.removeContext(keys.slice(0, -1));\n      }\n    }\n  }\n\n  async handleListElement(parsingContext, util, value, valueOriginal, depth, listRootKeys, listRootDepth) {\n    // Buffer our value as an RDF list using the listRootKey as predicate\n    let listPointer = parsingContext.listPointerStack[depth];\n\n    if (valueOriginal !== null && (await util.unaliasKeywords(valueOriginal, listRootKeys, depth))['@value'] !== null) {\n      if (!listPointer || !listPointer.value) {\n        const linkTerm = util.dataFactory.blankNode();\n        listPointer = {\n          value: linkTerm,\n          listRootDepth,\n          listId: linkTerm\n        };\n      } else {\n        // rdf:rest links are always emitted before the next element,\n        // as the blank node identifier is only created at that point.\n        // Because of this reason, the final rdf:nil is emitted when the stack depth is decreased.\n        const newLinkTerm = util.dataFactory.blankNode();\n        parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfRest, newLinkTerm, util.getDefaultGraph())); // Update the list pointer for the next element\n\n        listPointer.value = newLinkTerm;\n      } // Emit a list element for the current value\n      // Omit rdf:first if the value is invalid\n\n\n      if (value) {\n        parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfFirst, value, util.getDefaultGraph()));\n      }\n    } else {\n      // A falsy list element if found.\n      // Mark it as an rdf:nil list until another valid list element comes in\n      if (!listPointer) {\n        listPointer = {\n          listRootDepth,\n          listId: util.rdfNil\n        };\n      }\n    }\n\n    parsingContext.listPointerStack[depth] = listPointer;\n  }\n\n}\n\nexports.EntryHandlerArrayValue = EntryHandlerArrayValue;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerArrayValue.js"],"names":["Object","defineProperty","exports","value","EntryHandlerArrayValue","Util_1","require","isPropertyHandler","isStackProcessor","validate","parsingContext","util","keys","depth","inProperty","test","key","handle","parentKey","unaliasKeywordParent","listRootKey","listRootDepth","i","keyOption","values","valueToTerm","getContext","object","handleListElement","slice","length","newOnValueJob","undefined","unaliasKeyword","parentContext","Util","getContextValueContainer","emittedStack","shiftStack","contextTree","removeContext","valueOriginal","listRootKeys","listPointer","listPointerStack","unaliasKeywords","linkTerm","dataFactory","blankNode","listId","newLinkTerm","emitQuad","quad","rdfRest","getDefaultGraph","rdfFirst","rdfNil"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerArrayValue = void 0;\nconst Util_1 = require(\"../Util\");\n/**\n * Handles values that are part of an array.\n */\nclass EntryHandlerArrayValue {\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        return this.test(parsingContext, util, null, keys, depth);\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return typeof keys[depth] === 'number';\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        let parentKey = await util.unaliasKeywordParent(keys, depth);\n        // Check if we have an anonymous list\n        if (parentKey === '@list') {\n            // Our value is part of an array\n            // Determine the list root key\n            let listRootKey = null;\n            let listRootDepth = 0;\n            for (let i = depth - 2; i > 0; i--) {\n                const keyOption = keys[i];\n                if (typeof keyOption === 'string' || typeof keyOption === 'number') {\n                    listRootDepth = i;\n                    listRootKey = keyOption;\n                    break;\n                }\n            }\n            if (listRootKey !== null) {\n                // Emit the given objects as list elements\n                const values = await util.valueToTerm(await parsingContext.getContext(keys), listRootKey, value, depth, keys);\n                for (const object of values) {\n                    await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, listRootDepth), listRootDepth);\n                }\n                // If no values were found, emit a falsy list element to force an empty RDF list to be emitted.\n                if (values.length === 0) {\n                    await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, listRootDepth), listRootDepth);\n                }\n            }\n        }\n        else if (parentKey === '@set') {\n            // Our value is part of a set, so we just add it to the parent-parent\n            await parsingContext.newOnValueJob(keys.slice(0, -2), value, depth - 2, false);\n        }\n        else if (parentKey !== undefined && parentKey !== '@type') {\n            // Buffer our value using the parent key as predicate\n            // Determine the first parent key that is *not* an array key\n            // This is needed in case we have an @list container with nested arrays,\n            // where each of them should produce nested RDF lists.\n            for (let i = depth - 1; i > 0; i--) {\n                if (typeof keys[i] !== 'number') {\n                    parentKey = await util.unaliasKeyword(keys[i], keys, i);\n                    break;\n                }\n            }\n            // Check if the predicate is marked as an @list in the context\n            const parentContext = await parsingContext.getContext(keys.slice(0, -1));\n            if ('@list' in Util_1.Util.getContextValueContainer(parentContext, parentKey)) {\n                // Our value is part of an array\n                // Emit the given objects as list elements\n                parsingContext.emittedStack[depth + 1] = true; // Ensure the creation of bnodes for empty nodes\n                const values = await util.valueToTerm(await parsingContext.getContext(keys), parentKey, value, depth, keys);\n                for (const object of values) {\n                    await this.handleListElement(parsingContext, util, object, value, depth, keys.slice(0, -1), depth - 1);\n                }\n                // If no values were found, emit a falsy list element to force an empty RDF list to be emitted.\n                if (values.length === 0) {\n                    await this.handleListElement(parsingContext, util, null, value, depth, keys.slice(0, -1), depth - 1);\n                }\n            }\n            else {\n                // Copy the stack values up one level so that the next job can access them.\n                parsingContext.shiftStack(depth, 1);\n                // Execute the job one level higher\n                await parsingContext.newOnValueJob(keys.slice(0, -1), value, depth - 1, false);\n                // Remove any defined contexts at this level to avoid it to propagate to the next array element.\n                parsingContext.contextTree.removeContext(keys.slice(0, -1));\n            }\n        }\n    }\n    async handleListElement(parsingContext, util, value, valueOriginal, depth, listRootKeys, listRootDepth) {\n        // Buffer our value as an RDF list using the listRootKey as predicate\n        let listPointer = parsingContext.listPointerStack[depth];\n        if (valueOriginal !== null && (await util.unaliasKeywords(valueOriginal, listRootKeys, depth))['@value'] !== null) {\n            if (!listPointer || !listPointer.value) {\n                const linkTerm = util.dataFactory.blankNode();\n                listPointer = { value: linkTerm, listRootDepth, listId: linkTerm };\n            }\n            else {\n                // rdf:rest links are always emitted before the next element,\n                // as the blank node identifier is only created at that point.\n                // Because of this reason, the final rdf:nil is emitted when the stack depth is decreased.\n                const newLinkTerm = util.dataFactory.blankNode();\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfRest, newLinkTerm, util.getDefaultGraph()));\n                // Update the list pointer for the next element\n                listPointer.value = newLinkTerm;\n            }\n            // Emit a list element for the current value\n            // Omit rdf:first if the value is invalid\n            if (value) {\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer.value, util.rdfFirst, value, util.getDefaultGraph()));\n            }\n        }\n        else {\n            // A falsy list element if found.\n            // Mark it as an rdf:nil list until another valid list element comes in\n            if (!listPointer) {\n                listPointer = { listRootDepth, listId: util.rdfNil };\n            }\n        }\n        parsingContext.listPointerStack[depth] = listPointer;\n    }\n}\nexports.EntryHandlerArrayValue = EntryHandlerArrayValue;\n//# sourceMappingURL=EntryHandlerArrayValue.js.map"]},"metadata":{},"sourceType":"script"}