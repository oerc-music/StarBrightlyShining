{"ast":null,"code":"/**\n * Traverses a path to collect links and nodes into an expression.\n */\nexport default class PathExpressionHandler {\n  async handle(pathData) {\n    const segments = [];\n    let current = pathData; // Add all predicates to the path\n\n    while (current.parent) {\n      // Obtain and store predicate\n      if (current.predicate) {\n        segments.unshift({\n          predicate: await current.predicate,\n          reverse: await current.reverse,\n          sort: current.sort,\n          values: current.values\n        });\n      } // Move to parent link\n\n\n      current = current.parent;\n    } // Add the root subject to the path\n\n\n    if (!current.subject) throw new Error(`Expected root subject in ${current}`);\n    const subject = await current.subject;\n    segments.unshift({\n      subject\n    });\n    return segments;\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/ldflex/module/PathExpressionHandler.js"],"names":["PathExpressionHandler","handle","pathData","segments","current","parent","predicate","unshift","reverse","sort","values","subject","Error"],"mappings":"AAAA;AACA;AACA;AACA,eAAe,MAAMA,qBAAN,CAA4B;AAC7B,QAANC,MAAM,CAACC,QAAD,EAAW;AACrB,UAAMC,QAAQ,GAAG,EAAjB;AACA,QAAIC,OAAO,GAAGF,QAAd,CAFqB,CAEG;;AAExB,WAAOE,OAAO,CAACC,MAAf,EAAuB;AACrB;AACA,UAAID,OAAO,CAACE,SAAZ,EAAuB;AACrBH,QAAAA,QAAQ,CAACI,OAAT,CAAiB;AACfD,UAAAA,SAAS,EAAE,MAAMF,OAAO,CAACE,SADV;AAEfE,UAAAA,OAAO,EAAE,MAAMJ,OAAO,CAACI,OAFR;AAGfC,UAAAA,IAAI,EAAEL,OAAO,CAACK,IAHC;AAIfC,UAAAA,MAAM,EAAEN,OAAO,CAACM;AAJD,SAAjB;AAMD,OAToB,CASnB;;;AAGFN,MAAAA,OAAO,GAAGA,OAAO,CAACC,MAAlB;AACD,KAjBoB,CAiBnB;;;AAGF,QAAI,CAACD,OAAO,CAACO,OAAb,EAAsB,MAAM,IAAIC,KAAJ,CAAW,4BAA2BR,OAAQ,EAA9C,CAAN;AACtB,UAAMO,OAAO,GAAG,MAAMP,OAAO,CAACO,OAA9B;AACAR,IAAAA,QAAQ,CAACI,OAAT,CAAiB;AACfI,MAAAA;AADe,KAAjB;AAGA,WAAOR,QAAP;AACD;;AA3BwC","sourcesContent":["/**\n * Traverses a path to collect links and nodes into an expression.\n */\nexport default class PathExpressionHandler {\n  async handle(pathData) {\n    const segments = [];\n    let current = pathData; // Add all predicates to the path\n\n    while (current.parent) {\n      // Obtain and store predicate\n      if (current.predicate) {\n        segments.unshift({\n          predicate: await current.predicate,\n          reverse: await current.reverse,\n          sort: current.sort,\n          values: current.values\n        });\n      } // Move to parent link\n\n\n      current = current.parent;\n    } // Add the root subject to the path\n\n\n    if (!current.subject) throw new Error(`Expected root subject in ${current}`);\n    const subject = await current.subject;\n    segments.unshift({\n      subject\n    });\n    return segments;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}