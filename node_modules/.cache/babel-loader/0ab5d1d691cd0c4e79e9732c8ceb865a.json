{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationPathOneOrMore = void 0;\n\nconst actor_abstract_path_1 = require(\"@comunica/actor-abstract-path\");\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica Path OneOrMore Query Operation Actor.\n */\n\n\nclass ActorQueryOperationPathOneOrMore extends actor_abstract_path_1.ActorAbstractPath {\n  constructor(args) {\n    super(args, sparqlalgebrajs_1.Algebra.types.ONE_OR_MORE_PATH);\n  }\n\n  async runOperation(path, context) {\n    const distinct = await this.isPathArbitraryLengthDistinct(context, path);\n\n    if (distinct.operation) {\n      return distinct.operation;\n    }\n\n    context = distinct.context;\n    const predicate = path.predicate;\n    const sVar = path.subject.termType === 'Variable';\n    const oVar = path.object.termType === 'Variable';\n    const gVar = path.graph.termType === 'Variable';\n\n    if (!sVar && oVar) {\n      // Get all the results of applying this once, then do zeroOrMore for those\n      const single = actor_abstract_path_1.ActorAbstractPath.FACTORY.createDistinct(actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.subject, predicate.path, path.object, path.graph));\n      const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n        context,\n        operation: single\n      }));\n      const objectString = rdf_string_1.termToString(path.object); // All branches need to share the same termHashes to prevent duplicates\n\n      const termHashes = {};\n      const bindingsStream = new asynciterator_1.MultiTransformIterator(results.bindingsStream, {\n        multiTransform: bindings => {\n          const val = bindings.get(objectString);\n          const graph = gVar ? bindings.get(rdf_string_1.termToString(path.graph)) : path.graph;\n          return new asynciterator_1.TransformIterator(async () => {\n            const it = new asynciterator_1.BufferedIterator();\n            await this.getObjectsPredicateStar(val, predicate.path, path.graph, context, termHashes, it, {\n              count: 0\n            });\n            return it.transform({\n              transform(item, next, push) {\n                let binding = bus_query_operation_1.Bindings({\n                  [objectString]: item\n                });\n\n                if (gVar) {\n                  binding = binding.set(rdf_string_1.termToString(path.graph), graph);\n                }\n\n                push(binding);\n                next();\n              }\n\n            });\n          }, {\n            maxBufferSize: 128\n          });\n        },\n        autoStart: false\n      });\n      const variables = gVar ? [objectString, rdf_string_1.termToString(path.graph)] : [objectString];\n      return {\n        type: 'bindings',\n        bindingsStream,\n        variables,\n        canContainUndefs: false\n      };\n    }\n\n    if (sVar && oVar) {\n      // Get all the results of subjects with same predicate, but once, then fill in first variable for those\n      const single = actor_abstract_path_1.ActorAbstractPath.FACTORY.createDistinct(actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.subject, path.predicate.path, path.object, path.graph));\n      const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n        context,\n        operation: single\n      }));\n      const subjectString = rdf_string_1.termToString(path.subject);\n      const objectString = rdf_string_1.termToString(path.object);\n      const termHashes = {};\n      const bindingsStream = new asynciterator_1.MultiTransformIterator(results.bindingsStream, {\n        multiTransform: bindings => {\n          const subject = bindings.get(subjectString);\n          const object = bindings.get(objectString);\n          const graph = gVar ? bindings.get(rdf_string_1.termToString(path.graph)) : path.graph;\n          return new asynciterator_1.TransformIterator(async () => {\n            const it = new asynciterator_1.BufferedIterator();\n            await this.getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, subject, object, predicate.path, graph, context, termHashes, {}, it, {\n              count: 0\n            });\n            return it.transform({\n              transform(item, next, push) {\n                if (gVar) {\n                  item = item.set(rdf_string_1.termToString(path.graph), graph);\n                }\n\n                push(item);\n                next();\n              }\n\n            });\n          }, {\n            maxBufferSize: 128\n          });\n        },\n        autoStart: false\n      });\n      const variables = gVar ? [subjectString, objectString, rdf_string_1.termToString(path.graph)] : [subjectString, objectString];\n      return {\n        type: 'bindings',\n        bindingsStream,\n        variables,\n        canContainUndefs: false\n      };\n    }\n\n    if (sVar && !oVar) {\n      return this.mediatorQueryOperation.mediate({\n        context,\n        operation: actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.object, actor_abstract_path_1.ActorAbstractPath.FACTORY.createOneOrMorePath(actor_abstract_path_1.ActorAbstractPath.FACTORY.createInv(predicate.path)), path.subject, path.graph)\n      });\n    } // If (!sVar && !oVar)\n\n\n    const variable = this.generateVariable();\n    const vString = rdf_string_1.termToString(variable);\n    const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n      context,\n      operation: actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.subject, predicate, variable, path.graph)\n    }));\n    const bindingsStream = results.bindingsStream.transform({\n      filter: item => item.get(vString).equals(path.object),\n\n      transform(item, next, push) {\n        const binding = gVar ? bus_query_operation_1.Bindings({\n          [rdf_string_1.termToString(path.graph)]: item.get(rdf_string_1.termToString(path.graph))\n        }) : bus_query_operation_1.Bindings({});\n        push(binding);\n        next();\n      }\n\n    });\n    return {\n      type: 'bindings',\n      bindingsStream,\n      variables: gVar ? [rdf_string_1.termToString(path.graph)] : [],\n      canContainUndefs: false\n    };\n  }\n\n}\n\nexports.ActorQueryOperationPathOneOrMore = ActorQueryOperationPathOneOrMore;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-path-one-or-more/lib/ActorQueryOperationPathOneOrMore.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationPathOneOrMore","actor_abstract_path_1","require","bus_query_operation_1","asynciterator_1","rdf_string_1","sparqlalgebrajs_1","ActorAbstractPath","constructor","args","Algebra","types","ONE_OR_MORE_PATH","runOperation","path","context","distinct","isPathArbitraryLengthDistinct","operation","predicate","sVar","subject","termType","oVar","object","gVar","graph","single","FACTORY","createDistinct","createPath","results","ActorQueryOperation","getSafeBindings","mediatorQueryOperation","mediate","objectString","termToString","termHashes","bindingsStream","MultiTransformIterator","multiTransform","bindings","val","get","TransformIterator","it","BufferedIterator","getObjectsPredicateStar","count","transform","item","next","push","binding","Bindings","set","maxBufferSize","autoStart","variables","type","canContainUndefs","subjectString","getSubjectAndObjectBindingsPredicateStar","createOneOrMorePath","createInv","variable","generateVariable","vString","filter","equals"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,gCAAR,GAA2C,KAAK,CAAhD;;AACA,MAAMC,qBAAqB,GAAGC,OAAO,CAAC,+BAAD,CAArC;;AACA,MAAMC,qBAAqB,GAAGD,OAAO,CAAC,+BAAD,CAArC;;AACA,MAAME,eAAe,GAAGF,OAAO,CAAC,eAAD,CAA/B;;AACA,MAAMG,YAAY,GAAGH,OAAO,CAAC,YAAD,CAA5B;;AACA,MAAMI,iBAAiB,GAAGJ,OAAO,CAAC,iBAAD,CAAjC;AACA;AACA;AACA;;;AACA,MAAMF,gCAAN,SAA+CC,qBAAqB,CAACM,iBAArE,CAAuF;AACnFC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAMA,IAAN,EAAYH,iBAAiB,CAACI,OAAlB,CAA0BC,KAA1B,CAAgCC,gBAA5C;AACH;;AACiB,QAAZC,YAAY,CAACC,IAAD,EAAOC,OAAP,EAAgB;AAC9B,UAAMC,QAAQ,GAAG,MAAM,KAAKC,6BAAL,CAAmCF,OAAnC,EAA4CD,IAA5C,CAAvB;;AACA,QAAIE,QAAQ,CAACE,SAAb,EAAwB;AACpB,aAAOF,QAAQ,CAACE,SAAhB;AACH;;AACDH,IAAAA,OAAO,GAAGC,QAAQ,CAACD,OAAnB;AACA,UAAMI,SAAS,GAAGL,IAAI,CAACK,SAAvB;AACA,UAAMC,IAAI,GAAGN,IAAI,CAACO,OAAL,CAAaC,QAAb,KAA0B,UAAvC;AACA,UAAMC,IAAI,GAAGT,IAAI,CAACU,MAAL,CAAYF,QAAZ,KAAyB,UAAtC;AACA,UAAMG,IAAI,GAAGX,IAAI,CAACY,KAAL,CAAWJ,QAAX,KAAwB,UAArC;;AACA,QAAI,CAACF,IAAD,IAASG,IAAb,EAAmB;AACf;AACA,YAAMI,MAAM,GAAG1B,qBAAqB,CAACM,iBAAtB,CAAwCqB,OAAxC,CAAgDC,cAAhD,CAA+D5B,qBAAqB,CAACM,iBAAtB,CAAwCqB,OAAxC,CAAgDE,UAAhD,CAA2DhB,IAAI,CAACO,OAAhE,EAAyEF,SAAS,CAACL,IAAnF,EAAyFA,IAAI,CAACU,MAA9F,EAAsGV,IAAI,CAACY,KAA3G,CAA/D,CAAf;AACA,YAAMK,OAAO,GAAG5B,qBAAqB,CAAC6B,mBAAtB,CAA0CC,eAA1C,CAA0D,MAAM,KAAKC,sBAAL,CAA4BC,OAA5B,CAAoC;AAAEpB,QAAAA,OAAF;AAAWG,QAAAA,SAAS,EAAES;AAAtB,OAApC,CAAhE,CAAhB;AACA,YAAMS,YAAY,GAAG/B,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACU,MAA/B,CAArB,CAJe,CAKf;;AACA,YAAMc,UAAU,GAAG,EAAnB;AACA,YAAMC,cAAc,GAAG,IAAInC,eAAe,CAACoC,sBAApB,CAA2CT,OAAO,CAACQ,cAAnD,EAAmE;AACtFE,QAAAA,cAAc,EAAGC,QAAD,IAAc;AAC1B,gBAAMC,GAAG,GAAGD,QAAQ,CAACE,GAAT,CAAaR,YAAb,CAAZ;AACA,gBAAMV,KAAK,GAAGD,IAAI,GAAGiB,QAAQ,CAACE,GAAT,CAAavC,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACY,KAA/B,CAAb,CAAH,GAAyDZ,IAAI,CAACY,KAAhF;AACA,iBAAO,IAAItB,eAAe,CAACyC,iBAApB,CAAsC,YAAY;AACrD,kBAAMC,EAAE,GAAG,IAAI1C,eAAe,CAAC2C,gBAApB,EAAX;AACA,kBAAM,KAAKC,uBAAL,CAA6BL,GAA7B,EAAkCxB,SAAS,CAACL,IAA5C,EAAkDA,IAAI,CAACY,KAAvD,EAA8DX,OAA9D,EAAuEuB,UAAvE,EAAmFQ,EAAnF,EAAuF;AAAEG,cAAAA,KAAK,EAAE;AAAT,aAAvF,CAAN;AACA,mBAAOH,EAAE,CAACI,SAAH,CAAa;AAChBA,cAAAA,SAAS,CAACC,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmB;AACxB,oBAAIC,OAAO,GAAGnD,qBAAqB,CAACoD,QAAtB,CAA+B;AAAE,mBAACnB,YAAD,GAAgBe;AAAlB,iBAA/B,CAAd;;AACA,oBAAI1B,IAAJ,EAAU;AACN6B,kBAAAA,OAAO,GAAGA,OAAO,CAACE,GAAR,CAAYnD,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACY,KAA/B,CAAZ,EAAmDA,KAAnD,CAAV;AACH;;AACD2B,gBAAAA,IAAI,CAACC,OAAD,CAAJ;AACAF,gBAAAA,IAAI;AACP;;AARe,aAAb,CAAP;AAUH,WAbM,EAaJ;AAAEK,YAAAA,aAAa,EAAE;AAAjB,WAbI,CAAP;AAcH,SAlBqF;AAmBtFC,QAAAA,SAAS,EAAE;AAnB2E,OAAnE,CAAvB;AAqBA,YAAMC,SAAS,GAAGlC,IAAI,GAAG,CAACW,YAAD,EAAe/B,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACY,KAA/B,CAAf,CAAH,GAA2D,CAACU,YAAD,CAAjF;AACA,aAAO;AAAEwB,QAAAA,IAAI,EAAE,UAAR;AAAoBrB,QAAAA,cAApB;AAAoCoB,QAAAA,SAApC;AAA+CE,QAAAA,gBAAgB,EAAE;AAAjE,OAAP;AACH;;AACD,QAAIzC,IAAI,IAAIG,IAAZ,EAAkB;AACd;AACA,YAAMI,MAAM,GAAG1B,qBAAqB,CAACM,iBAAtB,CAAwCqB,OAAxC,CAAgDC,cAAhD,CAA+D5B,qBAAqB,CAACM,iBAAtB,CAAwCqB,OAAxC,CAAgDE,UAAhD,CAA2DhB,IAAI,CAACO,OAAhE,EAAyEP,IAAI,CAACK,SAAL,CAAeL,IAAxF,EAA8FA,IAAI,CAACU,MAAnG,EAA2GV,IAAI,CAACY,KAAhH,CAA/D,CAAf;AACA,YAAMK,OAAO,GAAG5B,qBAAqB,CAAC6B,mBAAtB,CAA0CC,eAA1C,CAA0D,MAAM,KAAKC,sBAAL,CAA4BC,OAA5B,CAAoC;AAAEpB,QAAAA,OAAF;AAAWG,QAAAA,SAAS,EAAES;AAAtB,OAApC,CAAhE,CAAhB;AACA,YAAMmC,aAAa,GAAGzD,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACO,OAA/B,CAAtB;AACA,YAAMe,YAAY,GAAG/B,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACU,MAA/B,CAArB;AACA,YAAMc,UAAU,GAAG,EAAnB;AACA,YAAMC,cAAc,GAAG,IAAInC,eAAe,CAACoC,sBAApB,CAA2CT,OAAO,CAACQ,cAAnD,EAAmE;AACtFE,QAAAA,cAAc,EAAGC,QAAD,IAAc;AAC1B,gBAAMrB,OAAO,GAAGqB,QAAQ,CAACE,GAAT,CAAakB,aAAb,CAAhB;AACA,gBAAMtC,MAAM,GAAGkB,QAAQ,CAACE,GAAT,CAAaR,YAAb,CAAf;AACA,gBAAMV,KAAK,GAAGD,IAAI,GAAGiB,QAAQ,CAACE,GAAT,CAAavC,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACY,KAA/B,CAAb,CAAH,GAAyDZ,IAAI,CAACY,KAAhF;AACA,iBAAO,IAAItB,eAAe,CAACyC,iBAApB,CAAsC,YAAY;AACrD,kBAAMC,EAAE,GAAG,IAAI1C,eAAe,CAAC2C,gBAApB,EAAX;AACA,kBAAM,KAAKgB,wCAAL,CAA8CD,aAA9C,EAA6D1B,YAA7D,EAA2Ef,OAA3E,EAAoFG,MAApF,EAA4FL,SAAS,CAACL,IAAtG,EAA4GY,KAA5G,EAAmHX,OAAnH,EAA4HuB,UAA5H,EAAwI,EAAxI,EAA4IQ,EAA5I,EAAgJ;AAAEG,cAAAA,KAAK,EAAE;AAAT,aAAhJ,CAAN;AACA,mBAAOH,EAAE,CAACI,SAAH,CAAa;AAChBA,cAAAA,SAAS,CAACC,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmB;AACxB,oBAAI5B,IAAJ,EAAU;AACN0B,kBAAAA,IAAI,GAAGA,IAAI,CAACK,GAAL,CAASnD,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACY,KAA/B,CAAT,EAAgDA,KAAhD,CAAP;AACH;;AACD2B,gBAAAA,IAAI,CAACF,IAAD,CAAJ;AACAC,gBAAAA,IAAI;AACP;;AAPe,aAAb,CAAP;AASH,WAZM,EAYJ;AAAEK,YAAAA,aAAa,EAAE;AAAjB,WAZI,CAAP;AAaH,SAlBqF;AAmBtFC,QAAAA,SAAS,EAAE;AAnB2E,OAAnE,CAAvB;AAqBA,YAAMC,SAAS,GAAGlC,IAAI,GAClB,CAACqC,aAAD,EAAgB1B,YAAhB,EAA8B/B,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACY,KAA/B,CAA9B,CADkB,GAElB,CAACoC,aAAD,EAAgB1B,YAAhB,CAFJ;AAGA,aAAO;AAAEwB,QAAAA,IAAI,EAAE,UAAR;AAAoBrB,QAAAA,cAApB;AAAoCoB,QAAAA,SAApC;AAA+CE,QAAAA,gBAAgB,EAAE;AAAjE,OAAP;AACH;;AACD,QAAIzC,IAAI,IAAI,CAACG,IAAb,EAAmB;AACf,aAAO,KAAKW,sBAAL,CAA4BC,OAA5B,CAAoC;AACvCpB,QAAAA,OADuC;AAEvCG,QAAAA,SAAS,EAAEjB,qBAAqB,CAACM,iBAAtB,CAAwCqB,OAAxC,CAAgDE,UAAhD,CAA2DhB,IAAI,CAACU,MAAhE,EAAwEvB,qBAAqB,CAACM,iBAAtB,CAAwCqB,OAAxC,CAAgDoC,mBAAhD,CAAoE/D,qBAAqB,CAACM,iBAAtB,CAAwCqB,OAAxC,CAAgDqC,SAAhD,CAA0D9C,SAAS,CAACL,IAApE,CAApE,CAAxE,EAAwNA,IAAI,CAACO,OAA7N,EAAsOP,IAAI,CAACY,KAA3O;AAF4B,OAApC,CAAP;AAIH,KA/E6B,CAgF9B;;;AACA,UAAMwC,QAAQ,GAAG,KAAKC,gBAAL,EAAjB;AACA,UAAMC,OAAO,GAAG/D,YAAY,CAACgC,YAAb,CAA0B6B,QAA1B,CAAhB;AACA,UAAMnC,OAAO,GAAG5B,qBAAqB,CAAC6B,mBAAtB,CAA0CC,eAA1C,CAA0D,MAAM,KAAKC,sBAAL,CAA4BC,OAA5B,CAAoC;AAChHpB,MAAAA,OADgH;AAEhHG,MAAAA,SAAS,EAAEjB,qBAAqB,CAACM,iBAAtB,CAAwCqB,OAAxC,CAAgDE,UAAhD,CAA2DhB,IAAI,CAACO,OAAhE,EAAyEF,SAAzE,EAAoF+C,QAApF,EAA8FpD,IAAI,CAACY,KAAnG;AAFqG,KAApC,CAAhE,CAAhB;AAIA,UAAMa,cAAc,GAAGR,OAAO,CAACQ,cAAR,CAAuBW,SAAvB,CAAiC;AACpDmB,MAAAA,MAAM,EAAElB,IAAI,IAAIA,IAAI,CAACP,GAAL,CAASwB,OAAT,EAAkBE,MAAlB,CAAyBxD,IAAI,CAACU,MAA9B,CADoC;;AAEpD0B,MAAAA,SAAS,CAACC,IAAD,EAAOC,IAAP,EAAaC,IAAb,EAAmB;AACxB,cAAMC,OAAO,GAAG7B,IAAI,GAChBtB,qBAAqB,CAACoD,QAAtB,CAA+B;AAAE,WAAClD,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACY,KAA/B,CAAD,GAAyCyB,IAAI,CAACP,GAAL,CAASvC,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACY,KAA/B,CAAT;AAA3C,SAA/B,CADgB,GAEhBvB,qBAAqB,CAACoD,QAAtB,CAA+B,EAA/B,CAFJ;AAGAF,QAAAA,IAAI,CAACC,OAAD,CAAJ;AACAF,QAAAA,IAAI;AACP;;AARmD,KAAjC,CAAvB;AAUA,WAAO;AACHQ,MAAAA,IAAI,EAAE,UADH;AAEHrB,MAAAA,cAFG;AAGHoB,MAAAA,SAAS,EAAElC,IAAI,GAAG,CAACpB,YAAY,CAACgC,YAAb,CAA0BvB,IAAI,CAACY,KAA/B,CAAD,CAAH,GAA6C,EAHzD;AAIHmC,MAAAA,gBAAgB,EAAE;AAJf,KAAP;AAMH;;AA3GkF;;AA6GvF/D,OAAO,CAACE,gCAAR,GAA2CA,gCAA3C","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationPathOneOrMore = void 0;\nconst actor_abstract_path_1 = require(\"@comunica/actor-abstract-path\");\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n/**\n * A comunica Path OneOrMore Query Operation Actor.\n */\nclass ActorQueryOperationPathOneOrMore extends actor_abstract_path_1.ActorAbstractPath {\n    constructor(args) {\n        super(args, sparqlalgebrajs_1.Algebra.types.ONE_OR_MORE_PATH);\n    }\n    async runOperation(path, context) {\n        const distinct = await this.isPathArbitraryLengthDistinct(context, path);\n        if (distinct.operation) {\n            return distinct.operation;\n        }\n        context = distinct.context;\n        const predicate = path.predicate;\n        const sVar = path.subject.termType === 'Variable';\n        const oVar = path.object.termType === 'Variable';\n        const gVar = path.graph.termType === 'Variable';\n        if (!sVar && oVar) {\n            // Get all the results of applying this once, then do zeroOrMore for those\n            const single = actor_abstract_path_1.ActorAbstractPath.FACTORY.createDistinct(actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.subject, predicate.path, path.object, path.graph));\n            const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ context, operation: single }));\n            const objectString = rdf_string_1.termToString(path.object);\n            // All branches need to share the same termHashes to prevent duplicates\n            const termHashes = {};\n            const bindingsStream = new asynciterator_1.MultiTransformIterator(results.bindingsStream, {\n                multiTransform: (bindings) => {\n                    const val = bindings.get(objectString);\n                    const graph = gVar ? bindings.get(rdf_string_1.termToString(path.graph)) : path.graph;\n                    return new asynciterator_1.TransformIterator(async () => {\n                        const it = new asynciterator_1.BufferedIterator();\n                        await this.getObjectsPredicateStar(val, predicate.path, path.graph, context, termHashes, it, { count: 0 });\n                        return it.transform({\n                            transform(item, next, push) {\n                                let binding = bus_query_operation_1.Bindings({ [objectString]: item });\n                                if (gVar) {\n                                    binding = binding.set(rdf_string_1.termToString(path.graph), graph);\n                                }\n                                push(binding);\n                                next();\n                            },\n                        });\n                    }, { maxBufferSize: 128 });\n                },\n                autoStart: false,\n            });\n            const variables = gVar ? [objectString, rdf_string_1.termToString(path.graph)] : [objectString];\n            return { type: 'bindings', bindingsStream, variables, canContainUndefs: false };\n        }\n        if (sVar && oVar) {\n            // Get all the results of subjects with same predicate, but once, then fill in first variable for those\n            const single = actor_abstract_path_1.ActorAbstractPath.FACTORY.createDistinct(actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.subject, path.predicate.path, path.object, path.graph));\n            const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ context, operation: single }));\n            const subjectString = rdf_string_1.termToString(path.subject);\n            const objectString = rdf_string_1.termToString(path.object);\n            const termHashes = {};\n            const bindingsStream = new asynciterator_1.MultiTransformIterator(results.bindingsStream, {\n                multiTransform: (bindings) => {\n                    const subject = bindings.get(subjectString);\n                    const object = bindings.get(objectString);\n                    const graph = gVar ? bindings.get(rdf_string_1.termToString(path.graph)) : path.graph;\n                    return new asynciterator_1.TransformIterator(async () => {\n                        const it = new asynciterator_1.BufferedIterator();\n                        await this.getSubjectAndObjectBindingsPredicateStar(subjectString, objectString, subject, object, predicate.path, graph, context, termHashes, {}, it, { count: 0 });\n                        return it.transform({\n                            transform(item, next, push) {\n                                if (gVar) {\n                                    item = item.set(rdf_string_1.termToString(path.graph), graph);\n                                }\n                                push(item);\n                                next();\n                            },\n                        });\n                    }, { maxBufferSize: 128 });\n                },\n                autoStart: false,\n            });\n            const variables = gVar ?\n                [subjectString, objectString, rdf_string_1.termToString(path.graph)] :\n                [subjectString, objectString];\n            return { type: 'bindings', bindingsStream, variables, canContainUndefs: false };\n        }\n        if (sVar && !oVar) {\n            return this.mediatorQueryOperation.mediate({\n                context,\n                operation: actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.object, actor_abstract_path_1.ActorAbstractPath.FACTORY.createOneOrMorePath(actor_abstract_path_1.ActorAbstractPath.FACTORY.createInv(predicate.path)), path.subject, path.graph),\n            });\n        }\n        // If (!sVar && !oVar)\n        const variable = this.generateVariable();\n        const vString = rdf_string_1.termToString(variable);\n        const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n            context,\n            operation: actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.subject, predicate, variable, path.graph),\n        }));\n        const bindingsStream = results.bindingsStream.transform({\n            filter: item => item.get(vString).equals(path.object),\n            transform(item, next, push) {\n                const binding = gVar ?\n                    bus_query_operation_1.Bindings({ [rdf_string_1.termToString(path.graph)]: item.get(rdf_string_1.termToString(path.graph)) }) :\n                    bus_query_operation_1.Bindings({});\n                push(binding);\n                next();\n            },\n        });\n        return {\n            type: 'bindings',\n            bindingsStream,\n            variables: gVar ? [rdf_string_1.termToString(path.graph)] : [],\n            canContainUndefs: false,\n        };\n    }\n}\nexports.ActorQueryOperationPathOneOrMore = ActorQueryOperationPathOneOrMore;\n//# sourceMappingURL=ActorQueryOperationPathOneOrMore.js.map"]},"metadata":{},"sourceType":"script"}