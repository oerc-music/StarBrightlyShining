{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationMinus = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst BindingsIndex_1 = require(\"./BindingsIndex\");\n/**\n * A comunica Minus Query Operation Actor.\n */\n\n\nclass ActorQueryOperationMinus extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n  constructor(args) {\n    super(args, 'minus');\n  }\n\n  async testOperation(operation, context) {\n    return true;\n  }\n\n  async runOperation(pattern, context) {\n    const buffer = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n      operation: pattern.right,\n      context\n    }));\n    const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n      operation: pattern.left,\n      context\n    }));\n    const commons = this.getCommonVariables(buffer.variables, output.variables);\n\n    if (commons.length > 0) {\n      /**\n       * To assure we've filtered all B (`buffer`) values from A (`output`) we wait until we've fetched all values of B.\n       * Then we save these triples in `index` and use it to filter our A-stream.\n       */\n      const index = new BindingsIndex_1.BindingsIndex(commons);\n      const bindingsStream = new asynciterator_1.TransformIterator(async () => {\n        await new Promise(resolve => {\n          buffer.bindingsStream.on('data', data => index.add(data));\n          buffer.bindingsStream.on('end', resolve);\n        });\n        return output.bindingsStream.filter(data => !index.contains(data));\n      }, {\n        autoStart: false\n      });\n      const canContainUndefs = buffer.canContainUndefs || output.canContainUndefs;\n      return {\n        type: 'bindings',\n        bindingsStream,\n        variables: output.variables,\n        metadata: output.metadata,\n        canContainUndefs\n      };\n    }\n\n    return output;\n  }\n  /**\n   * This function puts all common values between 2 arrays in a map with `value` : true\n   */\n\n\n  getCommonVariables(array1, array2) {\n    return Object.keys(array1.filter(value => array2.includes(value)).reduce((hash, key) => {\n      hash[key] = true;\n      return hash;\n    }, {}));\n  }\n\n}\n\nexports.ActorQueryOperationMinus = ActorQueryOperationMinus;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-minus/lib/ActorQueryOperationMinus.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationMinus","bus_query_operation_1","require","asynciterator_1","BindingsIndex_1","ActorQueryOperationTypedMediated","constructor","args","testOperation","operation","context","runOperation","pattern","buffer","ActorQueryOperation","getSafeBindings","mediatorQueryOperation","mediate","right","output","left","commons","getCommonVariables","variables","length","index","BindingsIndex","bindingsStream","TransformIterator","Promise","resolve","on","data","add","filter","contains","autoStart","canContainUndefs","type","metadata","array1","array2","keys","includes","reduce","hash","key"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationMinus = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst BindingsIndex_1 = require(\"./BindingsIndex\");\n/**\n * A comunica Minus Query Operation Actor.\n */\nclass ActorQueryOperationMinus extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n    constructor(args) {\n        super(args, 'minus');\n    }\n    async testOperation(operation, context) {\n        return true;\n    }\n    async runOperation(pattern, context) {\n        const buffer = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: pattern.right, context }));\n        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: pattern.left, context }));\n        const commons = this.getCommonVariables(buffer.variables, output.variables);\n        if (commons.length > 0) {\n            /**\n             * To assure we've filtered all B (`buffer`) values from A (`output`) we wait until we've fetched all values of B.\n             * Then we save these triples in `index` and use it to filter our A-stream.\n             */\n            const index = new BindingsIndex_1.BindingsIndex(commons);\n            const bindingsStream = new asynciterator_1.TransformIterator(async () => {\n                await new Promise(resolve => {\n                    buffer.bindingsStream.on('data', data => index.add(data));\n                    buffer.bindingsStream.on('end', resolve);\n                });\n                return output.bindingsStream.filter(data => !index.contains(data));\n            }, { autoStart: false });\n            const canContainUndefs = buffer.canContainUndefs || output.canContainUndefs;\n            return {\n                type: 'bindings',\n                bindingsStream,\n                variables: output.variables,\n                metadata: output.metadata,\n                canContainUndefs,\n            };\n        }\n        return output;\n    }\n    /**\n     * This function puts all common values between 2 arrays in a map with `value` : true\n     */\n    getCommonVariables(array1, array2) {\n        return Object.keys(array1.filter((value) => array2.includes(value)).reduce((hash, key) => {\n            hash[key] = true;\n            return hash;\n        }, {}));\n    }\n}\nexports.ActorQueryOperationMinus = ActorQueryOperationMinus;\n//# sourceMappingURL=ActorQueryOperationMinus.js.map"]},"metadata":{},"sourceType":"script"}