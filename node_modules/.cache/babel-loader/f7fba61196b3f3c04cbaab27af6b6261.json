{"ast":null,"code":"import update from 'immutability-helper';\nimport { FETCH_MANIFESTATIONS, FETCH_TEI } from '../actions/index';\nconst EMBODIMENT = 'frbr:embodiment';\nconst ASSOCIATED = \"http://example.com/must-revisit-these/associatedWith\";\nconst MEMBER = 'rdfs:member';\nconst TEITYPE = 'meld:TEIEmbodiment';\nconst LIBRETTOTYPE = 'mo:PublishedLibretto';\nexport default function (state = {\n  TEI: {},\n  componentTargets: {},\n  fragImages: {},\n  librettoTargets: {}\n}, action) {\n  switch (action.type) {\n    case FETCH_TEI:\n      return update(state, {\n        TEI: {\n          $merge: {\n            [action.payload.uri]: action.payload.data\n          }\n        }\n      });\n\n    case FETCH_MANIFESTATIONS:\n      // find associated TEI\n      const target = action.payload.target;\n      const part = action.payload.part;\n\n      if (typeof part === \"undefined\") {\n        // part wasn't on segment line\n        return state;\n      } // console.log(\"In FETCH_MANIFESTATIONS TEI, target is: \", target, \" part is: \", part);\n\n\n      let fragments = [];\n      let libretto = []; // go through each part, finding embodibags\n\n      if (EMBODIMENT in part) {\n        if (!Array.isArray(part[EMBODIMENT])) {\n          part[EMBODIMENT] = [part[EMBODIMENT]];\n        }\n\n        part[EMBODIMENT].map(embodiment => {\n          // go through each embodiment\n          if (MEMBER in embodiment) {\n            // extract set of fragments\n            if (!Array.isArray(embodiment[\"@type\"])) {\n              embodiment[\"@type\"] = [embodiment[\"@type\"]];\n            }\n\n            if (embodiment[\"@type\"].includes(TEITYPE)) {\n              if (!Array.isArray(embodiment[MEMBER])) {\n                embodiment[MEMBER] = [embodiment[MEMBER]];\n              }\n\n              let TEIFrags = embodiment[MEMBER].map(member => {\n                return member[\"@id\"];\n              });\n\n              if (embodiment[\"@type\"].includes(LIBRETTOTYPE)) {\n                console.log(\"----------------------\");\n                libretto = libretto.concat(TEIFrags);\n              }\n\n              fragments = fragments.concat(TEIFrags);\n            } else {\n              console.log(\"TEI Reducer: Embodiment with unknown type\", embodiment);\n            } //fragments[fragtype] = embodiment[MEMBER].map( (member) => {\n\n          } else {\n            console.log(\"Embodiment without members: \", part, embodiment);\n          }\n        });\n        return update(state, {\n          componentTargets: {\n            $merge: {\n              [target[\"@id\"]]: fragments\n            }\n          },\n          librettoTargets: {\n            $merge: {\n              [target[\"@id\"]]: libretto\n            }\n          }\n        });\n      }\n      /*\n          if(ASSOCIATED in target) {\n        if(!Array.isArray(target[ASSOCIATED])) {\n          target[ASSOCIATED] = [target[ASSOCIATED]];\n        }\n              // extract target fragments\n              // TODO properly ontologize ASSOCIATED, including differentiating TEI and others\n              const fragments = target[ASSOCIATED].map( (assoc) => {\n                  return assoc[\"@id\"];\n              });\n              const targetid = target[\"@id\"];\n        // are there any associated images?\n        const fragImages = {};\n          target[ASSOCIATED].filter( (assoc) => {\n          return EMBODIMENT in assoc\n        }).map( (assoc) => {\n          fragImages[assoc[\"@id\"]] = assoc[EMBODIMENT][\"@id\"];\n        })\n              return update(state, {\n          componentTargets: { $merge: { [target[\"@id\"]]: fragments }},\n          fragImages: { $merge: fragImages }\n         });\n          console.log(\"FETCH_COMPONENT_TARGET: Unassociated target! \", target);\n          }*/\n\n\n      return state;\n\n    default:\n      return state;\n  }\n}\n;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/meld-clients-core/lib/reducers/reducer_tei.js"],"names":["update","FETCH_MANIFESTATIONS","FETCH_TEI","EMBODIMENT","ASSOCIATED","MEMBER","TEITYPE","LIBRETTOTYPE","state","TEI","componentTargets","fragImages","librettoTargets","action","type","$merge","payload","uri","data","target","part","fragments","libretto","Array","isArray","map","embodiment","includes","TEIFrags","member","console","log","concat"],"mappings":"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","sourcesContent":["import update from 'immutability-helper';\nimport { FETCH_MANIFESTATIONS, FETCH_TEI } from '../actions/index';\nconst EMBODIMENT = 'frbr:embodiment';\nconst ASSOCIATED = \"http://example.com/must-revisit-these/associatedWith\";\nconst MEMBER = 'rdfs:member';\nconst TEITYPE = 'meld:TEIEmbodiment';\nconst LIBRETTOTYPE = 'mo:PublishedLibretto';\nexport default function (state = {\n  TEI: {},\n  componentTargets: {},\n  fragImages: {},\n  librettoTargets: {}\n}, action) {\n  switch (action.type) {\n    case FETCH_TEI:\n      return update(state, {\n        TEI: {\n          $merge: {\n            [action.payload.uri]: action.payload.data\n          }\n        }\n      });\n\n    case FETCH_MANIFESTATIONS:\n      // find associated TEI\n      const target = action.payload.target;\n      const part = action.payload.part;\n\n      if (typeof part === \"undefined\") {\n        // part wasn't on segment line\n        return state;\n      } // console.log(\"In FETCH_MANIFESTATIONS TEI, target is: \", target, \" part is: \", part);\n\n\n      let fragments = [];\n      let libretto = []; // go through each part, finding embodibags\n\n      if (EMBODIMENT in part) {\n        if (!Array.isArray(part[EMBODIMENT])) {\n          part[EMBODIMENT] = [part[EMBODIMENT]];\n        }\n\n        part[EMBODIMENT].map(embodiment => {\n          // go through each embodiment\n          if (MEMBER in embodiment) {\n            // extract set of fragments\n            if (!Array.isArray(embodiment[\"@type\"])) {\n              embodiment[\"@type\"] = [embodiment[\"@type\"]];\n            }\n\n            if (embodiment[\"@type\"].includes(TEITYPE)) {\n              if (!Array.isArray(embodiment[MEMBER])) {\n                embodiment[MEMBER] = [embodiment[MEMBER]];\n              }\n\n              let TEIFrags = embodiment[MEMBER].map(member => {\n                return member[\"@id\"];\n              });\n\n              if (embodiment[\"@type\"].includes(LIBRETTOTYPE)) {\n                console.log(\"----------------------\");\n                libretto = libretto.concat(TEIFrags);\n              }\n\n              fragments = fragments.concat(TEIFrags);\n            } else {\n              console.log(\"TEI Reducer: Embodiment with unknown type\", embodiment);\n            } //fragments[fragtype] = embodiment[MEMBER].map( (member) => {\n\n          } else {\n            console.log(\"Embodiment without members: \", part, embodiment);\n          }\n        });\n        return update(state, {\n          componentTargets: {\n            $merge: {\n              [target[\"@id\"]]: fragments\n            }\n          },\n          librettoTargets: {\n            $merge: {\n              [target[\"@id\"]]: libretto\n            }\n          }\n        });\n      }\n      /*\n          if(ASSOCIATED in target) {\n        if(!Array.isArray(target[ASSOCIATED])) {\n          target[ASSOCIATED] = [target[ASSOCIATED]];\n        }\n              // extract target fragments\n              // TODO properly ontologize ASSOCIATED, including differentiating TEI and others\n              const fragments = target[ASSOCIATED].map( (assoc) => {\n                  return assoc[\"@id\"];\n              });\n              const targetid = target[\"@id\"];\n        // are there any associated images?\n        const fragImages = {};\n          target[ASSOCIATED].filter( (assoc) => {\n          return EMBODIMENT in assoc\n        }).map( (assoc) => {\n          fragImages[assoc[\"@id\"]] = assoc[EMBODIMENT][\"@id\"];\n        })\n              return update(state, {\n          componentTargets: { $merge: { [target[\"@id\"]]: fragments }},\n          fragImages: { $merge: fragImages }\n         });\n          console.log(\"FETCH_COMPONENT_TARGET: Unassociated target! \", target);\n          }*/\n\n\n      return state;\n\n    default:\n      return state;\n  }\n}\n;"]},"metadata":{},"sourceType":"module"}