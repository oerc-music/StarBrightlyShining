{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorHttpNative = void 0;\n\nconst bus_http_1 = require(\"@comunica/bus-http\");\n\nconst context_entries_1 = require(\"@comunica/context-entries\");\n\nrequire(\"cross-fetch/polyfill\");\n\nconst Requester_1 = require(\"./Requester\");\n/**\n * A comunica Follow Redirects Http Actor.\n */\n\n\nclass ActorHttpNative extends bus_http_1.ActorHttp {\n  constructor(args) {\n    super(args);\n    this.userAgent = ActorHttpNative.createUserAgent();\n    this.requester = new Requester_1.default(args.agentOptions ? JSON.parse(args.agentOptions) : undefined);\n  }\n\n  static createUserAgent() {\n    return `Comunica/actor-http-native (${typeof global.navigator === 'undefined' ? `Node.js ${process.version}; ${process.platform}` : `Browser-${global.navigator.userAgent}`})`;\n  }\n\n  async test(action) {\n    // TODO: check for unsupported fetch features\n    return {\n      time: Number.POSITIVE_INFINITY\n    };\n  }\n\n  async run(action) {\n    const options = {}; // Input can be a Request object or a string\n    // if it is a Request object it can contain the same settings as the init object\n\n    if (action.input.url) {\n      options.url = action.input.url;\n      Object.assign(options, action.input);\n    } else {\n      options.url = action.input;\n    }\n\n    if (action.init) {\n      Object.assign(options, action.init);\n      options.headers = new Headers(action.init.headers);\n      options.body = action.init.body;\n    } else {\n      options.headers = action.input.headers;\n\n      if (action.input.body) {\n        throw new Error(`ActorHttpNative does not support passing body via input, use init instead.`);\n      }\n    }\n\n    if (!options.headers) {\n      options.headers = new Headers();\n    }\n\n    if (!options.headers.has('user-agent')) {\n      options.headers.append('user-agent', this.userAgent);\n    }\n\n    options.method = options.method || 'GET';\n\n    if (action.context && action.context.get(context_entries_1.KeysHttp.includeCredentials)) {\n      options.withCredentials = true;\n    }\n\n    if (action.context && action.context.get(context_entries_1.KeysHttp.auth)) {\n      options.auth = action.context.get(context_entries_1.KeysHttp.auth);\n    }\n\n    this.logInfo(action.context, `Requesting ${options.url}`, () => ({\n      headers: bus_http_1.ActorHttp.headersToHash(options.headers),\n      method: options.method\n    })); // Not all options are supported\n\n    return new Promise((resolve, reject) => {\n      const req = this.requester.createRequest(options);\n      req.on('error', reject);\n      req.on('response', httpResponse => {\n        httpResponse.on('error', error => {\n          httpResponse = null;\n          reject(error);\n        }); // Avoid memory leak on HEAD requests\n\n        if (options.method === 'HEAD') {\n          httpResponse.destroy();\n        } // Using setImmediate so error can be caught should it be thrown\n\n\n        setImmediate(() => {\n          if (httpResponse) {\n            // Expose fetch cancel promise\n            httpResponse.cancel = () => {\n              httpResponse.destroy();\n              return Promise.resolve();\n            }; // Missing several of the required fetch fields\n\n\n            const headers = httpResponse.headers;\n            const result = {\n              body: httpResponse,\n              headers,\n              ok: httpResponse.statusCode < 300,\n              redirected: options.url !== httpResponse.responseUrl,\n              status: httpResponse.statusCode,\n              // When the content came from another resource because of conneg, let Content-Location deliver the url\n              url: headers.has('content-location') ? headers.get('content-location') : httpResponse.responseUrl\n            };\n            resolve(result);\n          }\n        });\n      });\n    });\n  }\n\n}\n\nexports.ActorHttpNative = ActorHttpNative;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-http-native/lib/ActorHttpNative.js"],"names":["Object","defineProperty","exports","value","ActorHttpNative","bus_http_1","require","context_entries_1","Requester_1","ActorHttp","constructor","args","userAgent","createUserAgent","requester","default","agentOptions","JSON","parse","undefined","global","navigator","process","version","platform","test","action","time","Number","POSITIVE_INFINITY","run","options","input","url","assign","init","headers","Headers","body","Error","has","append","method","context","get","KeysHttp","includeCredentials","withCredentials","auth","logInfo","headersToHash","Promise","resolve","reject","req","createRequest","on","httpResponse","error","destroy","setImmediate","cancel","result","ok","statusCode","redirected","responseUrl","status"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorHttpNative = void 0;\nconst bus_http_1 = require(\"@comunica/bus-http\");\nconst context_entries_1 = require(\"@comunica/context-entries\");\nrequire(\"cross-fetch/polyfill\");\nconst Requester_1 = require(\"./Requester\");\n/**\n * A comunica Follow Redirects Http Actor.\n */\nclass ActorHttpNative extends bus_http_1.ActorHttp {\n    constructor(args) {\n        super(args);\n        this.userAgent = ActorHttpNative.createUserAgent();\n        this.requester = new Requester_1.default(args.agentOptions ? JSON.parse(args.agentOptions) : undefined);\n    }\n    static createUserAgent() {\n        return `Comunica/actor-http-native (${typeof global.navigator === 'undefined' ?\n            `Node.js ${process.version}; ${process.platform}` :\n            `Browser-${global.navigator.userAgent}`})`;\n    }\n    async test(action) {\n        // TODO: check for unsupported fetch features\n        return { time: Number.POSITIVE_INFINITY };\n    }\n    async run(action) {\n        const options = {};\n        // Input can be a Request object or a string\n        // if it is a Request object it can contain the same settings as the init object\n        if (action.input.url) {\n            options.url = action.input.url;\n            Object.assign(options, action.input);\n        }\n        else {\n            options.url = action.input;\n        }\n        if (action.init) {\n            Object.assign(options, action.init);\n            options.headers = new Headers(action.init.headers);\n            options.body = action.init.body;\n        }\n        else {\n            options.headers = action.input.headers;\n            if (action.input.body) {\n                throw new Error(`ActorHttpNative does not support passing body via input, use init instead.`);\n            }\n        }\n        if (!options.headers) {\n            options.headers = new Headers();\n        }\n        if (!options.headers.has('user-agent')) {\n            options.headers.append('user-agent', this.userAgent);\n        }\n        options.method = options.method || 'GET';\n        if (action.context && action.context.get(context_entries_1.KeysHttp.includeCredentials)) {\n            options.withCredentials = true;\n        }\n        if (action.context && action.context.get(context_entries_1.KeysHttp.auth)) {\n            options.auth = action.context.get(context_entries_1.KeysHttp.auth);\n        }\n        this.logInfo(action.context, `Requesting ${options.url}`, () => ({\n            headers: bus_http_1.ActorHttp.headersToHash(options.headers),\n            method: options.method,\n        }));\n        // Not all options are supported\n        return new Promise((resolve, reject) => {\n            const req = this.requester.createRequest(options);\n            req.on('error', reject);\n            req.on('response', httpResponse => {\n                httpResponse.on('error', (error) => {\n                    httpResponse = null;\n                    reject(error);\n                });\n                // Avoid memory leak on HEAD requests\n                if (options.method === 'HEAD') {\n                    httpResponse.destroy();\n                }\n                // Using setImmediate so error can be caught should it be thrown\n                setImmediate(() => {\n                    if (httpResponse) {\n                        // Expose fetch cancel promise\n                        httpResponse.cancel = () => {\n                            httpResponse.destroy();\n                            return Promise.resolve();\n                        };\n                        // Missing several of the required fetch fields\n                        const headers = httpResponse.headers;\n                        const result = {\n                            body: httpResponse,\n                            headers,\n                            ok: httpResponse.statusCode < 300,\n                            redirected: options.url !== httpResponse.responseUrl,\n                            status: httpResponse.statusCode,\n                            // When the content came from another resource because of conneg, let Content-Location deliver the url\n                            url: headers.has('content-location') ? headers.get('content-location') : httpResponse.responseUrl,\n                        };\n                        resolve(result);\n                    }\n                });\n            });\n        });\n    }\n}\nexports.ActorHttpNative = ActorHttpNative;\n//# sourceMappingURL=ActorHttpNative.js.map"]},"metadata":{},"sourceType":"script"}