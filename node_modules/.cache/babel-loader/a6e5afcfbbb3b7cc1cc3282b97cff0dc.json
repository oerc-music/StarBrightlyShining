{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst algebra_1 = require(\"./algebra\");\n\nconst factory_1 = require(\"./factory\");\n\nclass Util {\n  /**\n   * Flattens an array of arrays to an array.\n   * @param arr - Array of arrays\n   */\n  static flatten(arr) {\n    return Array.prototype.concat(...arr).filter(x => x);\n  }\n  /**\n   * Detects all in-scope variables.\n   * In practice this means iterating through the entire algebra tree, finding all variables,\n   * and stopping when a project function is found.\n   * @param {Operation} op - Input algebra tree.\n   * @returns {Variable[]} - List of unique in-scope variables.\n   */\n\n\n  static inScopeVariables(op) {\n    const variables = [];\n\n    function addVariable(v) {\n      if (!variables.find(v2 => v.value === v2.value)) variables.push(v);\n    }\n\n    function recurseTerm(quad) {\n      if (quad.subject.termType === 'Variable') addVariable(quad.subject);\n      if (quad.predicate.termType === 'Variable') addVariable(quad.predicate);\n      if (quad.object.termType === 'Variable') addVariable(quad.object);\n      if (quad.graph.termType === 'Variable') addVariable(quad.graph);\n      if (quad.subject.termType === 'Quad') recurseTerm(quad.subject);\n      if (quad.predicate.termType === 'Quad') recurseTerm(quad.predicate);\n      if (quad.object.termType === 'Quad') recurseTerm(quad.object);\n      if (quad.graph.termType === 'Quad') recurseTerm(quad.graph);\n    } // https://www.w3.org/TR/sparql11-query/#variableScope\n\n\n    Util.recurseOperation(op, {\n      [algebra_1.types.EXPRESSION]: op => {\n        let expr = op;\n\n        if (expr.expressionType === 'aggregate' && expr.variable) {\n          let agg = expr;\n          addVariable(agg.variable);\n        }\n\n        return true;\n      },\n      [algebra_1.types.EXTEND]: op => {\n        let extend = op;\n        addVariable(extend.variable);\n        return true;\n      },\n      [algebra_1.types.GRAPH]: op => {\n        let graph = op;\n        if (graph.name.termType === 'Variable') addVariable(graph.name);\n        return true;\n      },\n      [algebra_1.types.GROUP]: op => {\n        let group = op;\n        group.variables.forEach(addVariable);\n        return true;\n      },\n      [algebra_1.types.PATH]: op => {\n        let path = op;\n        if (path.subject.termType === 'Variable') addVariable(path.subject);\n        if (path.object.termType === 'Variable') addVariable(path.object);\n        if (path.graph.termType === 'Variable') addVariable(path.graph);\n        if (path.subject.termType === 'Quad') recurseTerm(path.subject);\n        if (path.object.termType === 'Quad') recurseTerm(path.object);\n        if (path.graph.termType === 'Quad') recurseTerm(path.graph);\n        return true;\n      },\n      [algebra_1.types.PATTERN]: op => {\n        let pattern = op;\n        recurseTerm(pattern);\n        return true;\n      },\n      [algebra_1.types.PROJECT]: op => {\n        let project = op;\n        project.variables.forEach(addVariable);\n        return false;\n      },\n      [algebra_1.types.SERVICE]: op => {\n        let service = op;\n        if (service.name.termType === 'Variable') addVariable(service.name);\n        return true;\n      },\n      [algebra_1.types.VALUES]: op => {\n        let values = op;\n        values.variables.forEach(addVariable);\n        return true;\n      }\n    });\n    return variables;\n  }\n  /**\n   * Recurses through the given algebra tree\n   * A map of callback functions can be provided for individual Operation types to gather data.\n   * The return value of those callbacks should indicate whether recursion should be applied or not.\n   * Making modifications will change the original input object.\n   * @param {Operation} op - The Operation to recurse on.\n   * @param { [type: string]: (op: Operation) => boolean } callbacks - A map of required callback Operations.\n   */\n\n\n  static recurseOperation(op, callbacks) {\n    let result = op;\n    let doRecursion = true;\n    if (callbacks[op.type]) doRecursion = callbacks[op.type](op);\n    if (!doRecursion) return;\n\n    let recurseOp = op => Util.recurseOperation(op, callbacks);\n\n    switch (result.type) {\n      case algebra_1.types.ALT:\n        const alt = result;\n        recurseOp(alt.left);\n        recurseOp(alt.right);\n        break;\n\n      case algebra_1.types.ASK:\n        const ask = result;\n        recurseOp(ask.input);\n        break;\n\n      case algebra_1.types.BGP:\n        const bgp = result;\n        bgp.patterns.forEach(recurseOp);\n        break;\n\n      case algebra_1.types.CONSTRUCT:\n        const construct = result;\n        recurseOp(construct.input);\n        construct.template.map(recurseOp);\n        break;\n\n      case algebra_1.types.DESCRIBE:\n        const describe = result;\n        recurseOp(describe.input);\n        break;\n\n      case algebra_1.types.DISTINCT:\n        const distinct = result;\n        recurseOp(distinct.input);\n        break;\n\n      case algebra_1.types.EXPRESSION:\n        const expr = result;\n\n        if (expr.expressionType === algebra_1.expressionTypes.EXISTENCE) {\n          const exist = expr;\n          recurseOp(exist.input);\n        }\n\n        break;\n\n      case algebra_1.types.EXTEND:\n        const extend = result;\n        recurseOp(extend.input);\n        recurseOp(extend.expression);\n        break;\n\n      case algebra_1.types.FILTER:\n        const filter = result;\n        recurseOp(filter.input);\n        recurseOp(filter.expression);\n        break;\n\n      case algebra_1.types.FROM:\n        const from = result;\n        recurseOp(from.input);\n        break;\n\n      case algebra_1.types.GRAPH:\n        const graph = result;\n        recurseOp(graph.input);\n        break;\n\n      case algebra_1.types.GROUP:\n        const group = result;\n        recurseOp(group.input);\n        group.aggregates.forEach(recurseOp);\n        break;\n\n      case algebra_1.types.INV:\n        const inv = result;\n        recurseOp(inv.path);\n        break;\n\n      case algebra_1.types.JOIN:\n        const join = result;\n        recurseOp(join.left);\n        recurseOp(join.right);\n        break;\n\n      case algebra_1.types.LEFT_JOIN:\n        const leftJoin = result;\n        recurseOp(leftJoin.left);\n        recurseOp(leftJoin.right);\n        if (leftJoin.expression) recurseOp(leftJoin.expression);\n        break;\n\n      case algebra_1.types.LINK:\n        break;\n\n      case algebra_1.types.MINUS:\n        const minus = result;\n        recurseOp(minus.left);\n        recurseOp(minus.right);\n        break;\n\n      case algebra_1.types.NPS:\n        break;\n\n      case algebra_1.types.ONE_OR_MORE_PATH:\n        const oom = result;\n        recurseOp(oom.path);\n        break;\n\n      case algebra_1.types.ORDER_BY:\n        const order = result;\n        recurseOp(order.input);\n        order.expressions.forEach(recurseOp);\n        break;\n\n      case algebra_1.types.PATH:\n        const path = result;\n        recurseOp(path.predicate);\n        break;\n\n      case algebra_1.types.PATTERN:\n        break;\n\n      case algebra_1.types.PROJECT:\n        const project = result;\n        recurseOp(project.input);\n        break;\n\n      case algebra_1.types.REDUCED:\n        const reduced = result;\n        recurseOp(reduced.input);\n        break;\n\n      case algebra_1.types.SEQ:\n        const seq = result;\n        recurseOp(seq.left);\n        recurseOp(seq.right);\n        break;\n\n      case algebra_1.types.SERVICE:\n        const service = result;\n        recurseOp(service.input);\n        break;\n\n      case algebra_1.types.SLICE:\n        const slice = result;\n        recurseOp(slice.input);\n        break;\n\n      case algebra_1.types.UNION:\n        const union = result;\n        recurseOp(union.left);\n        recurseOp(union.right);\n        break;\n\n      case algebra_1.types.VALUES:\n        break;\n\n      case algebra_1.types.ZERO_OR_MORE_PATH:\n        const zom = result;\n        recurseOp(zom.path);\n        break;\n\n      case algebra_1.types.ZERO_OR_ONE_PATH:\n        const zoo = result;\n        recurseOp(zoo.path);\n        break;\n      // UPDATE operations\n\n      case algebra_1.types.COMPOSITE_UPDATE:\n        const cu = result;\n        cu.updates.forEach(update => recurseOp(update));\n        break;\n\n      case algebra_1.types.DELETE_INSERT:\n        const di = result;\n        if (di.delete) di.delete.forEach(pattern => recurseOp(pattern));\n        if (di.insert) di.insert.forEach(pattern => recurseOp(pattern));\n        if (di.where) recurseOp(di.where);\n        break;\n      // all of these only have graph IDs as values\n\n      case algebra_1.types.LOAD:\n        break;\n\n      case algebra_1.types.CLEAR:\n        break;\n\n      case algebra_1.types.CREATE:\n        break;\n\n      case algebra_1.types.DROP:\n        break;\n\n      case algebra_1.types.ADD:\n        break;\n\n      case algebra_1.types.MOVE:\n        break;\n\n      case algebra_1.types.COPY:\n        break;\n\n      default:\n        throw new Error('Unknown Operation type ' + result.type);\n    }\n  }\n  /**\n   * Creates a deep copy of the given Operation.\n   * Creates shallow copies of the non-Operation values.\n   * A map of callback functions can be provided for individual Operation types\n   * to specifically modify the given objects before triggering recursion.\n   * The return value of those callbacks should indicate whether recursion should be applied to this returned object or not.\n   * @param {Operation} op - The Operation to recurse on.\n   * @param { [type: string]: (op: Operation, factory: Factory) => RecurseResult } callbacks - A map of required callback Operations.\n   * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.\n   * @returns {Operation} - The copied result.\n   */\n\n\n  static mapOperation(op, callbacks, factory) {\n    let result = op;\n    let doRecursion = true;\n    factory = factory || new factory_1.default();\n    if (callbacks[op.type]) ({\n      result,\n      recurse: doRecursion\n    } = callbacks[op.type](op, factory));\n    if (!doRecursion) return result;\n\n    let mapOp = op => Util.mapOperation(op, callbacks, factory);\n\n    switch (result.type) {\n      case algebra_1.types.ALT:\n        const alt = result;\n        return factory.createAlt(mapOp(alt.left), mapOp(alt.right));\n\n      case algebra_1.types.ASK:\n        const ask = result;\n        return factory.createAsk(mapOp(ask.input));\n\n      case algebra_1.types.BGP:\n        const bgp = result;\n        return factory.createBgp(bgp.patterns.map(mapOp));\n\n      case algebra_1.types.CONSTRUCT:\n        const construct = result;\n        return factory.createConstruct(mapOp(construct.input), construct.template.map(mapOp));\n\n      case algebra_1.types.DESCRIBE:\n        const describe = result;\n        return factory.createDescribe(mapOp(describe.input), describe.terms);\n\n      case algebra_1.types.DISTINCT:\n        const distinct = result;\n        return factory.createDistinct(mapOp(distinct.input));\n\n      case algebra_1.types.EXPRESSION:\n        const expr = result;\n        return Util.mapExpression(expr, callbacks, factory);\n\n      case algebra_1.types.EXTEND:\n        const extend = result;\n        return factory.createExtend(mapOp(extend.input), extend.variable, mapOp(extend.expression));\n\n      case algebra_1.types.FILTER:\n        const filter = result;\n        return factory.createFilter(mapOp(filter.input), mapOp(filter.expression));\n\n      case algebra_1.types.FROM:\n        const from = result;\n        return factory.createFrom(mapOp(from.input), [].concat(from.default), [].concat(from.named));\n\n      case algebra_1.types.GRAPH:\n        const graph = result;\n        return factory.createGraph(mapOp(graph.input), graph.name);\n\n      case algebra_1.types.GROUP:\n        const group = result;\n        return factory.createGroup(mapOp(group.input), [].concat(group.variables), group.aggregates.map(mapOp));\n\n      case algebra_1.types.INV:\n        const inv = result;\n        return factory.createInv(mapOp(inv.path));\n\n      case algebra_1.types.JOIN:\n        const join = result;\n        return factory.createJoin(mapOp(join.left), mapOp(join.right));\n\n      case algebra_1.types.LEFT_JOIN:\n        const leftJoin = result;\n        return factory.createLeftJoin(mapOp(leftJoin.left), mapOp(leftJoin.right), leftJoin.expression ? mapOp(leftJoin.expression) : undefined);\n\n      case algebra_1.types.LINK:\n        const link = result;\n        return factory.createLink(link.iri);\n\n      case algebra_1.types.MINUS:\n        const minus = result;\n        return factory.createMinus(mapOp(minus.left), mapOp(minus.right));\n\n      case algebra_1.types.NPS:\n        const nps = result;\n        return factory.createNps([].concat(nps.iris));\n\n      case algebra_1.types.ONE_OR_MORE_PATH:\n        const oom = result;\n        return factory.createOneOrMorePath(mapOp(oom.path));\n\n      case algebra_1.types.ORDER_BY:\n        const order = result;\n        return factory.createOrderBy(mapOp(order.input), order.expressions.map(mapOp));\n\n      case algebra_1.types.PATH:\n        const path = result;\n        return factory.createPath(path.subject, mapOp(path.predicate), path.object, path.graph);\n\n      case algebra_1.types.PATTERN:\n        const pattern = result;\n        return factory.createPattern(pattern.subject, pattern.predicate, pattern.object, pattern.graph);\n\n      case algebra_1.types.PROJECT:\n        const project = result;\n        return factory.createProject(mapOp(project.input), [].concat(project.variables));\n\n      case algebra_1.types.REDUCED:\n        const reduced = result;\n        return factory.createReduced(mapOp(reduced.input));\n\n      case algebra_1.types.SEQ:\n        const seq = result;\n        return factory.createSeq(mapOp(seq.left), mapOp(seq.right));\n\n      case algebra_1.types.SERVICE:\n        const service = result;\n        return factory.createService(mapOp(service.input), service.name, service.silent);\n\n      case algebra_1.types.SLICE:\n        const slice = result;\n        return factory.createSlice(mapOp(slice.input), slice.start, slice.length);\n\n      case algebra_1.types.UNION:\n        const union = result;\n        return factory.createUnion(mapOp(union.left), mapOp(union.right));\n\n      case algebra_1.types.VALUES:\n        const values = result;\n        return factory.createValues([].concat(values.variables), values.bindings.map(b => Object.assign({}, b)));\n\n      case algebra_1.types.ZERO_OR_MORE_PATH:\n        const zom = result;\n        return factory.createZeroOrMorePath(mapOp(zom.path));\n\n      case algebra_1.types.ZERO_OR_ONE_PATH:\n        const zoo = result;\n        return factory.createZeroOrOnePath(mapOp(zoo.path));\n      // UPDATE operations\n\n      case algebra_1.types.COMPOSITE_UPDATE:\n        const cu = result;\n        return factory.createCompositeUpdate(cu.updates.map(mapOp));\n\n      case algebra_1.types.DELETE_INSERT:\n        const di = result;\n        return factory.createDeleteInsert(di.delete ? di.delete.map(mapOp) : undefined, di.insert ? di.insert.map(mapOp) : undefined, di.where ? mapOp(di.where) : undefined);\n\n      case algebra_1.types.LOAD:\n        const load = result;\n        return factory.createLoad(load.source, load.destination, load.silent);\n\n      case algebra_1.types.CLEAR:\n        const clear = result;\n        return factory.createClear(clear.source, clear.silent);\n\n      case algebra_1.types.CREATE:\n        const create = result;\n        return factory.createCreate(create.source, create.silent);\n\n      case algebra_1.types.DROP:\n        const drop = result;\n        return factory.createDrop(drop.source, drop.silent);\n\n      case algebra_1.types.ADD:\n        const add = result;\n        return factory.createAdd(add.source, add.destination);\n\n      case algebra_1.types.MOVE:\n        const move = result;\n        return factory.createMove(move.source, move.destination);\n\n      case algebra_1.types.COPY:\n        const copy = result;\n        return factory.createCopy(copy.source, copy.destination);\n\n      default:\n        throw new Error('Unknown Operation type ' + result);\n    }\n  }\n  /**\n   * Similar to the {@link mapOperation} function but specifically for expressions.\n   * Both functions call each other while copying.\n   * Should not be called directly since it does not execute the callbacks, these happen in {@link mapOperation}.\n   * @param {Expression} expr - The Operation to recurse on.\n   * @param { [type: string]: (op: Operation, factory: Factory) => RecurseResult } callbacks - A map of required callback Operations.\n   * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.\n   * @returns {Operation} - The copied result.\n   */\n\n\n  static mapExpression(expr, callbacks, factory) {\n    let recurse = op => Util.mapOperation(op, callbacks, factory);\n\n    switch (expr.expressionType) {\n      case algebra_1.expressionTypes.AGGREGATE:\n        if (expr.variable) {\n          const bound = expr;\n          return factory.createBoundAggregate(bound.variable, bound.aggregator, recurse(bound.expression), bound.distinct, bound.separator);\n        }\n\n        const aggregate = expr;\n        return factory.createAggregateExpression(aggregate.aggregator, recurse(aggregate.expression), aggregate.distinct, aggregate.separator);\n\n      case algebra_1.expressionTypes.EXISTENCE:\n        const exist = expr;\n        return factory.createExistenceExpression(exist.not, recurse(exist.input));\n\n      case algebra_1.expressionTypes.NAMED:\n        const named = expr;\n        return factory.createNamedExpression(named.name, named.args.map(recurse));\n\n      case algebra_1.expressionTypes.OPERATOR:\n        const op = expr;\n        return factory.createOperatorExpression(op.operator, op.args.map(recurse));\n\n      case algebra_1.expressionTypes.TERM:\n        const term = expr;\n        return factory.createTermExpression(term.term);\n\n      case algebra_1.expressionTypes.WILDCARD:\n        return factory.createWildcardExpression();\n\n      default:\n        throw new Error('Unknown Expression type ' + expr.expressionType);\n    }\n  }\n\n  static createUniqueVariable(label, variables, dataFactory) {\n    let counter = 0;\n    let labelLoop = label;\n\n    while (variables[labelLoop]) {\n      labelLoop = label + counter++;\n    }\n\n    return dataFactory.variable(labelLoop);\n  } // separate terms from wildcard since we handle them differently\n\n\n  static isTerm(term) {\n    return term.termType !== undefined && term.termType !== 'Quad' && term.termType !== 'Wildcard';\n  }\n\n  static isWildcard(term) {\n    return term.termType === 'Wildcard';\n  }\n\n}\n\nexports.default = Util;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/sparqlalgebrajs/lib/util.js"],"names":["Object","defineProperty","exports","value","algebra_1","require","factory_1","Util","flatten","arr","Array","prototype","concat","filter","x","inScopeVariables","op","variables","addVariable","v","find","v2","push","recurseTerm","quad","subject","termType","predicate","object","graph","recurseOperation","types","EXPRESSION","expr","expressionType","variable","agg","EXTEND","extend","GRAPH","name","GROUP","group","forEach","PATH","path","PATTERN","pattern","PROJECT","project","SERVICE","service","VALUES","values","callbacks","result","doRecursion","type","recurseOp","ALT","alt","left","right","ASK","ask","input","BGP","bgp","patterns","CONSTRUCT","construct","template","map","DESCRIBE","describe","DISTINCT","distinct","expressionTypes","EXISTENCE","exist","expression","FILTER","FROM","from","aggregates","INV","inv","JOIN","join","LEFT_JOIN","leftJoin","LINK","MINUS","minus","NPS","ONE_OR_MORE_PATH","oom","ORDER_BY","order","expressions","REDUCED","reduced","SEQ","seq","SLICE","slice","UNION","union","ZERO_OR_MORE_PATH","zom","ZERO_OR_ONE_PATH","zoo","COMPOSITE_UPDATE","cu","updates","update","DELETE_INSERT","di","delete","insert","where","LOAD","CLEAR","CREATE","DROP","ADD","MOVE","COPY","Error","mapOperation","factory","default","recurse","mapOp","createAlt","createAsk","createBgp","createConstruct","createDescribe","terms","createDistinct","mapExpression","createExtend","createFilter","createFrom","named","createGraph","createGroup","createInv","createJoin","createLeftJoin","undefined","link","createLink","iri","createMinus","nps","createNps","iris","createOneOrMorePath","createOrderBy","createPath","createPattern","createProject","createReduced","createSeq","createService","silent","createSlice","start","length","createUnion","createValues","bindings","b","assign","createZeroOrMorePath","createZeroOrOnePath","createCompositeUpdate","createDeleteInsert","load","createLoad","source","destination","clear","createClear","create","createCreate","drop","createDrop","add","createAdd","move","createMove","copy","createCopy","AGGREGATE","bound","createBoundAggregate","aggregator","separator","aggregate","createAggregateExpression","createExistenceExpression","not","NAMED","createNamedExpression","args","OPERATOR","createOperatorExpression","operator","TERM","term","createTermExpression","WILDCARD","createWildcardExpression","createUniqueVariable","label","dataFactory","counter","labelLoop","isTerm","isWildcard"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst algebra_1 = require(\"./algebra\");\nconst factory_1 = require(\"./factory\");\nclass Util {\n    /**\n     * Flattens an array of arrays to an array.\n     * @param arr - Array of arrays\n     */\n    static flatten(arr) {\n        return Array.prototype.concat(...arr).filter(x => x);\n    }\n    /**\n     * Detects all in-scope variables.\n     * In practice this means iterating through the entire algebra tree, finding all variables,\n     * and stopping when a project function is found.\n     * @param {Operation} op - Input algebra tree.\n     * @returns {Variable[]} - List of unique in-scope variables.\n     */\n    static inScopeVariables(op) {\n        const variables = [];\n        function addVariable(v) {\n            if (!variables.find(v2 => v.value === v2.value))\n                variables.push(v);\n        }\n        function recurseTerm(quad) {\n            if (quad.subject.termType === 'Variable')\n                addVariable(quad.subject);\n            if (quad.predicate.termType === 'Variable')\n                addVariable(quad.predicate);\n            if (quad.object.termType === 'Variable')\n                addVariable(quad.object);\n            if (quad.graph.termType === 'Variable')\n                addVariable(quad.graph);\n            if (quad.subject.termType === 'Quad')\n                recurseTerm(quad.subject);\n            if (quad.predicate.termType === 'Quad')\n                recurseTerm(quad.predicate);\n            if (quad.object.termType === 'Quad')\n                recurseTerm(quad.object);\n            if (quad.graph.termType === 'Quad')\n                recurseTerm(quad.graph);\n        }\n        // https://www.w3.org/TR/sparql11-query/#variableScope\n        Util.recurseOperation(op, {\n            [algebra_1.types.EXPRESSION]: (op) => {\n                let expr = op;\n                if (expr.expressionType === 'aggregate' && expr.variable) {\n                    let agg = expr;\n                    addVariable(agg.variable);\n                }\n                return true;\n            },\n            [algebra_1.types.EXTEND]: (op) => {\n                let extend = op;\n                addVariable(extend.variable);\n                return true;\n            },\n            [algebra_1.types.GRAPH]: (op) => {\n                let graph = op;\n                if (graph.name.termType === 'Variable')\n                    addVariable(graph.name);\n                return true;\n            },\n            [algebra_1.types.GROUP]: (op) => {\n                let group = op;\n                group.variables.forEach(addVariable);\n                return true;\n            },\n            [algebra_1.types.PATH]: (op) => {\n                let path = op;\n                if (path.subject.termType === 'Variable')\n                    addVariable(path.subject);\n                if (path.object.termType === 'Variable')\n                    addVariable(path.object);\n                if (path.graph.termType === 'Variable')\n                    addVariable(path.graph);\n                if (path.subject.termType === 'Quad')\n                    recurseTerm(path.subject);\n                if (path.object.termType === 'Quad')\n                    recurseTerm(path.object);\n                if (path.graph.termType === 'Quad')\n                    recurseTerm(path.graph);\n                return true;\n            },\n            [algebra_1.types.PATTERN]: (op) => {\n                let pattern = op;\n                recurseTerm(pattern);\n                return true;\n            },\n            [algebra_1.types.PROJECT]: (op) => {\n                let project = op;\n                project.variables.forEach(addVariable);\n                return false;\n            },\n            [algebra_1.types.SERVICE]: (op) => {\n                let service = op;\n                if (service.name.termType === 'Variable')\n                    addVariable(service.name);\n                return true;\n            },\n            [algebra_1.types.VALUES]: (op) => {\n                let values = op;\n                values.variables.forEach(addVariable);\n                return true;\n            },\n        });\n        return variables;\n    }\n    /**\n     * Recurses through the given algebra tree\n     * A map of callback functions can be provided for individual Operation types to gather data.\n     * The return value of those callbacks should indicate whether recursion should be applied or not.\n     * Making modifications will change the original input object.\n     * @param {Operation} op - The Operation to recurse on.\n     * @param { [type: string]: (op: Operation) => boolean } callbacks - A map of required callback Operations.\n     */\n    static recurseOperation(op, callbacks) {\n        let result = op;\n        let doRecursion = true;\n        if (callbacks[op.type])\n            doRecursion = callbacks[op.type](op);\n        if (!doRecursion)\n            return;\n        let recurseOp = (op) => Util.recurseOperation(op, callbacks);\n        switch (result.type) {\n            case algebra_1.types.ALT:\n                const alt = result;\n                recurseOp(alt.left);\n                recurseOp(alt.right);\n                break;\n            case algebra_1.types.ASK:\n                const ask = result;\n                recurseOp(ask.input);\n                break;\n            case algebra_1.types.BGP:\n                const bgp = result;\n                bgp.patterns.forEach(recurseOp);\n                break;\n            case algebra_1.types.CONSTRUCT:\n                const construct = result;\n                recurseOp(construct.input);\n                construct.template.map(recurseOp);\n                break;\n            case algebra_1.types.DESCRIBE:\n                const describe = result;\n                recurseOp(describe.input);\n                break;\n            case algebra_1.types.DISTINCT:\n                const distinct = result;\n                recurseOp(distinct.input);\n                break;\n            case algebra_1.types.EXPRESSION:\n                const expr = result;\n                if (expr.expressionType === algebra_1.expressionTypes.EXISTENCE) {\n                    const exist = expr;\n                    recurseOp(exist.input);\n                }\n                break;\n            case algebra_1.types.EXTEND:\n                const extend = result;\n                recurseOp(extend.input);\n                recurseOp(extend.expression);\n                break;\n            case algebra_1.types.FILTER:\n                const filter = result;\n                recurseOp(filter.input);\n                recurseOp(filter.expression);\n                break;\n            case algebra_1.types.FROM:\n                const from = result;\n                recurseOp(from.input);\n                break;\n            case algebra_1.types.GRAPH:\n                const graph = result;\n                recurseOp(graph.input);\n                break;\n            case algebra_1.types.GROUP:\n                const group = result;\n                recurseOp(group.input);\n                group.aggregates.forEach(recurseOp);\n                break;\n            case algebra_1.types.INV:\n                const inv = result;\n                recurseOp(inv.path);\n                break;\n            case algebra_1.types.JOIN:\n                const join = result;\n                recurseOp(join.left);\n                recurseOp(join.right);\n                break;\n            case algebra_1.types.LEFT_JOIN:\n                const leftJoin = result;\n                recurseOp(leftJoin.left);\n                recurseOp(leftJoin.right);\n                if (leftJoin.expression)\n                    recurseOp(leftJoin.expression);\n                break;\n            case algebra_1.types.LINK:\n                break;\n            case algebra_1.types.MINUS:\n                const minus = result;\n                recurseOp(minus.left);\n                recurseOp(minus.right);\n                break;\n            case algebra_1.types.NPS:\n                break;\n            case algebra_1.types.ONE_OR_MORE_PATH:\n                const oom = result;\n                recurseOp(oom.path);\n                break;\n            case algebra_1.types.ORDER_BY:\n                const order = result;\n                recurseOp(order.input);\n                order.expressions.forEach(recurseOp);\n                break;\n            case algebra_1.types.PATH:\n                const path = result;\n                recurseOp(path.predicate);\n                break;\n            case algebra_1.types.PATTERN:\n                break;\n            case algebra_1.types.PROJECT:\n                const project = result;\n                recurseOp(project.input);\n                break;\n            case algebra_1.types.REDUCED:\n                const reduced = result;\n                recurseOp(reduced.input);\n                break;\n            case algebra_1.types.SEQ:\n                const seq = result;\n                recurseOp(seq.left);\n                recurseOp(seq.right);\n                break;\n            case algebra_1.types.SERVICE:\n                const service = result;\n                recurseOp(service.input);\n                break;\n            case algebra_1.types.SLICE:\n                const slice = result;\n                recurseOp(slice.input);\n                break;\n            case algebra_1.types.UNION:\n                const union = result;\n                recurseOp(union.left);\n                recurseOp(union.right);\n                break;\n            case algebra_1.types.VALUES:\n                break;\n            case algebra_1.types.ZERO_OR_MORE_PATH:\n                const zom = result;\n                recurseOp(zom.path);\n                break;\n            case algebra_1.types.ZERO_OR_ONE_PATH:\n                const zoo = result;\n                recurseOp(zoo.path);\n                break;\n            // UPDATE operations\n            case algebra_1.types.COMPOSITE_UPDATE:\n                const cu = result;\n                cu.updates.forEach(update => recurseOp(update));\n                break;\n            case algebra_1.types.DELETE_INSERT:\n                const di = result;\n                if (di.delete)\n                    di.delete.forEach(pattern => recurseOp(pattern));\n                if (di.insert)\n                    di.insert.forEach(pattern => recurseOp(pattern));\n                if (di.where)\n                    recurseOp(di.where);\n                break;\n            // all of these only have graph IDs as values\n            case algebra_1.types.LOAD: break;\n            case algebra_1.types.CLEAR: break;\n            case algebra_1.types.CREATE: break;\n            case algebra_1.types.DROP: break;\n            case algebra_1.types.ADD: break;\n            case algebra_1.types.MOVE: break;\n            case algebra_1.types.COPY: break;\n            default: throw new Error('Unknown Operation type ' + result.type);\n        }\n    }\n    /**\n     * Creates a deep copy of the given Operation.\n     * Creates shallow copies of the non-Operation values.\n     * A map of callback functions can be provided for individual Operation types\n     * to specifically modify the given objects before triggering recursion.\n     * The return value of those callbacks should indicate whether recursion should be applied to this returned object or not.\n     * @param {Operation} op - The Operation to recurse on.\n     * @param { [type: string]: (op: Operation, factory: Factory) => RecurseResult } callbacks - A map of required callback Operations.\n     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.\n     * @returns {Operation} - The copied result.\n     */\n    static mapOperation(op, callbacks, factory) {\n        let result = op;\n        let doRecursion = true;\n        factory = factory || new factory_1.default();\n        if (callbacks[op.type])\n            ({ result, recurse: doRecursion } = callbacks[op.type](op, factory));\n        if (!doRecursion)\n            return result;\n        let mapOp = (op) => Util.mapOperation(op, callbacks, factory);\n        switch (result.type) {\n            case algebra_1.types.ALT:\n                const alt = result;\n                return factory.createAlt(mapOp(alt.left), mapOp(alt.right));\n            case algebra_1.types.ASK:\n                const ask = result;\n                return factory.createAsk(mapOp(ask.input));\n            case algebra_1.types.BGP:\n                const bgp = result;\n                return factory.createBgp(bgp.patterns.map(mapOp));\n            case algebra_1.types.CONSTRUCT:\n                const construct = result;\n                return factory.createConstruct(mapOp(construct.input), construct.template.map(mapOp));\n            case algebra_1.types.DESCRIBE:\n                const describe = result;\n                return factory.createDescribe(mapOp(describe.input), describe.terms);\n            case algebra_1.types.DISTINCT:\n                const distinct = result;\n                return factory.createDistinct(mapOp(distinct.input));\n            case algebra_1.types.EXPRESSION:\n                const expr = result;\n                return Util.mapExpression(expr, callbacks, factory);\n            case algebra_1.types.EXTEND:\n                const extend = result;\n                return factory.createExtend(mapOp(extend.input), extend.variable, mapOp(extend.expression));\n            case algebra_1.types.FILTER:\n                const filter = result;\n                return factory.createFilter(mapOp(filter.input), mapOp(filter.expression));\n            case algebra_1.types.FROM:\n                const from = result;\n                return factory.createFrom(mapOp(from.input), [].concat(from.default), [].concat(from.named));\n            case algebra_1.types.GRAPH:\n                const graph = result;\n                return factory.createGraph(mapOp(graph.input), graph.name);\n            case algebra_1.types.GROUP:\n                const group = result;\n                return factory.createGroup(mapOp(group.input), [].concat(group.variables), group.aggregates.map(mapOp));\n            case algebra_1.types.INV:\n                const inv = result;\n                return factory.createInv(mapOp(inv.path));\n            case algebra_1.types.JOIN:\n                const join = result;\n                return factory.createJoin(mapOp(join.left), mapOp(join.right));\n            case algebra_1.types.LEFT_JOIN:\n                const leftJoin = result;\n                return factory.createLeftJoin(mapOp(leftJoin.left), mapOp(leftJoin.right), leftJoin.expression ? mapOp(leftJoin.expression) : undefined);\n            case algebra_1.types.LINK:\n                const link = result;\n                return factory.createLink(link.iri);\n            case algebra_1.types.MINUS:\n                const minus = result;\n                return factory.createMinus(mapOp(minus.left), mapOp(minus.right));\n            case algebra_1.types.NPS:\n                const nps = result;\n                return factory.createNps([].concat(nps.iris));\n            case algebra_1.types.ONE_OR_MORE_PATH:\n                const oom = result;\n                return factory.createOneOrMorePath(mapOp(oom.path));\n            case algebra_1.types.ORDER_BY:\n                const order = result;\n                return factory.createOrderBy(mapOp(order.input), order.expressions.map(mapOp));\n            case algebra_1.types.PATH:\n                const path = result;\n                return factory.createPath(path.subject, mapOp(path.predicate), path.object, path.graph);\n            case algebra_1.types.PATTERN:\n                const pattern = result;\n                return factory.createPattern(pattern.subject, pattern.predicate, pattern.object, pattern.graph);\n            case algebra_1.types.PROJECT:\n                const project = result;\n                return factory.createProject(mapOp(project.input), [].concat(project.variables));\n            case algebra_1.types.REDUCED:\n                const reduced = result;\n                return factory.createReduced(mapOp(reduced.input));\n            case algebra_1.types.SEQ:\n                const seq = result;\n                return factory.createSeq(mapOp(seq.left), mapOp(seq.right));\n            case algebra_1.types.SERVICE:\n                const service = result;\n                return factory.createService(mapOp(service.input), service.name, service.silent);\n            case algebra_1.types.SLICE:\n                const slice = result;\n                return factory.createSlice(mapOp(slice.input), slice.start, slice.length);\n            case algebra_1.types.UNION:\n                const union = result;\n                return factory.createUnion(mapOp(union.left), mapOp(union.right));\n            case algebra_1.types.VALUES:\n                const values = result;\n                return factory.createValues([].concat(values.variables), values.bindings.map(b => Object.assign({}, b)));\n            case algebra_1.types.ZERO_OR_MORE_PATH:\n                const zom = result;\n                return factory.createZeroOrMorePath(mapOp(zom.path));\n            case algebra_1.types.ZERO_OR_ONE_PATH:\n                const zoo = result;\n                return factory.createZeroOrOnePath(mapOp(zoo.path));\n            // UPDATE operations\n            case algebra_1.types.COMPOSITE_UPDATE:\n                const cu = result;\n                return factory.createCompositeUpdate(cu.updates.map(mapOp));\n            case algebra_1.types.DELETE_INSERT:\n                const di = result;\n                return factory.createDeleteInsert(di.delete ? di.delete.map(mapOp) : undefined, di.insert ? di.insert.map(mapOp) : undefined, di.where ? mapOp(di.where) : undefined);\n            case algebra_1.types.LOAD:\n                const load = result;\n                return factory.createLoad(load.source, load.destination, load.silent);\n            case algebra_1.types.CLEAR:\n                const clear = result;\n                return factory.createClear(clear.source, clear.silent);\n            case algebra_1.types.CREATE:\n                const create = result;\n                return factory.createCreate(create.source, create.silent);\n            case algebra_1.types.DROP:\n                const drop = result;\n                return factory.createDrop(drop.source, drop.silent);\n            case algebra_1.types.ADD:\n                const add = result;\n                return factory.createAdd(add.source, add.destination);\n            case algebra_1.types.MOVE:\n                const move = result;\n                return factory.createMove(move.source, move.destination);\n            case algebra_1.types.COPY:\n                const copy = result;\n                return factory.createCopy(copy.source, copy.destination);\n            default: throw new Error('Unknown Operation type ' + result);\n        }\n    }\n    /**\n     * Similar to the {@link mapOperation} function but specifically for expressions.\n     * Both functions call each other while copying.\n     * Should not be called directly since it does not execute the callbacks, these happen in {@link mapOperation}.\n     * @param {Expression} expr - The Operation to recurse on.\n     * @param { [type: string]: (op: Operation, factory: Factory) => RecurseResult } callbacks - A map of required callback Operations.\n     * @param {Factory} factory - Factory used to create new Operations. Will use default factory if none is provided.\n     * @returns {Operation} - The copied result.\n     */\n    static mapExpression(expr, callbacks, factory) {\n        let recurse = (op) => Util.mapOperation(op, callbacks, factory);\n        switch (expr.expressionType) {\n            case algebra_1.expressionTypes.AGGREGATE:\n                if (expr.variable) {\n                    const bound = expr;\n                    return factory.createBoundAggregate(bound.variable, bound.aggregator, recurse(bound.expression), bound.distinct, bound.separator);\n                }\n                const aggregate = expr;\n                return factory.createAggregateExpression(aggregate.aggregator, recurse(aggregate.expression), aggregate.distinct, aggregate.separator);\n            case algebra_1.expressionTypes.EXISTENCE:\n                const exist = expr;\n                return factory.createExistenceExpression(exist.not, recurse(exist.input));\n            case algebra_1.expressionTypes.NAMED:\n                const named = expr;\n                return factory.createNamedExpression(named.name, named.args.map(recurse));\n            case algebra_1.expressionTypes.OPERATOR:\n                const op = expr;\n                return factory.createOperatorExpression(op.operator, op.args.map(recurse));\n            case algebra_1.expressionTypes.TERM:\n                const term = expr;\n                return factory.createTermExpression(term.term);\n            case algebra_1.expressionTypes.WILDCARD:\n                return factory.createWildcardExpression();\n            default: throw new Error('Unknown Expression type ' + expr.expressionType);\n        }\n    }\n    static createUniqueVariable(label, variables, dataFactory) {\n        let counter = 0;\n        let labelLoop = label;\n        while (variables[labelLoop]) {\n            labelLoop = label + counter++;\n        }\n        return dataFactory.variable(labelLoop);\n    }\n    // separate terms from wildcard since we handle them differently\n    static isTerm(term) {\n        return term.termType !== undefined && term.termType !== 'Quad' && term.termType !== 'Wildcard';\n    }\n    static isWildcard(term) {\n        return term.termType === 'Wildcard';\n    }\n}\nexports.default = Util;\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}