{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AsyncEvaluator = void 0;\n\nconst Transformation_1 = require(\"../Transformation\");\n\nconst RecursiveExpressionEvaluator_1 = require(\"./RecursiveExpressionEvaluator\");\n\nclass AsyncEvaluator {\n  constructor(algExpr, config = {}) {\n    this.algExpr = algExpr;\n    this.config = config;\n    this.expr = Transformation_1.transformAlgebra(algExpr);\n    const context = {\n      now: config.now || new Date(Date.now()),\n      bnode: config.bnode || undefined,\n      baseIRI: config.baseIRI || undefined,\n      exists: config.exists,\n      aggregate: config.aggregate\n    };\n    this.evaluator = new RecursiveExpressionEvaluator_1.AsyncRecursiveEvaluator(context);\n  }\n\n  async evaluate(mapping) {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result).toRDF();\n  }\n\n  async evaluateAsEBV(mapping) {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result).coerceEBV();\n  }\n\n  async evaluateAsInternal(mapping) {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result);\n  }\n\n}\n\nexports.AsyncEvaluator = AsyncEvaluator;\n\nfunction log(val) {\n  // console.log(val);\n  return val;\n}","map":{"version":3,"sources":["../../../lib/evaluators/AsyncEvaluator.ts"],"names":[],"mappings":";;;;;;;AAKA,MAAA,gBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAGA,MAAA,8BAAA,GAAA,OAAA,CAAA,gCAAA,CAAA;;AAkBA,MAAa,cAAb,CAA2B;AAIzB,EAAA,WAAA,CAAmB,OAAnB,EAAmD,MAAA,GAA+B,EAAlF,EAAoF;AAAjE,SAAA,OAAA,GAAA,OAAA;AAAgC,SAAA,MAAA,GAAA,MAAA;AACjD,SAAK,IAAL,GAAY,gBAAA,CAAA,gBAAA,CAAiB,OAAjB,CAAZ;AAEA,UAAM,OAAO,GAAG;AACd,MAAA,GAAG,EAAE,MAAM,CAAC,GAAP,IAAc,IAAI,IAAJ,CAAS,IAAI,CAAC,GAAL,EAAT,CADL;AAEd,MAAA,KAAK,EAAE,MAAM,CAAC,KAAP,IAAgB,SAFT;AAGd,MAAA,OAAO,EAAE,MAAM,CAAC,OAAP,IAAkB,SAHb;AAId,MAAA,MAAM,EAAE,MAAM,CAAC,MAJD;AAKd,MAAA,SAAS,EAAE,MAAM,CAAC;AALJ,KAAhB;AAQA,SAAK,SAAL,GAAiB,IAAI,8BAAA,CAAA,uBAAJ,CAA4B,OAA5B,CAAjB;AACD;;AAEa,QAAR,QAAQ,CAAC,OAAD,EAAkB;AAC9B,UAAM,MAAM,GAAG,MAAM,KAAK,SAAL,CAAe,QAAf,CAAwB,KAAK,IAA7B,EAAmC,OAAnC,CAArB;AACA,WAAO,GAAG,CAAC,MAAD,CAAH,CAAY,KAAZ,EAAP;AACD;;AAEkB,QAAb,aAAa,CAAC,OAAD,EAAkB;AACnC,UAAM,MAAM,GAAG,MAAM,KAAK,SAAL,CAAe,QAAf,CAAwB,KAAK,IAA7B,EAAmC,OAAnC,CAArB;AACA,WAAO,GAAG,CAAC,MAAD,CAAH,CAAY,SAAZ,EAAP;AACD;;AAEuB,QAAlB,kBAAkB,CAAC,OAAD,EAAkB;AACxC,UAAM,MAAM,GAAG,MAAM,KAAK,SAAL,CAAe,QAAf,CAAwB,KAAK,IAA7B,EAAmC,OAAnC,CAArB;AACA,WAAO,GAAG,CAAC,MAAD,CAAV;AACD;;AA/BwB;;AAA3B,OAAA,CAAA,cAAA,GAAA,cAAA;;AAkCA,SAAS,GAAT,CAAgB,GAAhB,EAAsB;AACpB;AACA,SAAO,GAAP;AACD","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as E from '../expressions/Expressions';\n\nimport { transformAlgebra } from '../Transformation';\nimport { Bindings, ExpressionEvaluator } from '../Types';\n\nimport { AsyncRecursiveEvaluator } from './RecursiveExpressionEvaluator';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\n\nexport interface AsyncEvaluatorConfig {\n  now?: Date;\n  baseIRI?: string;\n\n  exists?: (expression: Alg.ExistenceExpression, mapping: Bindings) => Promise<boolean>;\n  aggregate?: (expression: Alg.AggregateExpression) => Promise<RDF.Term>;\n  bnode?: (input?: string) => Promise<RDF.BlankNode>;\n}\n\nexport type AsyncEvaluatorContext = AsyncEvaluatorConfig & {\n  now: Date;\n};\n\nexport class AsyncEvaluator {\n  private expr: Expression;\n  private evaluator: ExpressionEvaluator<Expression, Promise<Term>>;\n\n  constructor(public algExpr: Alg.Expression, public config: AsyncEvaluatorConfig = {}) {\n    this.expr = transformAlgebra(algExpr);\n\n    const context = {\n      now: config.now || new Date(Date.now()),\n      bnode: config.bnode || undefined,\n      baseIRI: config.baseIRI || undefined,\n      exists: config.exists,\n      aggregate: config.aggregate,\n    };\n\n    this.evaluator = new AsyncRecursiveEvaluator(context);\n  }\n\n  async evaluate(mapping: Bindings): Promise<RDF.Term> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result).toRDF();\n  }\n\n  async evaluateAsEBV(mapping: Bindings): Promise<boolean> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result).coerceEBV();\n  }\n\n  async evaluateAsInternal(mapping: Bindings): Promise<Term> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result);\n  }\n}\n\nfunction log<T>(val: T): T {\n  // console.log(val);\n  return val;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}