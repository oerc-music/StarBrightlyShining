{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EntryHandlerKeywordType = void 0;\n\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n\nconst Util_1 = require(\"../../Util\");\n\nconst EntryHandlerPredicate_1 = require(\"../EntryHandlerPredicate\");\n\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @graph entries.\n */\n\n\nclass EntryHandlerKeywordType extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n  constructor() {\n    super('@type');\n  }\n\n  isStackProcessor() {\n    return false;\n  }\n\n  async handle(parsingContext, util, key, keys, value, depth) {\n    const keyOriginal = keys[depth]; // The current identifier identifies an rdf:type predicate.\n    // But we only emit it once the node closes,\n    // as it's possible that the @type is used to identify the datatype of a literal, which we ignore here.\n\n    const context = await parsingContext.getContext(keys);\n    const predicate = util.rdfType;\n    const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, await util.unaliasKeywordParent(keys, depth)); // Handle multiple values if the value is an array\n\n    const elements = Array.isArray(value) ? value : [value];\n\n    for (const element of elements) {\n      if (typeof element !== 'string') {\n        parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @type '${element}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPE_VALUE));\n      }\n\n      const type = util.createVocabOrBaseTerm(context, element);\n\n      if (type) {\n        await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, type, reverse);\n      }\n    } // Collect type-scoped contexts if they exist\n\n\n    let scopedContext = Promise.resolve(context);\n    let hasTypedScopedContext = false;\n\n    for (const element of elements.sort()) {\n      // Spec requires lexicographical ordering\n      const typeContext = Util_1.Util.getContextValue(context, '@context', element, null);\n\n      if (typeContext) {\n        hasTypedScopedContext = true;\n        scopedContext = scopedContext.then(c => parsingContext.parseContext(typeContext, c.getContextRaw()));\n      }\n    } // Error if an out-of-order type-scoped context was found when support is not enabled.\n\n\n    if (parsingContext.streamingProfile && (hasTypedScopedContext || !parsingContext.streamingProfileAllowOutOfOrderPlainType) && (parsingContext.processingStack[depth] || parsingContext.idStack[depth])) {\n      parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded('Found an out-of-order type-scoped context, while streaming is enabled.' + '(disable `streamingProfile`)', jsonld_context_parser_1.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));\n    } // If at least least one type-scoped context applies, set them in the tree.\n\n\n    if (hasTypedScopedContext) {\n      // Do not propagate by default\n      scopedContext = scopedContext.then(c => {\n        if (!('@propagate' in c.getContextRaw())) {\n          c.getContextRaw()['@propagate'] = false;\n        } // Set the original context at this depth as a fallback\n        // This is needed when a context was already defined at the given depth,\n        // and this context needs to remain accessible from child nodes when propagation is disabled.\n\n\n        if (c.getContextRaw()['@propagate'] === false) {\n          c.getContextRaw()['@__propagateFallback'] = context.getContextRaw();\n        }\n\n        return c;\n      }); // Set the new context in the context tree\n\n      parsingContext.contextTree.setContext(keys.slice(0, keys.length - 1), scopedContext);\n    } // Flag that type has been processed at this depth\n\n\n    parsingContext.processingType[depth] = true;\n  }\n\n}\n\nexports.EntryHandlerKeywordType = EntryHandlerKeywordType;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-parser/lib/entryhandler/keyword/EntryHandlerKeywordType.js"],"names":["Object","defineProperty","exports","value","EntryHandlerKeywordType","jsonld_context_parser_1","require","Util_1","EntryHandlerPredicate_1","EntryHandlerKeyword_1","EntryHandlerKeyword","constructor","isStackProcessor","handle","parsingContext","util","key","keys","depth","keyOriginal","context","getContext","predicate","rdfType","reverse","Util","isPropertyReverse","unaliasKeywordParent","elements","Array","isArray","element","emitError","ErrorCoded","ERROR_CODES","INVALID_TYPE_VALUE","type","createVocabOrBaseTerm","EntryHandlerPredicate","handlePredicateObject","scopedContext","Promise","resolve","hasTypedScopedContext","sort","typeContext","getContextValue","then","c","parseContext","getContextRaw","streamingProfile","streamingProfileAllowOutOfOrderPlainType","processingStack","idStack","INVALID_STREAMING_KEY_ORDER","contextTree","setContext","slice","length","processingType"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerKeywordType = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst Util_1 = require(\"../../Util\");\nconst EntryHandlerPredicate_1 = require(\"../EntryHandlerPredicate\");\nconst EntryHandlerKeyword_1 = require(\"./EntryHandlerKeyword\");\n/**\n * Handles @graph entries.\n */\nclass EntryHandlerKeywordType extends EntryHandlerKeyword_1.EntryHandlerKeyword {\n    constructor() {\n        super('@type');\n    }\n    isStackProcessor() {\n        return false;\n    }\n    async handle(parsingContext, util, key, keys, value, depth) {\n        const keyOriginal = keys[depth];\n        // The current identifier identifies an rdf:type predicate.\n        // But we only emit it once the node closes,\n        // as it's possible that the @type is used to identify the datatype of a literal, which we ignore here.\n        const context = await parsingContext.getContext(keys);\n        const predicate = util.rdfType;\n        const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, await util.unaliasKeywordParent(keys, depth));\n        // Handle multiple values if the value is an array\n        const elements = Array.isArray(value) ? value : [value];\n        for (const element of elements) {\n            if (typeof element !== 'string') {\n                parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded(`Found illegal @type '${element}'`, jsonld_context_parser_1.ERROR_CODES.INVALID_TYPE_VALUE));\n            }\n            const type = util.createVocabOrBaseTerm(context, element);\n            if (type) {\n                await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, type, reverse);\n            }\n        }\n        // Collect type-scoped contexts if they exist\n        let scopedContext = Promise.resolve(context);\n        let hasTypedScopedContext = false;\n        for (const element of elements.sort()) { // Spec requires lexicographical ordering\n            const typeContext = Util_1.Util.getContextValue(context, '@context', element, null);\n            if (typeContext) {\n                hasTypedScopedContext = true;\n                scopedContext = scopedContext.then((c) => parsingContext.parseContext(typeContext, c.getContextRaw()));\n            }\n        }\n        // Error if an out-of-order type-scoped context was found when support is not enabled.\n        if (parsingContext.streamingProfile\n            && (hasTypedScopedContext || !parsingContext.streamingProfileAllowOutOfOrderPlainType)\n            && (parsingContext.processingStack[depth] || parsingContext.idStack[depth])) {\n            parsingContext.emitError(new jsonld_context_parser_1.ErrorCoded('Found an out-of-order type-scoped context, while streaming is enabled.' +\n                '(disable `streamingProfile`)', jsonld_context_parser_1.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));\n        }\n        // If at least least one type-scoped context applies, set them in the tree.\n        if (hasTypedScopedContext) {\n            // Do not propagate by default\n            scopedContext = scopedContext.then((c) => {\n                if (!('@propagate' in c.getContextRaw())) {\n                    c.getContextRaw()['@propagate'] = false;\n                }\n                // Set the original context at this depth as a fallback\n                // This is needed when a context was already defined at the given depth,\n                // and this context needs to remain accessible from child nodes when propagation is disabled.\n                if (c.getContextRaw()['@propagate'] === false) {\n                    c.getContextRaw()['@__propagateFallback'] = context.getContextRaw();\n                }\n                return c;\n            });\n            // Set the new context in the context tree\n            parsingContext.contextTree.setContext(keys.slice(0, keys.length - 1), scopedContext);\n        }\n        // Flag that type has been processed at this depth\n        parsingContext.processingType[depth] = true;\n    }\n}\nexports.EntryHandlerKeywordType = EntryHandlerKeywordType;\n//# sourceMappingURL=EntryHandlerKeywordType.js.map"]},"metadata":{},"sourceType":"script"}