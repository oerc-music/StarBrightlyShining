{"ast":null,"code":"var XSD_INTEGER = 'http://www.w3.org/2001/XMLSchema#integer';\nvar XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\n\nfunction Generator(options) {\n  this._options = options = options || {};\n  var prefixes = options.prefixes || {};\n  this._prefixByIri = {};\n  var prefixIris = [];\n\n  for (var prefix in prefixes) {\n    var iri = prefixes[prefix];\n\n    if (isString(iri)) {\n      this._prefixByIri[iri] = prefix;\n      prefixIris.push(iri);\n    }\n  }\n\n  var iriList = prefixIris.join('|').replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n  this._prefixRegex = new RegExp('^(' + iriList + ')([a-zA-Z][\\\\-_a-zA-Z0-9]*)$');\n  this._usedPrefixes = {};\n  this._sparqlStar = options.sparqlStar;\n  this._indent = isString(options.indent) ? options.indent : '  ';\n  this._newline = isString(options.newline) ? options.newline : '\\n';\n  this._explicitDatatype = Boolean(options.explicitDatatype);\n} // Converts the parsed query object into a SPARQL query\n\n\nGenerator.prototype.toQuery = function (q) {\n  var query = '';\n  if (q.queryType) query += q.queryType.toUpperCase() + ' ';\n  if (q.reduced) query += 'REDUCED ';\n  if (q.distinct) query += 'DISTINCT ';\n\n  if (q.variables) {\n    query += mapJoin(q.variables, undefined, function (variable) {\n      return isTerm(variable) ? this.toEntity(variable) : '(' + this.toExpression(variable.expression) + ' AS ' + variableToString(variable.variable) + ')';\n    }, this) + ' ';\n  } else if (q.template) query += this.group(q.template, true) + this._newline;\n\n  if (q.from) query += this.graphs('FROM ', q.from.default) + this.graphs('FROM NAMED ', q.from.named);\n  if (q.where) query += 'WHERE ' + this.group(q.where, true) + this._newline;\n  if (q.updates) query += mapJoin(q.updates, ';' + this._newline, this.toUpdate, this);\n  if (q.group) query += 'GROUP BY ' + mapJoin(q.group, undefined, function (it) {\n    var result = isString(it.expression) ? it.expression : '(' + this.toExpression(it.expression) + ')';\n    return it.variable ? '(' + result + ' AS ' + variableToString(it.variable) + ')' : result;\n  }, this) + this._newline;\n  if (q.having) query += 'HAVING (' + mapJoin(q.having, undefined, this.toExpression, this) + ')' + this._newline;\n  if (q.order) query += 'ORDER BY ' + mapJoin(q.order, undefined, function (it) {\n    var expr = '(' + this.toExpression(it.expression) + ')';\n    return !it.descending ? expr : 'DESC ' + expr;\n  }, this) + this._newline;\n  if (q.offset) query += 'OFFSET ' + q.offset + this._newline;\n  if (q.limit) query += 'LIMIT ' + q.limit + this._newline;\n  if (q.values) query += this.values(q); // stringify prefixes at the end to mark used ones\n\n  query = this.baseAndPrefixes(q) + query;\n  return query.trim();\n};\n\nGenerator.prototype.baseAndPrefixes = function (q) {\n  var base = q.base ? 'BASE <' + q.base + '>' + this._newline : '';\n  var prefixes = '';\n\n  for (var key in q.prefixes) {\n    if (this._options.allPrefixes || this._usedPrefixes[key]) prefixes += 'PREFIX ' + key + ': <' + q.prefixes[key] + '>' + this._newline;\n  }\n\n  return base + prefixes;\n}; // Converts the parsed SPARQL pattern into a SPARQL pattern\n\n\nGenerator.prototype.toPattern = function (pattern) {\n  var type = pattern.type || pattern instanceof Array && 'array' || (pattern.subject && pattern.predicate && pattern.object ? 'triple' : '');\n  if (!(type in this)) throw new Error('Unknown entry type: ' + type);\n  return this[type](pattern);\n};\n\nGenerator.prototype.triple = function (t) {\n  return this.toEntity(t.subject) + ' ' + this.toEntity(t.predicate) + ' ' + this.toEntity(t.object) + '.';\n};\n\nGenerator.prototype.array = function (items) {\n  return mapJoin(items, this._newline, this.toPattern, this);\n};\n\nGenerator.prototype.bgp = function (bgp) {\n  return this.encodeTriples(bgp.triples);\n};\n\nGenerator.prototype.encodeTriples = function (triples) {\n  if (!triples.length) return '';\n  var parts = [],\n      subject = undefined,\n      predicate = undefined;\n\n  for (var i = 0; i < triples.length; i++) {\n    var triple = triples[i]; // Triple with different subject\n\n    if (!equalTerms(triple.subject, subject)) {\n      // Terminate previous triple\n      if (subject) parts.push('.' + this._newline);\n      subject = triple.subject;\n      predicate = triple.predicate;\n      parts.push(this.toEntity(subject), ' ', this.toEntity(predicate));\n    } // Triple with same subject but different predicate\n    else if (!equalTerms(triple.predicate, predicate)) {\n      predicate = triple.predicate;\n      parts.push(';' + this._newline, this._indent, this.toEntity(predicate));\n    } // Triple with same subject and predicate\n    else {\n      parts.push(',');\n    }\n\n    parts.push(' ', this.toEntity(triple.object));\n  }\n\n  parts.push('.');\n  return parts.join('');\n};\n\nGenerator.prototype.graph = function (graph) {\n  return 'GRAPH ' + this.toEntity(graph.name) + ' ' + this.group(graph);\n};\n\nGenerator.prototype.graphs = function (keyword, graphs) {\n  return !graphs || graphs.length === 0 ? '' : mapJoin(graphs, '', function (g) {\n    return keyword + this.toEntity(g) + this._newline;\n  }, this);\n};\n\nGenerator.prototype.group = function (group, inline) {\n  group = inline !== true ? this.array(group.patterns || group.triples) : this.toPattern(group.type !== 'group' ? group : group.patterns);\n  return group.indexOf(this._newline) === -1 ? '{ ' + group + ' }' : '{' + this._newline + this.indent(group) + this._newline + '}';\n};\n\nGenerator.prototype.query = function (query) {\n  return this.toQuery(query);\n};\n\nGenerator.prototype.filter = function (filter) {\n  return 'FILTER(' + this.toExpression(filter.expression) + ')';\n};\n\nGenerator.prototype.bind = function (bind) {\n  return 'BIND(' + this.toExpression(bind.expression) + ' AS ' + variableToString(bind.variable) + ')';\n};\n\nGenerator.prototype.optional = function (optional) {\n  return 'OPTIONAL ' + this.group(optional);\n};\n\nGenerator.prototype.union = function (union) {\n  return mapJoin(union.patterns, this._newline + 'UNION' + this._newline, function (p) {\n    return this.group(p, true);\n  }, this);\n};\n\nGenerator.prototype.minus = function (minus) {\n  return 'MINUS ' + this.group(minus);\n};\n\nGenerator.prototype.values = function (valuesList) {\n  // Gather unique keys\n  var keys = Object.keys(valuesList.values.reduce(function (keyHash, values) {\n    for (var key in values) keyHash[key] = true;\n\n    return keyHash;\n  }, {})); // Check whether simple syntax can be used\n\n  var lparen, rparen;\n\n  if (keys.length === 1) {\n    lparen = rparen = '';\n  } else {\n    lparen = '(';\n    rparen = ')';\n  } // Create value rows\n\n\n  return 'VALUES ' + lparen + keys.join(' ') + rparen + ' {' + this._newline + mapJoin(valuesList.values, this._newline, function (values) {\n    return '  ' + lparen + mapJoin(keys, undefined, function (key) {\n      return values[key] ? this.toEntity(values[key]) : 'UNDEF';\n    }, this) + rparen;\n  }, this) + this._newline + '}';\n};\n\nGenerator.prototype.service = function (service) {\n  return 'SERVICE ' + (service.silent ? 'SILENT ' : '') + this.toEntity(service.name) + ' ' + this.group(service);\n}; // Converts the parsed expression object into a SPARQL expression\n\n\nGenerator.prototype.toExpression = function (expr) {\n  if (isTerm(expr)) {\n    return this.toEntity(expr);\n  }\n\n  switch (expr.type.toLowerCase()) {\n    case 'aggregate':\n      return expr.aggregation.toUpperCase() + '(' + (expr.distinct ? 'DISTINCT ' : '') + this.toExpression(expr.expression) + (expr.separator ? '; SEPARATOR = ' + '\"' + expr.separator.replace(escape, escapeReplacer) + '\"' : '') + ')';\n\n    case 'functioncall':\n      return this.toEntity(expr.function) + '(' + mapJoin(expr.args, ', ', this.toExpression, this) + ')';\n\n    case 'operation':\n      var operator = expr.operator.toUpperCase(),\n          args = expr.args || [];\n\n      switch (expr.operator.toLowerCase()) {\n        // Infix operators\n        case '<':\n        case '>':\n        case '>=':\n        case '<=':\n        case '&&':\n        case '||':\n        case '=':\n        case '!=':\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n          return (isTerm(args[0]) ? this.toEntity(args[0]) : '(' + this.toExpression(args[0]) + ')') + ' ' + operator + ' ' + (isTerm(args[1]) ? this.toEntity(args[1]) : '(' + this.toExpression(args[1]) + ')');\n        // Unary operators\n\n        case '!':\n          return '!(' + this.toExpression(args[0]) + ')';\n\n        case 'uminus':\n          return '-(' + this.toExpression(args[0]) + ')';\n        // IN and NOT IN\n\n        case 'notin':\n          operator = 'NOT IN';\n\n        case 'in':\n          return this.toExpression(args[0]) + ' ' + operator + '(' + (isString(args[1]) ? args[1] : mapJoin(args[1], ', ', this.toExpression, this)) + ')';\n        // EXISTS and NOT EXISTS\n\n        case 'notexists':\n          operator = 'NOT EXISTS';\n\n        case 'exists':\n          return operator + ' ' + this.group(args[0], true);\n        // Other expressions\n\n        default:\n          return operator + '(' + mapJoin(args, ', ', this.toExpression, this) + ')';\n      }\n\n    default:\n      throw new Error('Unknown expression type: ' + expr.type);\n  }\n}; // Converts the parsed entity (or property path) into a SPARQL entity\n\n\nGenerator.prototype.toEntity = function (value) {\n  if (isTerm(value)) {\n    switch (value.termType) {\n      // variable, * selector, or blank node\n      case 'Wildcard':\n        return '*';\n\n      case 'Variable':\n        return variableToString(value);\n\n      case 'BlankNode':\n        return '_:' + value.value;\n      // literal\n\n      case 'Literal':\n        var lexical = value.value || '',\n            language = value.language || '',\n            datatype = value.datatype;\n        value = '\"' + lexical.replace(escape, escapeReplacer) + '\"';\n\n        if (language) {\n          value += '@' + language;\n        } else if (datatype) {\n          // Abbreviate literals when possible\n          if (!this._explicitDatatype) {\n            switch (datatype.value) {\n              case XSD_STRING:\n                return value;\n\n              case XSD_INTEGER:\n                if (/^\\d+$/.test(lexical)) // Add space to avoid confusion with decimals in broken parsers\n                  return lexical + ' ';\n            }\n          }\n\n          value += '^^' + this.encodeIRI(datatype.value);\n        }\n\n        return value;\n\n      case 'Quad':\n        if (!this._sparqlStar) throw new Error('SPARQL* support is not enabled');\n\n        if (value.graph && value.graph.termType !== \"DefaultGraph\") {\n          return '<< GRAPH ' + this.toEntity(value.graph) + ' { ' + this.toEntity(value.subject) + ' ' + this.toEntity(value.predicate) + ' ' + this.toEntity(value.object) + ' } ' + ' >>';\n        } else {\n          return '<< ' + this.toEntity(value.subject) + ' ' + this.toEntity(value.predicate) + ' ' + this.toEntity(value.object) + ' >>';\n        }\n\n      // IRI\n\n      default:\n        return this.encodeIRI(value.value);\n    }\n  } // property path\n  else {\n    var items = value.items.map(this.toEntity, this),\n        path = value.pathType;\n\n    switch (path) {\n      // prefix operator\n      case '^':\n      case '!':\n        return path + items[0];\n      // postfix operator\n\n      case '*':\n      case '+':\n      case '?':\n        return '(' + items[0] + path + ')';\n      // infix operator\n\n      default:\n        return '(' + items.join(path) + ')';\n    }\n  }\n};\n\nvar escape = /[\"\\\\\\t\\n\\r\\b\\f]/g,\n    escapeReplacer = function (c) {\n  return escapeReplacements[c];\n},\n    escapeReplacements = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n}; // Represent the IRI, as a prefixed name when possible\n\n\nGenerator.prototype.encodeIRI = function (iri) {\n  var prefixMatch = this._prefixRegex.exec(iri);\n\n  if (prefixMatch) {\n    var prefix = this._prefixByIri[prefixMatch[1]];\n    this._usedPrefixes[prefix] = true;\n    return prefix + ':' + prefixMatch[2];\n  }\n\n  return '<' + iri + '>';\n}; // Converts the parsed update object into a SPARQL update clause\n\n\nGenerator.prototype.toUpdate = function (update) {\n  switch (update.type || update.updateType) {\n    case 'load':\n      return 'LOAD' + (update.source ? ' ' + this.toEntity(update.source) : '') + (update.destination ? ' INTO GRAPH ' + this.toEntity(update.destination) : '');\n\n    case 'insert':\n      return 'INSERT DATA ' + this.group(update.insert, true);\n\n    case 'delete':\n      return 'DELETE DATA ' + this.group(update.delete, true);\n\n    case 'deletewhere':\n      return 'DELETE WHERE ' + this.group(update.delete, true);\n\n    case 'insertdelete':\n      return (update.graph ? 'WITH ' + this.toEntity(update.graph) + this._newline : '') + (update.delete.length ? 'DELETE ' + this.group(update.delete, true) + this._newline : '') + (update.insert.length ? 'INSERT ' + this.group(update.insert, true) + this._newline : '') + (update.using ? this.graphs('USING ', update.using.default) : '') + (update.using ? this.graphs('USING NAMED ', update.using.named) : '') + 'WHERE ' + this.group(update.where, true);\n\n    case 'add':\n    case 'copy':\n    case 'move':\n      return update.type.toUpperCase() + (update.source.default ? ' DEFAULT ' : ' ') + 'TO ' + this.toEntity(update.destination.name);\n\n    case 'create':\n    case 'clear':\n    case 'drop':\n      return update.type.toUpperCase() + (update.silent ? ' SILENT ' : ' ') + (update.graph.default ? 'DEFAULT' : update.graph.named ? 'NAMED' : update.graph.all ? 'ALL' : 'GRAPH ' + this.toEntity(update.graph.name));\n\n    default:\n      throw new Error('Unknown update query type: ' + update.type);\n  }\n}; // Indents each line of the string\n\n\nGenerator.prototype.indent = function (text) {\n  return text.replace(/^/gm, this._indent);\n};\n\nfunction variableToString(variable) {\n  return '?' + variable.value;\n} // Checks whether the object is a string\n\n\nfunction isString(object) {\n  return typeof object === 'string';\n} // Checks whether the object is a Term\n\n\nfunction isTerm(object) {\n  return typeof object.termType === 'string';\n} // Checks whether term1 and term2 are equivalent without `.equals()` prototype method\n\n\nfunction equalTerms(term1, term2) {\n  if (!term1 || !isTerm(term1)) {\n    return false;\n  }\n\n  if (!term2 || !isTerm(term2)) {\n    return false;\n  }\n\n  if (term1.termType !== term2.termType) {\n    return false;\n  }\n\n  switch (term1.termType) {\n    case 'Literal':\n      return term1.value === term2.value && term1.language === term2.language && equalTerms(term1.datatype, term2.datatype);\n\n    case 'Quad':\n      return equalTerms(term1.subject, term2.subject) && equalTerms(term1.predicate, term2.predicate) && equalTerms(term1.object, term2.object) && equalTerms(term1.graph, term2.graph);\n\n    default:\n      return term1.value === term2.value;\n  }\n} // Maps the array with the given function, and joins the results using the separator\n\n\nfunction mapJoin(array, sep, func, self) {\n  return array.map(func, self).join(isString(sep) ? sep : ' ');\n}\n/**\n * @param options {\n *   allPrefixes: boolean,\n *   indentation: string,\n *   newline: string\n * }\n */\n\n\nmodule.exports = function SparqlGenerator(options = {}) {\n  return {\n    stringify: function (query) {\n      var currentOptions = Object.create(options);\n      currentOptions.prefixes = query.prefixes;\n      return new Generator(currentOptions).toQuery(query);\n    },\n    createGenerator: function () {\n      return new Generator(options);\n    }\n  };\n};","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/sparqljs/lib/SparqlGenerator.js"],"names":["XSD_INTEGER","XSD_STRING","Generator","options","_options","prefixes","_prefixByIri","prefixIris","prefix","iri","isString","push","iriList","join","replace","_prefixRegex","RegExp","_usedPrefixes","_sparqlStar","sparqlStar","_indent","indent","_newline","newline","_explicitDatatype","Boolean","explicitDatatype","prototype","toQuery","q","query","queryType","toUpperCase","reduced","distinct","variables","mapJoin","undefined","variable","isTerm","toEntity","toExpression","expression","variableToString","template","group","from","graphs","default","named","where","updates","toUpdate","it","result","having","order","expr","descending","offset","limit","values","baseAndPrefixes","trim","base","key","allPrefixes","toPattern","pattern","type","Array","subject","predicate","object","Error","triple","t","array","items","bgp","encodeTriples","triples","length","parts","i","equalTerms","graph","name","keyword","g","inline","patterns","indexOf","filter","bind","optional","union","p","minus","valuesList","keys","Object","reduce","keyHash","lparen","rparen","service","silent","toLowerCase","aggregation","separator","escape","escapeReplacer","function","args","operator","value","termType","lexical","language","datatype","test","encodeIRI","map","path","pathType","c","escapeReplacements","prefixMatch","exec","update","updateType","source","destination","insert","delete","using","all","text","term1","term2","sep","func","self","module","exports","SparqlGenerator","stringify","currentOptions","create","createGenerator"],"mappings":"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","sourcesContent":["var XSD_INTEGER = 'http://www.w3.org/2001/XMLSchema#integer';\nvar XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\n\nfunction Generator(options) {\n  this._options = options = options || {};\n\n  var prefixes = options.prefixes || {};\n  this._prefixByIri = {};\n  var prefixIris = [];\n  for (var prefix in prefixes) {\n    var iri = prefixes[prefix];\n    if (isString(iri)) {\n      this._prefixByIri[iri] = prefix;\n      prefixIris.push(iri);\n    }\n  }\n  var iriList = prefixIris.join('|').replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n  this._prefixRegex = new RegExp('^(' + iriList + ')([a-zA-Z][\\\\-_a-zA-Z0-9]*)$');\n  this._usedPrefixes = {};\n  this._sparqlStar = options.sparqlStar;\n  this._indent =  isString(options.indent)  ? options.indent  : '  ';\n  this._newline = isString(options.newline) ? options.newline : '\\n';\n  this._explicitDatatype = Boolean(options.explicitDatatype);\n}\n\n// Converts the parsed query object into a SPARQL query\nGenerator.prototype.toQuery = function (q) {\n  var query = '';\n\n  if (q.queryType)\n    query += q.queryType.toUpperCase() + ' ';\n  if (q.reduced)\n    query += 'REDUCED ';\n  if (q.distinct)\n    query += 'DISTINCT ';\n\n  if (q.variables){\n    query += mapJoin(q.variables, undefined, function (variable) {\n      return isTerm(variable) ? this.toEntity(variable) :\n             '(' + this.toExpression(variable.expression) + ' AS ' + variableToString(variable.variable) + ')';\n    }, this) + ' ';\n  }\n  else if (q.template)\n    query += this.group(q.template, true) + this._newline;\n\n  if (q.from)\n    query += this.graphs('FROM ', q.from.default) + this.graphs('FROM NAMED ', q.from.named);\n  if (q.where)\n    query += 'WHERE ' + this.group(q.where, true) + this._newline;\n\n  if (q.updates)\n    query += mapJoin(q.updates, ';' + this._newline, this.toUpdate, this);\n\n  if (q.group)\n    query += 'GROUP BY ' + mapJoin(q.group, undefined, function (it) {\n      var result = isString(it.expression) ? it.expression : '(' + this.toExpression(it.expression) + ')';\n      return it.variable ? '(' + result + ' AS ' + variableToString(it.variable) + ')' : result;\n    }, this) + this._newline;\n  if (q.having)\n    query += 'HAVING (' + mapJoin(q.having, undefined, this.toExpression, this) + ')' + this._newline;\n  if (q.order)\n    query += 'ORDER BY ' + mapJoin(q.order, undefined, function (it) {\n      var expr = '(' + this.toExpression(it.expression) + ')';\n      return !it.descending ? expr : 'DESC ' + expr;\n    }, this) + this._newline;\n\n  if (q.offset)\n    query += 'OFFSET ' + q.offset + this._newline;\n  if (q.limit)\n    query += 'LIMIT ' + q.limit + this._newline;\n\n  if (q.values)\n    query += this.values(q);\n\n  // stringify prefixes at the end to mark used ones\n  query = this.baseAndPrefixes(q) + query;\n  return query.trim();\n};\n\nGenerator.prototype.baseAndPrefixes = function (q) {\n  var base = q.base ? ('BASE <' + q.base + '>' + this._newline) : '';\n  var prefixes = '';\n  for (var key in q.prefixes) {\n    if (this._options.allPrefixes || this._usedPrefixes[key])\n      prefixes += 'PREFIX ' + key + ': <' + q.prefixes[key] + '>' + this._newline;\n  }\n  return base + prefixes;\n};\n\n// Converts the parsed SPARQL pattern into a SPARQL pattern\nGenerator.prototype.toPattern = function (pattern) {\n  var type = pattern.type || (pattern instanceof Array) && 'array' ||\n             (pattern.subject && pattern.predicate && pattern.object ? 'triple' : '');\n  if (!(type in this))\n    throw new Error('Unknown entry type: ' + type);\n  return this[type](pattern);\n};\n\nGenerator.prototype.triple = function (t) {\n  return this.toEntity(t.subject) + ' ' + this.toEntity(t.predicate) + ' ' + this.toEntity(t.object) + '.';\n};\n\nGenerator.prototype.array = function (items) {\n  return mapJoin(items, this._newline, this.toPattern, this);\n};\n\nGenerator.prototype.bgp = function (bgp) {\n  return this.encodeTriples(bgp.triples);\n};\n\nGenerator.prototype.encodeTriples = function (triples) {\n  if (!triples.length)\n    return '';\n\n  var parts = [], subject = undefined, predicate = undefined;\n  for (var i = 0; i < triples.length; i++) {\n    var triple = triples[i];\n    // Triple with different subject\n    if (!equalTerms(triple.subject, subject)) {\n      // Terminate previous triple\n      if (subject)\n        parts.push('.' + this._newline);\n      subject = triple.subject;\n      predicate = triple.predicate;\n      parts.push(this.toEntity(subject), ' ', this.toEntity(predicate));\n    }\n    // Triple with same subject but different predicate\n    else if (!equalTerms(triple.predicate, predicate)) {\n      predicate = triple.predicate;\n      parts.push(';' + this._newline, this._indent, this.toEntity(predicate));\n    }\n    // Triple with same subject and predicate\n    else {\n      parts.push(',');\n    }\n    parts.push(' ', this.toEntity(triple.object));\n  }\n  parts.push('.');\n\n  return parts.join('');\n}\n\nGenerator.prototype.graph = function (graph) {\n  return 'GRAPH ' + this.toEntity(graph.name) + ' ' + this.group(graph);\n};\n\nGenerator.prototype.graphs = function (keyword, graphs) {\n  return !graphs || graphs.length === 0 ? '' :\n    mapJoin(graphs, '', function (g) { return keyword + this.toEntity(g) + this._newline; }, this)\n}\n\nGenerator.prototype.group = function (group, inline) {\n  group = inline !== true ? this.array(group.patterns || group.triples)\n                          : this.toPattern(group.type !== 'group' ? group : group.patterns);\n  return group.indexOf(this._newline) === -1 ? '{ ' + group + ' }' : '{' + this._newline + this.indent(group) + this._newline + '}';\n};\n\nGenerator.prototype.query = function (query) {\n  return this.toQuery(query);\n};\n\nGenerator.prototype.filter = function (filter) {\n  return 'FILTER(' + this.toExpression(filter.expression) + ')';\n};\n\nGenerator.prototype.bind = function (bind) {\n  return 'BIND(' + this.toExpression(bind.expression) + ' AS ' + variableToString(bind.variable) + ')';\n};\n\nGenerator.prototype.optional = function (optional) {\n  return 'OPTIONAL ' + this.group(optional);\n};\n\nGenerator.prototype.union = function (union) {\n  return mapJoin(union.patterns, this._newline + 'UNION' + this._newline, function (p) { return this.group(p, true); }, this);\n};\n\nGenerator.prototype.minus = function (minus) {\n  return 'MINUS ' + this.group(minus);\n};\n\nGenerator.prototype.values = function (valuesList) {\n  // Gather unique keys\n  var keys = Object.keys(valuesList.values.reduce(function (keyHash, values) {\n    for (var key in values) keyHash[key] = true;\n    return keyHash;\n  }, {}));\n  // Check whether simple syntax can be used\n  var lparen, rparen;\n  if (keys.length === 1) {\n    lparen = rparen = '';\n  } else {\n    lparen = '(';\n    rparen = ')';\n  }\n  // Create value rows\n  return 'VALUES ' + lparen + keys.join(' ') + rparen + ' {' + this._newline +\n    mapJoin(valuesList.values, this._newline, function (values) {\n      return '  ' + lparen + mapJoin(keys, undefined, function (key) {\n        return values[key] ? this.toEntity(values[key]) : 'UNDEF';\n      }, this) + rparen;\n    }, this) + this._newline + '}';\n};\n\nGenerator.prototype.service = function (service) {\n  return 'SERVICE ' + (service.silent ? 'SILENT ' : '') + this.toEntity(service.name) + ' ' +\n         this.group(service);\n};\n\n// Converts the parsed expression object into a SPARQL expression\nGenerator.prototype.toExpression = function (expr) {\n  if (isTerm(expr)) {\n    return this.toEntity(expr);\n  }\n  switch (expr.type.toLowerCase()) {\n    case 'aggregate':\n      return expr.aggregation.toUpperCase() +\n             '(' + (expr.distinct ? 'DISTINCT ' : '') + this.toExpression(expr.expression) +\n             (expr.separator ? '; SEPARATOR = ' + '\"' + expr.separator.replace(escape, escapeReplacer) + '\"' : '') + ')';\n    case 'functioncall':\n      return this.toEntity(expr.function) + '(' + mapJoin(expr.args, ', ', this.toExpression, this) + ')';\n    case 'operation':\n      var operator = expr.operator.toUpperCase(), args = expr.args || [];\n      switch (expr.operator.toLowerCase()) {\n      // Infix operators\n      case '<':\n      case '>':\n      case '>=':\n      case '<=':\n      case '&&':\n      case '||':\n      case '=':\n      case '!=':\n      case '+':\n      case '-':\n      case '*':\n      case '/':\n          return (isTerm(args[0]) ? this.toEntity(args[0]) : '(' + this.toExpression(args[0]) + ')') +\n                 ' ' + operator + ' ' +\n                 (isTerm(args[1]) ? this.toEntity(args[1]) : '(' + this.toExpression(args[1]) + ')');\n      // Unary operators\n      case '!':\n        return '!(' + this.toExpression(args[0]) + ')';\n      case 'uminus':\n        return '-(' + this.toExpression(args[0]) + ')';\n      // IN and NOT IN\n      case 'notin':\n        operator = 'NOT IN';\n      case 'in':\n        return this.toExpression(args[0]) + ' ' + operator +\n               '(' + (isString(args[1]) ? args[1] : mapJoin(args[1], ', ', this.toExpression, this)) + ')';\n      // EXISTS and NOT EXISTS\n      case 'notexists':\n        operator = 'NOT EXISTS';\n      case 'exists':\n        return operator + ' ' + this.group(args[0], true);\n      // Other expressions\n      default:\n        return operator + '(' + mapJoin(args, ', ', this.toExpression, this) + ')';\n      }\n    default:\n      throw new Error('Unknown expression type: ' + expr.type);\n  }\n};\n\n// Converts the parsed entity (or property path) into a SPARQL entity\nGenerator.prototype.toEntity = function (value) {\n  if (isTerm(value)) {\n    switch (value.termType) {\n    // variable, * selector, or blank node\n    case 'Wildcard':\n      return '*';\n    case 'Variable':\n      return variableToString(value);\n    case 'BlankNode':\n      return '_:' + value.value;\n    // literal\n    case 'Literal':\n      var lexical = value.value || '', language = value.language || '', datatype = value.datatype;\n      value = '\"' + lexical.replace(escape, escapeReplacer) + '\"';\n      if (language){\n        value += '@' + language;\n      } else if (datatype) {\n        // Abbreviate literals when possible\n        if (!this._explicitDatatype) {\n          switch (datatype.value) {\n          case XSD_STRING:\n            return value;\n          case XSD_INTEGER:\n            if (/^\\d+$/.test(lexical))\n              // Add space to avoid confusion with decimals in broken parsers\n              return lexical + ' ';\n          }\n        }\n        value += '^^' + this.encodeIRI(datatype.value);\n      }\n      return value;\n    case 'Quad':\n      if (!this._sparqlStar)\n          throw new Error('SPARQL* support is not enabled');\n\n      if (value.graph && value.graph.termType !== \"DefaultGraph\") {\n        return '<< GRAPH ' +\n          this.toEntity(value.graph) +\n          ' { ' +\n          this.toEntity(value.subject) + ' ' +\n          this.toEntity(value.predicate) + ' ' +\n          this.toEntity(value.object) +\n          ' } ' +\n          ' >>'\n      }\n      else {\n        return (\n          '<< ' +\n          this.toEntity(value.subject) + ' ' +\n          this.toEntity(value.predicate) + ' ' +\n          this.toEntity(value.object) +\n          ' >>'\n        );\n      }\n    // IRI\n    default:\n      return this.encodeIRI(value.value);\n    }\n  }\n  // property path\n  else {\n    var items = value.items.map(this.toEntity, this), path = value.pathType;\n    switch (path) {\n    // prefix operator\n    case '^':\n    case '!':\n      return path + items[0];\n    // postfix operator\n    case '*':\n    case '+':\n    case '?':\n      return '(' + items[0] + path + ')';\n    // infix operator\n    default:\n      return '(' + items.join(path) + ')';\n    }\n  }\n};\nvar escape = /[\"\\\\\\t\\n\\r\\b\\f]/g,\n    escapeReplacer = function (c) { return escapeReplacements[c]; },\n    escapeReplacements = { '\\\\': '\\\\\\\\', '\"': '\\\\\"', '\\t': '\\\\t',\n                           '\\n': '\\\\n', '\\r': '\\\\r', '\\b': '\\\\b', '\\f': '\\\\f' };\n\n// Represent the IRI, as a prefixed name when possible\nGenerator.prototype.encodeIRI = function (iri) {\n  var prefixMatch = this._prefixRegex.exec(iri);\n  if (prefixMatch) {\n    var prefix = this._prefixByIri[prefixMatch[1]];\n    this._usedPrefixes[prefix] = true;\n    return prefix + ':' + prefixMatch[2];\n  }\n  return '<' + iri + '>';\n};\n\n// Converts the parsed update object into a SPARQL update clause\nGenerator.prototype.toUpdate = function (update) {\n  switch (update.type || update.updateType) {\n  case 'load':\n    return 'LOAD' + (update.source ? ' ' + this.toEntity(update.source) : '') +\n           (update.destination ? ' INTO GRAPH ' + this.toEntity(update.destination) : '');\n  case 'insert':\n    return 'INSERT DATA '  + this.group(update.insert, true);\n  case 'delete':\n    return 'DELETE DATA '  + this.group(update.delete, true);\n  case 'deletewhere':\n    return 'DELETE WHERE ' + this.group(update.delete, true);\n  case 'insertdelete':\n    return (update.graph ? 'WITH ' + this.toEntity(update.graph) + this._newline : '') +\n           (update.delete.length ? 'DELETE ' + this.group(update.delete, true) + this._newline : '') +\n           (update.insert.length ? 'INSERT ' + this.group(update.insert, true) + this._newline : '') +\n           (update.using ? this.graphs('USING ', update.using.default) : '') +\n           (update.using ? this.graphs('USING NAMED ', update.using.named) : '') +\n           'WHERE ' + this.group(update.where, true);\n  case 'add':\n  case 'copy':\n  case 'move':\n    return update.type.toUpperCase() + (update.source.default ? ' DEFAULT ' : ' ') +\n           'TO ' + this.toEntity(update.destination.name);\n  case 'create':\n  case 'clear':\n  case 'drop':\n    return update.type.toUpperCase() + (update.silent ? ' SILENT ' : ' ') + (\n      update.graph.default ? 'DEFAULT' :\n      update.graph.named ? 'NAMED' :\n      update.graph.all ? 'ALL' :\n      ('GRAPH ' + this.toEntity(update.graph.name))\n    );\n  default:\n    throw new Error('Unknown update query type: ' + update.type);\n  }\n};\n\n// Indents each line of the string\nGenerator.prototype.indent = function(text) { return text.replace(/^/gm, this._indent); }\n\nfunction variableToString(variable){\n  return '?' + variable.value;\n}\n\n// Checks whether the object is a string\nfunction isString(object) { return typeof object === 'string'; }\n\n// Checks whether the object is a Term\nfunction isTerm(object) {\n  return typeof object.termType === 'string';\n}\n\n// Checks whether term1 and term2 are equivalent without `.equals()` prototype method\nfunction equalTerms(term1, term2) {\n  if (!term1 || !isTerm(term1)) { return false; }\n  if (!term2 || !isTerm(term2)) { return false; }\n  if (term1.termType !== term2.termType) { return false; }\n  switch (term1.termType) {\n    case 'Literal':\n      return term1.value === term2.value\n          && term1.language === term2.language\n          && equalTerms(term1.datatype, term2.datatype);\n    case 'Quad':\n      return equalTerms(term1.subject, term2.subject)\n          && equalTerms(term1.predicate, term2.predicate)\n          && equalTerms(term1.object, term2.object)\n          && equalTerms(term1.graph, term2.graph);\n    default:\n      return term1.value === term2.value;\n  }\n}\n\n// Maps the array with the given function, and joins the results using the separator\nfunction mapJoin(array, sep, func, self) {\n  return array.map(func, self).join(isString(sep) ? sep : ' ');\n}\n\n/**\n * @param options {\n *   allPrefixes: boolean,\n *   indentation: string,\n *   newline: string\n * }\n */\nmodule.exports = function SparqlGenerator(options = {}) {\n  return {\n    stringify: function (query) {\n      var currentOptions = Object.create(options);\n      currentOptions.prefixes = query.prefixes;\n      return new Generator(currentOptions).toQuery(query);\n    },\n    createGenerator: function() { return new Generator(options); }\n  };\n};\n"]},"metadata":{},"sourceType":"script"}