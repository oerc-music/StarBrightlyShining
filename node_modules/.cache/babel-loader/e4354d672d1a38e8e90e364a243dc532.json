{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SparqlJsonParser = void 0;\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst SparqlJsonBindingsTransformer_1 = require(\"./SparqlJsonBindingsTransformer\");\n/**\n * Parser for the SPARQL 1.1 Query Results JSON format.\n * @see https://www.w3.org/TR/sparql11-results-json/\n */\n\n\nclass SparqlJsonParser {\n  constructor(settings) {\n    settings = settings || {};\n    this.dataFactory = settings.dataFactory || new rdf_data_factory_1.DataFactory();\n    this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;\n  }\n  /**\n   * Convert a SPARQL JSON bindings response to an array of bindings objects.\n   * @param sparqlResponse A SPARQL JSON response.\n   * @return {IBindings[]} An array of bindings.\n   */\n\n\n  parseJsonResults(sparqlResponse) {\n    return sparqlResponse.results.bindings.map(rawBindings => this.parseJsonBindings(rawBindings));\n  }\n  /**\n   * Convert a SPARQL JSON bindings response stream to a stream of bindings objects.\n   *\n   * The bindings stream will emit a 'variables' event that will contain\n   * the array of variables (as RDF.Variable[]), as defined in the response head.\n   *\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.\n   * @return {NodeJS.ReadableStream} A stream of bindings.\n   */\n\n\n  parseJsonResultsStream(sparqlResponseStream) {\n    sparqlResponseStream.on('error', error => resultStream.emit('error', error));\n    const variables = [];\n    sparqlResponseStream.pipe(require('JSONStream').parse('head.vars.*')).on('data', variable => variables.push(this.dataFactory.variable(variable))).on('end', () => resultStream.emit('variables', variables));\n    const resultStream = sparqlResponseStream.pipe(require('JSONStream').parse('results.bindings.*')).pipe(new SparqlJsonBindingsTransformer_1.SparqlJsonBindingsTransformer(this));\n    return resultStream;\n  }\n  /**\n   * Convert a SPARQL JSON result binding to a bindings object.\n   * @param rawBindings A SPARQL JSON result binding.\n   * @return {IBindings} A bindings object.\n   */\n\n\n  parseJsonBindings(rawBindings) {\n    const bindings = {};\n\n    for (const key in rawBindings) {\n      const rawValue = rawBindings[key];\n      let value = null;\n\n      switch (rawValue.type) {\n        case 'bnode':\n          value = this.dataFactory.blankNode(rawValue.value);\n          break;\n\n        case 'literal':\n          if (rawValue['xml:lang']) {\n            value = this.dataFactory.literal(rawValue.value, rawValue['xml:lang']);\n          } else if (rawValue.datatype) {\n            value = this.dataFactory.literal(rawValue.value, this.dataFactory.namedNode(rawValue.datatype));\n          } else {\n            value = this.dataFactory.literal(rawValue.value);\n          }\n\n          break;\n\n        case 'typed-literal':\n          // Virtuoso uses this non-spec-compliant way of defining typed literals\n          value = this.dataFactory.literal(rawValue.value, this.dataFactory.namedNode(rawValue.datatype));\n          break;\n\n        default:\n          value = this.dataFactory.namedNode(rawValue.value);\n          break;\n      }\n\n      bindings[this.prefixVariableQuestionMark ? '?' + key : key] = value;\n    }\n\n    return bindings;\n  }\n  /**\n   * Convert a SPARQL JSON boolean response to a boolean.\n   * This will throw an error if the given reponse was not a valid boolean response.\n   * @param sparqlResponse A SPARQL JSON response.\n   * @return {IBindings[]} An array of bindings.\n   */\n\n\n  parseJsonBoolean(sparqlResponse) {\n    if ('boolean' in sparqlResponse) {\n      return sparqlResponse.boolean;\n    }\n\n    throw new Error('No valid ASK response was found.');\n  }\n  /**\n   * Convert a SPARQL JSON boolean response stream to a promise resolving to a boolean.\n   * This will reject if the given reponse was not a valid boolean response.\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.\n   * @return {NodeJS.ReadableStream} A stream of bindings.\n   */\n\n\n  parseJsonBooleanStream(sparqlResponseStream) {\n    return new Promise((resolve, reject) => {\n      sparqlResponseStream.on('error', reject);\n      sparqlResponseStream.pipe(require('JSONStream').parse('boolean')).on('data', resolve).on('end', () => reject(new Error('No valid ASK response was found.')));\n    });\n  }\n\n}\n\nexports.SparqlJsonParser = SparqlJsonParser;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/sparqljson-parse/lib/SparqlJsonParser.js"],"names":["Object","defineProperty","exports","value","SparqlJsonParser","rdf_data_factory_1","require","SparqlJsonBindingsTransformer_1","constructor","settings","dataFactory","DataFactory","prefixVariableQuestionMark","parseJsonResults","sparqlResponse","results","bindings","map","rawBindings","parseJsonBindings","parseJsonResultsStream","sparqlResponseStream","on","error","resultStream","emit","variables","pipe","parse","variable","push","SparqlJsonBindingsTransformer","key","rawValue","type","blankNode","literal","datatype","namedNode","parseJsonBoolean","boolean","Error","parseJsonBooleanStream","Promise","resolve","reject"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SparqlJsonParser = void 0;\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst SparqlJsonBindingsTransformer_1 = require(\"./SparqlJsonBindingsTransformer\");\n/**\n * Parser for the SPARQL 1.1 Query Results JSON format.\n * @see https://www.w3.org/TR/sparql11-results-json/\n */\nclass SparqlJsonParser {\n    constructor(settings) {\n        settings = settings || {};\n        this.dataFactory = settings.dataFactory || new rdf_data_factory_1.DataFactory();\n        this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;\n    }\n    /**\n     * Convert a SPARQL JSON bindings response to an array of bindings objects.\n     * @param sparqlResponse A SPARQL JSON response.\n     * @return {IBindings[]} An array of bindings.\n     */\n    parseJsonResults(sparqlResponse) {\n        return sparqlResponse.results.bindings.map((rawBindings) => this.parseJsonBindings(rawBindings));\n    }\n    /**\n     * Convert a SPARQL JSON bindings response stream to a stream of bindings objects.\n     *\n     * The bindings stream will emit a 'variables' event that will contain\n     * the array of variables (as RDF.Variable[]), as defined in the response head.\n     *\n     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.\n     * @return {NodeJS.ReadableStream} A stream of bindings.\n     */\n    parseJsonResultsStream(sparqlResponseStream) {\n        sparqlResponseStream.on('error', (error) => resultStream.emit('error', error));\n        const variables = [];\n        sparqlResponseStream\n            .pipe(require('JSONStream').parse('head.vars.*'))\n            .on('data', (variable) => variables.push(this.dataFactory.variable(variable)))\n            .on('end', () => resultStream.emit('variables', variables));\n        const resultStream = sparqlResponseStream\n            .pipe(require('JSONStream').parse('results.bindings.*'))\n            .pipe(new SparqlJsonBindingsTransformer_1.SparqlJsonBindingsTransformer(this));\n        return resultStream;\n    }\n    /**\n     * Convert a SPARQL JSON result binding to a bindings object.\n     * @param rawBindings A SPARQL JSON result binding.\n     * @return {IBindings} A bindings object.\n     */\n    parseJsonBindings(rawBindings) {\n        const bindings = {};\n        for (const key in rawBindings) {\n            const rawValue = rawBindings[key];\n            let value = null;\n            switch (rawValue.type) {\n                case 'bnode':\n                    value = this.dataFactory.blankNode(rawValue.value);\n                    break;\n                case 'literal':\n                    if (rawValue['xml:lang']) {\n                        value = this.dataFactory.literal(rawValue.value, rawValue['xml:lang']);\n                    }\n                    else if (rawValue.datatype) {\n                        value = this.dataFactory.literal(rawValue.value, this.dataFactory.namedNode(rawValue.datatype));\n                    }\n                    else {\n                        value = this.dataFactory.literal(rawValue.value);\n                    }\n                    break;\n                case 'typed-literal':\n                    // Virtuoso uses this non-spec-compliant way of defining typed literals\n                    value = this.dataFactory.literal(rawValue.value, this.dataFactory.namedNode(rawValue.datatype));\n                    break;\n                default:\n                    value = this.dataFactory.namedNode(rawValue.value);\n                    break;\n            }\n            bindings[this.prefixVariableQuestionMark ? ('?' + key) : key] = value;\n        }\n        return bindings;\n    }\n    /**\n     * Convert a SPARQL JSON boolean response to a boolean.\n     * This will throw an error if the given reponse was not a valid boolean response.\n     * @param sparqlResponse A SPARQL JSON response.\n     * @return {IBindings[]} An array of bindings.\n     */\n    parseJsonBoolean(sparqlResponse) {\n        if ('boolean' in sparqlResponse) {\n            return sparqlResponse.boolean;\n        }\n        throw new Error('No valid ASK response was found.');\n    }\n    /**\n     * Convert a SPARQL JSON boolean response stream to a promise resolving to a boolean.\n     * This will reject if the given reponse was not a valid boolean response.\n     * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.\n     * @return {NodeJS.ReadableStream} A stream of bindings.\n     */\n    parseJsonBooleanStream(sparqlResponseStream) {\n        return new Promise((resolve, reject) => {\n            sparqlResponseStream.on('error', reject);\n            sparqlResponseStream.pipe(require('JSONStream').parse('boolean'))\n                .on('data', resolve)\n                .on('end', () => reject(new Error('No valid ASK response was found.')));\n        });\n    }\n}\nexports.SparqlJsonParser = SparqlJsonParser;\n//# sourceMappingURL=SparqlJsonParser.js.map"]},"metadata":{},"sourceType":"script"}