{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncIterator from \"@babel/runtime/helpers/asyncIterator\";\nimport { createTaskQueue } from './util';\nimport data from '@solid/query-ldflex';\nconst evaluatorQueue = createTaskQueue();\n/**\n * Evaluates a map of LDflex expressions into a singular value or a list.\n * Expressions can be changed and/or re-evaluated.\n */\n\nexport default class ExpressionEvaluator {\n  constructor() {\n    _defineProperty(this, \"pending\", {});\n\n    _defineProperty(this, \"cancel\", false);\n  }\n  /** Stops all pending and future evaluations */\n\n\n  destroy() {\n    this.pending = {};\n    this.cancel = true;\n    evaluatorQueue.clear(this);\n  }\n  /** Evaluates the given singular value and list expressions. */\n\n\n  async evaluate(values, lists, updateCallback) {\n    // Reset the pending status and clear any errors\n    updateCallback({\n      pending: true,\n      error: undefined\n    }); // Create evaluators for each expression, and mark them as pending\n\n    const evaluators = evaluatorQueue.schedule([...Object.entries(values).map(([key, expr]) => () => this.evaluateAsValue(key, expr, updateCallback)), ...Object.entries(lists).map(([key, expr]) => () => this.evaluateAsList(key, expr, updateCallback))], this); // Wait until all evaluators are done (or one of them errors)\n\n    try {\n      await Promise.all(evaluators);\n    } catch (error) {\n      updateCallback({\n        error\n      });\n    } // Update the pending flag if all evaluators wrote their value or errored,\n    // and if no new evaluators are pending\n\n\n    const statuses = await Promise.all(evaluators.map(e => e.catch(error => {\n      console.warn('@solid/react-components', 'Expression evaluation failed.', error);\n      return true;\n    }))); // Stop if results are no longer needed\n\n    if (this.cancel) return; // Reset the pending flag if all are done and no others are pending\n\n    if (!statuses.some(done => !done) && Object.keys(this.pending).length === 0) updateCallback({\n      pending: false\n    });\n  }\n  /** Evaluates the property expression as a singular value. */\n\n\n  async evaluateAsValue(key, expr, updateCallback) {\n    // Obtain and await the promise\n    const promise = this.pending[key] = this.resolveExpression(expr);\n    let value;\n\n    try {\n      value = await promise; // Stop if another evaluator took over in the meantime (component update)\n\n      if (this.pending[key] !== promise) return false;\n    } // Update the result and remove the evaluator, even in case of errors\n    finally {\n      if (this.pending[key] === promise) {\n        delete this.pending[key];\n        updateCallback({\n          [key]: value\n        });\n      }\n    }\n\n    return true;\n  }\n  /** Evaluates the property expression as a list. */\n\n\n  async evaluateAsList(key, expr, updateCallback) {\n    // Read the iterable's items, throttling updates to avoid congestion\n    let empty = true;\n    const items = [];\n    const iterable = this.pending[key] = this.resolveExpression(expr);\n\n    const update = () => !this.cancel && updateCallback({\n      [key]: [...items]\n    });\n\n    const updateQueue = createTaskQueue({\n      timeBetween: 100,\n      drop: true\n    });\n\n    try {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(iterable), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const item = _value; // Stop if another evaluator took over in the meantime (component update)\n\n          if (this.pending[key] !== iterable) {\n            updateQueue.clear();\n            return false;\n          } // Add the item and schedule an update\n\n\n          empty = false;\n          items.push(item);\n          updateQueue.schedule(update);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            await _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } // Ensure pending updates are applied immediately, and the evaluator is removed\n    finally {\n      const needsUpdate = empty || updateQueue.clear();\n\n      if (this.pending[key] === iterable) {\n        delete this.pending[key];\n        if (needsUpdate) update();\n      }\n    }\n\n    return true;\n  }\n  /** Resolves the expression into an LDflex path. */\n\n\n  resolveExpression(expr) {\n    // Ignore an empty expression\n    if (!expr) return ''; // Resolve an LDflex string expression\n    else if (typeof expr === 'string') return data.resolve(expr); // Return a resolved LDflex path (and any other object) as-is\n    else return expr;\n  }\n\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@solid/react/module/ExpressionEvaluator.js"],"names":["_defineProperty","_asyncIterator","createTaskQueue","data","evaluatorQueue","ExpressionEvaluator","constructor","destroy","pending","cancel","clear","evaluate","values","lists","updateCallback","error","undefined","evaluators","schedule","Object","entries","map","key","expr","evaluateAsValue","evaluateAsList","Promise","all","statuses","e","catch","console","warn","some","done","keys","length","promise","resolveExpression","value","empty","items","iterable","update","updateQueue","timeBetween","drop","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","_value","next","item","push","err","return","needsUpdate","resolve"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncIterator from \"@babel/runtime/helpers/asyncIterator\";\nimport { createTaskQueue } from './util';\nimport data from '@solid/query-ldflex';\nconst evaluatorQueue = createTaskQueue();\n/**\n * Evaluates a map of LDflex expressions into a singular value or a list.\n * Expressions can be changed and/or re-evaluated.\n */\n\nexport default class ExpressionEvaluator {\n  constructor() {\n    _defineProperty(this, \"pending\", {});\n\n    _defineProperty(this, \"cancel\", false);\n  }\n\n  /** Stops all pending and future evaluations */\n  destroy() {\n    this.pending = {};\n    this.cancel = true;\n    evaluatorQueue.clear(this);\n  }\n  /** Evaluates the given singular value and list expressions. */\n\n\n  async evaluate(values, lists, updateCallback) {\n    // Reset the pending status and clear any errors\n    updateCallback({\n      pending: true,\n      error: undefined\n    }); // Create evaluators for each expression, and mark them as pending\n\n    const evaluators = evaluatorQueue.schedule([...Object.entries(values).map(([key, expr]) => () => this.evaluateAsValue(key, expr, updateCallback)), ...Object.entries(lists).map(([key, expr]) => () => this.evaluateAsList(key, expr, updateCallback))], this); // Wait until all evaluators are done (or one of them errors)\n\n    try {\n      await Promise.all(evaluators);\n    } catch (error) {\n      updateCallback({\n        error\n      });\n    } // Update the pending flag if all evaluators wrote their value or errored,\n    // and if no new evaluators are pending\n\n\n    const statuses = await Promise.all(evaluators.map(e => e.catch(error => {\n      console.warn('@solid/react-components', 'Expression evaluation failed.', error);\n      return true;\n    }))); // Stop if results are no longer needed\n\n    if (this.cancel) return; // Reset the pending flag if all are done and no others are pending\n\n    if (!statuses.some(done => !done) && Object.keys(this.pending).length === 0) updateCallback({\n      pending: false\n    });\n  }\n  /** Evaluates the property expression as a singular value. */\n\n\n  async evaluateAsValue(key, expr, updateCallback) {\n    // Obtain and await the promise\n    const promise = this.pending[key] = this.resolveExpression(expr);\n    let value;\n\n    try {\n      value = await promise; // Stop if another evaluator took over in the meantime (component update)\n\n      if (this.pending[key] !== promise) return false;\n    } // Update the result and remove the evaluator, even in case of errors\n    finally {\n      if (this.pending[key] === promise) {\n        delete this.pending[key];\n        updateCallback({\n          [key]: value\n        });\n      }\n    }\n\n    return true;\n  }\n  /** Evaluates the property expression as a list. */\n\n\n  async evaluateAsList(key, expr, updateCallback) {\n    // Read the iterable's items, throttling updates to avoid congestion\n    let empty = true;\n    const items = [];\n    const iterable = this.pending[key] = this.resolveExpression(expr);\n\n    const update = () => !this.cancel && updateCallback({\n      [key]: [...items]\n    });\n\n    const updateQueue = createTaskQueue({\n      timeBetween: 100,\n      drop: true\n    });\n\n    try {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(iterable), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const item = _value;\n\n          // Stop if another evaluator took over in the meantime (component update)\n          if (this.pending[key] !== iterable) {\n            updateQueue.clear();\n            return false;\n          } // Add the item and schedule an update\n\n\n          empty = false;\n          items.push(item);\n          updateQueue.schedule(update);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            await _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } // Ensure pending updates are applied immediately, and the evaluator is removed\n    finally {\n      const needsUpdate = empty || updateQueue.clear();\n\n      if (this.pending[key] === iterable) {\n        delete this.pending[key];\n        if (needsUpdate) update();\n      }\n    }\n\n    return true;\n  }\n  /** Resolves the expression into an LDflex path. */\n\n\n  resolveExpression(expr) {\n    // Ignore an empty expression\n    if (!expr) return ''; // Resolve an LDflex string expression\n    else if (typeof expr === 'string') return data.resolve(expr); // Return a resolved LDflex path (and any other object) as-is\n      else return expr;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}