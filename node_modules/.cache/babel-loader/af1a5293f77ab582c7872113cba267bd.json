{"ast":null,"code":"import update from 'immutability-helper';\nimport { FETCH_COMPONENT_TARGET, FETCH_CONCEPTUAL_SCORE, FETCH_MANIFESTATIONS, FETCH_RIBBON_CONTENT, FETCH_SCORE, REGISTER_PUBLISHED_PERFORMANCE_SCORE, SCORE_NEXT_PAGE, SCORE_PAGE_TO_TARGET, SCORE_PREV_PAGE, TRANSITION_TO_NEXT_SESSION, UPDATE_LATEST_RENDERED_PAGENUM, SCORE_SET_OPTIONS } from '../actions/index';\nconst EMBODIMENT = 'frbr:embodiment';\nconst MEITYPE = 'meld:MEIEmbodiment';\nconst AUDIOTYPE = 'meld:AudioEmbodiment';\nconst TEITYPE = 'meld:TEIEmbodiment';\nconst MEMBER = 'rdfs:member';\nlet conceptualScore;\n\nfunction retrieveOrGenerateSVG(data, state, url, pageNum, options) {\n  // We can use the previously cached SVG if:\n  // 1. We already have SVG rendered for this URI\n  // 2. We already have SVG rendered for this page number\n  // 3. We rendered it with these options\n  if (url in state.pageState && url in state.SVG && pageNum in state.SVG[url] && JSON.stringify(state.SVG[url][pageNum].options) === JSON.stringify(options)) {\n    // we can reuse the cached SVG!\n    console.log(`Score reducer: Reusing SVG for ${url} page ${pageNum}`);\n    return state.SVG[url][pageNum].data;\n  } else {\n    // we need to generate SVG!\n    // is the MEI file currently loaded into Verovio?\n    if (url !== state.currentlyLoadedIntoVrv) {\n      // no -- so set our options, and then load it\n      state.vrvTk.setOptions(options);\n      state.vrvTk.loadData(data);\n    } // have we loaded this page before?\n\n\n    if (url in state.SVG && pageNum in state.SVG[url]) {\n      // yes. Options must have changed, or we would have returned above.\n      // So, redo layout to take account of new options\n      state.vrvTk.setOptions(options);\n      state.vrvTk.redoLayout();\n    } // now render the page and return the SVG\n\n\n    return state.vrvTk.renderToSVG(pageNum, options);\n  }\n}\n\nfunction retrieveOptions(options, url, currentPage, state) {\n  let opts;\n\n  if (typeof options === \"object\") {\n    // use options object if supplied with action\n    opts = options;\n  } else if (url in state.SVG && currentPage in state.SVG[url]) {\n    // otherwise if we've previously rendered this page, use those options\n    opts = state.SVG[url][currentPage].options;\n  } else {\n    opts = state.options; // or as fallback, use defaults\n  }\n\n  return opts;\n}\n\nexport function ScoreReducer(state = {\n  currentlyLoadedIntoVrv: null,\n  publishedScores: {},\n  conceptualScores: {},\n  MEI: {},\n  SVG: {},\n  pageState: {},\n  componentTargets: {},\n  scoreMapping: {},\n  pageNum: 1,\n  latestRenderedPageNum: 0,\n  pageCount: 0,\n  triggerNextSession: \"\",\n  triggerPrevSession: \"\",\n  vrvTk: new verovio.toolkit(),\n  options: {\n    // default, unless overridden in FETCH_SCORE or SCORE_SET_OPTIONS\n    ignoreLayout: 1,\n    adjustPageHeight: 1,\n    scale: 35,\n    pageHeight: 1000 * 100 / 35,\n    pageWidth: 700 * 100 / 35\n  }\n}, action) {\n  let svg;\n  let url;\n  let currentPage;\n  let options;\n  const pageCount = state.vrvTk.getPageCount();\n\n  switch (action.type) {\n    case FETCH_SCORE:\n      url = action.payload.config.url;\n      currentPage = url in state.pageState ? state.pageState[url].currentPage : 1; // set options:\n\n      options = retrieveOptions(action.payload.config.options, url, currentPage, state); // We can use a previously cached SVG if:\n      // 1. We already have SVG rendered for this URI\n      // 2. We already have SVG rendered for this page number\n      // 3. We already have SVG rendered for these options\n\n      svg = retrieveOrGenerateSVG(action.payload.data, state, url, currentPage, options);\n      return update(state, {\n        currentlyLoadedIntoVrv: {\n          $set: url\n        },\n        SVG: {\n          [url]: {\n            $set: {\n              [currentPage]: {\n                data: svg,\n                options: options\n              }\n            }\n          }\n        },\n        MEI: {\n          $merge: {\n            [url]: action.payload.data\n          }\n        },\n        pageState: {\n          [url]: {\n            $set: {\n              currentPage: currentPage,\n              pageCount: state.vrvTk.getPageCount(),\n              currentOptions: options\n            }\n          }\n        }\n      });\n\n    case FETCH_RIBBON_CONTENT:\n      /*\t\tvar orch =  new Orchestration(action.payload.data);\n          var svgRibbon = orch.drawOrchestration(false, 0, 400, 0, 600);\n          return update(state, {MEI: { $merge: {[action.payload.config.url]: svgRibbon.outerHTML}}});*/\n      var data = action.payload.data;\n      if (!state.MEIfile) state.MEIfile = {};\n      return update(state, {\n        MEIfile: {\n          $merge: {\n            [action.payload.config.url]: action.payload.data\n          }\n        }\n      });\n\n    case FETCH_MANIFESTATIONS:\n      // console.log(\"IN FETCH_MANIFESTATIONS, payload is: \", action.payload)\n      const target = action.payload.target;\n      const part = action.payload.part;\n\n      if (typeof part === \"undefined\") {\n        // part wasn't on segment line\n        return state;\n      }\n\n      let fragments = {}; // go through each part, finding embodibags\n\n      if (EMBODIMENT in part) {\n        if (!Array.isArray(part[EMBODIMENT])) {\n          part[EMBODIMENT] = [part[EMBODIMENT]];\n        }\n\n        part[EMBODIMENT].map(embodiment => {\n          // go through each embodiment\n          if (MEMBER in embodiment) {\n            let fragtype; // extract set of fragments\n            // we want to separate out different types of media fragments\n\n            if (!Array.isArray(embodiment[\"@type\"])) {\n              embodiment[\"@type\"] = [embodiment[\"@type\"]];\n            }\n\n            if (!Array.isArray(target[\"@type\"])) {\n              target[\"@type\"] = [target[\"@type\"]];\n            }\n\n            if (embodiment[\"@type\"].includes(MEITYPE)) {\n              fragtype = \"MEI\";\n            } else if (embodiment[\"@type\"].includes(AUDIOTYPE)) {\n              fragtype = \"Audio\";\n            } else if (embodiment[\"@type\"].includes(TEITYPE)) {\n              fragtype = \"TEI\";\n            } else {\n              console.log(\"Score Reducer: Embodiment with unknown type\", embodiment);\n            }\n\n            if (!Array.isArray(embodiment[MEMBER])) {\n              embodiment[MEMBER] = [embodiment[MEMBER]];\n            }\n\n            fragments[fragtype] = fragments[fragtype] || [];\n            fragments[fragtype] = fragments[fragtype].concat(embodiment[MEMBER].map(member => {\n              return member[\"@id\"];\n            }));\n            fragments[\"description\"] = target[\"rdfs:label\"];\n\n            if (target[\"@type\"].includes(\"meld:Muzicode\")) {\n              fragments[\"muzicodeType\"] = target[\"mc:type\"];\n              fragments[\"cue\"] = target[\"climb:cue\"];\n            }\n          } else {\n            console.log(\"Embodiment without members: \", part, embodiment);\n          }\n        }); // console.log(\"Updating state: \");\n        // console.log( update(state, {componentTargets: { $merge: { [target[\"@id\"]]: fragments } } }));\n\n        return update(state, {\n          componentTargets: {\n            $merge: {\n              [target[\"@id\"]]: fragments\n            }\n          }\n        });\n      }\n\n      console.log(\"FETCH_MANIFESTATIONS: Unembodied target! \", target);\n      return state;\n\n    case FETCH_CONCEPTUAL_SCORE:\n      const cS = action.payload; //return update(state, {publishedScores: { $push: [conceptualScore[PUBLISHED_AS][\"@id\"]] } });\n\n      return update(state, {\n        publishedScores: {\n          $set: {\n            [cS[\"mo:published_as\"][\"@id\"]]: cS[\"@id\"]\n          }\n        }\n      });\n\n    case FETCH_COMPONENT_TARGET:\n      // ensure that our structure target collection is an array, then push this one in\n      conceptualScore = action.payload.conceptualScore; // make sure we have an entry for this conceptual score, and that its value is an array\n\n      let newState = update(state, {\n        conceptualScores: {\n          $merge: {\n            [action.payload.conceptualScore]: state['conceptualScores'][action.payload.conceptualScore] || []\n          }\n        }\n      }); // if this is a new structure target, push it in\n\n      if (!newState['conceptualScores'][action.payload.conceptualScore].includes(action.payload.structureTarget)) {\n        newState = update(newState, {\n          conceptualScores: {\n            [action.payload.conceptualScore]: {\n              $push: [action.payload.structureTarget]\n            }\n          }\n        });\n      }\n\n      return newState;\n\n    case SCORE_NEXT_PAGE:\n      url = action.payload.uri;\n\n      if (!action.payload.data) {\n        console.log(\"SCORE_NEXT_PAGE attempted on non-loaded MEI data - ignoring!\");\n        return state;\n      }\n\n      if (action.payload.pageNum !== state.pageState[url].currentPage) {\n        console.warn(`Mismatch in page numbers: received ${action.payload.pageNum} expected ${state.pageState[url].currentPage}`);\n      }\n\n      if (action.payload.pageNum === pageCount) {\n        // we've left the last page, set up a transfer to the next session\n        // console.log(\"TRIGGERING\")\n        console.info(\"Attempted SCORE_NEXT_PAGE while on last page of score\");\n        return update(state, {\n          triggerNextSession: {\n            $set: true\n          }\n        });\n      } else {\n        options = retrieveOptions(state.pageState[url].currentOptions, url, state.pageState.currentPage, state);\n        svg = retrieveOrGenerateSVG(state.MEI[url], state, url, action.payload.pageNum + 1, options);\n        return update(state, {\n          SVG: {\n            [url]: {\n              $merge: {\n                [action.payload.pageNum + 1]: {\n                  data: svg,\n                  options: options\n                }\n              }\n            }\n          },\n          pageState: {\n            [url]: {\n              $set: {\n                currentPage: action.payload.pageNum + 1,\n                pageCount: state.vrvTk.getPageCount(),\n                currentOptions: options\n              }\n            }\n          }\n        });\n      }\n\n    case SCORE_PREV_PAGE:\n      url = action.payload.uri;\n\n      if (!action.payload.data) {\n        console.log(\"SCORE_PREV_PAGE attempted on non-loaded MEI data - ignoring!\");\n        return state;\n      }\n\n      if (action.payload.pageNum !== state.pageState[url].currentPage) {\n        console.warn(`Mismatch in page numbers: received ${action.payload.pageNum} expected ${state.pageState[url].currentPage}`);\n      }\n\n      if (action.payload.pageNum === 1) {\n        // we're on the first page, go back to previous session\n        // console.log(\"TRIGGERING\")\n        console.info(\"Attempted SCORE_PREV_PAGE while on first page of score\");\n        return update(state, {\n          triggerPrevSession: {\n            $set: true\n          }\n        });\n      } else {\n        options = retrieveOptions(state.pageState[url].currentOptions, url, state.pageState.currentPage, state);\n        svg = retrieveOrGenerateSVG(state.MEI[url], state, url, action.payload.pageNum - 1, options);\n        return update(state, {\n          SVG: {\n            [url]: {\n              $merge: {\n                [action.payload.pageNum - 1]: {\n                  data: svg,\n                  options: options\n                }\n              }\n            }\n          },\n          pageState: {\n            [url]: {\n              $set: {\n                currentPage: action.payload.pageNum - 1,\n                pageCount: state.vrvTk.getPageCount(),\n                currentOptions: options\n              }\n            }\n          }\n        });\n      }\n\n    case SCORE_SET_OPTIONS:\n      url = action.payload.uri;\n      currentPage = url in state.pageState && \"currentPage\" in state.pageState[url] ? state.pageState[url].currentPage : 1;\n      svg = retrieveOrGenerateSVG(state.MEI[url], state, url, currentPage, action.payload.options);\n      return update(state, {\n        options: {\n          $set: action.payload.options\n        },\n        currentlyLoadedIntoVrv: {\n          $set: url\n        },\n        SVG: {\n          [url]: {\n            $set: {\n              [currentPage]: {\n                data: svg,\n                options: action.payload.options\n              }\n            }\n          }\n        },\n        pageState: {\n          [url]: {\n            $set: {\n              currentPage: currentPage,\n              pageCount: state.vrvTk.getPageCount(),\n              currentOptions: options\n            }\n          }\n        }\n      });\n\n    case TRANSITION_TO_NEXT_SESSION:\n      // console.log(\"forcing transition to next session if queued\");\n      return update(state, {\n        triggerNextSession: {\n          $set: true\n        }\n      });\n\n    case SCORE_PAGE_TO_TARGET:\n      if (!action.payload.data) {\n        console.log(\"SCORE_PAGE_TO_TARGET attempted on non-loaded MEI data - ignoring!\");\n        return state;\n      }\n\n      const frag = action.payload.target.split(\"#\")[1];\n      const pageNum = state.vrvTk.getPageWithElement(frag);\n\n      if (pageNum === 0) {\n        console.log(\"SCORE_PAGE_TO_TARGET attempted on a target that doesn't exist in the MEI - ignoring!\", frag);\n        return state;\n      }\n\n      url = action.payload.uri;\n      options = retrieveOptions(state.pageState[url].currentOptions, url, pageNum, state);\n      svg = retrieveOrGenerateSVG(state.MEI[url], state, url, pageNum, options);\n      return update(state, {\n        SVG: {\n          [url]: {\n            $merge: {\n              [pageNum]: {\n                data: svg,\n                options: options\n              }\n            }\n          }\n        },\n        pageState: {\n          [url]: {\n            $set: {\n              currentPage: pageNum,\n              pageCount: state.vrvTk.getPageCount(),\n              currentOptions: options\n            }\n          }\n        }\n      });\n\n    case REGISTER_PUBLISHED_PERFORMANCE_SCORE:\n      // console.log(\"Register published performance score: \", action.payload, \"on state: \", state);\n      if (action.payload.conceptualScore[\"@id\"] in state.scoreMapping) {\n        // we already know this conceptual score\n        // do we already know about the published score for this performance medium?\n        if (action.payload.performanceMedium[\"@id\"] in state.scoreMapping[action.payload.publishedScore[\"@id\"]]) {\n          // yes; so nothing to do. FIXME: should we cater for multiple published scores for same performance medium?\n          return state;\n        } else {\n          // no; so register the published score for this new performance medium\n          return update(state, {\n            scoreMapping: {\n              [action.payload.publishedScore[\"@id\"]]: {\n                $merge: {\n                  [action.payload.performanceMedium[\"@id\"]]: action.payload.conceptualScore[\"@id\"]\n                }\n              }\n            }\n          });\n        }\n      } else {\n        // first time we see this conceptual score\n        // so attach the published score according to performance medium\n        return update(state, {\n          scoreMapping: {\n            $merge: {\n              [action.payload.publishedScore[\"@id\"]]: {\n                [action.payload.performanceMedium[\"@id\"]]: action.payload.conceptualScore[\"@id\"]\n              }\n            }\n          }\n        });\n      }\n\n    case UPDATE_LATEST_RENDERED_PAGENUM:\n      return update(state, {\n        latestRenderedPageNum: {\n          $set: action.payload\n        }\n      });\n\n    default:\n      return state;\n  }\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/meld-clients-core/lib/reducers/reducer_score.js"],"names":["update","FETCH_COMPONENT_TARGET","FETCH_CONCEPTUAL_SCORE","FETCH_MANIFESTATIONS","FETCH_RIBBON_CONTENT","FETCH_SCORE","REGISTER_PUBLISHED_PERFORMANCE_SCORE","SCORE_NEXT_PAGE","SCORE_PAGE_TO_TARGET","SCORE_PREV_PAGE","TRANSITION_TO_NEXT_SESSION","UPDATE_LATEST_RENDERED_PAGENUM","SCORE_SET_OPTIONS","EMBODIMENT","MEITYPE","AUDIOTYPE","TEITYPE","MEMBER","conceptualScore","retrieveOrGenerateSVG","data","state","url","pageNum","options","pageState","SVG","JSON","stringify","console","log","currentlyLoadedIntoVrv","vrvTk","setOptions","loadData","redoLayout","renderToSVG","retrieveOptions","currentPage","opts","ScoreReducer","publishedScores","conceptualScores","MEI","componentTargets","scoreMapping","latestRenderedPageNum","pageCount","triggerNextSession","triggerPrevSession","verovio","toolkit","ignoreLayout","adjustPageHeight","scale","pageHeight","pageWidth","action","svg","getPageCount","type","payload","config","$set","$merge","currentOptions","MEIfile","target","part","fragments","Array","isArray","map","embodiment","fragtype","includes","concat","member","cS","newState","structureTarget","$push","uri","warn","info","frag","split","getPageWithElement","performanceMedium","publishedScore"],"mappings":"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","sourcesContent":["import update from 'immutability-helper';\nimport { FETCH_COMPONENT_TARGET, FETCH_CONCEPTUAL_SCORE, FETCH_MANIFESTATIONS, FETCH_RIBBON_CONTENT, FETCH_SCORE, REGISTER_PUBLISHED_PERFORMANCE_SCORE, SCORE_NEXT_PAGE, SCORE_PAGE_TO_TARGET, SCORE_PREV_PAGE, TRANSITION_TO_NEXT_SESSION, UPDATE_LATEST_RENDERED_PAGENUM, SCORE_SET_OPTIONS } from '../actions/index';\nconst EMBODIMENT = 'frbr:embodiment';\nconst MEITYPE = 'meld:MEIEmbodiment';\nconst AUDIOTYPE = 'meld:AudioEmbodiment';\nconst TEITYPE = 'meld:TEIEmbodiment';\nconst MEMBER = 'rdfs:member';\nlet conceptualScore;\n\nfunction retrieveOrGenerateSVG(data, state, url, pageNum, options) {\n  // We can use the previously cached SVG if:\n  // 1. We already have SVG rendered for this URI\n  // 2. We already have SVG rendered for this page number\n  // 3. We rendered it with these options\n  if (url in state.pageState && url in state.SVG && pageNum in state.SVG[url] && JSON.stringify(state.SVG[url][pageNum].options) === JSON.stringify(options)) {\n    // we can reuse the cached SVG!\n    console.log(`Score reducer: Reusing SVG for ${url} page ${pageNum}`);\n    return state.SVG[url][pageNum].data;\n  } else {\n    // we need to generate SVG!\n    // is the MEI file currently loaded into Verovio?\n    if (url !== state.currentlyLoadedIntoVrv) {\n      // no -- so set our options, and then load it\n      state.vrvTk.setOptions(options);\n      state.vrvTk.loadData(data);\n    } // have we loaded this page before?\n\n\n    if (url in state.SVG && pageNum in state.SVG[url]) {\n      // yes. Options must have changed, or we would have returned above.\n      // So, redo layout to take account of new options\n      state.vrvTk.setOptions(options);\n      state.vrvTk.redoLayout();\n    } // now render the page and return the SVG\n\n\n    return state.vrvTk.renderToSVG(pageNum, options);\n  }\n}\n\nfunction retrieveOptions(options, url, currentPage, state) {\n  let opts;\n\n  if (typeof options === \"object\") {\n    // use options object if supplied with action\n    opts = options;\n  } else if (url in state.SVG && currentPage in state.SVG[url]) {\n    // otherwise if we've previously rendered this page, use those options\n    opts = state.SVG[url][currentPage].options;\n  } else {\n    opts = state.options; // or as fallback, use defaults\n  }\n\n  return opts;\n}\n\nexport function ScoreReducer(state = {\n  currentlyLoadedIntoVrv: null,\n  publishedScores: {},\n  conceptualScores: {},\n  MEI: {},\n  SVG: {},\n  pageState: {},\n  componentTargets: {},\n  scoreMapping: {},\n  pageNum: 1,\n  latestRenderedPageNum: 0,\n  pageCount: 0,\n  triggerNextSession: \"\",\n  triggerPrevSession: \"\",\n  vrvTk: new verovio.toolkit(),\n  options: {\n    // default, unless overridden in FETCH_SCORE or SCORE_SET_OPTIONS\n    ignoreLayout: 1,\n    adjustPageHeight: 1,\n    scale: 35,\n    pageHeight: 1000 * 100 / 35,\n    pageWidth: 700 * 100 / 35\n  }\n}, action) {\n  let svg;\n  let url;\n  let currentPage;\n  let options;\n  const pageCount = state.vrvTk.getPageCount();\n\n  switch (action.type) {\n    case FETCH_SCORE:\n      url = action.payload.config.url;\n      currentPage = url in state.pageState ? state.pageState[url].currentPage : 1; // set options:\n\n      options = retrieveOptions(action.payload.config.options, url, currentPage, state); // We can use a previously cached SVG if:\n      // 1. We already have SVG rendered for this URI\n      // 2. We already have SVG rendered for this page number\n      // 3. We already have SVG rendered for these options\n\n      svg = retrieveOrGenerateSVG(action.payload.data, state, url, currentPage, options);\n      return update(state, {\n        currentlyLoadedIntoVrv: {\n          $set: url\n        },\n        SVG: {\n          [url]: {\n            $set: {\n              [currentPage]: {\n                data: svg,\n                options: options\n              }\n            }\n          }\n        },\n        MEI: {\n          $merge: {\n            [url]: action.payload.data\n          }\n        },\n        pageState: {\n          [url]: {\n            $set: {\n              currentPage: currentPage,\n              pageCount: state.vrvTk.getPageCount(),\n              currentOptions: options\n            }\n          }\n        }\n      });\n\n    case FETCH_RIBBON_CONTENT:\n      /*\t\tvar orch =  new Orchestration(action.payload.data);\n          var svgRibbon = orch.drawOrchestration(false, 0, 400, 0, 600);\n          return update(state, {MEI: { $merge: {[action.payload.config.url]: svgRibbon.outerHTML}}});*/\n      var data = action.payload.data;\n      if (!state.MEIfile) state.MEIfile = {};\n      return update(state, {\n        MEIfile: {\n          $merge: {\n            [action.payload.config.url]: action.payload.data\n          }\n        }\n      });\n\n    case FETCH_MANIFESTATIONS:\n      // console.log(\"IN FETCH_MANIFESTATIONS, payload is: \", action.payload)\n      const target = action.payload.target;\n      const part = action.payload.part;\n\n      if (typeof part === \"undefined\") {\n        // part wasn't on segment line\n        return state;\n      }\n\n      let fragments = {}; // go through each part, finding embodibags\n\n      if (EMBODIMENT in part) {\n        if (!Array.isArray(part[EMBODIMENT])) {\n          part[EMBODIMENT] = [part[EMBODIMENT]];\n        }\n\n        part[EMBODIMENT].map(embodiment => {\n          // go through each embodiment\n          if (MEMBER in embodiment) {\n            let fragtype; // extract set of fragments\n            // we want to separate out different types of media fragments\n\n            if (!Array.isArray(embodiment[\"@type\"])) {\n              embodiment[\"@type\"] = [embodiment[\"@type\"]];\n            }\n\n            if (!Array.isArray(target[\"@type\"])) {\n              target[\"@type\"] = [target[\"@type\"]];\n            }\n\n            if (embodiment[\"@type\"].includes(MEITYPE)) {\n              fragtype = \"MEI\";\n            } else if (embodiment[\"@type\"].includes(AUDIOTYPE)) {\n              fragtype = \"Audio\";\n            } else if (embodiment[\"@type\"].includes(TEITYPE)) {\n              fragtype = \"TEI\";\n            } else {\n              console.log(\"Score Reducer: Embodiment with unknown type\", embodiment);\n            }\n\n            if (!Array.isArray(embodiment[MEMBER])) {\n              embodiment[MEMBER] = [embodiment[MEMBER]];\n            }\n\n            fragments[fragtype] = fragments[fragtype] || [];\n            fragments[fragtype] = fragments[fragtype].concat(embodiment[MEMBER].map(member => {\n              return member[\"@id\"];\n            }));\n            fragments[\"description\"] = target[\"rdfs:label\"];\n\n            if (target[\"@type\"].includes(\"meld:Muzicode\")) {\n              fragments[\"muzicodeType\"] = target[\"mc:type\"];\n              fragments[\"cue\"] = target[\"climb:cue\"];\n            }\n          } else {\n            console.log(\"Embodiment without members: \", part, embodiment);\n          }\n        }); // console.log(\"Updating state: \");\n        // console.log( update(state, {componentTargets: { $merge: { [target[\"@id\"]]: fragments } } }));\n\n        return update(state, {\n          componentTargets: {\n            $merge: {\n              [target[\"@id\"]]: fragments\n            }\n          }\n        });\n      }\n\n      console.log(\"FETCH_MANIFESTATIONS: Unembodied target! \", target);\n      return state;\n\n    case FETCH_CONCEPTUAL_SCORE:\n      const cS = action.payload; //return update(state, {publishedScores: { $push: [conceptualScore[PUBLISHED_AS][\"@id\"]] } });\n\n      return update(state, {\n        publishedScores: {\n          $set: {\n            [cS[\"mo:published_as\"][\"@id\"]]: cS[\"@id\"]\n          }\n        }\n      });\n\n    case FETCH_COMPONENT_TARGET:\n      // ensure that our structure target collection is an array, then push this one in\n      conceptualScore = action.payload.conceptualScore; // make sure we have an entry for this conceptual score, and that its value is an array\n\n      let newState = update(state, {\n        conceptualScores: {\n          $merge: {\n            [action.payload.conceptualScore]: state['conceptualScores'][action.payload.conceptualScore] || []\n          }\n        }\n      }); // if this is a new structure target, push it in\n\n      if (!newState['conceptualScores'][action.payload.conceptualScore].includes(action.payload.structureTarget)) {\n        newState = update(newState, {\n          conceptualScores: {\n            [action.payload.conceptualScore]: {\n              $push: [action.payload.structureTarget]\n            }\n          }\n        });\n      }\n\n      return newState;\n\n    case SCORE_NEXT_PAGE:\n      url = action.payload.uri;\n\n      if (!action.payload.data) {\n        console.log(\"SCORE_NEXT_PAGE attempted on non-loaded MEI data - ignoring!\");\n        return state;\n      }\n\n      if (action.payload.pageNum !== state.pageState[url].currentPage) {\n        console.warn(`Mismatch in page numbers: received ${action.payload.pageNum} expected ${state.pageState[url].currentPage}`);\n      }\n\n      if (action.payload.pageNum === pageCount) {\n        // we've left the last page, set up a transfer to the next session\n        // console.log(\"TRIGGERING\")\n        console.info(\"Attempted SCORE_NEXT_PAGE while on last page of score\");\n        return update(state, {\n          triggerNextSession: {\n            $set: true\n          }\n        });\n      } else {\n        options = retrieveOptions(state.pageState[url].currentOptions, url, state.pageState.currentPage, state);\n        svg = retrieveOrGenerateSVG(state.MEI[url], state, url, action.payload.pageNum + 1, options);\n        return update(state, {\n          SVG: {\n            [url]: {\n              $merge: {\n                [action.payload.pageNum + 1]: {\n                  data: svg,\n                  options: options\n                }\n              }\n            }\n          },\n          pageState: {\n            [url]: {\n              $set: {\n                currentPage: action.payload.pageNum + 1,\n                pageCount: state.vrvTk.getPageCount(),\n                currentOptions: options\n              }\n            }\n          }\n        });\n      }\n\n    case SCORE_PREV_PAGE:\n      url = action.payload.uri;\n\n      if (!action.payload.data) {\n        console.log(\"SCORE_PREV_PAGE attempted on non-loaded MEI data - ignoring!\");\n        return state;\n      }\n\n      if (action.payload.pageNum !== state.pageState[url].currentPage) {\n        console.warn(`Mismatch in page numbers: received ${action.payload.pageNum} expected ${state.pageState[url].currentPage}`);\n      }\n\n      if (action.payload.pageNum === 1) {\n        // we're on the first page, go back to previous session\n        // console.log(\"TRIGGERING\")\n        console.info(\"Attempted SCORE_PREV_PAGE while on first page of score\");\n        return update(state, {\n          triggerPrevSession: {\n            $set: true\n          }\n        });\n      } else {\n        options = retrieveOptions(state.pageState[url].currentOptions, url, state.pageState.currentPage, state);\n        svg = retrieveOrGenerateSVG(state.MEI[url], state, url, action.payload.pageNum - 1, options);\n        return update(state, {\n          SVG: {\n            [url]: {\n              $merge: {\n                [action.payload.pageNum - 1]: {\n                  data: svg,\n                  options: options\n                }\n              }\n            }\n          },\n          pageState: {\n            [url]: {\n              $set: {\n                currentPage: action.payload.pageNum - 1,\n                pageCount: state.vrvTk.getPageCount(),\n                currentOptions: options\n              }\n            }\n          }\n        });\n      }\n\n    case SCORE_SET_OPTIONS:\n      url = action.payload.uri;\n      currentPage = url in state.pageState && \"currentPage\" in state.pageState[url] ? state.pageState[url].currentPage : 1;\n      svg = retrieveOrGenerateSVG(state.MEI[url], state, url, currentPage, action.payload.options);\n      return update(state, {\n        options: {\n          $set: action.payload.options\n        },\n        currentlyLoadedIntoVrv: {\n          $set: url\n        },\n        SVG: {\n          [url]: {\n            $set: {\n              [currentPage]: {\n                data: svg,\n                options: action.payload.options\n              }\n            }\n          }\n        },\n        pageState: {\n          [url]: {\n            $set: {\n              currentPage: currentPage,\n              pageCount: state.vrvTk.getPageCount(),\n              currentOptions: options\n            }\n          }\n        }\n      });\n\n    case TRANSITION_TO_NEXT_SESSION:\n      // console.log(\"forcing transition to next session if queued\");\n      return update(state, {\n        triggerNextSession: {\n          $set: true\n        }\n      });\n\n    case SCORE_PAGE_TO_TARGET:\n      if (!action.payload.data) {\n        console.log(\"SCORE_PAGE_TO_TARGET attempted on non-loaded MEI data - ignoring!\");\n        return state;\n      }\n\n      const frag = action.payload.target.split(\"#\")[1];\n      const pageNum = state.vrvTk.getPageWithElement(frag);\n\n      if (pageNum === 0) {\n        console.log(\"SCORE_PAGE_TO_TARGET attempted on a target that doesn't exist in the MEI - ignoring!\", frag);\n        return state;\n      }\n\n      url = action.payload.uri;\n      options = retrieveOptions(state.pageState[url].currentOptions, url, pageNum, state);\n      svg = retrieveOrGenerateSVG(state.MEI[url], state, url, pageNum, options);\n      return update(state, {\n        SVG: {\n          [url]: {\n            $merge: {\n              [pageNum]: {\n                data: svg,\n                options: options\n              }\n            }\n          }\n        },\n        pageState: {\n          [url]: {\n            $set: {\n              currentPage: pageNum,\n              pageCount: state.vrvTk.getPageCount(),\n              currentOptions: options\n            }\n          }\n        }\n      });\n\n    case REGISTER_PUBLISHED_PERFORMANCE_SCORE:\n      // console.log(\"Register published performance score: \", action.payload, \"on state: \", state);\n      if (action.payload.conceptualScore[\"@id\"] in state.scoreMapping) {\n        // we already know this conceptual score\n        // do we already know about the published score for this performance medium?\n        if (action.payload.performanceMedium[\"@id\"] in state.scoreMapping[action.payload.publishedScore[\"@id\"]]) {\n          // yes; so nothing to do. FIXME: should we cater for multiple published scores for same performance medium?\n          return state;\n        } else {\n          // no; so register the published score for this new performance medium\n          return update(state, {\n            scoreMapping: {\n              [action.payload.publishedScore[\"@id\"]]: {\n                $merge: {\n                  [action.payload.performanceMedium[\"@id\"]]: action.payload.conceptualScore[\"@id\"]\n                }\n              }\n            }\n          });\n        }\n      } else {\n        // first time we see this conceptual score\n        // so attach the published score according to performance medium\n        return update(state, {\n          scoreMapping: {\n            $merge: {\n              [action.payload.publishedScore[\"@id\"]]: {\n                [action.payload.performanceMedium[\"@id\"]]: action.payload.conceptualScore[\"@id\"]\n              }\n            }\n          }\n        });\n      }\n\n    case UPDATE_LATEST_RENDERED_PAGENUM:\n      return update(state, {\n        latestRenderedPageNum: {\n          $set: action.payload\n        }\n      });\n\n    default:\n      return state;\n  }\n}"]},"metadata":{},"sourceType":"module"}