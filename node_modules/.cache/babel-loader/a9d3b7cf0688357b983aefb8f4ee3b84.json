{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorRdfDereferenceHttpParseBase = void 0;\n\nconst bus_http_1 = require(\"@comunica/bus-http\");\n\nconst bus_rdf_dereference_1 = require(\"@comunica/bus-rdf-dereference\");\n\nconst cross_fetch_1 = require(\"cross-fetch\");\n\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * An actor that listens on the 'rdf-dereference' bus.\n *\n * It starts by grabbing all available RDF media types from the RDF parse bus.\n * After that, it resolves the URL using the HTTP bus using an accept header compiled from the available media types.\n * Finally, the response is parsed using the RDF parse bus.\n */\n\n\nclass ActorRdfDereferenceHttpParseBase extends bus_rdf_dereference_1.ActorRdfDereferenceMediaMappings {\n  constructor(args) {\n    super(args);\n  }\n\n  async test(action) {\n    if (!/^https?:/u.test(action.url)) {\n      throw new Error(`Cannot retrieve ${action.url} because it is not an HTTP(S) URL.`);\n    }\n\n    return true;\n  }\n\n  async run(action) {\n    var _a; // Define accept header based on available media types.\n\n\n    const {\n      mediaTypes\n    } = await this.mediatorRdfParseMediatypes.mediate({\n      context: action.context,\n      mediaTypes: true\n    });\n    const acceptHeader = this.mediaTypesToAcceptString(mediaTypes, this.getMaxAcceptHeaderLength()); // Resolve HTTP URL using appropriate accept header\n\n    const headers = new cross_fetch_1.Headers({\n      Accept: acceptHeader\n    }); // Append any custom passed headers\n\n    for (const key in action.headers) {\n      headers.append(key, action.headers[key]);\n    }\n\n    const httpAction = {\n      context: action.context,\n      init: {\n        headers,\n        method: action.method\n      },\n      input: action.url\n    };\n    let httpResponse;\n\n    try {\n      httpResponse = await this.mediatorHttp.mediate(httpAction);\n    } catch (error) {\n      return this.handleDereferenceError(action, error);\n    } // The response URL can be relative to the given URL\n\n\n    const url = relative_to_absolute_iri_1.resolve(httpResponse.url, action.url); // Convert output headers to a hash\n\n    const outputHeaders = {}; // eslint-disable-next-line no-return-assign\n\n    httpResponse.headers.forEach((value, key) => outputHeaders[key] = value); // Only parse if retrieval was successful\n\n    if (httpResponse.status !== 200) {\n      const error = new Error(`Could not retrieve ${action.url} (${httpResponse.status}: ${httpResponse.statusText || 'unknown error'})`); // Close the body if we have one, to avoid process to hang\n\n      if (httpResponse.body) {\n        await httpResponse.body.cancel();\n      }\n\n      return this.handleDereferenceError(action, error);\n    } // Wrap WhatWG readable stream into a Node.js readable stream\n    // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n\n\n    const responseStream = bus_http_1.ActorHttp.toNodeReadable(httpResponse.body); // Parse the resulting response\n\n    const match = ActorRdfDereferenceHttpParseBase.REGEX_MEDIATYPE.exec((_a = httpResponse.headers.get('content-type')) !== null && _a !== void 0 ? _a : '');\n    let mediaType = match[0]; // If no media type could be found, try to determine it via the file extension\n\n    if (!mediaType || mediaType === 'text/plain') {\n      mediaType = this.getMediaTypeFromExtension(httpResponse.url);\n    }\n\n    const parseAction = {\n      baseIRI: url,\n      headers: httpResponse.headers,\n      input: responseStream\n    };\n    let parseOutput;\n\n    try {\n      parseOutput = (await this.mediatorRdfParseHandle.mediate({\n        context: action.context,\n        handle: parseAction,\n        handleMediaType: mediaType\n      })).handle;\n    } catch (error) {\n      // Close the body, to avoid process to hang\n      await httpResponse.body.cancel();\n      return this.handleDereferenceError(action, error);\n    }\n\n    const quads = this.handleDereferenceStreamErrors(action, parseOutput.quads); // Return the parsed quad stream and whether or not only triples are supported\n\n    return {\n      url,\n      quads,\n      triples: parseOutput.triples,\n      headers: outputHeaders\n    };\n  }\n\n  mediaTypesToAcceptString(mediaTypes, maxLength) {\n    const wildcard = '*/*;q=0.1';\n    const parts = [];\n    const sortedMediaTypes = Object.keys(mediaTypes).map(mediaType => ({\n      mediaType,\n      priority: mediaTypes[mediaType]\n    })).sort((left, right) => right.priority - left.priority); // Take into account the ',' characters joining each type\n\n    const separatorLength = sortedMediaTypes.length - 1;\n    let partsLength = separatorLength;\n\n    for (const entry of sortedMediaTypes) {\n      const part = entry.mediaType + (entry.priority !== 1 ? `;q=${entry.priority.toFixed(3).replace(/0*$/u, '')}` : '');\n\n      if (partsLength + part.length > maxLength) {\n        while (partsLength + wildcard.length > maxLength) {\n          const last = parts.pop() || ''; // Don't forget the ','\n\n          partsLength -= last.length + 1;\n        }\n\n        parts.push(wildcard);\n        break;\n      }\n\n      parts.push(part);\n      partsLength += part.length;\n    }\n\n    if (parts.length === 0) {\n      return '*/*';\n    }\n\n    return parts.join(',');\n  }\n\n}\n\nexports.ActorRdfDereferenceHttpParseBase = ActorRdfDereferenceHttpParseBase;\nActorRdfDereferenceHttpParseBase.REGEX_MEDIATYPE = /^[^ ;]*/u;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-rdf-dereference-http-parse/lib/ActorRdfDereferenceHttpParseBase.js"],"names":["Object","defineProperty","exports","value","ActorRdfDereferenceHttpParseBase","bus_http_1","require","bus_rdf_dereference_1","cross_fetch_1","relative_to_absolute_iri_1","ActorRdfDereferenceMediaMappings","constructor","args","test","action","url","Error","run","_a","mediaTypes","mediatorRdfParseMediatypes","mediate","context","acceptHeader","mediaTypesToAcceptString","getMaxAcceptHeaderLength","headers","Headers","Accept","key","append","httpAction","init","method","input","httpResponse","mediatorHttp","error","handleDereferenceError","resolve","outputHeaders","forEach","status","statusText","body","cancel","responseStream","ActorHttp","toNodeReadable","match","REGEX_MEDIATYPE","exec","get","mediaType","getMediaTypeFromExtension","parseAction","baseIRI","parseOutput","mediatorRdfParseHandle","handle","handleMediaType","quads","handleDereferenceStreamErrors","triples","maxLength","wildcard","parts","sortedMediaTypes","keys","map","priority","sort","left","right","separatorLength","length","partsLength","entry","part","toFixed","replace","last","pop","push","join"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorRdfDereferenceHttpParseBase = void 0;\nconst bus_http_1 = require(\"@comunica/bus-http\");\nconst bus_rdf_dereference_1 = require(\"@comunica/bus-rdf-dereference\");\nconst cross_fetch_1 = require(\"cross-fetch\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n/**\n * An actor that listens on the 'rdf-dereference' bus.\n *\n * It starts by grabbing all available RDF media types from the RDF parse bus.\n * After that, it resolves the URL using the HTTP bus using an accept header compiled from the available media types.\n * Finally, the response is parsed using the RDF parse bus.\n */\nclass ActorRdfDereferenceHttpParseBase extends bus_rdf_dereference_1.ActorRdfDereferenceMediaMappings {\n    constructor(args) {\n        super(args);\n    }\n    async test(action) {\n        if (!/^https?:/u.test(action.url)) {\n            throw new Error(`Cannot retrieve ${action.url} because it is not an HTTP(S) URL.`);\n        }\n        return true;\n    }\n    async run(action) {\n        var _a;\n        // Define accept header based on available media types.\n        const { mediaTypes } = await this.mediatorRdfParseMediatypes.mediate({ context: action.context, mediaTypes: true });\n        const acceptHeader = this.mediaTypesToAcceptString(mediaTypes, this.getMaxAcceptHeaderLength());\n        // Resolve HTTP URL using appropriate accept header\n        const headers = new cross_fetch_1.Headers({ Accept: acceptHeader });\n        // Append any custom passed headers\n        for (const key in action.headers) {\n            headers.append(key, action.headers[key]);\n        }\n        const httpAction = {\n            context: action.context,\n            init: { headers, method: action.method },\n            input: action.url,\n        };\n        let httpResponse;\n        try {\n            httpResponse = await this.mediatorHttp.mediate(httpAction);\n        }\n        catch (error) {\n            return this.handleDereferenceError(action, error);\n        }\n        // The response URL can be relative to the given URL\n        const url = relative_to_absolute_iri_1.resolve(httpResponse.url, action.url);\n        // Convert output headers to a hash\n        const outputHeaders = {};\n        // eslint-disable-next-line no-return-assign\n        httpResponse.headers.forEach((value, key) => outputHeaders[key] = value);\n        // Only parse if retrieval was successful\n        if (httpResponse.status !== 200) {\n            const error = new Error(`Could not retrieve ${action.url} (${httpResponse.status}: ${httpResponse.statusText || 'unknown error'})`);\n            // Close the body if we have one, to avoid process to hang\n            if (httpResponse.body) {\n                await httpResponse.body.cancel();\n            }\n            return this.handleDereferenceError(action, error);\n        }\n        // Wrap WhatWG readable stream into a Node.js readable stream\n        // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n        const responseStream = bus_http_1.ActorHttp.toNodeReadable(httpResponse.body);\n        // Parse the resulting response\n        const match = ActorRdfDereferenceHttpParseBase.REGEX_MEDIATYPE\n            .exec((_a = httpResponse.headers.get('content-type')) !== null && _a !== void 0 ? _a : '');\n        let mediaType = match[0];\n        // If no media type could be found, try to determine it via the file extension\n        if (!mediaType || mediaType === 'text/plain') {\n            mediaType = this.getMediaTypeFromExtension(httpResponse.url);\n        }\n        const parseAction = {\n            baseIRI: url,\n            headers: httpResponse.headers,\n            input: responseStream,\n        };\n        let parseOutput;\n        try {\n            parseOutput = (await this.mediatorRdfParseHandle.mediate({ context: action.context, handle: parseAction, handleMediaType: mediaType })).handle;\n        }\n        catch (error) {\n            // Close the body, to avoid process to hang\n            await httpResponse.body.cancel();\n            return this.handleDereferenceError(action, error);\n        }\n        const quads = this.handleDereferenceStreamErrors(action, parseOutput.quads);\n        // Return the parsed quad stream and whether or not only triples are supported\n        return { url, quads, triples: parseOutput.triples, headers: outputHeaders };\n    }\n    mediaTypesToAcceptString(mediaTypes, maxLength) {\n        const wildcard = '*/*;q=0.1';\n        const parts = [];\n        const sortedMediaTypes = Object.keys(mediaTypes)\n            .map(mediaType => ({ mediaType, priority: mediaTypes[mediaType] }))\n            .sort((left, right) => right.priority - left.priority);\n        // Take into account the ',' characters joining each type\n        const separatorLength = sortedMediaTypes.length - 1;\n        let partsLength = separatorLength;\n        for (const entry of sortedMediaTypes) {\n            const part = entry.mediaType + (entry.priority !== 1 ?\n                `;q=${entry.priority.toFixed(3).replace(/0*$/u, '')}` :\n                '');\n            if (partsLength + part.length > maxLength) {\n                while (partsLength + wildcard.length > maxLength) {\n                    const last = parts.pop() || '';\n                    // Don't forget the ','\n                    partsLength -= last.length + 1;\n                }\n                parts.push(wildcard);\n                break;\n            }\n            parts.push(part);\n            partsLength += part.length;\n        }\n        if (parts.length === 0) {\n            return '*/*';\n        }\n        return parts.join(',');\n    }\n}\nexports.ActorRdfDereferenceHttpParseBase = ActorRdfDereferenceHttpParseBase;\nActorRdfDereferenceHttpParseBase.REGEX_MEDIATYPE = /^[^ ;]*/u;\n//# sourceMappingURL=ActorRdfDereferenceHttpParseBase.js.map"]},"metadata":{},"sourceType":"script"}