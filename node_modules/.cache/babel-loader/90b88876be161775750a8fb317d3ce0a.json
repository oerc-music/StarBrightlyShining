{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * All available quad term names.\n * @type {[string , string , string , string]}\n */\n\nexports.QUAD_TERM_NAMES = ['subject', 'predicate', 'object', 'graph'];\n/**\n * All available triple term names.\n * @type {[string , string , string]}\n */\n\nexports.TRIPLE_TERM_NAMES = ['subject', 'predicate', 'object'];\n/**\n * Get all terms in the given quad.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,\n *                                     this term will not be returned in the array.\n *                                     (default: false)\n * @return {Term[]} The available terms in the quad.\n */\n\nfunction getTerms(quad, ignoreDefaultGraph) {\n  if (ignoreDefaultGraph && quad.graph.termType === 'DefaultGraph') {\n    return [quad.subject, quad.predicate, quad.object];\n  }\n\n  return [quad.subject, quad.predicate, quad.object, quad.graph];\n}\n\nexports.getTerms = getTerms;\n/**\n * Get all terms in the given quad, including nested quads.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,\n *                                     this term will not be returned in the array.\n *                                     (default: false)\n * @return {Term[]} The available terms in the nested quad, excluding quad terms.\n */\n\nfunction getTermsNested(quad, ignoreDefaultGraph) {\n  const terms = [];\n\n  for (const term of getTerms(quad, ignoreDefaultGraph)) {\n    if (term.termType === 'Quad') {\n      getTermsNested(term, ignoreDefaultGraph).forEach(subTerm => terms.push(subTerm));\n    } else {\n      terms.push(term);\n    }\n  }\n\n  return terms;\n}\n\nexports.getTermsNested = getTermsNested;\n/**\n * Convert the given quad to an array of named terms.\n * This is the reverse operation of {@link collectNamedTerms}.\n * @param {BaseQuad} quad An RDFJS quad.\n * @return {INamedTerm[]} An array of named terms.\n */\n\nfunction getNamedTerms(quad) {\n  return [{\n    key: 'subject',\n    value: quad.subject\n  }, {\n    key: 'predicate',\n    value: quad.predicate\n  }, {\n    key: 'object',\n    value: quad.object\n  }, {\n    key: 'graph',\n    value: quad.graph\n  }];\n}\n\nexports.getNamedTerms = getNamedTerms;\n/**\n * Convert an array of named terms to an RDFJS quad.\n * This is the reverse operation of {@link getNamedTerms}.\n * @param {INamedTerm[]} namedTerms An array of named terms.\n * @param {(termName: QuadTermName) => Term} defaultCb An optional callback for when\n *                                                     certain terms are not available in the array.\n * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.\n * @return {Q} The resulting RDFJS quad.\n * @template Q The type of quad to output, defaults to RDF.Quad.\n */\n\nfunction collectNamedTerms(namedTerms, defaultCb, dataFactory) {\n  const elements = {};\n  namedTerms.forEach(namedTerm => elements[namedTerm.key] = namedTerm.value);\n\n  if (defaultCb) {\n    elements.subject = elements.subject || defaultCb('subject');\n    elements.predicate = elements.predicate || defaultCb('predicate');\n    elements.object = elements.object || defaultCb('object');\n    elements.graph = elements.graph || defaultCb('graph');\n  }\n\n  return (dataFactory || DF).quad(elements.subject, elements.predicate, elements.object, elements.graph);\n}\n\nexports.collectNamedTerms = collectNamedTerms;\n/**\n * Iterats over each term.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} cb A callback function.\n */\n\nfunction forEachTerms(quad, cb) {\n  cb(quad.subject, 'subject');\n  cb(quad.predicate, 'predicate');\n  cb(quad.object, 'object');\n  cb(quad.graph, 'graph');\n}\n\nexports.forEachTerms = forEachTerms;\n/**\n * Get all terms in the given quad that return true on the given filter function.\n * @param {BaseQuad} quad A quad.\n * @param {(value: Term, key: QuadTermName) => boolean} filter A filter callback.\n * @return {Term[]} The list of matching terms.\n */\n\nfunction filterTerms(quad, filter) {\n  const terms = [];\n\n  if (filter(quad.subject, 'subject')) {\n    terms.push(quad.subject);\n  }\n\n  if (filter(quad.predicate, 'predicate')) {\n    terms.push(quad.predicate);\n  }\n\n  if (filter(quad.object, 'object')) {\n    terms.push(quad.object);\n  }\n\n  if (filter(quad.graph, 'graph')) {\n    terms.push(quad.graph);\n  }\n\n  return terms;\n}\n\nexports.filterTerms = filterTerms;\n/**\n * Get all quad term names in the given quad that return true on the given filter function.\n * @param {BaseQuad} quad A quad.\n * @param {(value: Term, key: QuadTermName, all: INamedTerm[]) => boolean} filter A filter callback.\n * @return {QuadTermName[]} The list of matching quad term names.\n */\n\nfunction filterQuadTermNames(quad, filter) {\n  const names = [];\n\n  if (filter(quad.subject, 'subject')) {\n    names.push('subject');\n  }\n\n  if (filter(quad.predicate, 'predicate')) {\n    names.push('predicate');\n  }\n\n  if (filter(quad.object, 'object')) {\n    names.push('object');\n  }\n\n  if (filter(quad.graph, 'graph')) {\n    names.push('graph');\n  }\n\n  return names;\n}\n\nexports.filterQuadTermNames = filterQuadTermNames;\n/**\n * Map all terms of a quad.\n * @param {Quad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName) => Term} mapper A mapper function.\n * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.\n * @return {Quad} A new RDFJS quad.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\n\nfunction mapTerms(quad, mapper, dataFactory) {\n  return (dataFactory || DF).quad(mapper(quad.subject, 'subject'), mapper(quad.predicate, 'predicate'), mapper(quad.object, 'object'), mapper(quad.graph, 'graph'));\n}\n\nexports.mapTerms = mapTerms;\n/**\n * Reduce all terms of a quad.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(previousValue: U, currentValue: Term, key: QuadTermName) => U} reducer A reduce function.\n * @param {U} initialValue The initial value.\n * @return {U} The final value.\n */\n\nfunction reduceTerms(quad, reducer, initialValue) {\n  let value = initialValue;\n  value = reducer(value, quad.subject, 'subject');\n  value = reducer(value, quad.predicate, 'predicate');\n  value = reducer(value, quad.object, 'object');\n  return reducer(value, quad.graph, 'graph');\n}\n\nexports.reduceTerms = reduceTerms;\n/**\n * Determines whether all terms satisfy the specified test.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} checker A checker function.\n * @return {boolean} If all terms satisfy the specified test.\n */\n\nfunction everyTerms(quad, checker) {\n  return checker(quad.subject, 'subject') && checker(quad.predicate, 'predicate') && checker(quad.object, 'object') && checker(quad.graph, 'graph');\n}\n\nexports.everyTerms = everyTerms;\n/**\n * Determines whether at least one term satisfies the specified test.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} checker A checker function.\n * @return {boolean} If at least one term satisfies the specified test.\n */\n\nfunction someTerms(quad, checker) {\n  return checker(quad.subject, 'subject') || checker(quad.predicate, 'predicate') || checker(quad.object, 'object') || checker(quad.graph, 'graph');\n}\n\nexports.someTerms = someTerms;\n/**\n * Check if the given terms match.\n *\n * At least one of the following must be true:\n * * Term B is undefined.\n * * Term B is a variable.\n * * Term A and B are quads, and return true for `matchPatternComplete`.\n * * Quad term and term are equal (`termB.equals(termA)` return true)\n *\n * @param termA A term.\n * @param termB An optional term.\n */\n\nfunction matchTerm(termA, termB) {\n  return !termB || termB.termType === 'Variable' || termB.termType === 'Quad' && termA.termType === 'Quad' && matchPatternComplete(termA, termB) || termB.equals(termA);\n}\n\nexports.matchTerm = matchTerm;\n/**\n * Check if the given quad matches with the given quad terms.\n *\n * Each term must match at least one of the following:\n * * Term is undefined.\n * * Term is a variable.\n * * Quad term and term are both quads, and return true for `matchPatternComplete`.\n * * Quad term and term are equal (`quadTerm.equals(term)` return true)\n *\n * @param {BaseQuad} quad A quad to match with (can not contain variables).\n * @param {Term} subject An optional subject.\n * @param {Term} predicate An optional predicate.\n * @param {Term} object An optional object.\n * @param {Term} graph An optional graph.\n * @return {boolean} If the quad matches with the quad terms.\n */\n\nfunction matchPattern(quad, subject, predicate, object, graph) {\n  return matchTerm(quad.subject, subject) && matchTerm(quad.predicate, predicate) && matchTerm(quad.object, object) && matchTerm(quad.graph, graph);\n}\n\nexports.matchPattern = matchPattern;\n/**\n * Check if the first quad matches with all terms from the second quad.\n *\n * Each term must match at least one of the following:\n * * Quad2 term is a variable.\n * * Quad1 term and Quad2 term are equal (`term1.equals(term2)` return true)\n *\n * @param {BaseQuad} quad A quad (can not contain variables).\n * @param {BaseQuad} pattern A quad pattern (can contain variables).\n * @return {boolean} If the quad terms match.\n */\n\nfunction matchPatternComplete(quad, pattern) {\n  return matchPattern(quad, pattern.subject, pattern.predicate, pattern.object, pattern.graph);\n}\n\nexports.matchPatternComplete = matchPatternComplete;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/rdf-terms/lib/QuadTermUtil.js"],"names":["Object","defineProperty","exports","value","rdf_data_factory_1","require","DF","DataFactory","QUAD_TERM_NAMES","TRIPLE_TERM_NAMES","getTerms","quad","ignoreDefaultGraph","graph","termType","subject","predicate","object","getTermsNested","terms","term","forEach","subTerm","push","getNamedTerms","key","collectNamedTerms","namedTerms","defaultCb","dataFactory","elements","namedTerm","forEachTerms","cb","filterTerms","filter","filterQuadTermNames","names","mapTerms","mapper","reduceTerms","reducer","initialValue","everyTerms","checker","someTerms","matchTerm","termA","termB","matchPatternComplete","equals","matchPattern","pattern"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * All available quad term names.\n * @type {[string , string , string , string]}\n */\nexports.QUAD_TERM_NAMES = ['subject', 'predicate', 'object', 'graph'];\n/**\n * All available triple term names.\n * @type {[string , string , string]}\n */\nexports.TRIPLE_TERM_NAMES = ['subject', 'predicate', 'object'];\n/**\n * Get all terms in the given quad.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,\n *                                     this term will not be returned in the array.\n *                                     (default: false)\n * @return {Term[]} The available terms in the quad.\n */\nfunction getTerms(quad, ignoreDefaultGraph) {\n    if (ignoreDefaultGraph && quad.graph.termType === 'DefaultGraph') {\n        return [quad.subject, quad.predicate, quad.object];\n    }\n    return [quad.subject, quad.predicate, quad.object, quad.graph];\n}\nexports.getTerms = getTerms;\n/**\n * Get all terms in the given quad, including nested quads.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {boolean} ignoreDefaultGraph If true and the quad has the default graph as graph,\n *                                     this term will not be returned in the array.\n *                                     (default: false)\n * @return {Term[]} The available terms in the nested quad, excluding quad terms.\n */\nfunction getTermsNested(quad, ignoreDefaultGraph) {\n    const terms = [];\n    for (const term of getTerms(quad, ignoreDefaultGraph)) {\n        if (term.termType === 'Quad') {\n            getTermsNested(term, ignoreDefaultGraph).forEach(subTerm => terms.push(subTerm));\n        }\n        else {\n            terms.push(term);\n        }\n    }\n    return terms;\n}\nexports.getTermsNested = getTermsNested;\n/**\n * Convert the given quad to an array of named terms.\n * This is the reverse operation of {@link collectNamedTerms}.\n * @param {BaseQuad} quad An RDFJS quad.\n * @return {INamedTerm[]} An array of named terms.\n */\nfunction getNamedTerms(quad) {\n    return [\n        { key: 'subject', value: quad.subject },\n        { key: 'predicate', value: quad.predicate },\n        { key: 'object', value: quad.object },\n        { key: 'graph', value: quad.graph },\n    ];\n}\nexports.getNamedTerms = getNamedTerms;\n/**\n * Convert an array of named terms to an RDFJS quad.\n * This is the reverse operation of {@link getNamedTerms}.\n * @param {INamedTerm[]} namedTerms An array of named terms.\n * @param {(termName: QuadTermName) => Term} defaultCb An optional callback for when\n *                                                     certain terms are not available in the array.\n * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.\n * @return {Q} The resulting RDFJS quad.\n * @template Q The type of quad to output, defaults to RDF.Quad.\n */\nfunction collectNamedTerms(namedTerms, defaultCb, dataFactory) {\n    const elements = {};\n    namedTerms.forEach((namedTerm) => elements[namedTerm.key] = namedTerm.value);\n    if (defaultCb) {\n        elements.subject = elements.subject || defaultCb('subject');\n        elements.predicate = elements.predicate || defaultCb('predicate');\n        elements.object = elements.object || defaultCb('object');\n        elements.graph = elements.graph || defaultCb('graph');\n    }\n    return (dataFactory || DF).quad(elements.subject, elements.predicate, elements.object, elements.graph);\n}\nexports.collectNamedTerms = collectNamedTerms;\n/**\n * Iterats over each term.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} cb A callback function.\n */\nfunction forEachTerms(quad, cb) {\n    cb(quad.subject, 'subject');\n    cb(quad.predicate, 'predicate');\n    cb(quad.object, 'object');\n    cb(quad.graph, 'graph');\n}\nexports.forEachTerms = forEachTerms;\n/**\n * Get all terms in the given quad that return true on the given filter function.\n * @param {BaseQuad} quad A quad.\n * @param {(value: Term, key: QuadTermName) => boolean} filter A filter callback.\n * @return {Term[]} The list of matching terms.\n */\nfunction filterTerms(quad, filter) {\n    const terms = [];\n    if (filter(quad.subject, 'subject')) {\n        terms.push(quad.subject);\n    }\n    if (filter(quad.predicate, 'predicate')) {\n        terms.push(quad.predicate);\n    }\n    if (filter(quad.object, 'object')) {\n        terms.push(quad.object);\n    }\n    if (filter(quad.graph, 'graph')) {\n        terms.push(quad.graph);\n    }\n    return terms;\n}\nexports.filterTerms = filterTerms;\n/**\n * Get all quad term names in the given quad that return true on the given filter function.\n * @param {BaseQuad} quad A quad.\n * @param {(value: Term, key: QuadTermName, all: INamedTerm[]) => boolean} filter A filter callback.\n * @return {QuadTermName[]} The list of matching quad term names.\n */\nfunction filterQuadTermNames(quad, filter) {\n    const names = [];\n    if (filter(quad.subject, 'subject')) {\n        names.push('subject');\n    }\n    if (filter(quad.predicate, 'predicate')) {\n        names.push('predicate');\n    }\n    if (filter(quad.object, 'object')) {\n        names.push('object');\n    }\n    if (filter(quad.graph, 'graph')) {\n        names.push('graph');\n    }\n    return names;\n}\nexports.filterQuadTermNames = filterQuadTermNames;\n/**\n * Map all terms of a quad.\n * @param {Quad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName) => Term} mapper A mapper function.\n * @param {RDF.DataFactory} dataFactory A custom data factory to create quads.\n * @return {Quad} A new RDFJS quad.\n * @template Q The type of quad, defaults to RDF.Quad.\n */\nfunction mapTerms(quad, mapper, dataFactory) {\n    return (dataFactory || DF).quad(mapper(quad.subject, 'subject'), mapper(quad.predicate, 'predicate'), mapper(quad.object, 'object'), mapper(quad.graph, 'graph'));\n}\nexports.mapTerms = mapTerms;\n/**\n * Reduce all terms of a quad.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(previousValue: U, currentValue: Term, key: QuadTermName) => U} reducer A reduce function.\n * @param {U} initialValue The initial value.\n * @return {U} The final value.\n */\nfunction reduceTerms(quad, reducer, initialValue) {\n    let value = initialValue;\n    value = reducer(value, quad.subject, 'subject');\n    value = reducer(value, quad.predicate, 'predicate');\n    value = reducer(value, quad.object, 'object');\n    return reducer(value, quad.graph, 'graph');\n}\nexports.reduceTerms = reduceTerms;\n/**\n * Determines whether all terms satisfy the specified test.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} checker A checker function.\n * @return {boolean} If all terms satisfy the specified test.\n */\nfunction everyTerms(quad, checker) {\n    return checker(quad.subject, 'subject')\n        && checker(quad.predicate, 'predicate')\n        && checker(quad.object, 'object')\n        && checker(quad.graph, 'graph');\n}\nexports.everyTerms = everyTerms;\n/**\n * Determines whether at least one term satisfies the specified test.\n * @param {BaseQuad} quad An RDFJS quad.\n * @param {(value: Term, key: QuadTermName} checker A checker function.\n * @return {boolean} If at least one term satisfies the specified test.\n */\nfunction someTerms(quad, checker) {\n    return checker(quad.subject, 'subject')\n        || checker(quad.predicate, 'predicate')\n        || checker(quad.object, 'object')\n        || checker(quad.graph, 'graph');\n}\nexports.someTerms = someTerms;\n/**\n * Check if the given terms match.\n *\n * At least one of the following must be true:\n * * Term B is undefined.\n * * Term B is a variable.\n * * Term A and B are quads, and return true for `matchPatternComplete`.\n * * Quad term and term are equal (`termB.equals(termA)` return true)\n *\n * @param termA A term.\n * @param termB An optional term.\n */\nfunction matchTerm(termA, termB) {\n    return !termB\n        || termB.termType === 'Variable'\n        || (termB.termType === 'Quad' && termA.termType === 'Quad' && matchPatternComplete(termA, termB))\n        || termB.equals(termA);\n}\nexports.matchTerm = matchTerm;\n/**\n * Check if the given quad matches with the given quad terms.\n *\n * Each term must match at least one of the following:\n * * Term is undefined.\n * * Term is a variable.\n * * Quad term and term are both quads, and return true for `matchPatternComplete`.\n * * Quad term and term are equal (`quadTerm.equals(term)` return true)\n *\n * @param {BaseQuad} quad A quad to match with (can not contain variables).\n * @param {Term} subject An optional subject.\n * @param {Term} predicate An optional predicate.\n * @param {Term} object An optional object.\n * @param {Term} graph An optional graph.\n * @return {boolean} If the quad matches with the quad terms.\n */\nfunction matchPattern(quad, subject, predicate, object, graph) {\n    return matchTerm(quad.subject, subject)\n        && matchTerm(quad.predicate, predicate)\n        && matchTerm(quad.object, object)\n        && matchTerm(quad.graph, graph);\n}\nexports.matchPattern = matchPattern;\n/**\n * Check if the first quad matches with all terms from the second quad.\n *\n * Each term must match at least one of the following:\n * * Quad2 term is a variable.\n * * Quad1 term and Quad2 term are equal (`term1.equals(term2)` return true)\n *\n * @param {BaseQuad} quad A quad (can not contain variables).\n * @param {BaseQuad} pattern A quad pattern (can contain variables).\n * @return {boolean} If the quad terms match.\n */\nfunction matchPatternComplete(quad, pattern) {\n    return matchPattern(quad, pattern.subject, pattern.predicate, pattern.object, pattern.graph);\n}\nexports.matchPatternComplete = matchPatternComplete;\n//# sourceMappingURL=QuadTermUtil.js.map"]},"metadata":{},"sourceType":"script"}