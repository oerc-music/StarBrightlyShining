{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RdfSourceSparql = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst fetch_sparql_endpoint_1 = require(\"fetch-sparql-endpoint\");\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst rdf_terms_1 = require(\"rdf-terms\");\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n\nconst DF = new rdf_data_factory_1.DataFactory();\n\nclass RdfSourceSparql {\n  constructor(url, context, mediatorHttp, forceHttpGet) {\n    this.url = url;\n    this.context = context;\n    this.mediatorHttp = mediatorHttp;\n    this.endpointFetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({\n      method: forceHttpGet ? 'GET' : 'POST',\n      fetch: (input, init) => this.mediatorHttp.mediate({\n        input,\n        init,\n        context: this.context\n      }),\n      prefixVariableQuestionMark: true\n    });\n  }\n  /**\n   * Replace all blank nodes in a pattern with variables.\n   * If the pattern contains no blank nodes the original pattern gets returned.\n   * @param {RDF.BaseQuad} pattern A quad pattern.\n   * @return {RDF.BaseQuad} A quad pattern with no blank nodes.\n   */\n\n\n  static replaceBlankNodes(pattern) {\n    const variableNames = rdf_terms_1.getVariables(rdf_terms_1.getTerms(pattern)).map(variableTerm => variableTerm.value); // Track the names the blank nodes get mapped to (required if the name has to change)\n\n    const blankMap = {};\n    let changed = false; // For every position, convert to a variable if there is a blank node\n\n    const result = rdf_terms_1.mapTerms(pattern, term => {\n      if (term.termType === 'BlankNode') {\n        let name = term.value;\n\n        if (blankMap[name]) {\n          name = blankMap[name];\n        } else {\n          if (variableNames.includes(name)) {\n            // Increase index added to name until we find one that is available (2 loops at most)\n            let idx = 0;\n\n            while (variableNames.includes(`${name}${idx}`)) {\n              ++idx;\n            }\n\n            name += idx;\n          }\n\n          blankMap[term.value] = name;\n          variableNames.push(name);\n        }\n\n        changed = true;\n        return DF.variable(name);\n      }\n\n      return term;\n    });\n    return changed ? result : pattern;\n  }\n  /**\n   * Convert a quad pattern to a BGP with only that pattern.\n   * @param {RDF.pattern} quad A quad pattern.\n   * @return {Bgp} A BGP.\n   */\n\n\n  static patternToBgp(pattern) {\n    return RdfSourceSparql.FACTORY.createBgp([RdfSourceSparql.FACTORY.createPattern(pattern.subject, pattern.predicate, pattern.object, pattern.graph)]);\n  }\n  /**\n   * Convert a quad pattern to a select query for this pattern.\n   * @param {RDF.Quad} pattern A quad pattern.\n   * @return {string} A select query string.\n   */\n\n\n  static patternToSelectQuery(pattern) {\n    const variables = rdf_terms_1.getVariables(rdf_terms_1.getTerms(pattern));\n    return sparqlalgebrajs_1.toSparql(RdfSourceSparql.FACTORY.createProject(RdfSourceSparql.patternToBgp(pattern), variables));\n  }\n  /**\n   * Convert a quad pattern to a count query for the number of matching triples for this pattern.\n   * @param {RDF.Quad} pattern A quad pattern.\n   * @return {string} A count query string.\n   */\n\n\n  static patternToCountQuery(pattern) {\n    return sparqlalgebrajs_1.toSparql(RdfSourceSparql.FACTORY.createProject(RdfSourceSparql.FACTORY.createExtend(RdfSourceSparql.FACTORY.createGroup(RdfSourceSparql.patternToBgp(pattern), [], [RdfSourceSparql.FACTORY.createBoundAggregate(DF.variable('var0'), 'count', RdfSourceSparql.FACTORY.createWildcardExpression(), false)]), DF.variable('count'), RdfSourceSparql.FACTORY.createTermExpression(DF.variable('var0'))), [DF.variable('count')]));\n  }\n  /**\n   * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.\n   * @param {string} endpoint A SPARQL endpoint URL.\n   * @param {string} query A SPARQL query string.\n   * @return {BindingsStream} A stream of bindings.\n   */\n\n\n  queryBindings(endpoint, query) {\n    const rawStream = this.endpointFetcher.fetchBindings(endpoint, query);\n    return asynciterator_1.wrap(rawStream, {\n      autoStart: false,\n      maxBufferSize: Number.POSITIVE_INFINITY\n    }).map(rawData => bus_query_operation_1.Bindings(rawData));\n  }\n\n  match(subject, predicate, object, graph) {\n    const pattern = RdfSourceSparql.replaceBlankNodes(RdfSourceSparql.FACTORY.createPattern(subject, predicate, object, graph));\n    const countQuery = RdfSourceSparql.patternToCountQuery(pattern);\n    const selectQuery = RdfSourceSparql.patternToSelectQuery(pattern); // Emit metadata containing the estimated count (reject is never called)\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    new Promise(resolve => {\n      const bindingsStream = this.queryBindings(this.url, countQuery);\n      bindingsStream.on('data', bindings => {\n        const count = bindings.get('?count');\n\n        if (count) {\n          const totalItems = Number.parseInt(count.value, 10);\n\n          if (Number.isNaN(totalItems)) {\n            return resolve({\n              totalItems: Number.POSITIVE_INFINITY\n            });\n          }\n\n          return resolve({\n            totalItems\n          });\n        }\n\n        return resolve({\n          totalItems: Number.POSITIVE_INFINITY\n        });\n      });\n      bindingsStream.on('error', () => resolve({\n        totalItems: Number.POSITIVE_INFINITY\n      }));\n      bindingsStream.on('end', () => resolve({\n        totalItems: Number.POSITIVE_INFINITY\n      }));\n    }).then(metadata => quads.setProperty('metadata', metadata)); // Materialize the queried pattern using each found binding.\n\n    const quads = this.queryBindings(this.url, selectQuery).map(bindings => rdf_terms_1.mapTerms(pattern, value => {\n      if (value.termType === 'Variable') {\n        const boundValue = bindings.get(`?${value.value}`);\n\n        if (!boundValue) {\n          quads.destroy(new Error(`The endpoint ${this.url} failed to provide a binding for ${value.value}.`));\n        }\n\n        return boundValue;\n      }\n\n      return value;\n    }));\n    return quads;\n  }\n\n}\n\nexports.RdfSourceSparql = RdfSourceSparql;\nRdfSourceSparql.FACTORY = new sparqlalgebrajs_1.Factory();","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-rdf-resolve-hypermedia-sparql/lib/RdfSourceSparql.js"],"names":["Object","defineProperty","exports","value","RdfSourceSparql","bus_query_operation_1","require","asynciterator_1","fetch_sparql_endpoint_1","rdf_data_factory_1","rdf_terms_1","sparqlalgebrajs_1","DF","DataFactory","constructor","url","context","mediatorHttp","forceHttpGet","endpointFetcher","SparqlEndpointFetcher","method","fetch","input","init","mediate","prefixVariableQuestionMark","replaceBlankNodes","pattern","variableNames","getVariables","getTerms","map","variableTerm","blankMap","changed","result","mapTerms","term","termType","name","includes","idx","push","variable","patternToBgp","FACTORY","createBgp","createPattern","subject","predicate","object","graph","patternToSelectQuery","variables","toSparql","createProject","patternToCountQuery","createExtend","createGroup","createBoundAggregate","createWildcardExpression","createTermExpression","queryBindings","endpoint","query","rawStream","fetchBindings","wrap","autoStart","maxBufferSize","Number","POSITIVE_INFINITY","rawData","Bindings","match","countQuery","selectQuery","Promise","resolve","bindingsStream","on","bindings","count","get","totalItems","parseInt","isNaN","then","metadata","quads","setProperty","boundValue","destroy","Error","Factory"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RdfSourceSparql = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst fetch_sparql_endpoint_1 = require(\"fetch-sparql-endpoint\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst rdf_terms_1 = require(\"rdf-terms\");\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\nconst DF = new rdf_data_factory_1.DataFactory();\nclass RdfSourceSparql {\n    constructor(url, context, mediatorHttp, forceHttpGet) {\n        this.url = url;\n        this.context = context;\n        this.mediatorHttp = mediatorHttp;\n        this.endpointFetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({\n            method: forceHttpGet ? 'GET' : 'POST',\n            fetch: (input, init) => this.mediatorHttp.mediate({ input, init, context: this.context }),\n            prefixVariableQuestionMark: true,\n        });\n    }\n    /**\n     * Replace all blank nodes in a pattern with variables.\n     * If the pattern contains no blank nodes the original pattern gets returned.\n     * @param {RDF.BaseQuad} pattern A quad pattern.\n     * @return {RDF.BaseQuad} A quad pattern with no blank nodes.\n     */\n    static replaceBlankNodes(pattern) {\n        const variableNames = rdf_terms_1.getVariables(rdf_terms_1.getTerms(pattern)).map(variableTerm => variableTerm.value);\n        // Track the names the blank nodes get mapped to (required if the name has to change)\n        const blankMap = {};\n        let changed = false;\n        // For every position, convert to a variable if there is a blank node\n        const result = rdf_terms_1.mapTerms(pattern, term => {\n            if (term.termType === 'BlankNode') {\n                let name = term.value;\n                if (blankMap[name]) {\n                    name = blankMap[name];\n                }\n                else {\n                    if (variableNames.includes(name)) {\n                        // Increase index added to name until we find one that is available (2 loops at most)\n                        let idx = 0;\n                        while (variableNames.includes(`${name}${idx}`)) {\n                            ++idx;\n                        }\n                        name += idx;\n                    }\n                    blankMap[term.value] = name;\n                    variableNames.push(name);\n                }\n                changed = true;\n                return DF.variable(name);\n            }\n            return term;\n        });\n        return changed ? result : pattern;\n    }\n    /**\n     * Convert a quad pattern to a BGP with only that pattern.\n     * @param {RDF.pattern} quad A quad pattern.\n     * @return {Bgp} A BGP.\n     */\n    static patternToBgp(pattern) {\n        return RdfSourceSparql.FACTORY.createBgp([RdfSourceSparql.FACTORY\n                .createPattern(pattern.subject, pattern.predicate, pattern.object, pattern.graph)]);\n    }\n    /**\n     * Convert a quad pattern to a select query for this pattern.\n     * @param {RDF.Quad} pattern A quad pattern.\n     * @return {string} A select query string.\n     */\n    static patternToSelectQuery(pattern) {\n        const variables = rdf_terms_1.getVariables(rdf_terms_1.getTerms(pattern));\n        return sparqlalgebrajs_1.toSparql(RdfSourceSparql.FACTORY.createProject(RdfSourceSparql.patternToBgp(pattern), variables));\n    }\n    /**\n     * Convert a quad pattern to a count query for the number of matching triples for this pattern.\n     * @param {RDF.Quad} pattern A quad pattern.\n     * @return {string} A count query string.\n     */\n    static patternToCountQuery(pattern) {\n        return sparqlalgebrajs_1.toSparql(RdfSourceSparql.FACTORY.createProject(RdfSourceSparql.FACTORY.createExtend(RdfSourceSparql.FACTORY.createGroup(RdfSourceSparql.patternToBgp(pattern), [], [RdfSourceSparql.FACTORY.createBoundAggregate(DF.variable('var0'), 'count', RdfSourceSparql.FACTORY.createWildcardExpression(), false)]), DF.variable('count'), RdfSourceSparql.FACTORY.createTermExpression(DF.variable('var0'))), [DF.variable('count')]));\n    }\n    /**\n     * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.\n     * @param {string} endpoint A SPARQL endpoint URL.\n     * @param {string} query A SPARQL query string.\n     * @return {BindingsStream} A stream of bindings.\n     */\n    queryBindings(endpoint, query) {\n        const rawStream = this.endpointFetcher.fetchBindings(endpoint, query);\n        return asynciterator_1.wrap(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY })\n            .map(rawData => bus_query_operation_1.Bindings(rawData));\n    }\n    match(subject, predicate, object, graph) {\n        const pattern = RdfSourceSparql.replaceBlankNodes(RdfSourceSparql.FACTORY.createPattern(subject, predicate, object, graph));\n        const countQuery = RdfSourceSparql.patternToCountQuery(pattern);\n        const selectQuery = RdfSourceSparql.patternToSelectQuery(pattern);\n        // Emit metadata containing the estimated count (reject is never called)\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        new Promise(resolve => {\n            const bindingsStream = this.queryBindings(this.url, countQuery);\n            bindingsStream.on('data', (bindings) => {\n                const count = bindings.get('?count');\n                if (count) {\n                    const totalItems = Number.parseInt(count.value, 10);\n                    if (Number.isNaN(totalItems)) {\n                        return resolve({ totalItems: Number.POSITIVE_INFINITY });\n                    }\n                    return resolve({ totalItems });\n                }\n                return resolve({ totalItems: Number.POSITIVE_INFINITY });\n            });\n            bindingsStream.on('error', () => resolve({ totalItems: Number.POSITIVE_INFINITY }));\n            bindingsStream.on('end', () => resolve({ totalItems: Number.POSITIVE_INFINITY }));\n        })\n            .then(metadata => quads.setProperty('metadata', metadata));\n        // Materialize the queried pattern using each found binding.\n        const quads = this.queryBindings(this.url, selectQuery)\n            .map((bindings) => rdf_terms_1.mapTerms(pattern, (value) => {\n            if (value.termType === 'Variable') {\n                const boundValue = bindings.get(`?${value.value}`);\n                if (!boundValue) {\n                    quads.destroy(new Error(`The endpoint ${this.url} failed to provide a binding for ${value.value}.`));\n                }\n                return boundValue;\n            }\n            return value;\n        }));\n        return quads;\n    }\n}\nexports.RdfSourceSparql = RdfSourceSparql;\nRdfSourceSparql.FACTORY = new sparqlalgebrajs_1.Factory();\n//# sourceMappingURL=RdfSourceSparql.js.map"]},"metadata":{},"sourceType":"script"}