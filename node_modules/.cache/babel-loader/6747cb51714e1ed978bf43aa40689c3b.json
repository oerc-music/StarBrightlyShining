{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationService = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst context_entries_1 = require(\"@comunica/context-entries\");\n\nconst core_1 = require(\"@comunica/core\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n/**\n * A comunica Service Query Operation Actor.\n * It unwraps the SERVICE operation and executes it on the given source.\n */\n\n\nclass ActorQueryOperationService extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n  constructor(args) {\n    super(args, 'service');\n  }\n\n  async testOperation(pattern, context) {\n    if (pattern.name.termType !== 'NamedNode') {\n      throw new Error(`${this.name} can only query services by IRI, while a ${pattern.name.termType} was given.`);\n    }\n\n    return true;\n  }\n\n  async runOperation(pattern, context) {\n    const endpoint = pattern.name.value; // Adjust our context to only have the endpoint as source\n\n    context = context || core_1.ActionContext({});\n    let subContext = context.delete(context_entries_1.KeysRdfResolveQuadPattern.source).delete(context_entries_1.KeysRdfResolveQuadPattern.sources);\n    const sourceType = this.forceSparqlEndpoint ? 'sparql' : 'auto';\n    subContext = subContext.set(context_entries_1.KeysRdfResolveQuadPattern.sources, [{\n      type: sourceType,\n      value: endpoint\n    }]); // Query the source\n\n    let output;\n\n    try {\n      output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n        operation: pattern.input,\n        context: subContext\n      }));\n    } catch (error) {\n      if (pattern.silent) {\n        // Emit a single empty binding\n        output = {\n          bindingsStream: new asynciterator_1.SingletonIterator(bus_query_operation_1.Bindings({})),\n          type: 'bindings',\n          variables: [],\n          canContainUndefs: false\n        };\n      } else {\n        throw error;\n      }\n    }\n\n    return output;\n  }\n\n}\n\nexports.ActorQueryOperationService = ActorQueryOperationService;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-service/lib/ActorQueryOperationService.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationService","bus_query_operation_1","require","context_entries_1","core_1","asynciterator_1","ActorQueryOperationTypedMediated","constructor","args","testOperation","pattern","context","name","termType","Error","runOperation","endpoint","ActionContext","subContext","delete","KeysRdfResolveQuadPattern","source","sources","sourceType","forceSparqlEndpoint","set","type","output","ActorQueryOperation","getSafeBindings","mediatorQueryOperation","mediate","operation","input","error","silent","bindingsStream","SingletonIterator","Bindings","variables","canContainUndefs"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,0BAAR,GAAqC,KAAK,CAA1C;;AACA,MAAMC,qBAAqB,GAAGC,OAAO,CAAC,+BAAD,CAArC;;AACA,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,2BAAD,CAAjC;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,gBAAD,CAAtB;;AACA,MAAMG,eAAe,GAAGH,OAAO,CAAC,eAAD,CAA/B;AACA;AACA;AACA;AACA;;;AACA,MAAMF,0BAAN,SAAyCC,qBAAqB,CAACK,gCAA/D,CAAgG;AAC5FC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAMA,IAAN,EAAY,SAAZ;AACH;;AACkB,QAAbC,aAAa,CAACC,OAAD,EAAUC,OAAV,EAAmB;AAClC,QAAID,OAAO,CAACE,IAAR,CAAaC,QAAb,KAA0B,WAA9B,EAA2C;AACvC,YAAM,IAAIC,KAAJ,CAAW,GAAE,KAAKF,IAAK,4CAA2CF,OAAO,CAACE,IAAR,CAAaC,QAAS,aAAxF,CAAN;AACH;;AACD,WAAO,IAAP;AACH;;AACiB,QAAZE,YAAY,CAACL,OAAD,EAAUC,OAAV,EAAmB;AACjC,UAAMK,QAAQ,GAAGN,OAAO,CAACE,IAAR,CAAab,KAA9B,CADiC,CAEjC;;AACAY,IAAAA,OAAO,GAAGA,OAAO,IAAIP,MAAM,CAACa,aAAP,CAAqB,EAArB,CAArB;AACA,QAAIC,UAAU,GAAGP,OAAO,CACnBQ,MADY,CACLhB,iBAAiB,CAACiB,yBAAlB,CAA4CC,MADvC,EAEZF,MAFY,CAELhB,iBAAiB,CAACiB,yBAAlB,CAA4CE,OAFvC,CAAjB;AAGA,UAAMC,UAAU,GAAG,KAAKC,mBAAL,GAA2B,QAA3B,GAAsC,MAAzD;AACAN,IAAAA,UAAU,GAAGA,UAAU,CAACO,GAAX,CAAetB,iBAAiB,CAACiB,yBAAlB,CAA4CE,OAA3D,EAAoE,CAAC;AAAEI,MAAAA,IAAI,EAAEH,UAAR;AAAoBxB,MAAAA,KAAK,EAAEiB;AAA3B,KAAD,CAApE,CAAb,CARiC,CASjC;;AACA,QAAIW,MAAJ;;AACA,QAAI;AACAA,MAAAA,MAAM,GAAG1B,qBAAqB,CAAC2B,mBAAtB,CAA0CC,eAA1C,CAA0D,MAAM,KAAKC,sBAAL,CAA4BC,OAA5B,CAAoC;AAAEC,QAAAA,SAAS,EAAEtB,OAAO,CAACuB,KAArB;AAA4BtB,QAAAA,OAAO,EAAEO;AAArC,OAApC,CAAhE,CAAT;AACH,KAFD,CAGA,OAAOgB,KAAP,EAAc;AACV,UAAIxB,OAAO,CAACyB,MAAZ,EAAoB;AAChB;AACAR,QAAAA,MAAM,GAAG;AACLS,UAAAA,cAAc,EAAE,IAAI/B,eAAe,CAACgC,iBAApB,CAAsCpC,qBAAqB,CAACqC,QAAtB,CAA+B,EAA/B,CAAtC,CADX;AAELZ,UAAAA,IAAI,EAAE,UAFD;AAGLa,UAAAA,SAAS,EAAE,EAHN;AAILC,UAAAA,gBAAgB,EAAE;AAJb,SAAT;AAMH,OARD,MASK;AACD,cAAMN,KAAN;AACH;AACJ;;AACD,WAAOP,MAAP;AACH;;AAvC2F;;AAyChG7B,OAAO,CAACE,0BAAR,GAAqCA,0BAArC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationService = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst context_entries_1 = require(\"@comunica/context-entries\");\nconst core_1 = require(\"@comunica/core\");\nconst asynciterator_1 = require(\"asynciterator\");\n/**\n * A comunica Service Query Operation Actor.\n * It unwraps the SERVICE operation and executes it on the given source.\n */\nclass ActorQueryOperationService extends bus_query_operation_1.ActorQueryOperationTypedMediated {\n    constructor(args) {\n        super(args, 'service');\n    }\n    async testOperation(pattern, context) {\n        if (pattern.name.termType !== 'NamedNode') {\n            throw new Error(`${this.name} can only query services by IRI, while a ${pattern.name.termType} was given.`);\n        }\n        return true;\n    }\n    async runOperation(pattern, context) {\n        const endpoint = pattern.name.value;\n        // Adjust our context to only have the endpoint as source\n        context = context || core_1.ActionContext({});\n        let subContext = context\n            .delete(context_entries_1.KeysRdfResolveQuadPattern.source)\n            .delete(context_entries_1.KeysRdfResolveQuadPattern.sources);\n        const sourceType = this.forceSparqlEndpoint ? 'sparql' : 'auto';\n        subContext = subContext.set(context_entries_1.KeysRdfResolveQuadPattern.sources, [{ type: sourceType, value: endpoint }]);\n        // Query the source\n        let output;\n        try {\n            output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: pattern.input, context: subContext }));\n        }\n        catch (error) {\n            if (pattern.silent) {\n                // Emit a single empty binding\n                output = {\n                    bindingsStream: new asynciterator_1.SingletonIterator(bus_query_operation_1.Bindings({})),\n                    type: 'bindings',\n                    variables: [],\n                    canContainUndefs: false,\n                };\n            }\n            else {\n                throw error;\n            }\n        }\n        return output;\n    }\n}\nexports.ActorQueryOperationService = ActorQueryOperationService;\n//# sourceMappingURL=ActorQueryOperationService.js.map"]},"metadata":{},"sourceType":"script"}