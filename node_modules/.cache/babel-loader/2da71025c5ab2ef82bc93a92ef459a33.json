{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultExpandOptions = exports.ContextParser = void 0;\n\nrequire(\"cross-fetch/polyfill\");\n\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\n\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\n\nconst FetchDocumentLoader_1 = require(\"./FetchDocumentLoader\");\n\nconst JsonLdContextNormalized_1 = require(\"./JsonLdContextNormalized\");\n\nconst Util_1 = require(\"./Util\"); // tslint:disable-next-line:no-var-requires\n\n\nconst canonicalizeJson = require('canonicalize');\n/**\n * Parses JSON-LD contexts.\n */\n\n\nclass ContextParser {\n  constructor(options) {\n    options = options || {};\n    this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();\n    this.documentCache = {};\n    this.validateContext = !options.skipValidation;\n    this.expandContentTypeToBase = !!options.expandContentTypeToBase;\n    this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;\n    this.redirectSchemaOrgHttps = 'redirectSchemaOrgHttps' in options ? !!options.redirectSchemaOrgHttps : true;\n  }\n  /**\n   * Validate the given @language value.\n   * An error will be thrown if it is invalid.\n   * @param value An @language value.\n   * @param {boolean} strictRange If the string value should be strictly checked against a regex.\n   * @param {string} errorCode The error code to emit on errors.\n   * @return {boolean} If validation passed.\n   *                   Can only be false if strictRange is false and the string value did not pass the regex.\n   */\n\n\n  static validateLanguage(value, strictRange, errorCode) {\n    if (typeof value !== 'string') {\n      throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);\n    }\n\n    if (!Util_1.Util.REGEX_LANGUAGE_TAG.test(value)) {\n      if (strictRange) {\n        throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(value)}'`, errorCode);\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Validate the given @direction value.\n   * An error will be thrown if it is invalid.\n   * @param value An @direction value.\n   * @param {boolean} strictValues If the string value should be strictly checked against a regex.\n   * @return {boolean} If validation passed.\n   *                   Can only be false if strictRange is false and the string value did not pass the regex.\n   */\n\n\n  static validateDirection(value, strictValues) {\n    if (typeof value !== 'string') {\n      throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n    }\n\n    if (!Util_1.Util.REGEX_DIRECTION_TAG.test(value)) {\n      if (strictValues) {\n        throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Add an @id term for all @reverse terms.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n   */\n\n\n  idifyReverseTerms(context) {\n    for (const key of Object.keys(context)) {\n      const value = context[key];\n\n      if (value && typeof value === 'object') {\n        if (value['@reverse'] && !value['@id']) {\n          if (typeof value['@reverse'] !== 'string' || Util_1.Util.isValidKeyword(value['@reverse'])) {\n            throw new ErrorCoded_1.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value['@reverse']}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n          }\n\n          value['@id'] = value['@reverse'];\n\n          if (Util_1.Util.isPotentialKeyword(value['@reverse'])) {\n            delete value['@reverse'];\n          } else {\n            value['@reverse'] = true;\n          }\n        }\n      }\n    }\n\n    return context;\n  }\n  /**\n   * Expand all prefixed terms in the given context.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n   *                                          via @base if @vocab is set to null.\n   */\n\n\n  expandPrefixedTerms(context, expandContentTypeToBase) {\n    const contextRaw = context.getContextRaw();\n\n    for (const key of Object.keys(contextRaw)) {\n      // Only expand allowed keys\n      if (Util_1.Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util_1.Util.isReservedInternalKeyword(key)) {\n        // Error if we try to alias a keyword to something else.\n        const keyValue = contextRaw[key];\n\n        if (Util_1.Util.isPotentialKeyword(key) && Util_1.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {\n          if (key !== '@type' || typeof contextRaw[key] === 'object' && !(contextRaw[key]['@protected'] || contextRaw[key]['@container'] === '@set')) {\n            throw new ErrorCoded_1.ErrorCoded(`Keywords can not be aliased to something else.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n          }\n        } // Error if we try to alias to an illegal keyword\n\n\n        if (Util_1.Util.ALIAS_RANGE_BLACKLIST.indexOf(Util_1.Util.getContextValueId(keyValue)) >= 0) {\n          throw new ErrorCoded_1.ErrorCoded(`Aliasing to certain keywords is not allowed.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.INVALID_KEYWORD_ALIAS);\n        } // Error if this term was marked as prefix as well\n\n\n        if (keyValue && Util_1.Util.isPotentialKeyword(Util_1.Util.getContextValueId(keyValue)) && keyValue['@prefix'] === true) {\n          throw new ErrorCoded_1.ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n        } // Loop because prefixes might be nested\n\n\n        while (Util_1.Util.isPrefixValue(contextRaw[key])) {\n          const value = contextRaw[key];\n          let changed = false;\n\n          if (typeof value === 'string') {\n            contextRaw[key] = context.expandTerm(value, true);\n            changed = changed || value !== contextRaw[key];\n          } else {\n            const id = value['@id'];\n            const type = value['@type']; // If @id is missing, don't allow @id to be added if @prefix: true and key not being a valid IRI.\n\n            const canAddIdEntry = !('@prefix' in value) || Util_1.Util.isValidIri(key);\n\n            if ('@id' in value) {\n              // Use @id value for expansion\n              if (id !== undefined && id !== null && typeof id === 'string') {\n                contextRaw[key]['@id'] = context.expandTerm(id, true);\n                changed = changed || id !== contextRaw[key]['@id'];\n              }\n            } else if (!Util_1.Util.isPotentialKeyword(key) && canAddIdEntry) {\n              // Add an explicit @id value based on the expanded key value\n              const newId = context.expandTerm(key, true);\n\n              if (newId !== key) {\n                // Don't set @id if expansion failed\n                contextRaw[key]['@id'] = newId;\n                changed = true;\n              }\n            }\n\n            if (type && typeof type === 'string' && type !== '@vocab' && (!value['@container'] || !value['@container']['@type']) && canAddIdEntry) {\n              // First check @vocab, then fallback to @base\n              contextRaw[key]['@type'] = context.expandTerm(type, true);\n\n              if (expandContentTypeToBase && type === contextRaw[key]['@type']) {\n                contextRaw[key]['@type'] = context.expandTerm(type, false);\n              }\n\n              changed = changed || type !== contextRaw[key]['@type'];\n            }\n          }\n\n          if (!changed) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Normalize the @language entries in the given context to lowercase.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {IParseOptions} parseOptions The parsing options.\n   */\n\n\n  normalize(context, {\n    processingMode,\n    normalizeLanguageTags\n  }) {\n    // Lowercase language keys in 1.0\n    if (normalizeLanguageTags || processingMode === 1.0) {\n      for (const key of Object.keys(context)) {\n        if (key === '@language' && typeof context[key] === 'string') {\n          context[key] = context[key].toLowerCase();\n        } else {\n          const value = context[key];\n\n          if (value && typeof value === 'object') {\n            if (typeof value['@language'] === 'string') {\n              value['@language'] = value['@language'].toLowerCase();\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Convert all @container strings and array values to hash-based values.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   */\n\n\n  containersToHash(context) {\n    for (const key of Object.keys(context)) {\n      const value = context[key];\n\n      if (value && typeof value === 'object') {\n        if (typeof value['@container'] === 'string') {\n          value['@container'] = {\n            [value['@container']]: true\n          };\n        } else if (Array.isArray(value['@container'])) {\n          const newValue = {};\n\n          for (const containerValue of value['@container']) {\n            newValue[containerValue] = true;\n          }\n\n          value['@container'] = newValue;\n        }\n      }\n    }\n  }\n  /**\n   * Normalize and apply context-levevl @protected terms onto each term separately.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {number} processingMode The processing mode.\n   */\n\n\n  applyScopedProtected(context, {\n    processingMode\n  }) {\n    if (processingMode && processingMode >= 1.1) {\n      if (context['@protected']) {\n        for (const key of Object.keys(context)) {\n          if (Util_1.Util.isReservedInternalKeyword(key)) {\n            continue;\n          }\n\n          if (!Util_1.Util.isPotentialKeyword(key) && !Util_1.Util.isTermProtected(context, key)) {\n            const value = context[key];\n\n            if (value && typeof value === 'object') {\n              if (!('@protected' in context[key])) {\n                // Mark terms with object values as protected if they don't have an @protected: false annotation\n                context[key]['@protected'] = true;\n              }\n            } else {\n              // Convert string-based term values to object-based values with @protected: true\n              context[key] = {\n                '@id': value,\n                '@protected': true\n              };\n            }\n          }\n        }\n\n        delete context['@protected'];\n      }\n    }\n  }\n  /**\n   * Check if the given context inheritance does not contain any overrides of protected terms.\n   * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.\n   * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.\n   * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.\n   */\n\n\n  validateKeywordRedefinitions(contextBefore, contextAfter, expandOptions) {\n    for (const key of Object.keys(contextAfter)) {\n      if (Util_1.Util.isTermProtected(contextBefore, key)) {\n        // The entry in the context before will always be in object-mode\n        // If the new entry is in string-mode, convert it to object-mode\n        // before checking if it is identical.\n        if (typeof contextAfter[key] === 'string') {\n          const isPrefix = Util_1.Util.isSimpleTermDefinitionPrefix(contextAfter[key], expandOptions);\n          contextAfter[key] = {\n            '@id': contextAfter[key]\n          }; // If the simple term def was a prefix, explicitly mark the term as a prefix in the expanded term definition,\n          // because otherwise we loose this information due to JSON-LD interpreting prefixes differently\n          // in simple vs expanded term definitions.\n\n          if (isPrefix) {\n            contextAfter[key]['@prefix'] = true;\n            contextBefore[key]['@prefix'] = true; // Also on before, to make sure the next step still considers them ==\n          }\n        } // Convert term values to strings for each comparison\n\n\n        const valueBefore = canonicalizeJson(contextBefore[key]); // We modify this deliberately,\n        // as we need it for the value comparison (they must be identical modulo '@protected')),\n        // and for the fact that this new value will override the first one.\n\n        contextAfter[key]['@protected'] = true;\n        const valueAfter = canonicalizeJson(contextAfter[key]); // Error if they are not identical\n\n        if (valueBefore !== valueAfter) {\n          throw new ErrorCoded_1.ErrorCoded(`Attempted to override the protected keyword ${key} from ${JSON.stringify(Util_1.Util.getContextValueId(contextBefore[key]))} to ${JSON.stringify(Util_1.Util.getContextValueId(contextAfter[key]))}`, ErrorCoded_1.ERROR_CODES.PROTECTED_TERM_REDEFINITION);\n        }\n      }\n    }\n  }\n  /**\n   * Validate the entries of the given context.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {IParseOptions} options The parse options.\n   */\n\n\n  validate(context, {\n    processingMode\n  }) {\n    for (const key of Object.keys(context)) {\n      // Ignore reserved internal keywords.\n      if (Util_1.Util.isReservedInternalKeyword(key)) {\n        continue;\n      } // Do not allow empty term\n\n\n      if (key === '') {\n        throw new ErrorCoded_1.ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n      }\n\n      const value = context[key];\n      const valueType = typeof value; // First check if the key is a keyword\n\n      if (Util_1.Util.isPotentialKeyword(key)) {\n        switch (key.substr(1)) {\n          case 'vocab':\n            if (value !== null && valueType !== 'string') {\n              throw new ErrorCoded_1.ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n            }\n\n            break;\n\n          case 'base':\n            if (value !== null && valueType !== 'string') {\n              throw new ErrorCoded_1.ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_IRI);\n            }\n\n            break;\n\n          case 'language':\n            if (value !== null) {\n              ContextParser.validateLanguage(value, true, ErrorCoded_1.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);\n            }\n\n            break;\n\n          case 'version':\n            if (value !== null && valueType !== 'number') {\n              throw new ErrorCoded_1.ErrorCoded(`Found an invalid @version number: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n            }\n\n            break;\n\n          case 'direction':\n            if (value !== null) {\n              ContextParser.validateDirection(value, true);\n            }\n\n            break;\n\n          case 'propagate':\n            if (processingMode === 1.0) {\n              throw new ErrorCoded_1.ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n            }\n\n            if (value !== null && valueType !== 'boolean') {\n              throw new ErrorCoded_1.ErrorCoded(`Found an invalid @propagate value: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_PROPAGATE_VALUE);\n            }\n\n            break;\n        } // Don't allow keywords to be overridden\n\n\n        if (Util_1.Util.isValidKeyword(key) && Util_1.Util.isValidKeyword(Util_1.Util.getContextValueId(value))) {\n          throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util_1.Util.getContextValueId(value)}'`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n        }\n\n        continue;\n      } // Otherwise, consider the key a term\n\n\n      if (value !== null) {\n        switch (valueType) {\n          case 'string':\n            if (Util_1.Util.getPrefix(value, context) === key) {\n              throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n            }\n\n            if (Util_1.Util.isValidIriWeak(key)) {\n              if (value === '@type') {\n                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n              } else if (Util_1.Util.isValidIri(value) && value !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n              }\n            }\n\n            break;\n\n          case 'object':\n            if (!Util_1.Util.isCompactIri(key) && !('@id' in value) && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n              throw new ErrorCoded_1.ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n            }\n\n            for (const objectKey of Object.keys(value)) {\n              const objectValue = value[objectKey];\n\n              if (!objectValue) {\n                continue;\n              }\n\n              switch (objectKey) {\n                case '@id':\n                  if (Util_1.Util.isValidKeyword(objectValue) && objectValue !== '@type' && objectValue !== '@id' && objectValue !== '@graph') {\n                    throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                  }\n\n                  if (Util_1.Util.isValidIriWeak(key)) {\n                    if (objectValue === '@type') {\n                      throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                    } else if (Util_1.Util.isValidIri(objectValue) && objectValue !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                      throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                    }\n                  }\n\n                  if (typeof objectValue !== 'string') {\n                    throw new ErrorCoded_1.ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                  }\n\n                  if (Util_1.Util.getPrefix(objectValue, context) === key) {\n                    throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                  }\n\n                  break;\n\n                case '@type':\n                  if (value['@container'] === '@type' && objectValue !== '@id' && objectValue !== '@vocab') {\n                    throw new ErrorCoded_1.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                  }\n\n                  if (typeof objectValue !== 'string') {\n                    throw new ErrorCoded_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                  }\n\n                  if (objectValue !== '@id' && objectValue !== '@vocab' && (processingMode === 1.0 || objectValue !== '@json') && (processingMode === 1.0 || objectValue !== '@none') && (objectValue[0] === '_' || !Util_1.Util.isValidIri(objectValue))) {\n                    throw new ErrorCoded_1.ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                  }\n\n                  break;\n\n                case '@reverse':\n                  if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                    throw new ErrorCoded_1.ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':\\\n'${objectValue}' and '${value['@id']}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                  }\n\n                  if ('@nest' in value) {\n                    throw new ErrorCoded_1.ErrorCoded(`@nest is not allowed in the reverse property '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                  }\n\n                  break;\n\n                case '@container':\n                  if (processingMode === 1.0) {\n                    if (Object.keys(objectValue).length > 1 || Util_1.Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {\n                      throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, \\\nmust be only one of ${Util_1.Util.CONTAINERS_1_0.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                    }\n                  }\n\n                  for (const containerValue of Object.keys(objectValue)) {\n                    if (containerValue === '@list' && value['@reverse']) {\n                      throw new ErrorCoded_1.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                    }\n\n                    if (Util_1.Util.CONTAINERS.indexOf(containerValue) < 0) {\n                      throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), \\\nmust be one of ${Util_1.Util.CONTAINERS.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                    }\n                  }\n\n                  break;\n\n                case '@language':\n                  ContextParser.validateLanguage(objectValue, true, ErrorCoded_1.ERROR_CODES.INVALID_LANGUAGE_MAPPING);\n                  break;\n\n                case '@direction':\n                  ContextParser.validateDirection(objectValue, true);\n                  break;\n\n                case '@prefix':\n                  if (objectValue !== null && typeof objectValue !== 'boolean') {\n                    throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_PREFIX_VALUE);\n                  }\n\n                  if (!('@id' in value) && !Util_1.Util.isValidIri(key)) {\n                    throw new ErrorCoded_1.ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                  }\n\n                  break;\n\n                case '@index':\n                  if (processingMode === 1.0 || !value['@container'] || !value['@container']['@index']) {\n                    throw new ErrorCoded_1.ErrorCoded(`Attempt to add illegal key to value object: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                  }\n\n                  break;\n\n                case '@nest':\n                  if (Util_1.Util.isPotentialKeyword(objectValue) && objectValue !== '@nest') {\n                    throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_NEST_VALUE);\n                  }\n\n              }\n            }\n\n            break;\n\n          default:\n            throw new ErrorCoded_1.ErrorCoded(`Found an invalid term value: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n        }\n      }\n    }\n  }\n  /**\n   * Apply the @base context entry to the given context under certain circumstances.\n   * @param context A context.\n   * @param options Parsing options.\n   * @param inheritFromParent If the @base value from the parent context can be inherited.\n   * @return The given context.\n   */\n\n\n  applyBaseEntry(context, options, inheritFromParent) {\n    // In some special cases, this can be a string, so ignore those.\n    if (typeof context === 'string') {\n      return context;\n    } // Give priority to @base in the parent context\n\n\n    if (inheritFromParent && !('@base' in context) && options.parentContext && typeof options.parentContext === 'object' && '@base' in options.parentContext) {\n      context['@base'] = options.parentContext['@base'];\n\n      if (options.parentContext['@__baseDocument']) {\n        context['@__baseDocument'] = true;\n      }\n    } // Override the base IRI if provided.\n\n\n    if (options.baseIRI && !options.external) {\n      if (!('@base' in context)) {\n        // The context base is the document base\n        context['@base'] = options.baseIRI;\n        context['@__baseDocument'] = true;\n      } else if (context['@base'] !== null && typeof context['@base'] === 'string' && !Util_1.Util.isValidIri(context['@base'])) {\n        // The context base is relative to the document base\n        context['@base'] = relative_to_absolute_iri_1.resolve(context['@base'], options.parentContext && options.parentContext['@base'] || options.baseIRI);\n      }\n    }\n\n    return context;\n  }\n  /**\n   * Resolve relative context IRIs, or return full IRIs as-is.\n   * @param {string} contextIri A context IRI.\n   * @param {string} baseIRI A base IRI.\n   * @return {string} The normalized context IRI.\n   */\n\n\n  normalizeContextIri(contextIri, baseIRI) {\n    if (!Util_1.Util.isValidIri(contextIri)) {\n      contextIri = relative_to_absolute_iri_1.resolve(contextIri, baseIRI);\n\n      if (!Util_1.Util.isValidIri(contextIri)) {\n        throw new Error(`Invalid context IRI: ${contextIri}`);\n      }\n    } // TODO: Temporary workaround for fixing schema.org CORS issues (https://github.com/schemaorg/schemaorg/issues/2578#issuecomment-652324465)\n\n\n    if (this.redirectSchemaOrgHttps && contextIri.startsWith('http://schema.org')) {\n      contextIri = 'https://schema.org/';\n    }\n\n    return contextIri;\n  }\n  /**\n   * Parse scoped contexts in the given context.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {IParseOptions} options Parsing options.\n   * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n   */\n\n\n  async parseInnerContexts(context, options) {\n    for (const key of Object.keys(context)) {\n      const value = context[key];\n\n      if (value && typeof value === 'object') {\n        if ('@context' in value && value['@context'] !== null && !options.ignoreScopedContexts) {\n          // Simulate a processing based on the parent context to check if there are any (potential errors).\n          // Honestly, I find it a bit weird to do this here, as the context may be unused,\n          // and the final effective context may differ based on any other embedded/scoped contexts.\n          // But hey, it's part of the spec, so we have no choice...\n          // https://w3c.github.io/json-ld-api/#h-note-10\n          if (this.validateContext) {\n            try {\n              const parentContext = Object.assign({}, context);\n              parentContext[key] = Object.assign({}, parentContext[key]);\n              delete parentContext[key]['@context'];\n              await this.parse(value['@context'], Object.assign(Object.assign({}, options), {\n                parentContext,\n                ignoreProtection: true,\n                ignoreRemoteScopedContexts: true,\n                ignoreScopedContexts: true\n              }));\n            } catch (e) {\n              throw new ErrorCoded_1.ErrorCoded(e.message, ErrorCoded_1.ERROR_CODES.INVALID_SCOPED_CONTEXT);\n            }\n          }\n\n          value['@context'] = (await this.parse(value['@context'], Object.assign(Object.assign({}, options), {\n            minimalProcessing: true,\n            ignoreRemoteScopedContexts: true,\n            parentContext: context\n          }))).getContextRaw();\n        }\n      }\n    }\n\n    return context;\n  }\n  /**\n   * Parse a JSON-LD context in any form.\n   * @param {JsonLdContext} context A context, URL to a context, or an array of contexts/URLs.\n   * @param {IParseOptions} options Optional parsing options.\n   * @return {Promise<JsonLdContextNormalized>} A promise resolving to the context.\n   */\n\n\n  async parse(context, options = {\n    processingMode: ContextParser.DEFAULT_PROCESSING_MODE\n  }) {\n    const {\n      baseIRI,\n      parentContext: parentContextInitial,\n      external,\n      processingMode,\n      normalizeLanguageTags,\n      ignoreProtection,\n      minimalProcessing\n    } = options;\n    let parentContext = parentContextInitial;\n    const remoteContexts = options.remoteContexts || {}; // Avoid remote context overflows\n\n    if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {\n      throw new ErrorCoded_1.ErrorCoded('Detected an overflow in remote context inclusions: ' + Object.keys(remoteContexts), ErrorCoded_1.ERROR_CODES.CONTEXT_OVERFLOW);\n    }\n\n    if (context === null || context === undefined) {\n      // Don't allow context nullification and there are protected terms\n      if (!ignoreProtection && parentContext && Util_1.Util.hasProtectedTerms(parentContext)) {\n        throw new ErrorCoded_1.ErrorCoded('Illegal context nullification when terms are protected', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);\n      } // Context that are explicitly set to null are empty.\n\n\n      return new JsonLdContextNormalized_1.JsonLdContextNormalized(this.applyBaseEntry({}, options, false));\n    } else if (typeof context === 'string') {\n      const contextIri = this.normalizeContextIri(context, baseIRI);\n      const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n\n      if (overriddenLoad) {\n        return new JsonLdContextNormalized_1.JsonLdContextNormalized(overriddenLoad);\n      }\n\n      const parsedStringContext = await this.parse(await this.load(contextIri), Object.assign(Object.assign({}, options), {\n        baseIRI: contextIri,\n        external: true,\n        remoteContexts: Object.assign(Object.assign({}, remoteContexts), {\n          [contextIri]: true\n        })\n      }));\n      this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);\n      return parsedStringContext;\n    } else if (Array.isArray(context)) {\n      // As a performance consideration, first load all external contexts in parallel.\n      const contextIris = [];\n      const contexts = await Promise.all(context.map((subContext, i) => {\n        if (typeof subContext === 'string') {\n          const contextIri = this.normalizeContextIri(subContext, baseIRI);\n          contextIris[i] = contextIri;\n          const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n\n          if (overriddenLoad) {\n            return overriddenLoad;\n          }\n\n          return this.load(contextIri);\n        } else {\n          return subContext;\n        }\n      })); // Don't apply inheritance logic on minimal processing\n\n      if (minimalProcessing) {\n        return new JsonLdContextNormalized_1.JsonLdContextNormalized(contexts);\n      }\n\n      const reducedContexts = await contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise.then(accContext => this.parse(contextEntry, Object.assign(Object.assign({}, options), {\n        baseIRI: contextIris[i] || options.baseIRI,\n        external: !!contextIris[i] || options.external,\n        parentContext: accContext.getContextRaw(),\n        remoteContexts: contextIris[i] ? Object.assign(Object.assign({}, remoteContexts), {\n          [contextIris[i]]: true\n        }) : remoteContexts\n      }))), Promise.resolve(new JsonLdContextNormalized_1.JsonLdContextNormalized(parentContext || {}))); // Override the base IRI if provided.\n\n      this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);\n      return reducedContexts;\n    } else if (typeof context === 'object') {\n      if ('@context' in context) {\n        return await this.parse(context['@context'], options);\n      } // Make a deep clone of the given context, to avoid modifying it.\n\n\n      context = JSON.parse(JSON.stringify(context)); // No better way in JS at the moment.\n\n      if (parentContext && !minimalProcessing) {\n        parentContext = JSON.parse(JSON.stringify(parentContext));\n      } // We have an actual context object.\n\n\n      let newContext = {}; // According to the JSON-LD spec, @base must be ignored from external contexts.\n\n      if (external) {\n        delete context['@base'];\n      } // Override the base IRI if provided.\n\n\n      this.applyBaseEntry(context, options, true); // Hashify container entries\n      // Do this before protected term validation as that influences term format\n\n      this.containersToHash(context); // Don't perform any other modifications if only minimal processing is needed.\n\n      if (minimalProcessing) {\n        return new JsonLdContextNormalized_1.JsonLdContextNormalized(context);\n      } // In JSON-LD 1.1, load @import'ed context prior to processing.\n\n\n      let importContext = {};\n\n      if ('@import' in context) {\n        if (processingMode && processingMode >= 1.1) {\n          // Only accept string values\n          if (typeof context['@import'] !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded('An @import value must be a string, but got ' + typeof context['@import'], ErrorCoded_1.ERROR_CODES.INVALID_IMPORT_VALUE);\n          } // Load context\n\n\n          importContext = await this.loadImportContext(this.normalizeContextIri(context['@import'], baseIRI));\n          delete context['@import'];\n        } else {\n          throw new ErrorCoded_1.ErrorCoded('Context importing is not supported in JSON-LD 1.0', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n        }\n      } // Merge different parts of the final context in order\n\n\n      newContext = Object.assign(Object.assign(Object.assign(Object.assign({}, newContext), typeof parentContext === 'object' ? parentContext : {}), importContext), context);\n      const newContextWrapped = new JsonLdContextNormalized_1.JsonLdContextNormalized(newContext); // Parse inner contexts with minimal processing\n\n      await this.parseInnerContexts(newContext, options); // In JSON-LD 1.1, check if we are not redefining any protected keywords\n\n      if (!ignoreProtection && parentContext && processingMode && processingMode >= 1.1) {\n        this.validateKeywordRedefinitions(parentContext, newContext, exports.defaultExpandOptions);\n      } // In JSON-LD 1.1, @vocab can be relative to @vocab in the parent context.\n\n\n      if ((newContext && newContext['@version'] || processingMode || ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1 && (context['@vocab'] && typeof context['@vocab'] === 'string' || context['@vocab'] === '') && context['@vocab'].indexOf(':') < 0 && parentContext && '@vocab' in parentContext) {\n        newContext['@vocab'] = parentContext['@vocab'] + context['@vocab'];\n      }\n\n      this.idifyReverseTerms(newContext);\n      this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase);\n      this.normalize(newContext, {\n        processingMode,\n        normalizeLanguageTags\n      });\n      this.applyScopedProtected(newContext, {\n        processingMode\n      });\n\n      if (this.validateContext) {\n        this.validate(newContext, {\n          processingMode\n        });\n      }\n\n      return newContextWrapped;\n    } else {\n      throw new ErrorCoded_1.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`, ErrorCoded_1.ERROR_CODES.INVALID_LOCAL_CONTEXT);\n    }\n  }\n  /**\n   * Fetch the given URL as a raw JSON-LD context.\n   * @param url An URL.\n   * @return A promise resolving to a raw JSON-LD context.\n   */\n\n\n  async load(url) {\n    // First try to retrieve the context from cache\n    const cached = this.documentCache[url];\n\n    if (cached) {\n      return typeof cached === 'string' ? cached : Array.isArray(cached) ? cached.slice() : Object.assign({}, cached);\n    } // If not in cache, load it\n\n\n    let document;\n\n    try {\n      document = await this.documentLoader.load(url);\n    } catch (e) {\n      throw new ErrorCoded_1.ErrorCoded(`Failed to load remote context ${url}: ${e.message}`, ErrorCoded_1.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);\n    } // Validate the context\n\n\n    if (!('@context' in document)) {\n      throw new ErrorCoded_1.ErrorCoded(`Missing @context in remote context at ${url}`, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n    }\n\n    return this.documentCache[url] = document['@context'];\n  }\n  /**\n   * Override the given context that may be loaded.\n   *\n   * This will check whether or not the url is recursively being loaded.\n   * @param url An URL.\n   * @param options Parsing options.\n   * @return An overridden context, or null.\n   *         Optionally an error can be thrown if a cyclic context is detected.\n   */\n\n\n  getOverriddenLoad(url, options) {\n    if (url in (options.remoteContexts || {})) {\n      if (options.ignoreRemoteScopedContexts) {\n        return url;\n      } else {\n        throw new ErrorCoded_1.ErrorCoded('Detected a cyclic context inclusion of ' + url, ErrorCoded_1.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Load an @import'ed context.\n   * @param importContextIri The full URI of an @import value.\n   */\n\n\n  async loadImportContext(importContextIri) {\n    // Load the context\n    const importContext = await this.load(importContextIri); // Require the context to be a non-array object\n\n    if (typeof importContext !== 'object' || Array.isArray(importContext)) {\n      throw new ErrorCoded_1.ErrorCoded('An imported context must be a single object: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n    } // Error if the context contains another @import\n\n\n    if ('@import' in importContext) {\n      throw new ErrorCoded_1.ErrorCoded('An imported context can not import another context: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n    }\n\n    return importContext;\n  }\n\n}\n\nexports.ContextParser = ContextParser;\nContextParser.DEFAULT_PROCESSING_MODE = 1.1;\nexports.defaultExpandOptions = {\n  allowPrefixForcing: true,\n  allowPrefixNonGenDelims: false,\n  allowVocabRelativeToBase: true\n};","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-context-parser/lib/ContextParser.js"],"names":["Object","defineProperty","exports","value","defaultExpandOptions","ContextParser","require","relative_to_absolute_iri_1","ErrorCoded_1","FetchDocumentLoader_1","JsonLdContextNormalized_1","Util_1","canonicalizeJson","constructor","options","documentLoader","FetchDocumentLoader","documentCache","validateContext","skipValidation","expandContentTypeToBase","remoteContextsDepthLimit","redirectSchemaOrgHttps","validateLanguage","strictRange","errorCode","ErrorCoded","JSON","stringify","Util","REGEX_LANGUAGE_TAG","test","validateDirection","strictValues","ERROR_CODES","INVALID_BASE_DIRECTION","REGEX_DIRECTION_TAG","idifyReverseTerms","context","key","keys","isValidKeyword","INVALID_IRI_MAPPING","isPotentialKeyword","expandPrefixedTerms","contextRaw","getContextRaw","EXPAND_KEYS_BLACKLIST","indexOf","isReservedInternalKeyword","keyValue","ALIAS_DOMAIN_BLACKLIST","KEYWORD_REDEFINITION","ALIAS_RANGE_BLACKLIST","getContextValueId","INVALID_KEYWORD_ALIAS","INVALID_TERM_DEFINITION","isPrefixValue","changed","expandTerm","id","type","canAddIdEntry","isValidIri","undefined","newId","normalize","processingMode","normalizeLanguageTags","toLowerCase","containersToHash","Array","isArray","newValue","containerValue","applyScopedProtected","isTermProtected","validateKeywordRedefinitions","contextBefore","contextAfter","expandOptions","isPrefix","isSimpleTermDefinitionPrefix","valueBefore","valueAfter","PROTECTED_TERM_REDEFINITION","validate","valueType","substr","INVALID_VOCAB_MAPPING","INVALID_BASE_IRI","INVALID_DEFAULT_LANGUAGE","INVALID_VERSION_VALUE","INVALID_CONTEXT_ENTRY","INVALID_PROPAGATE_VALUE","getPrefix","CYCLIC_IRI_MAPPING","isValidIriWeak","JsonLdContextNormalized","isCompactIri","objectKey","objectValue","INVALID_TYPE_MAPPING","INVALID_REVERSE_PROPERTY","length","CONTAINERS_1_0","join","INVALID_CONTAINER_MAPPING","CONTAINERS","INVALID_LANGUAGE_MAPPING","INVALID_PREFIX_VALUE","INVALID_NEST_VALUE","applyBaseEntry","inheritFromParent","parentContext","baseIRI","external","resolve","normalizeContextIri","contextIri","Error","startsWith","parseInnerContexts","ignoreScopedContexts","assign","parse","ignoreProtection","ignoreRemoteScopedContexts","e","message","INVALID_SCOPED_CONTEXT","minimalProcessing","DEFAULT_PROCESSING_MODE","parentContextInitial","remoteContexts","CONTEXT_OVERFLOW","hasProtectedTerms","INVALID_CONTEXT_NULLIFICATION","overriddenLoad","getOverriddenLoad","parsedStringContext","load","contextIris","contexts","Promise","all","map","subContext","i","reducedContexts","reduce","accContextPromise","contextEntry","then","accContext","newContext","importContext","INVALID_IMPORT_VALUE","loadImportContext","newContextWrapped","INVALID_LOCAL_CONTEXT","url","cached","slice","document","LOADING_REMOTE_CONTEXT_FAILED","INVALID_REMOTE_CONTEXT","RECURSIVE_CONTEXT_INCLUSION","importContextIri","allowPrefixForcing","allowPrefixNonGenDelims","allowVocabRelativeToBase"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultExpandOptions = exports.ContextParser = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst FetchDocumentLoader_1 = require(\"./FetchDocumentLoader\");\nconst JsonLdContextNormalized_1 = require(\"./JsonLdContextNormalized\");\nconst Util_1 = require(\"./Util\");\n// tslint:disable-next-line:no-var-requires\nconst canonicalizeJson = require('canonicalize');\n/**\n * Parses JSON-LD contexts.\n */\nclass ContextParser {\n    constructor(options) {\n        options = options || {};\n        this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();\n        this.documentCache = {};\n        this.validateContext = !options.skipValidation;\n        this.expandContentTypeToBase = !!options.expandContentTypeToBase;\n        this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;\n        this.redirectSchemaOrgHttps = 'redirectSchemaOrgHttps' in options ? !!options.redirectSchemaOrgHttps : true;\n    }\n    /**\n     * Validate the given @language value.\n     * An error will be thrown if it is invalid.\n     * @param value An @language value.\n     * @param {boolean} strictRange If the string value should be strictly checked against a regex.\n     * @param {string} errorCode The error code to emit on errors.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateLanguage(value, strictRange, errorCode) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);\n        }\n        if (!Util_1.Util.REGEX_LANGUAGE_TAG.test(value)) {\n            if (strictRange) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(value)}'`, errorCode);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate the given @direction value.\n     * An error will be thrown if it is invalid.\n     * @param value An @direction value.\n     * @param {boolean} strictValues If the string value should be strictly checked against a regex.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateDirection(value, strictValues) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n        }\n        if (!Util_1.Util.REGEX_DIRECTION_TAG.test(value)) {\n            if (strictValues) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Add an @id term for all @reverse terms.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    idifyReverseTerms(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (value['@reverse'] && !value['@id']) {\n                    if (typeof value['@reverse'] !== 'string' || Util_1.Util.isValidKeyword(value['@reverse'])) {\n                        throw new ErrorCoded_1.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value['@reverse']}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                    }\n                    value['@id'] = value['@reverse'];\n                    if (Util_1.Util.isPotentialKeyword(value['@reverse'])) {\n                        delete value['@reverse'];\n                    }\n                    else {\n                        value['@reverse'] = true;\n                    }\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Expand all prefixed terms in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n     *                                          via @base if @vocab is set to null.\n     */\n    expandPrefixedTerms(context, expandContentTypeToBase) {\n        const contextRaw = context.getContextRaw();\n        for (const key of Object.keys(contextRaw)) {\n            // Only expand allowed keys\n            if (Util_1.Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util_1.Util.isReservedInternalKeyword(key)) {\n                // Error if we try to alias a keyword to something else.\n                const keyValue = contextRaw[key];\n                if (Util_1.Util.isPotentialKeyword(key) && Util_1.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {\n                    if (key !== '@type' || typeof contextRaw[key] === 'object'\n                        && !(contextRaw[key]['@protected'] || contextRaw[key]['@container'] === '@set')) {\n                        throw new ErrorCoded_1.ErrorCoded(`Keywords can not be aliased to something else.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                    }\n                }\n                // Error if we try to alias to an illegal keyword\n                if (Util_1.Util.ALIAS_RANGE_BLACKLIST.indexOf(Util_1.Util.getContextValueId(keyValue)) >= 0) {\n                    throw new ErrorCoded_1.ErrorCoded(`Aliasing to certain keywords is not allowed.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.INVALID_KEYWORD_ALIAS);\n                }\n                // Error if this term was marked as prefix as well\n                if (keyValue && Util_1.Util.isPotentialKeyword(Util_1.Util.getContextValueId(keyValue))\n                    && keyValue['@prefix'] === true) {\n                    throw new ErrorCoded_1.ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                // Loop because prefixes might be nested\n                while (Util_1.Util.isPrefixValue(contextRaw[key])) {\n                    const value = contextRaw[key];\n                    let changed = false;\n                    if (typeof value === 'string') {\n                        contextRaw[key] = context.expandTerm(value, true);\n                        changed = changed || value !== contextRaw[key];\n                    }\n                    else {\n                        const id = value['@id'];\n                        const type = value['@type'];\n                        // If @id is missing, don't allow @id to be added if @prefix: true and key not being a valid IRI.\n                        const canAddIdEntry = !('@prefix' in value) || Util_1.Util.isValidIri(key);\n                        if ('@id' in value) {\n                            // Use @id value for expansion\n                            if (id !== undefined && id !== null && typeof id === 'string') {\n                                contextRaw[key]['@id'] = context.expandTerm(id, true);\n                                changed = changed || id !== contextRaw[key]['@id'];\n                            }\n                        }\n                        else if (!Util_1.Util.isPotentialKeyword(key) && canAddIdEntry) {\n                            // Add an explicit @id value based on the expanded key value\n                            const newId = context.expandTerm(key, true);\n                            if (newId !== key) {\n                                // Don't set @id if expansion failed\n                                contextRaw[key]['@id'] = newId;\n                                changed = true;\n                            }\n                        }\n                        if (type && typeof type === 'string' && type !== '@vocab'\n                            && (!value['@container'] || !value['@container']['@type'])\n                            && canAddIdEntry) {\n                            // First check @vocab, then fallback to @base\n                            contextRaw[key]['@type'] = context.expandTerm(type, true);\n                            if (expandContentTypeToBase && type === contextRaw[key]['@type']) {\n                                contextRaw[key]['@type'] = context.expandTerm(type, false);\n                            }\n                            changed = changed || type !== contextRaw[key]['@type'];\n                        }\n                    }\n                    if (!changed) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Normalize the @language entries in the given context to lowercase.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} parseOptions The parsing options.\n     */\n    normalize(context, { processingMode, normalizeLanguageTags }) {\n        // Lowercase language keys in 1.0\n        if (normalizeLanguageTags || processingMode === 1.0) {\n            for (const key of Object.keys(context)) {\n                if (key === '@language' && typeof context[key] === 'string') {\n                    context[key] = context[key].toLowerCase();\n                }\n                else {\n                    const value = context[key];\n                    if (value && typeof value === 'object') {\n                        if (typeof value['@language'] === 'string') {\n                            value['@language'] = value['@language'].toLowerCase();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Convert all @container strings and array values to hash-based values.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     */\n    containersToHash(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (typeof value['@container'] === 'string') {\n                    value['@container'] = { [value['@container']]: true };\n                }\n                else if (Array.isArray(value['@container'])) {\n                    const newValue = {};\n                    for (const containerValue of value['@container']) {\n                        newValue[containerValue] = true;\n                    }\n                    value['@container'] = newValue;\n                }\n            }\n        }\n    }\n    /**\n     * Normalize and apply context-levevl @protected terms onto each term separately.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {number} processingMode The processing mode.\n     */\n    applyScopedProtected(context, { processingMode }) {\n        if (processingMode && processingMode >= 1.1) {\n            if (context['@protected']) {\n                for (const key of Object.keys(context)) {\n                    if (Util_1.Util.isReservedInternalKeyword(key)) {\n                        continue;\n                    }\n                    if (!Util_1.Util.isPotentialKeyword(key) && !Util_1.Util.isTermProtected(context, key)) {\n                        const value = context[key];\n                        if (value && typeof value === 'object') {\n                            if (!('@protected' in context[key])) {\n                                // Mark terms with object values as protected if they don't have an @protected: false annotation\n                                context[key]['@protected'] = true;\n                            }\n                        }\n                        else {\n                            // Convert string-based term values to object-based values with @protected: true\n                            context[key] = {\n                                '@id': value,\n                                '@protected': true,\n                            };\n                        }\n                    }\n                }\n                delete context['@protected'];\n            }\n        }\n    }\n    /**\n     * Check if the given context inheritance does not contain any overrides of protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.\n     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.\n     */\n    validateKeywordRedefinitions(contextBefore, contextAfter, expandOptions) {\n        for (const key of Object.keys(contextAfter)) {\n            if (Util_1.Util.isTermProtected(contextBefore, key)) {\n                // The entry in the context before will always be in object-mode\n                // If the new entry is in string-mode, convert it to object-mode\n                // before checking if it is identical.\n                if (typeof contextAfter[key] === 'string') {\n                    const isPrefix = Util_1.Util.isSimpleTermDefinitionPrefix(contextAfter[key], expandOptions);\n                    contextAfter[key] = { '@id': contextAfter[key] };\n                    // If the simple term def was a prefix, explicitly mark the term as a prefix in the expanded term definition,\n                    // because otherwise we loose this information due to JSON-LD interpreting prefixes differently\n                    // in simple vs expanded term definitions.\n                    if (isPrefix) {\n                        contextAfter[key]['@prefix'] = true;\n                        contextBefore[key]['@prefix'] = true; // Also on before, to make sure the next step still considers them ==\n                    }\n                }\n                // Convert term values to strings for each comparison\n                const valueBefore = canonicalizeJson(contextBefore[key]);\n                // We modify this deliberately,\n                // as we need it for the value comparison (they must be identical modulo '@protected')),\n                // and for the fact that this new value will override the first one.\n                contextAfter[key]['@protected'] = true;\n                const valueAfter = canonicalizeJson(contextAfter[key]);\n                // Error if they are not identical\n                if (valueBefore !== valueAfter) {\n                    throw new ErrorCoded_1.ErrorCoded(`Attempted to override the protected keyword ${key} from ${JSON.stringify(Util_1.Util.getContextValueId(contextBefore[key]))} to ${JSON.stringify(Util_1.Util.getContextValueId(contextAfter[key]))}`, ErrorCoded_1.ERROR_CODES.PROTECTED_TERM_REDEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Validate the entries of the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options The parse options.\n     */\n    validate(context, { processingMode }) {\n        for (const key of Object.keys(context)) {\n            // Ignore reserved internal keywords.\n            if (Util_1.Util.isReservedInternalKeyword(key)) {\n                continue;\n            }\n            // Do not allow empty term\n            if (key === '') {\n                throw new ErrorCoded_1.ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n            }\n            const value = context[key];\n            const valueType = typeof value;\n            // First check if the key is a keyword\n            if (Util_1.Util.isPotentialKeyword(key)) {\n                switch (key.substr(1)) {\n                    case 'vocab':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                        }\n                        break;\n                    case 'base':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_IRI);\n                        }\n                        break;\n                    case 'language':\n                        if (value !== null) {\n                            ContextParser.validateLanguage(value, true, ErrorCoded_1.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);\n                        }\n                        break;\n                    case 'version':\n                        if (value !== null && valueType !== 'number') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @version number: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n                        }\n                        break;\n                    case 'direction':\n                        if (value !== null) {\n                            ContextParser.validateDirection(value, true);\n                        }\n                        break;\n                    case 'propagate':\n                        if (processingMode === 1.0) {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                        }\n                        if (value !== null && valueType !== 'boolean') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @propagate value: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_PROPAGATE_VALUE);\n                        }\n                        break;\n                }\n                // Don't allow keywords to be overridden\n                if (Util_1.Util.isValidKeyword(key) && Util_1.Util.isValidKeyword(Util_1.Util.getContextValueId(value))) {\n                    throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util_1.Util\n                        .getContextValueId(value)}'`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                }\n                continue;\n            }\n            // Otherwise, consider the key a term\n            if (value !== null) {\n                switch (valueType) {\n                    case 'string':\n                        if (Util_1.Util.getPrefix(value, context) === key) {\n                            throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                        }\n                        if (Util_1.Util.isValidIriWeak(key)) {\n                            if (value === '@type') {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                            else if (Util_1.Util.isValidIri(value) && value !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                        }\n                        break;\n                    case 'object':\n                        if (!Util_1.Util.isCompactIri(key) && !('@id' in value)\n                            && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n                            throw new ErrorCoded_1.ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                        }\n                        for (const objectKey of Object.keys(value)) {\n                            const objectValue = value[objectKey];\n                            if (!objectValue) {\n                                continue;\n                            }\n                            switch (objectKey) {\n                                case '@id':\n                                    if (Util_1.Util.isValidKeyword(objectValue)\n                                        && objectValue !== '@type' && objectValue !== '@id' && objectValue !== '@graph') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.isValidIriWeak(key)) {\n                                        if (objectValue === '@type') {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                        else if (Util_1.Util.isValidIri(objectValue)\n                                            && objectValue !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.getPrefix(objectValue, context) === key) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                            .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                                    }\n                                    break;\n                                case '@type':\n                                    if (value['@container'] === '@type' && objectValue !== '@id' && objectValue !== '@vocab') {\n                                        throw new ErrorCoded_1.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(valueType)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (objectValue !== '@id' && objectValue !== '@vocab'\n                                        && (processingMode === 1.0 || objectValue !== '@json')\n                                        && (processingMode === 1.0 || objectValue !== '@none')\n                                        && (objectValue[0] === '_' || !Util_1.Util.isValidIri(objectValue))) {\n                                        throw new ErrorCoded_1.ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    break;\n                                case '@reverse':\n                                    if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':\\\n'${objectValue}' and '${value['@id']}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    if ('@nest' in value) {\n                                        throw new ErrorCoded_1.ErrorCoded(`@nest is not allowed in the reverse property '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    break;\n                                case '@container':\n                                    if (processingMode === 1.0) {\n                                        if (Object.keys(objectValue).length > 1\n                                            || Util_1.Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, \\\nmust be only one of ${Util_1.Util.CONTAINERS_1_0.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    for (const containerValue of Object.keys(objectValue)) {\n                                        if (containerValue === '@list' && value['@reverse']) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                        }\n                                        if (Util_1.Util.CONTAINERS.indexOf(containerValue) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), \\\nmust be one of ${Util_1.Util.CONTAINERS.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    break;\n                                case '@language':\n                                    ContextParser.validateLanguage(objectValue, true, ErrorCoded_1.ERROR_CODES.INVALID_LANGUAGE_MAPPING);\n                                    break;\n                                case '@direction':\n                                    ContextParser.validateDirection(objectValue, true);\n                                    break;\n                                case '@prefix':\n                                    if (objectValue !== null && typeof objectValue !== 'boolean') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_PREFIX_VALUE);\n                                    }\n                                    if (!('@id' in value) && !Util_1.Util.isValidIri(key)) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@index':\n                                    if (processingMode === 1.0 || !value['@container'] || !value['@container']['@index']) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Attempt to add illegal key to value object: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@nest':\n                                    if (Util_1.Util.isPotentialKeyword(objectValue) && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_NEST_VALUE);\n                                    }\n                            }\n                        }\n                        break;\n                    default:\n                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term value: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Apply the @base context entry to the given context under certain circumstances.\n     * @param context A context.\n     * @param options Parsing options.\n     * @param inheritFromParent If the @base value from the parent context can be inherited.\n     * @return The given context.\n     */\n    applyBaseEntry(context, options, inheritFromParent) {\n        // In some special cases, this can be a string, so ignore those.\n        if (typeof context === 'string') {\n            return context;\n        }\n        // Give priority to @base in the parent context\n        if (inheritFromParent && !('@base' in context) && options.parentContext\n            && typeof options.parentContext === 'object' && '@base' in options.parentContext) {\n            context['@base'] = options.parentContext['@base'];\n            if (options.parentContext['@__baseDocument']) {\n                context['@__baseDocument'] = true;\n            }\n        }\n        // Override the base IRI if provided.\n        if (options.baseIRI && !options.external) {\n            if (!('@base' in context)) {\n                // The context base is the document base\n                context['@base'] = options.baseIRI;\n                context['@__baseDocument'] = true;\n            }\n            else if (context['@base'] !== null && typeof context['@base'] === 'string'\n                && !Util_1.Util.isValidIri(context['@base'])) {\n                // The context base is relative to the document base\n                context['@base'] = relative_to_absolute_iri_1.resolve(context['@base'], options.parentContext && options.parentContext['@base'] || options.baseIRI);\n            }\n        }\n        return context;\n    }\n    /**\n     * Resolve relative context IRIs, or return full IRIs as-is.\n     * @param {string} contextIri A context IRI.\n     * @param {string} baseIRI A base IRI.\n     * @return {string} The normalized context IRI.\n     */\n    normalizeContextIri(contextIri, baseIRI) {\n        if (!Util_1.Util.isValidIri(contextIri)) {\n            contextIri = relative_to_absolute_iri_1.resolve(contextIri, baseIRI);\n            if (!Util_1.Util.isValidIri(contextIri)) {\n                throw new Error(`Invalid context IRI: ${contextIri}`);\n            }\n        }\n        // TODO: Temporary workaround for fixing schema.org CORS issues (https://github.com/schemaorg/schemaorg/issues/2578#issuecomment-652324465)\n        if (this.redirectSchemaOrgHttps && contextIri.startsWith('http://schema.org')) {\n            contextIri = 'https://schema.org/';\n        }\n        return contextIri;\n    }\n    /**\n     * Parse scoped contexts in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options Parsing options.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    async parseInnerContexts(context, options) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if ('@context' in value && value['@context'] !== null && !options.ignoreScopedContexts) {\n                    // Simulate a processing based on the parent context to check if there are any (potential errors).\n                    // Honestly, I find it a bit weird to do this here, as the context may be unused,\n                    // and the final effective context may differ based on any other embedded/scoped contexts.\n                    // But hey, it's part of the spec, so we have no choice...\n                    // https://w3c.github.io/json-ld-api/#h-note-10\n                    if (this.validateContext) {\n                        try {\n                            const parentContext = Object.assign({}, context);\n                            parentContext[key] = Object.assign({}, parentContext[key]);\n                            delete parentContext[key]['@context'];\n                            await this.parse(value['@context'], Object.assign(Object.assign({}, options), { parentContext, ignoreProtection: true, ignoreRemoteScopedContexts: true, ignoreScopedContexts: true }));\n                        }\n                        catch (e) {\n                            throw new ErrorCoded_1.ErrorCoded(e.message, ErrorCoded_1.ERROR_CODES.INVALID_SCOPED_CONTEXT);\n                        }\n                    }\n                    value['@context'] = (await this.parse(value['@context'], Object.assign(Object.assign({}, options), { minimalProcessing: true, ignoreRemoteScopedContexts: true, parentContext: context })))\n                        .getContextRaw();\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Parse a JSON-LD context in any form.\n     * @param {JsonLdContext} context A context, URL to a context, or an array of contexts/URLs.\n     * @param {IParseOptions} options Optional parsing options.\n     * @return {Promise<JsonLdContextNormalized>} A promise resolving to the context.\n     */\n    async parse(context, options = {\n        processingMode: ContextParser.DEFAULT_PROCESSING_MODE,\n    }) {\n        const { baseIRI, parentContext: parentContextInitial, external, processingMode, normalizeLanguageTags, ignoreProtection, minimalProcessing, } = options;\n        let parentContext = parentContextInitial;\n        const remoteContexts = options.remoteContexts || {};\n        // Avoid remote context overflows\n        if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {\n            throw new ErrorCoded_1.ErrorCoded('Detected an overflow in remote context inclusions: ' + Object.keys(remoteContexts), ErrorCoded_1.ERROR_CODES.CONTEXT_OVERFLOW);\n        }\n        if (context === null || context === undefined) {\n            // Don't allow context nullification and there are protected terms\n            if (!ignoreProtection && parentContext && Util_1.Util.hasProtectedTerms(parentContext)) {\n                throw new ErrorCoded_1.ErrorCoded('Illegal context nullification when terms are protected', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);\n            }\n            // Context that are explicitly set to null are empty.\n            return new JsonLdContextNormalized_1.JsonLdContextNormalized(this.applyBaseEntry({}, options, false));\n        }\n        else if (typeof context === 'string') {\n            const contextIri = this.normalizeContextIri(context, baseIRI);\n            const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n            if (overriddenLoad) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(overriddenLoad);\n            }\n            const parsedStringContext = await this.parse(await this.load(contextIri), Object.assign(Object.assign({}, options), { baseIRI: contextIri, external: true, remoteContexts: Object.assign(Object.assign({}, remoteContexts), { [contextIri]: true }) }));\n            this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);\n            return parsedStringContext;\n        }\n        else if (Array.isArray(context)) {\n            // As a performance consideration, first load all external contexts in parallel.\n            const contextIris = [];\n            const contexts = await Promise.all(context.map((subContext, i) => {\n                if (typeof subContext === 'string') {\n                    const contextIri = this.normalizeContextIri(subContext, baseIRI);\n                    contextIris[i] = contextIri;\n                    const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n                    if (overriddenLoad) {\n                        return overriddenLoad;\n                    }\n                    return this.load(contextIri);\n                }\n                else {\n                    return subContext;\n                }\n            }));\n            // Don't apply inheritance logic on minimal processing\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(contexts);\n            }\n            const reducedContexts = await contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise\n                .then((accContext) => this.parse(contextEntry, Object.assign(Object.assign({}, options), { baseIRI: contextIris[i] || options.baseIRI, external: !!contextIris[i] || options.external, parentContext: accContext.getContextRaw(), remoteContexts: contextIris[i] ? Object.assign(Object.assign({}, remoteContexts), { [contextIris[i]]: true }) : remoteContexts }))), Promise.resolve(new JsonLdContextNormalized_1.JsonLdContextNormalized(parentContext || {})));\n            // Override the base IRI if provided.\n            this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);\n            return reducedContexts;\n        }\n        else if (typeof context === 'object') {\n            if ('@context' in context) {\n                return await this.parse(context['@context'], options);\n            }\n            // Make a deep clone of the given context, to avoid modifying it.\n            context = JSON.parse(JSON.stringify(context)); // No better way in JS at the moment.\n            if (parentContext && !minimalProcessing) {\n                parentContext = JSON.parse(JSON.stringify(parentContext));\n            }\n            // We have an actual context object.\n            let newContext = {};\n            // According to the JSON-LD spec, @base must be ignored from external contexts.\n            if (external) {\n                delete context['@base'];\n            }\n            // Override the base IRI if provided.\n            this.applyBaseEntry(context, options, true);\n            // Hashify container entries\n            // Do this before protected term validation as that influences term format\n            this.containersToHash(context);\n            // Don't perform any other modifications if only minimal processing is needed.\n            if (minimalProcessing) {\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(context);\n            }\n            // In JSON-LD 1.1, load @import'ed context prior to processing.\n            let importContext = {};\n            if ('@import' in context) {\n                if (processingMode && processingMode >= 1.1) {\n                    // Only accept string values\n                    if (typeof context['@import'] !== 'string') {\n                        throw new ErrorCoded_1.ErrorCoded('An @import value must be a string, but got ' + typeof context['@import'], ErrorCoded_1.ERROR_CODES.INVALID_IMPORT_VALUE);\n                    }\n                    // Load context\n                    importContext = await this.loadImportContext(this.normalizeContextIri(context['@import'], baseIRI));\n                    delete context['@import'];\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded('Context importing is not supported in JSON-LD 1.0', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                }\n            }\n            // Merge different parts of the final context in order\n            newContext = Object.assign(Object.assign(Object.assign(Object.assign({}, newContext), (typeof parentContext === 'object' ? parentContext : {})), importContext), context);\n            const newContextWrapped = new JsonLdContextNormalized_1.JsonLdContextNormalized(newContext);\n            // Parse inner contexts with minimal processing\n            await this.parseInnerContexts(newContext, options);\n            // In JSON-LD 1.1, check if we are not redefining any protected keywords\n            if (!ignoreProtection && parentContext && processingMode && processingMode >= 1.1) {\n                this.validateKeywordRedefinitions(parentContext, newContext, exports.defaultExpandOptions);\n            }\n            // In JSON-LD 1.1, @vocab can be relative to @vocab in the parent context.\n            if ((newContext && newContext['@version'] || processingMode || ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1\n                && ((context['@vocab'] && typeof context['@vocab'] === 'string') || context['@vocab'] === '')\n                && context['@vocab'].indexOf(':') < 0 && parentContext && '@vocab' in parentContext) {\n                newContext['@vocab'] = parentContext['@vocab'] + context['@vocab'];\n            }\n            this.idifyReverseTerms(newContext);\n            this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase);\n            this.normalize(newContext, { processingMode, normalizeLanguageTags });\n            this.applyScopedProtected(newContext, { processingMode });\n            if (this.validateContext) {\n                this.validate(newContext, { processingMode });\n            }\n            return newContextWrapped;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`, ErrorCoded_1.ERROR_CODES.INVALID_LOCAL_CONTEXT);\n        }\n    }\n    /**\n     * Fetch the given URL as a raw JSON-LD context.\n     * @param url An URL.\n     * @return A promise resolving to a raw JSON-LD context.\n     */\n    async load(url) {\n        // First try to retrieve the context from cache\n        const cached = this.documentCache[url];\n        if (cached) {\n            return typeof cached === 'string' ? cached : Array.isArray(cached) ? cached.slice() : Object.assign({}, cached);\n        }\n        // If not in cache, load it\n        let document;\n        try {\n            document = await this.documentLoader.load(url);\n        }\n        catch (e) {\n            throw new ErrorCoded_1.ErrorCoded(`Failed to load remote context ${url}: ${e.message}`, ErrorCoded_1.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);\n        }\n        // Validate the context\n        if (!('@context' in document)) {\n            throw new ErrorCoded_1.ErrorCoded(`Missing @context in remote context at ${url}`, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        return this.documentCache[url] = document['@context'];\n    }\n    /**\n     * Override the given context that may be loaded.\n     *\n     * This will check whether or not the url is recursively being loaded.\n     * @param url An URL.\n     * @param options Parsing options.\n     * @return An overridden context, or null.\n     *         Optionally an error can be thrown if a cyclic context is detected.\n     */\n    getOverriddenLoad(url, options) {\n        if (url in (options.remoteContexts || {})) {\n            if (options.ignoreRemoteScopedContexts) {\n                return url;\n            }\n            else {\n                throw new ErrorCoded_1.ErrorCoded('Detected a cyclic context inclusion of ' + url, ErrorCoded_1.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);\n            }\n        }\n        return null;\n    }\n    /**\n     * Load an @import'ed context.\n     * @param importContextIri The full URI of an @import value.\n     */\n    async loadImportContext(importContextIri) {\n        // Load the context\n        const importContext = await this.load(importContextIri);\n        // Require the context to be a non-array object\n        if (typeof importContext !== 'object' || Array.isArray(importContext)) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context must be a single object: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n        }\n        // Error if the context contains another @import\n        if ('@import' in importContext) {\n            throw new ErrorCoded_1.ErrorCoded('An imported context can not import another context: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n        }\n        return importContext;\n    }\n}\nexports.ContextParser = ContextParser;\nContextParser.DEFAULT_PROCESSING_MODE = 1.1;\nexports.defaultExpandOptions = {\n    allowPrefixForcing: true,\n    allowPrefixNonGenDelims: false,\n    allowVocabRelativeToBase: true,\n};\n//# sourceMappingURL=ContextParser.js.map"]},"metadata":{},"sourceType":"script"}