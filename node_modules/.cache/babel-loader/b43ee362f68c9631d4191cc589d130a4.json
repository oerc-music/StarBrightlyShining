{"ast":null,"code":"// N3.js implementations of the RDF/JS core data types\n// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\nimport namespaces from './IRIs';\nimport { isDefaultGraph } from './N3Util';\nconst {\n  rdf,\n  xsd\n} = namespaces; // eslint-disable-next-line prefer-const\n\nlet DEFAULTGRAPH;\nlet _blankNodeCounter = 0;\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\nconst quadId = /^<<(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) ?(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+)?>>$/; // ## DataFactory singleton\n\nconst DataFactory = {\n  namedNode,\n  blankNode,\n  variable,\n  literal,\n  defaultGraph,\n  quad,\n  triple: quad\n};\nexport default DataFactory; // ## Term constructor\n\nexport class Term {\n  constructor(id) {\n    this.id = id;\n  } // ### The value of this term\n\n\n  get value() {\n    return this.id;\n  } // ### Returns whether this object represents the same term as the other\n\n\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Term) return this.id === other.id; // Otherwise, compare term type and value\n\n    return !!other && this.termType === other.termType && this.value === other.value;\n  } // ### Returns a plain object representation of this term\n\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      value: this.value\n    };\n  }\n\n} // ## NamedNode constructor\n\nexport class NamedNode extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'NamedNode';\n  }\n\n} // ## Literal constructor\n\nexport class Literal extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'Literal';\n  } // ### The text value of this literal\n\n\n  get value() {\n    return this.id.substring(1, this.id.lastIndexOf('\"'));\n  } // ### The language of this literal\n\n\n  get language() {\n    // Find the last quotation mark (e.g., '\"abc\"@en-us')\n    const id = this.id;\n    let atPos = id.lastIndexOf('\"') + 1; // If \"@\" it follows, return the remaining substring; empty otherwise\n\n    return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n  } // ### The datatype IRI of this literal\n\n\n  get datatype() {\n    return new NamedNode(this.datatypeString);\n  } // ### The datatype string of this literal\n\n\n  get datatypeString() {\n    // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n    const id = this.id,\n          dtPos = id.lastIndexOf('\"') + 1;\n    const char = dtPos < id.length ? id[dtPos] : ''; // If \"^\" it follows, return the remaining substring\n\n    return char === '^' ? id.substr(dtPos + 2) : char !== '@' ? xsd.string : rdf.langString;\n  } // ### Returns whether this object represents the same term as the other\n\n\n  equals(other) {\n    // If both literals were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Literal) return this.id === other.id; // Otherwise, compare term type, value, language, and datatype\n\n    return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;\n  }\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      value: this.value,\n      language: this.language,\n      datatype: {\n        termType: 'NamedNode',\n        value: this.datatypeString\n      }\n    };\n  }\n\n} // ## BlankNode constructor\n\nexport class BlankNode extends Term {\n  constructor(name) {\n    super(`_:${name}`);\n  } // ### The term type of this term\n\n\n  get termType() {\n    return 'BlankNode';\n  } // ### The name of this blank node\n\n\n  get value() {\n    return this.id.substr(2);\n  }\n\n}\nexport class Variable extends Term {\n  constructor(name) {\n    super(`?${name}`);\n  } // ### The term type of this term\n\n\n  get termType() {\n    return 'Variable';\n  } // ### The name of this variable\n\n\n  get value() {\n    return this.id.substr(1);\n  }\n\n} // ## DefaultGraph constructor\n\nexport class DefaultGraph extends Term {\n  constructor() {\n    super('');\n    return DEFAULTGRAPH || this;\n  } // ### The term type of this term\n\n\n  get termType() {\n    return 'DefaultGraph';\n  } // ### Returns whether this object represents the same term as the other\n\n\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through strict equality;\n    // otherwise, compare term types.\n    return this === other || !!other && this.termType === other.termType;\n  }\n\n} // ## DefaultGraph singleton\n\nDEFAULTGRAPH = new DefaultGraph(); // ### Constructs a term from the given internal string ID\n\nexport function termFromId(id, factory) {\n  factory = factory || DataFactory; // Falsy value or empty string indicate the default graph\n\n  if (!id) return factory.defaultGraph(); // Identify the term type based on the first character\n\n  switch (id[0]) {\n    case '?':\n      return factory.variable(id.substr(1));\n\n    case '_':\n      return factory.blankNode(id.substr(2));\n\n    case '\"':\n      // Shortcut for internal literals\n      if (factory === DataFactory) return new Literal(id); // Literal without datatype or language\n\n      if (id[id.length - 1] === '\"') return factory.literal(id.substr(1, id.length - 2)); // Literal with datatype or language\n\n      const endPos = id.lastIndexOf('\"', id.length - 1);\n      return factory.literal(id.substr(1, endPos - 1), id[endPos + 1] === '@' ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3)));\n\n    case '<':\n      const components = quadId.exec(id);\n      return factory.quad(termFromId(unescapeQuotes(components[1]), factory), termFromId(unescapeQuotes(components[2]), factory), termFromId(unescapeQuotes(components[3]), factory), components[4] && termFromId(unescapeQuotes(components[4]), factory));\n\n    default:\n      return factory.namedNode(id);\n  }\n} // ### Constructs an internal string ID from the given term or ID string\n\nexport function termToId(term) {\n  if (typeof term === 'string') return term;\n  if (term instanceof Term && term.termType !== 'Quad') return term.id;\n  if (!term) return DEFAULTGRAPH.id; // Term instantiated with another library\n\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value;\n\n    case 'BlankNode':\n      return `_:${term.value}`;\n\n    case 'Variable':\n      return `?${term.value}`;\n\n    case 'DefaultGraph':\n      return '';\n\n    case 'Literal':\n      return `\"${term.value}\"${term.language ? `@${term.language}` : term.datatype && term.datatype.value !== xsd.string ? `^^${term.datatype.value}` : ''}`;\n\n    case 'Quad':\n      // To identify RDF* quad components, we escape quotes by doubling them.\n      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n      return `<<${escapeQuotes(termToId(term.subject))} ${escapeQuotes(termToId(term.predicate))} ${escapeQuotes(termToId(term.object))}${isDefaultGraph(term.graph) ? '' : ` ${termToId(term.graph)}`}>>`;\n\n    default:\n      throw new Error(`Unexpected termType: ${term.termType}`);\n  }\n} // ## Quad constructor\n\nexport class Quad extends Term {\n  constructor(subject, predicate, object, graph) {\n    super('');\n    this._subject = subject;\n    this._predicate = predicate;\n    this._object = object;\n    this._graph = graph || DEFAULTGRAPH;\n  } // ### The term type of this term\n\n\n  get termType() {\n    return 'Quad';\n  }\n\n  get subject() {\n    return this._subject;\n  }\n\n  get predicate() {\n    return this._predicate;\n  }\n\n  get object() {\n    return this._object;\n  }\n\n  get graph() {\n    return this._graph;\n  } // ### Returns a plain object representation of this quad\n\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      subject: this._subject.toJSON(),\n      predicate: this._predicate.toJSON(),\n      object: this._object.toJSON(),\n      graph: this._graph.toJSON()\n    };\n  } // ### Returns whether this object represents the same quad as the other\n\n\n  equals(other) {\n    return !!other && this._subject.equals(other.subject) && this._predicate.equals(other.predicate) && this._object.equals(other.object) && this._graph.equals(other.graph);\n  }\n\n}\nexport { Quad as Triple }; // ### Escapes the quotes within the given literal\n\nexport function escapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`);\n} // ### Unescapes the quotes within the given literal\n\nexport function unescapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"\"/g, '\"')}`);\n} // ### Creates an IRI\n\nfunction namedNode(iri) {\n  return new NamedNode(iri);\n} // ### Creates a blank node\n\n\nfunction blankNode(name) {\n  return new BlankNode(name || `n3-${_blankNodeCounter++}`);\n} // ### Creates a literal\n\n\nfunction literal(value, languageOrDataType) {\n  // Create a language-tagged string\n  if (typeof languageOrDataType === 'string') return new Literal(`\"${value}\"@${languageOrDataType.toLowerCase()}`); // Automatically determine datatype for booleans and numbers\n\n  let datatype = languageOrDataType ? languageOrDataType.value : '';\n\n  if (datatype === '') {\n    // Convert a boolean\n    if (typeof value === 'boolean') datatype = xsd.boolean; // Convert an integer or double\n    else if (typeof value === 'number') {\n      if (Number.isFinite(value)) datatype = Number.isInteger(value) ? xsd.integer : xsd.double;else {\n        datatype = xsd.double;\n        if (!Number.isNaN(value)) value = value > 0 ? 'INF' : '-INF';\n      }\n    }\n  } // Create a datatyped literal\n\n\n  return datatype === '' || datatype === xsd.string ? new Literal(`\"${value}\"`) : new Literal(`\"${value}\"^^${datatype}`);\n} // ### Creates a variable\n\n\nfunction variable(name) {\n  return new Variable(name);\n} // ### Returns the default graph\n\n\nfunction defaultGraph() {\n  return DEFAULTGRAPH;\n} // ### Creates a quad\n\n\nfunction quad(subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph);\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/n3/src/N3DataFactory.js"],"names":["namespaces","isDefaultGraph","rdf","xsd","DEFAULTGRAPH","_blankNodeCounter","escapedLiteral","quadId","DataFactory","namedNode","blankNode","variable","literal","defaultGraph","quad","triple","Term","constructor","id","value","equals","other","termType","toJSON","NamedNode","Literal","substring","lastIndexOf","language","atPos","length","substr","toLowerCase","datatype","datatypeString","dtPos","char","string","langString","BlankNode","name","Variable","DefaultGraph","termFromId","factory","endPos","components","exec","unescapeQuotes","termToId","term","escapeQuotes","subject","predicate","object","graph","Error","Quad","_subject","_predicate","_object","_graph","Triple","replace","_","quoted","iri","languageOrDataType","boolean","Number","isFinite","isInteger","integer","double","isNaN"],"mappings":"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","sourcesContent":["// N3.js implementations of the RDF/JS core data types\n// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\n\nimport namespaces from './IRIs';\nimport { isDefaultGraph } from './N3Util';\nconst { rdf, xsd } = namespaces;\n\n// eslint-disable-next-line prefer-const\nlet DEFAULTGRAPH;\nlet _blankNodeCounter = 0;\n\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\nconst quadId = /^<<(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) ?(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+)?>>$/;\n\n// ## DataFactory singleton\nconst DataFactory = {\n  namedNode,\n  blankNode,\n  variable,\n  literal,\n  defaultGraph,\n  quad,\n  triple: quad,\n};\nexport default DataFactory;\n\n// ## Term constructor\nexport class Term {\n  constructor(id) {\n    this.id = id;\n  }\n\n  // ### The value of this term\n  get value() {\n    return this.id;\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Term)\n      return this.id === other.id;\n    // Otherwise, compare term type and value\n    return !!other && this.termType === other.termType &&\n                      this.value    === other.value;\n  }\n\n  // ### Returns a plain object representation of this term\n  toJSON() {\n    return {\n      termType: this.termType,\n      value:    this.value,\n    };\n  }\n}\n\n\n// ## NamedNode constructor\nexport class NamedNode extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'NamedNode';\n  }\n}\n\n// ## Literal constructor\nexport class Literal extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'Literal';\n  }\n\n  // ### The text value of this literal\n  get value() {\n    return this.id.substring(1, this.id.lastIndexOf('\"'));\n  }\n\n  // ### The language of this literal\n  get language() {\n    // Find the last quotation mark (e.g., '\"abc\"@en-us')\n    const id = this.id;\n    let atPos = id.lastIndexOf('\"') + 1;\n    // If \"@\" it follows, return the remaining substring; empty otherwise\n    return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n  }\n\n  // ### The datatype IRI of this literal\n  get datatype() {\n    return new NamedNode(this.datatypeString);\n  }\n\n  // ### The datatype string of this literal\n  get datatypeString() {\n    // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n    const id = this.id, dtPos = id.lastIndexOf('\"') + 1;\n    const char = dtPos < id.length ? id[dtPos] : '';\n    // If \"^\" it follows, return the remaining substring\n    return char === '^' ? id.substr(dtPos + 2) :\n           // If \"@\" follows, return rdf:langString; xsd:string otherwise\n           (char !== '@' ? xsd.string : rdf.langString);\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both literals were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Literal)\n      return this.id === other.id;\n    // Otherwise, compare term type, value, language, and datatype\n    return !!other && !!other.datatype &&\n                      this.termType === other.termType &&\n                      this.value    === other.value    &&\n                      this.language === other.language &&\n                      this.datatype.value === other.datatype.value;\n  }\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      value:    this.value,\n      language: this.language,\n      datatype: { termType: 'NamedNode', value: this.datatypeString },\n    };\n  }\n}\n\n// ## BlankNode constructor\nexport class BlankNode extends Term {\n  constructor(name) {\n    super(`_:${name}`);\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'BlankNode';\n  }\n\n  // ### The name of this blank node\n  get value() {\n    return this.id.substr(2);\n  }\n}\n\nexport class Variable extends Term {\n  constructor(name) {\n    super(`?${name}`);\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'Variable';\n  }\n\n  // ### The name of this variable\n  get value() {\n    return this.id.substr(1);\n  }\n}\n\n// ## DefaultGraph constructor\nexport class DefaultGraph extends Term {\n  constructor() {\n    super('');\n    return DEFAULTGRAPH || this;\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'DefaultGraph';\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through strict equality;\n    // otherwise, compare term types.\n    return (this === other) || (!!other && (this.termType === other.termType));\n  }\n}\n\n// ## DefaultGraph singleton\nDEFAULTGRAPH = new DefaultGraph();\n\n\n// ### Constructs a term from the given internal string ID\nexport function termFromId(id, factory) {\n  factory = factory || DataFactory;\n\n  // Falsy value or empty string indicate the default graph\n  if (!id)\n    return factory.defaultGraph();\n\n  // Identify the term type based on the first character\n  switch (id[0]) {\n  case '?':\n    return factory.variable(id.substr(1));\n  case '_':\n    return factory.blankNode(id.substr(2));\n  case '\"':\n    // Shortcut for internal literals\n    if (factory === DataFactory)\n      return new Literal(id);\n    // Literal without datatype or language\n    if (id[id.length - 1] === '\"')\n      return factory.literal(id.substr(1, id.length - 2));\n    // Literal with datatype or language\n    const endPos = id.lastIndexOf('\"', id.length - 1);\n    return factory.literal(id.substr(1, endPos - 1),\n            id[endPos + 1] === '@' ? id.substr(endPos + 2)\n                                   : factory.namedNode(id.substr(endPos + 3)));\n  case '<':\n    const components = quadId.exec(id);\n    return factory.quad(\n      termFromId(unescapeQuotes(components[1]), factory),\n      termFromId(unescapeQuotes(components[2]), factory),\n      termFromId(unescapeQuotes(components[3]), factory),\n      components[4] && termFromId(unescapeQuotes(components[4]), factory)\n    );\n  default:\n    return factory.namedNode(id);\n  }\n}\n\n// ### Constructs an internal string ID from the given term or ID string\nexport function termToId(term) {\n  if (typeof term === 'string')\n    return term;\n  if (term instanceof Term && term.termType !== 'Quad')\n    return term.id;\n  if (!term)\n    return DEFAULTGRAPH.id;\n\n  // Term instantiated with another library\n  switch (term.termType) {\n  case 'NamedNode':    return term.value;\n  case 'BlankNode':    return `_:${term.value}`;\n  case 'Variable':     return `?${term.value}`;\n  case 'DefaultGraph': return '';\n  case 'Literal':      return `\"${term.value}\"${\n    term.language ? `@${term.language}` :\n      (term.datatype && term.datatype.value !== xsd.string ? `^^${term.datatype.value}` : '')}`;\n  case 'Quad':\n    // To identify RDF* quad components, we escape quotes by doubling them.\n    // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n    return `<<${\n        escapeQuotes(termToId(term.subject))\n      } ${\n        escapeQuotes(termToId(term.predicate))\n      } ${\n        escapeQuotes(termToId(term.object))\n      }${\n        (isDefaultGraph(term.graph)) ? '' : ` ${termToId(term.graph)}`\n      }>>`;\n  default: throw new Error(`Unexpected termType: ${term.termType}`);\n  }\n}\n\n\n// ## Quad constructor\nexport class Quad extends Term {\n  constructor(subject, predicate, object, graph) {\n    super('');\n    this._subject   = subject;\n    this._predicate = predicate;\n    this._object    = object;\n    this._graph     = graph || DEFAULTGRAPH;\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'Quad';\n  }\n\n  get subject() {\n    return this._subject;\n  }\n\n  get predicate() {\n    return this._predicate;\n  }\n\n  get object() {\n    return this._object;\n  }\n\n  get graph() {\n    return this._graph;\n  }\n\n  // ### Returns a plain object representation of this quad\n  toJSON() {\n    return {\n      termType:  this.termType,\n      subject:   this._subject.toJSON(),\n      predicate: this._predicate.toJSON(),\n      object:    this._object.toJSON(),\n      graph:     this._graph.toJSON(),\n    };\n  }\n\n  // ### Returns whether this object represents the same quad as the other\n  equals(other) {\n    return !!other && this._subject.equals(other.subject)     &&\n                      this._predicate.equals(other.predicate) &&\n                      this._object.equals(other.object)       &&\n                      this._graph.equals(other.graph);\n  }\n}\nexport { Quad as Triple };\n\n// ### Escapes the quotes within the given literal\nexport function escapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`);\n}\n\n// ### Unescapes the quotes within the given literal\nexport function unescapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"\"/g, '\"')}`);\n}\n\n// ### Creates an IRI\nfunction namedNode(iri) {\n  return new NamedNode(iri);\n}\n\n// ### Creates a blank node\nfunction blankNode(name) {\n  return new BlankNode(name || `n3-${_blankNodeCounter++}`);\n}\n\n// ### Creates a literal\nfunction literal(value, languageOrDataType) {\n  // Create a language-tagged string\n  if (typeof languageOrDataType === 'string')\n    return new Literal(`\"${value}\"@${languageOrDataType.toLowerCase()}`);\n\n  // Automatically determine datatype for booleans and numbers\n  let datatype = languageOrDataType ? languageOrDataType.value : '';\n  if (datatype === '') {\n    // Convert a boolean\n    if (typeof value === 'boolean')\n      datatype = xsd.boolean;\n    // Convert an integer or double\n    else if (typeof value === 'number') {\n      if (Number.isFinite(value))\n        datatype = Number.isInteger(value) ? xsd.integer : xsd.double;\n      else {\n        datatype = xsd.double;\n        if (!Number.isNaN(value))\n          value = value > 0 ? 'INF' : '-INF';\n      }\n    }\n  }\n\n  // Create a datatyped literal\n  return (datatype === '' || datatype === xsd.string) ?\n    new Literal(`\"${value}\"`) :\n    new Literal(`\"${value}\"^^${datatype}`);\n}\n\n// ### Creates a variable\nfunction variable(name) {\n  return new Variable(name);\n}\n\n// ### Returns the default graph\nfunction defaultGraph() {\n  return DEFAULTGRAPH;\n}\n\n// ### Creates a quad\nfunction quad(subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph);\n}\n"]},"metadata":{},"sourceType":"module"}