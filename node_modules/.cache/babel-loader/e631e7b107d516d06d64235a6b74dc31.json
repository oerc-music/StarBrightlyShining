{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst Wildcard = require('sparqljs').Wildcard;\n\nclass Factory {\n  constructor(dataFactory) {\n    this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();\n    this.stringType = this.createTerm('http://www.w3.org/2001/XMLSchema#string');\n  }\n\n  createAlt(left, right) {\n    return {\n      type: 'alt',\n      left,\n      right\n    };\n  }\n\n  createAsk(input) {\n    return {\n      type: 'ask',\n      input\n    };\n  }\n\n  createBoundAggregate(variable, aggregate, expression, distinct, separator) {\n    let result = this.createAggregateExpression(aggregate, expression, distinct, separator);\n    result.variable = variable;\n    return result;\n  }\n\n  createBgp(patterns) {\n    return {\n      type: 'bgp',\n      patterns\n    };\n  }\n\n  createConstruct(input, template) {\n    return {\n      type: 'construct',\n      input,\n      template\n    };\n  }\n\n  createDescribe(input, terms) {\n    return {\n      type: 'describe',\n      input,\n      terms\n    };\n  }\n\n  createDistinct(input) {\n    return {\n      type: 'distinct',\n      input\n    };\n  }\n\n  createExtend(input, variable, expression) {\n    return {\n      type: 'extend',\n      input,\n      variable,\n      expression\n    };\n  }\n\n  createFrom(input, def, named) {\n    return {\n      type: 'from',\n      input,\n      default: def,\n      named\n    };\n  }\n\n  createFilter(input, expression) {\n    return {\n      type: 'filter',\n      input,\n      expression\n    };\n  }\n\n  createGraph(input, name) {\n    return {\n      type: 'graph',\n      input,\n      name\n    };\n  }\n\n  createGroup(input, variables, aggregates) {\n    return {\n      type: 'group',\n      input,\n      variables,\n      aggregates\n    };\n  }\n\n  createInv(path) {\n    return {\n      type: 'inv',\n      path\n    };\n  }\n\n  createJoin(left, right) {\n    return {\n      type: 'join',\n      left,\n      right\n    };\n  }\n\n  createLeftJoin(left, right, expression) {\n    if (expression) return {\n      type: 'leftjoin',\n      left,\n      right,\n      expression\n    };\n    return {\n      type: 'leftjoin',\n      left,\n      right\n    };\n  }\n\n  createLink(iri) {\n    return {\n      type: 'link',\n      iri\n    };\n  }\n\n  createMinus(left, right) {\n    return {\n      type: 'minus',\n      left,\n      right\n    };\n  }\n\n  createNps(iris) {\n    return {\n      type: 'nps',\n      iris\n    };\n  }\n\n  createOneOrMorePath(path) {\n    return {\n      type: 'OneOrMorePath',\n      path\n    };\n  }\n\n  createOrderBy(input, expressions) {\n    return {\n      type: 'orderby',\n      input,\n      expressions\n    };\n  }\n\n  createPath(subject, predicate, object, graph) {\n    if (graph) return {\n      type: 'path',\n      subject,\n      predicate,\n      object,\n      graph\n    };\n    return {\n      type: 'path',\n      subject,\n      predicate,\n      object,\n      graph: this.dataFactory.defaultGraph()\n    };\n  }\n\n  createPattern(subject, predicate, object, graph) {\n    let pattern = this.dataFactory.quad(subject, predicate, object, graph);\n    pattern.type = 'pattern';\n    return pattern;\n  }\n\n  createProject(input, variables) {\n    return {\n      type: 'project',\n      input,\n      variables\n    };\n  }\n\n  createReduced(input) {\n    return {\n      type: 'reduced',\n      input\n    };\n  }\n\n  createSeq(left, right) {\n    return {\n      type: 'seq',\n      left,\n      right\n    };\n  }\n\n  createService(input, name, silent) {\n    return {\n      type: 'service',\n      input,\n      name,\n      silent\n    };\n  }\n\n  createSlice(input, start, length) {\n    if (start === undefined) start = 0;\n    if (length !== undefined) return {\n      type: 'slice',\n      input,\n      start,\n      length\n    };\n    return {\n      type: 'slice',\n      input,\n      start\n    };\n  }\n\n  createUnion(left, right) {\n    return {\n      type: 'union',\n      left,\n      right\n    };\n  }\n\n  createValues(variables, bindings) {\n    return {\n      type: 'values',\n      variables,\n      bindings\n    };\n  }\n\n  createZeroOrMorePath(path) {\n    return {\n      type: 'ZeroOrMorePath',\n      path\n    };\n  }\n\n  createZeroOrOnePath(path) {\n    return {\n      type: 'ZeroOrOnePath',\n      path\n    };\n  }\n\n  createAggregateExpression(aggregator, expression, distinct, separator) {\n    if (separator) return {\n      type: 'expression',\n      expressionType: 'aggregate',\n      aggregator: aggregator,\n      expression,\n      separator,\n      distinct\n    };\n    return {\n      type: 'expression',\n      expressionType: 'aggregate',\n      aggregator: aggregator,\n      expression,\n      distinct\n    };\n  }\n\n  createExistenceExpression(not, input) {\n    return {\n      type: 'expression',\n      expressionType: 'existence',\n      not,\n      input\n    };\n  }\n\n  createNamedExpression(name, args) {\n    return {\n      type: 'expression',\n      expressionType: 'named',\n      name,\n      args\n    };\n  }\n\n  createOperatorExpression(operator, args) {\n    return {\n      type: 'expression',\n      expressionType: 'operator',\n      operator,\n      args\n    };\n  }\n\n  createTermExpression(term) {\n    return {\n      type: 'expression',\n      expressionType: 'term',\n      term\n    };\n  }\n\n  createWildcardExpression() {\n    return {\n      type: 'expression',\n      expressionType: 'wildcard',\n      wildcard: new Wildcard()\n    };\n  }\n\n  createTerm(str) {\n    return rdf_string_1.stringToTerm(str, this.dataFactory);\n  } // Update functions\n\n\n  createCompositeUpdate(updates) {\n    return {\n      type: 'compositeupdate',\n      updates\n    };\n  }\n\n  createDeleteInsert(deleteQuads, insertQuads, where) {\n    const result = {\n      type: 'deleteinsert'\n    };\n    if (deleteQuads) result.delete = deleteQuads;\n    if (insertQuads) result.insert = insertQuads;\n    if (where) result.where = where;\n    return result;\n  }\n\n  createLoad(source, destination, silent) {\n    const result = {\n      type: 'load',\n      source\n    };\n    if (destination) result.destination = destination;\n    return this.addSilent(result, silent);\n  }\n\n  createClear(source, silent) {\n    return this.addSilent({\n      type: 'clear',\n      source\n    }, silent);\n  }\n\n  createCreate(source, silent) {\n    return this.addSilent({\n      type: 'create',\n      source\n    }, silent);\n  }\n\n  createDrop(source, silent) {\n    return this.addSilent({\n      type: 'drop',\n      source\n    }, silent);\n  }\n\n  createAdd(source, destination, silent) {\n    return this.addSilent({\n      type: 'add',\n      source,\n      destination\n    }, silent);\n  }\n\n  createMove(source, destination, silent) {\n    return this.addSilent({\n      type: 'move',\n      source,\n      destination\n    }, silent);\n  }\n\n  createCopy(source, destination, silent) {\n    return this.addSilent({\n      type: 'copy',\n      source,\n      destination\n    }, silent);\n  }\n\n  addSilent(input, silent) {\n    if (silent) input.silent = silent;\n    return input;\n  }\n\n}\n\nexports.default = Factory;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/sparqlalgebrajs/lib/factory.js"],"names":["Object","defineProperty","exports","value","rdf_data_factory_1","require","rdf_string_1","Wildcard","Factory","constructor","dataFactory","DataFactory","stringType","createTerm","createAlt","left","right","type","createAsk","input","createBoundAggregate","variable","aggregate","expression","distinct","separator","result","createAggregateExpression","createBgp","patterns","createConstruct","template","createDescribe","terms","createDistinct","createExtend","createFrom","def","named","default","createFilter","createGraph","name","createGroup","variables","aggregates","createInv","path","createJoin","createLeftJoin","createLink","iri","createMinus","createNps","iris","createOneOrMorePath","createOrderBy","expressions","createPath","subject","predicate","object","graph","defaultGraph","createPattern","pattern","quad","createProject","createReduced","createSeq","createService","silent","createSlice","start","length","undefined","createUnion","createValues","bindings","createZeroOrMorePath","createZeroOrOnePath","aggregator","expressionType","createExistenceExpression","not","createNamedExpression","args","createOperatorExpression","operator","createTermExpression","term","createWildcardExpression","wildcard","str","stringToTerm","createCompositeUpdate","updates","createDeleteInsert","deleteQuads","insertQuads","where","delete","insert","createLoad","source","destination","addSilent","createClear","createCreate","createDrop","createAdd","createMove","createCopy"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst Wildcard = require('sparqljs').Wildcard;\nclass Factory {\n    constructor(dataFactory) {\n        this.dataFactory = dataFactory || new rdf_data_factory_1.DataFactory();\n        this.stringType = this.createTerm('http://www.w3.org/2001/XMLSchema#string');\n    }\n    createAlt(left, right) { return { type: 'alt', left, right }; }\n    createAsk(input) { return { type: 'ask', input }; }\n    createBoundAggregate(variable, aggregate, expression, distinct, separator) {\n        let result = this.createAggregateExpression(aggregate, expression, distinct, separator);\n        result.variable = variable;\n        return result;\n    }\n    createBgp(patterns) { return { type: 'bgp', patterns }; }\n    createConstruct(input, template) { return { type: 'construct', input, template }; }\n    createDescribe(input, terms) { return { type: 'describe', input, terms }; }\n    createDistinct(input) { return { type: 'distinct', input }; }\n    createExtend(input, variable, expression) { return { type: 'extend', input, variable, expression }; }\n    createFrom(input, def, named) { return { type: 'from', input, default: def, named }; }\n    createFilter(input, expression) { return { type: 'filter', input, expression }; }\n    createGraph(input, name) { return { type: 'graph', input, name }; }\n    createGroup(input, variables, aggregates) { return { type: 'group', input, variables, aggregates }; }\n    createInv(path) { return { type: 'inv', path }; }\n    createJoin(left, right) { return { type: 'join', left, right }; }\n    createLeftJoin(left, right, expression) {\n        if (expression)\n            return { type: 'leftjoin', left, right, expression };\n        return { type: 'leftjoin', left, right };\n    }\n    createLink(iri) { return { type: 'link', iri }; }\n    createMinus(left, right) { return { type: 'minus', left, right }; }\n    createNps(iris) { return { type: 'nps', iris }; }\n    createOneOrMorePath(path) { return { type: 'OneOrMorePath', path }; }\n    createOrderBy(input, expressions) { return { type: 'orderby', input, expressions }; }\n    createPath(subject, predicate, object, graph) {\n        if (graph)\n            return { type: 'path', subject, predicate, object, graph };\n        return { type: 'path', subject, predicate, object, graph: this.dataFactory.defaultGraph() };\n    }\n    createPattern(subject, predicate, object, graph) {\n        let pattern = this.dataFactory.quad(subject, predicate, object, graph);\n        pattern.type = 'pattern';\n        return pattern;\n    }\n    createProject(input, variables) { return { type: 'project', input, variables }; }\n    createReduced(input) { return { type: 'reduced', input }; }\n    createSeq(left, right) { return { type: 'seq', left, right }; }\n    createService(input, name, silent) { return { type: 'service', input, name, silent }; }\n    createSlice(input, start, length) {\n        if (start === undefined)\n            start = 0;\n        if (length !== undefined)\n            return { type: 'slice', input, start, length };\n        return { type: 'slice', input, start };\n    }\n    createUnion(left, right) { return { type: 'union', left, right }; }\n    createValues(variables, bindings) { return { type: 'values', variables, bindings }; }\n    createZeroOrMorePath(path) { return { type: 'ZeroOrMorePath', path }; }\n    createZeroOrOnePath(path) { return { type: 'ZeroOrOnePath', path }; }\n    createAggregateExpression(aggregator, expression, distinct, separator) {\n        if (separator)\n            return { type: 'expression', expressionType: 'aggregate', aggregator: aggregator, expression, separator, distinct };\n        return { type: 'expression', expressionType: 'aggregate', aggregator: aggregator, expression, distinct };\n    }\n    createExistenceExpression(not, input) { return { type: 'expression', expressionType: 'existence', not, input }; }\n    createNamedExpression(name, args) { return { type: 'expression', expressionType: 'named', name, args }; }\n    createOperatorExpression(operator, args) { return { type: 'expression', expressionType: 'operator', operator, args }; }\n    createTermExpression(term) { return { type: 'expression', expressionType: 'term', term }; }\n    createWildcardExpression() { return { type: 'expression', expressionType: 'wildcard', wildcard: new Wildcard() }; }\n    createTerm(str) {\n        return rdf_string_1.stringToTerm(str, this.dataFactory);\n    }\n    // Update functions\n    createCompositeUpdate(updates) { return { type: 'compositeupdate', updates }; }\n    createDeleteInsert(deleteQuads, insertQuads, where) {\n        const result = { type: 'deleteinsert' };\n        if (deleteQuads)\n            result.delete = deleteQuads;\n        if (insertQuads)\n            result.insert = insertQuads;\n        if (where)\n            result.where = where;\n        return result;\n    }\n    createLoad(source, destination, silent) {\n        const result = { type: 'load', source };\n        if (destination)\n            result.destination = destination;\n        return this.addSilent(result, silent);\n    }\n    createClear(source, silent) {\n        return this.addSilent({ type: 'clear', source }, silent);\n    }\n    createCreate(source, silent) {\n        return this.addSilent({ type: 'create', source }, silent);\n    }\n    createDrop(source, silent) {\n        return this.addSilent({ type: 'drop', source }, silent);\n    }\n    createAdd(source, destination, silent) {\n        return this.addSilent({ type: 'add', source, destination }, silent);\n    }\n    createMove(source, destination, silent) {\n        return this.addSilent({ type: 'move', source, destination }, silent);\n    }\n    createCopy(source, destination, silent) {\n        return this.addSilent({ type: 'copy', source, destination }, silent);\n    }\n    addSilent(input, silent) {\n        if (silent)\n            input.silent = silent;\n        return input;\n    }\n}\nexports.default = Factory;\n//# sourceMappingURL=factory.js.map"]},"metadata":{},"sourceType":"script"}