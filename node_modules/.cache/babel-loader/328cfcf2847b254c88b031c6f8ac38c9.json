{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContainerHandlerType = void 0;\n\nconst EntryHandlerPredicate_1 = require(\"../entryhandler/EntryHandlerPredicate\");\n\nconst Util_1 = require(\"../Util\");\n/**\n * Container handler for @type.\n *\n * This will add this entry to the parent node, and use the current key as an rdf:type value.\n */\n\n\nclass ContainerHandlerType {\n  canCombineWithGraph() {\n    return false;\n  }\n\n  async handle(containers, parsingContext, util, keys, value, depth) {\n    if (!Array.isArray(value)) {\n      if (typeof value === 'string') {\n        // Determine the @type of the container\n        const context = await parsingContext.getContext(keys);\n        const containerTypeType = Util_1.Util.getContextValueType(context, keys[depth - 1]); // String values refer to node references\n\n        const id = containerTypeType === '@vocab' ? await util.createVocabOrBaseTerm(context, value) : await util.resourceToTerm(context, value);\n\n        if (id) {\n          // Handle the value of this node as @id, which will also cause the predicate from above to be emitted.\n          const subValue = {\n            '@id': id.termType === 'NamedNode' ? id.value : value\n          };\n          await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), subValue, depth - 1, true); // Set the id in the stack so it can be used for the rdf:type handling later on\n\n          parsingContext.idStack[depth + 1] = [id];\n        }\n      } else {\n        // Other values are handled by handling them as a proper job\n        // Check needed for cases where entries don't have an explicit @id\n        const entryHasIdentifier = !!parsingContext.idStack[depth + 1]; // Handle the value of this node, which will also cause the predicate from above to be emitted.\n\n        if (!entryHasIdentifier) {\n          delete parsingContext.idStack[depth]; // Force new (blank node) identifier\n        }\n\n        await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n\n        if (!entryHasIdentifier) {\n          parsingContext.idStack[depth + 1] = parsingContext.idStack[depth]; // Copy the id to the child node, for @type\n        }\n      } // Identify the type to emit.\n\n\n      const keyOriginal = await util.getContainerKey(keys[depth], keys, depth);\n      const type = keyOriginal !== null ? util.createVocabOrBaseTerm(await parsingContext.getContext(keys), keyOriginal) : null;\n\n      if (type) {\n        // Push the type to the stack using the rdf:type predicate\n        await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, util.rdfType, type, false);\n      } // Flush any pending flush buffers\n\n\n      await parsingContext.handlePendingContainerFlushBuffers();\n    }\n\n    parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n  }\n\n}\n\nexports.ContainerHandlerType = ContainerHandlerType;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-parser/lib/containerhandler/ContainerHandlerType.js"],"names":["Object","defineProperty","exports","value","ContainerHandlerType","EntryHandlerPredicate_1","require","Util_1","canCombineWithGraph","handle","containers","parsingContext","util","keys","depth","Array","isArray","context","getContext","containerTypeType","Util","getContextValueType","id","createVocabOrBaseTerm","resourceToTerm","subValue","termType","newOnValueJob","slice","length","idStack","entryHasIdentifier","keyOriginal","getContainerKey","type","EntryHandlerPredicate","handlePredicateObject","rdfType","handlePendingContainerFlushBuffers","emittedStack"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContainerHandlerType = void 0;\nconst EntryHandlerPredicate_1 = require(\"../entryhandler/EntryHandlerPredicate\");\nconst Util_1 = require(\"../Util\");\n/**\n * Container handler for @type.\n *\n * This will add this entry to the parent node, and use the current key as an rdf:type value.\n */\nclass ContainerHandlerType {\n    canCombineWithGraph() {\n        return false;\n    }\n    async handle(containers, parsingContext, util, keys, value, depth) {\n        if (!Array.isArray(value)) {\n            if (typeof value === 'string') {\n                // Determine the @type of the container\n                const context = await parsingContext.getContext(keys);\n                const containerTypeType = Util_1.Util.getContextValueType(context, keys[depth - 1]);\n                // String values refer to node references\n                const id = containerTypeType === '@vocab'\n                    ? await util.createVocabOrBaseTerm(context, value)\n                    : await util.resourceToTerm(context, value);\n                if (id) {\n                    // Handle the value of this node as @id, which will also cause the predicate from above to be emitted.\n                    const subValue = { '@id': id.termType === 'NamedNode' ? id.value : value };\n                    await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), subValue, depth - 1, true);\n                    // Set the id in the stack so it can be used for the rdf:type handling later on\n                    parsingContext.idStack[depth + 1] = [id];\n                }\n            }\n            else {\n                // Other values are handled by handling them as a proper job\n                // Check needed for cases where entries don't have an explicit @id\n                const entryHasIdentifier = !!parsingContext.idStack[depth + 1];\n                // Handle the value of this node, which will also cause the predicate from above to be emitted.\n                if (!entryHasIdentifier) {\n                    delete parsingContext.idStack[depth]; // Force new (blank node) identifier\n                }\n                await parsingContext.newOnValueJob(keys.slice(0, keys.length - 1), value, depth - 1, true);\n                if (!entryHasIdentifier) {\n                    parsingContext.idStack[depth + 1] = parsingContext.idStack[depth]; // Copy the id to the child node, for @type\n                }\n            }\n            // Identify the type to emit.\n            const keyOriginal = await util.getContainerKey(keys[depth], keys, depth);\n            const type = keyOriginal !== null\n                ? util.createVocabOrBaseTerm(await parsingContext.getContext(keys), keyOriginal)\n                : null;\n            if (type) {\n                // Push the type to the stack using the rdf:type predicate\n                await EntryHandlerPredicate_1.EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth + 1, util.rdfType, type, false);\n            }\n            // Flush any pending flush buffers\n            await parsingContext.handlePendingContainerFlushBuffers();\n        }\n        parsingContext.emittedStack[depth] = false; // Don't emit the predicate owning this container.\n    }\n}\nexports.ContainerHandlerType = ContainerHandlerType;\n//# sourceMappingURL=ContainerHandlerType.js.map"]},"metadata":{},"sourceType":"script"}