{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NonLexicalLiteral = exports.StringLiteral = exports.LangStringLiteral = exports.DateTimeLiteral = exports.BooleanLiteral = exports.NumericLiteral = exports.Literal = exports.BlankNode = exports.NamedNode = exports.Term = void 0;\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst Expressions_1 = require(\"./Expressions\");\n\nconst C = require(\"../util/Consts\");\n\nconst Err = require(\"../util/Errors\");\n\nconst DF = new rdf_data_factory_1.DataFactory();\n\nclass Term {\n  constructor() {\n    this.expressionType = Expressions_1.ExpressionType.Term;\n  }\n\n  str() {\n    throw new Err.InvalidArgumentTypes([this], C.RegularOperator.STR);\n  }\n\n  coerceEBV() {\n    throw new Err.EBVCoercionError(this);\n  }\n\n}\n\nexports.Term = Term; // NamedNodes -----------------------------------------------------------------\n\nclass NamedNode extends Term {\n  constructor(value) {\n    super();\n    this.value = value;\n    this.termType = 'namedNode';\n  }\n\n  toRDF() {\n    return DF.namedNode(this.value);\n  }\n\n  str() {\n    return this.value;\n  }\n\n}\n\nexports.NamedNode = NamedNode; // BlankNodes -----------------------------------------------------------------\n\nclass BlankNode extends Term {\n  constructor(value) {\n    super();\n    this.termType = 'blankNode';\n    this.value = typeof value === 'string' ? DF.blankNode(value) : value;\n  }\n\n  static nextID() {\n    BlankNode._nextID += 1;\n    return BlankNode.nextID.toString();\n  }\n\n  toRDF() {\n    return this.value;\n  }\n\n}\n\nexports.BlankNode = BlankNode;\nBlankNode._nextID = 0; // Literals-- -----------------------------------------------------------------\n\nclass Literal extends Term {\n  constructor(typedValue, typeURL, strValue, language) {\n    super();\n    this.typedValue = typedValue;\n    this.typeURL = typeURL;\n    this.strValue = strValue;\n    this.language = language;\n    this.termType = 'literal';\n    this.type = C.type(typeURL.value);\n  }\n\n  toRDF() {\n    return DF.literal(this.strValue || this.str(), this.language || this.typeURL);\n  }\n\n  str() {\n    return this.strValue || this.typedValue.toString();\n  }\n\n}\n\nexports.Literal = Literal;\n\nclass NumericLiteral extends Literal {\n  coerceEBV() {\n    return !!this.typedValue;\n  }\n\n  toRDF() {\n    const term = super.toRDF();\n\n    if (!isFinite(this.typedValue)) {\n      term.value = term.value.replace('Infinity', 'INF');\n    }\n\n    return term;\n  }\n\n  str() {\n    return this.strValue || NumericLiteral.specificFormatters[this.type](this.typedValue);\n  }\n\n}\n\nexports.NumericLiteral = NumericLiteral;\nNumericLiteral.specificFormatters = {\n  integer: value => value.toFixed(),\n  float: value => value.toString(),\n  decimal: value => value.toString(),\n  // // Be consistent with float\n  // decimal: (value) => {\n  //   const jsDecimal = value.toString();\n  //   return jsDecimal.match(/\\./)\n  //     ? jsDecimal\n  //     : jsDecimal + '.0';\n  // },\n  // https://www.w3.org/TR/xmlschema-2/#double\n  double: value => {\n    const jsExponential = value.toExponential();\n    const [jsMantisse, jsExponent] = jsExponential.split('e'); // leading + must be removed for integer\n    // https://www.w3.org/TR/xmlschema-2/#integer\n\n    const exponent = jsExponent.replace(/\\+/, ''); // SPARQL test suite prefers trailing zero's\n\n    const mantisse = jsMantisse.match(/\\./) ? jsMantisse : jsMantisse + '.0';\n    return `${mantisse}E${exponent}`;\n  }\n};\n\nclass BooleanLiteral extends Literal {\n  constructor(typedValue, strValue) {\n    super(typedValue, C.make(C.TypeURL.XSD_BOOLEAN), strValue);\n    this.typedValue = typedValue;\n    this.strValue = strValue;\n  }\n\n  coerceEBV() {\n    return !!this.typedValue;\n  }\n\n}\n\nexports.BooleanLiteral = BooleanLiteral;\n\nclass DateTimeLiteral extends Literal {\n  // strValue is mandatory here because toISOString will always add\n  // milliseconds, even if they were not present.\n  constructor(typedValue, strValue) {\n    super(typedValue, C.make(C.TypeURL.XSD_DATE_TIME), strValue);\n    this.typedValue = typedValue;\n    this.strValue = strValue;\n  }\n\n}\n\nexports.DateTimeLiteral = DateTimeLiteral;\n\nclass LangStringLiteral extends Literal {\n  constructor(typedValue, language) {\n    super(typedValue, C.make(C.TypeURL.RDF_LANG_STRING), typedValue, language);\n    this.typedValue = typedValue;\n    this.language = language;\n  }\n\n  coerceEBV() {\n    return this.strValue.length !== 0;\n  }\n\n}\n\nexports.LangStringLiteral = LangStringLiteral; // https://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal\n// https://www.w3.org/TR/sparql11-query/#defn_SimpleLiteral\n// https://www.w3.org/TR/sparql11-query/#func-strings\n// This does not include language tagged literals\n\nclass StringLiteral extends Literal {\n  constructor(typedValue) {\n    super(typedValue, C.make(C.TypeURL.XSD_STRING), typedValue);\n    this.typedValue = typedValue;\n  }\n\n  coerceEBV() {\n    return this.strValue.length !== 0;\n  }\n\n}\n\nexports.StringLiteral = StringLiteral;\n/*\n * This class is used when a literal is parsed, and it's value is\n * an invalid lexical form for it's datatype. The spec defines value with\n * invalid lexical form are still valid terms, and as such we can not error\n * immediately. This class makes sure that the typedValue will remain undefined,\n * and the category 'nonlexical'. This way, only when operators apply to the\n * 'nonlexical' category, they will keep working, otherwise they will throw a\n * type error.\n * This seems to match the spec, except maybe for functions that accept\n * non-lexical values for their datatype.\n *\n * See:\n *  - https://www.w3.org/TR/xquery/#dt-type-error\n *  - https://www.w3.org/TR/rdf-concepts/#section-Literal-Value\n *  - https://www.w3.org/TR/xquery/#dt-ebv\n *  - ... some other more precise thing i can't find...\n */\n\nclass NonLexicalLiteral extends Literal {\n  constructor(typedValue, typeURL, strValue, language) {\n    super(typedValue, typeURL, strValue, language);\n    this.typedValue = undefined;\n    this.type = 'nonlexical';\n    this.shouldBeCategory = C.type(typeURL.value);\n  }\n\n  coerceEBV() {\n    const isNumericOrBool = C.PrimitiveNumericTypes.contains(this.shouldBeCategory) || this.shouldBeCategory === 'boolean';\n\n    if (isNumericOrBool) {\n      return false;\n    }\n\n    throw new Err.EBVCoercionError(this);\n  }\n\n}\n\nexports.NonLexicalLiteral = NonLexicalLiteral;","map":{"version":3,"sources":["../../../lib/expressions/Term.ts"],"names":[],"mappings":"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","sourcesContent":["import {DataFactory} from 'rdf-data-factory';\nimport * as RDF from 'rdf-js';\n\nimport { ExpressionType, TermExpression, TermType } from './Expressions';\n\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nconst DF = new DataFactory();\n\nexport abstract class Term implements TermExpression {\n  expressionType: ExpressionType.Term = ExpressionType.Term;\n  abstract termType: TermType;\n\n  abstract toRDF(): RDF.Term;\n\n  str(): string {\n    throw new Err.InvalidArgumentTypes([this], C.RegularOperator.STR);\n  }\n\n  coerceEBV(): boolean {\n    throw new Err.EBVCoercionError(this);\n  }\n\n}\n\n// NamedNodes -----------------------------------------------------------------\nexport class NamedNode extends Term {\n  termType: TermType = 'namedNode';\n  constructor(public value: string) { super(); }\n\n  toRDF(): RDF.Term {\n    return DF.namedNode(this.value);\n  }\n\n  str(): string {\n    return this.value;\n  }\n}\n\n// BlankNodes -----------------------------------------------------------------\n\nexport class BlankNode extends Term {\n  static _nextID = 0;\n\n  value: RDF.BlankNode;\n  termType: TermType = 'blankNode';\n\n  constructor(value: RDF.BlankNode|string) {\n    super();\n    this.value = typeof value === 'string' ? DF.blankNode(value) : value;\n  }\n\n  static nextID() {\n    BlankNode._nextID += 1;\n    return BlankNode.nextID.toString();\n  }\n\n  toRDF(): RDF.Term {\n    return this.value;\n  }\n}\n\n// Literals-- -----------------------------------------------------------------\nexport class Literal<T> extends Term {\n  termType: 'literal' = 'literal';\n  type: C.Type;\n\n  constructor(\n    public typedValue: T,\n    public typeURL: RDF.NamedNode,\n    public strValue?: string,\n    public language?: string) {\n    super();\n    this.type = C.type(typeURL.value);\n  }\n\n  toRDF(): RDF.Term {\n    return DF.literal(\n      this.strValue || this.str(),\n      this.language || this.typeURL);\n  }\n\n  str(): string {\n    return this.strValue || this.typedValue.toString();\n  }\n}\n\nexport class NumericLiteral extends Literal<number> {\n  private static specificFormatters: { [key in C.PrimitiveNumericType]: (val: number) => string } = {\n    integer: (value) => value.toFixed(), // Avoid emitting non lexical integers\n    float: (value) => value.toString(),\n    decimal: (value) => value.toString(),\n    // // Be consistent with float\n    // decimal: (value) => {\n    //   const jsDecimal = value.toString();\n    //   return jsDecimal.match(/\\./)\n    //     ? jsDecimal\n    //     : jsDecimal + '.0';\n    // },\n\n    // https://www.w3.org/TR/xmlschema-2/#double\n    double: (value) => {\n      const jsExponential = value.toExponential();\n      const [jsMantisse, jsExponent] = jsExponential.split('e');\n\n      // leading + must be removed for integer\n      // https://www.w3.org/TR/xmlschema-2/#integer\n      const exponent = jsExponent.replace(/\\+/, '');\n\n      // SPARQL test suite prefers trailing zero's\n      const mantisse = jsMantisse.match(/\\./)\n        ? jsMantisse\n        : jsMantisse + '.0';\n\n      return `${mantisse}E${exponent}`;\n    },\n  };\n\n  type: C.PrimitiveNumericType;\n\n  coerceEBV(): boolean {\n    return !!this.typedValue;\n  }\n\n  toRDF(): RDF.Term {\n    const term = super.toRDF();\n    if (!isFinite(this.typedValue)) {\n      term.value = term.value.replace('Infinity', 'INF');\n    }\n    return term;\n  }\n\n  str(): string {\n    return this.strValue\n      || NumericLiteral.specificFormatters[this.type](this.typedValue);\n  }\n}\n\nexport class BooleanLiteral extends Literal<boolean> {\n  constructor(public typedValue: boolean, public strValue?: string) {\n    super(typedValue, C.make(C.TypeURL.XSD_BOOLEAN), strValue);\n  }\n  coerceEBV(): boolean {\n    return !!this.typedValue;\n  }\n}\n\nexport class DateTimeLiteral extends Literal<Date> {\n  // strValue is mandatory here because toISOString will always add\n  // milliseconds, even if they were not present.\n  constructor(public typedValue: Date, public strValue: string) {\n    super(typedValue, C.make(C.TypeURL.XSD_DATE_TIME), strValue);\n  }\n}\n\nexport class LangStringLiteral extends Literal<string> {\n  constructor(public typedValue: string, public language: string) {\n    super(typedValue, C.make(C.TypeURL.RDF_LANG_STRING), typedValue, language);\n  }\n\n  coerceEBV(): boolean {\n    return this.strValue.length !== 0;\n  }\n}\n\n// https://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal\n// https://www.w3.org/TR/sparql11-query/#defn_SimpleLiteral\n// https://www.w3.org/TR/sparql11-query/#func-strings\n// This does not include language tagged literals\nexport class StringLiteral extends Literal<string> {\n  constructor(public typedValue: string) {\n    super(typedValue, C.make(C.TypeURL.XSD_STRING), typedValue);\n  }\n\n  coerceEBV(): boolean {\n    return this.strValue.length !== 0;\n  }\n}\n\n/*\n * This class is used when a literal is parsed, and it's value is\n * an invalid lexical form for it's datatype. The spec defines value with\n * invalid lexical form are still valid terms, and as such we can not error\n * immediately. This class makes sure that the typedValue will remain undefined,\n * and the category 'nonlexical'. This way, only when operators apply to the\n * 'nonlexical' category, they will keep working, otherwise they will throw a\n * type error.\n * This seems to match the spec, except maybe for functions that accept\n * non-lexical values for their datatype.\n *\n * See:\n *  - https://www.w3.org/TR/xquery/#dt-type-error\n *  - https://www.w3.org/TR/rdf-concepts/#section-Literal-Value\n *  - https://www.w3.org/TR/xquery/#dt-ebv\n *  - ... some other more precise thing i can't find...\n */\nexport class NonLexicalLiteral extends Literal<undefined> {\n  private shouldBeCategory: C.Type;\n  constructor(\n    typedValue: undefined,\n    typeURL: RDF.NamedNode,\n    strValue?: string,\n    language?: string) {\n    super(typedValue, typeURL, strValue, language);\n    this.typedValue = undefined;\n    this.type = 'nonlexical';\n    this.shouldBeCategory = C.type(typeURL.value);\n  }\n\n  coerceEBV(): boolean {\n    const isNumericOrBool =\n      C.PrimitiveNumericTypes.contains(this.shouldBeCategory)\n      || this.shouldBeCategory === 'boolean';\n\n    if (isNumericOrBool) { return false; }\n    throw new Err.EBVCoercionError(this);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}