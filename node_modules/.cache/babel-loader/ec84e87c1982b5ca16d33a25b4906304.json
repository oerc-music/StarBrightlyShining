{"ast":null,"code":"var Parser = require('./lib/SparqlParser').Parser;\n\nvar Generator = require('./lib/SparqlGenerator');\n\nvar Wildcard = require(\"./lib/Wildcard\").Wildcard;\n\nvar {\n  DataFactory\n} = require('rdf-data-factory');\n\nmodule.exports = {\n  /**\n   * Creates a SPARQL parser with the given pre-defined prefixes and base IRI\n   * @param options {\n   *   prefixes?: { [prefix: string]: string },\n   *   baseIRI?: string,\n   *   factory?: import('rdf-js').DataFactory,\n   *   sparqlStar?: boolean,\n   * }\n   */\n  Parser: function ({\n    prefixes,\n    baseIRI,\n    factory,\n    sparqlStar,\n    skipUngroupedVariableCheck\n  } = {}) {\n    // Create a copy of the prefixes\n    var prefixesCopy = {};\n\n    for (var prefix in prefixes || {}) prefixesCopy[prefix] = prefixes[prefix]; // Create a new parser with the given prefixes\n    // (Workaround for https://github.com/zaach/jison/issues/241)\n\n\n    var parser = new Parser();\n\n    parser.parse = function () {\n      Parser.base = baseIRI || '';\n      Parser.prefixes = Object.create(prefixesCopy);\n      Parser.factory = factory || new DataFactory();\n      Parser.sparqlStar = Boolean(sparqlStar);\n      Parser.skipUngroupedVariableCheck = Boolean(skipUngroupedVariableCheck);\n      return Parser.prototype.parse.apply(parser, arguments);\n    };\n\n    parser._resetBlanks = Parser._resetBlanks;\n    return parser;\n  },\n  Generator: Generator,\n  Wildcard: Wildcard\n};","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/sparqljs/sparql.js"],"names":["Parser","require","Generator","Wildcard","DataFactory","module","exports","prefixes","baseIRI","factory","sparqlStar","skipUngroupedVariableCheck","prefixesCopy","prefix","parser","parse","base","Object","create","Boolean","prototype","apply","arguments","_resetBlanks"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,oBAAD,CAAP,CAA8BD,MAA3C;;AACA,IAAIE,SAAS,GAAGD,OAAO,CAAC,uBAAD,CAAvB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,gBAAD,CAAP,CAA0BE,QAAzC;;AACA,IAAI;AAAEC,EAAAA;AAAF,IAAkBH,OAAO,CAAC,kBAAD,CAA7B;;AAEAI,MAAM,CAACC,OAAP,GAAiB;AACf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEN,EAAAA,MAAM,EAAE,UAAU;AAAEO,IAAAA,QAAF;AAAYC,IAAAA,OAAZ;AAAqBC,IAAAA,OAArB;AAA8BC,IAAAA,UAA9B;AAA0CC,IAAAA;AAA1C,MAAyE,EAAnF,EAAuF;AAC7F;AACA,QAAIC,YAAY,GAAG,EAAnB;;AACA,SAAK,IAAIC,MAAT,IAAmBN,QAAQ,IAAI,EAA/B,EACEK,YAAY,CAACC,MAAD,CAAZ,GAAuBN,QAAQ,CAACM,MAAD,CAA/B,CAJ2F,CAM7F;AACA;;;AACA,QAAIC,MAAM,GAAG,IAAId,MAAJ,EAAb;;AACAc,IAAAA,MAAM,CAACC,KAAP,GAAe,YAAY;AACzBf,MAAAA,MAAM,CAACgB,IAAP,GAAcR,OAAO,IAAI,EAAzB;AACAR,MAAAA,MAAM,CAACO,QAAP,GAAkBU,MAAM,CAACC,MAAP,CAAcN,YAAd,CAAlB;AACAZ,MAAAA,MAAM,CAACS,OAAP,GAAiBA,OAAO,IAAI,IAAIL,WAAJ,EAA5B;AACAJ,MAAAA,MAAM,CAACU,UAAP,GAAoBS,OAAO,CAACT,UAAD,CAA3B;AACAV,MAAAA,MAAM,CAACW,0BAAP,GAAoCQ,OAAO,CAACR,0BAAD,CAA3C;AACA,aAAOX,MAAM,CAACoB,SAAP,CAAiBL,KAAjB,CAAuBM,KAAvB,CAA6BP,MAA7B,EAAqCQ,SAArC,CAAP;AACD,KAPD;;AAQAR,IAAAA,MAAM,CAACS,YAAP,GAAsBvB,MAAM,CAACuB,YAA7B;AACA,WAAOT,MAAP;AACD,GA7Bc;AA8BfZ,EAAAA,SAAS,EAAEA,SA9BI;AA+BfC,EAAAA,QAAQ,EAAEA;AA/BK,CAAjB","sourcesContent":["var Parser = require('./lib/SparqlParser').Parser;\nvar Generator = require('./lib/SparqlGenerator');\nvar Wildcard = require(\"./lib/Wildcard\").Wildcard;\nvar { DataFactory } = require('rdf-data-factory');\n\nmodule.exports = {\n  /**\n   * Creates a SPARQL parser with the given pre-defined prefixes and base IRI\n   * @param options {\n   *   prefixes?: { [prefix: string]: string },\n   *   baseIRI?: string,\n   *   factory?: import('rdf-js').DataFactory,\n   *   sparqlStar?: boolean,\n   * }\n   */\n  Parser: function ({ prefixes, baseIRI, factory, sparqlStar, skipUngroupedVariableCheck } = {}) {\n    // Create a copy of the prefixes\n    var prefixesCopy = {};\n    for (var prefix in prefixes || {})\n      prefixesCopy[prefix] = prefixes[prefix];\n\n    // Create a new parser with the given prefixes\n    // (Workaround for https://github.com/zaach/jison/issues/241)\n    var parser = new Parser();\n    parser.parse = function () {\n      Parser.base = baseIRI || '';\n      Parser.prefixes = Object.create(prefixesCopy);\n      Parser.factory = factory || new DataFactory();\n      Parser.sparqlStar = Boolean(sparqlStar);\n      Parser.skipUngroupedVariableCheck = Boolean(skipUngroupedVariableCheck)\n      return Parser.prototype.parse.apply(parser, arguments);\n    };\n    parser._resetBlanks = Parser._resetBlanks;\n    return parser;\n  },\n  Generator: Generator,\n  Wildcard: Wildcard,\n};\n"]},"metadata":{},"sourceType":"script"}