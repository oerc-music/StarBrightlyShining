{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EntryHandlerPredicate = void 0;\n\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n\nconst Util_1 = require(\"../Util\");\n/**\n * Interprets keys as predicates.\n * The most common case in JSON-LD processing.\n */\n\n\nclass EntryHandlerPredicate {\n  /**\n   * Handle the given predicate-object by either emitting it,\n   * or by placing it in the appropriate stack for later emission when no @graph and/or @id has been defined.\n   * @param {ParsingContext} parsingContext A parsing context.\n   * @param {Util} util A utility instance.\n   * @param {any[]} keys A stack of keys.\n   * @param {number} depth The current depth.\n   * @param {Term} predicate The predicate.\n   * @param {Term} object The object.\n   * @param {boolean} reverse If the property is reversed.\n   * @return {Promise<void>} A promise resolving when handling is done.\n   */\n  static async handlePredicateObject(parsingContext, util, keys, depth, predicate, object, reverse) {\n    const depthProperties = await util.getPropertiesDepth(keys, depth);\n    const depthOffsetGraph = await util.getDepthOffsetGraph(depth, keys);\n    const depthPropertiesGraph = depth - depthOffsetGraph;\n    const subjects = parsingContext.idStack[depthProperties];\n\n    if (subjects) {\n      // Emit directly if the @id was already defined\n      for (const subject of subjects) {\n        // Check if we're in a @graph context\n        const atGraph = depthOffsetGraph >= 0;\n\n        if (atGraph) {\n          const graphs = parsingContext.idStack[depthPropertiesGraph - 1];\n\n          if (graphs) {\n            for (const graph of graphs) {\n              // Emit our quad if graph @id is known\n              if (reverse) {\n                util.validateReverseSubject(object);\n                parsingContext.emitQuad(depth, util.dataFactory.quad(object, predicate, subject, graph));\n              } else {\n                parsingContext.emitQuad(depth, util.dataFactory.quad(subject, predicate, object, graph));\n              }\n            }\n          } else {\n            // Buffer our triple if graph @id is not known yet.\n            if (reverse) {\n              util.validateReverseSubject(object);\n              parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push({\n                subject: object,\n                predicate,\n                object: subject\n              });\n            } else {\n              parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push({\n                subject,\n                predicate,\n                object\n              });\n            }\n          }\n        } else {\n          // Emit if no @graph was applicable\n          const graph = await util.getGraphContainerValue(keys, depthProperties);\n\n          if (reverse) {\n            util.validateReverseSubject(object);\n            parsingContext.emitQuad(depth, util.dataFactory.quad(object, predicate, subject, graph));\n          } else {\n            parsingContext.emitQuad(depth, util.dataFactory.quad(subject, predicate, object, graph));\n          }\n        }\n      }\n    } else {\n      // Buffer until our @id becomes known, or we go up the stack\n      if (reverse) {\n        util.validateReverseSubject(object);\n      }\n\n      parsingContext.getUnidentifiedValueBufferSafe(depthProperties).push({\n        predicate,\n        object,\n        reverse\n      });\n    }\n  }\n\n  isPropertyHandler() {\n    return true;\n  }\n\n  isStackProcessor() {\n    return true;\n  }\n\n  async validate(parsingContext, util, keys, depth, inProperty) {\n    const key = keys[depth];\n\n    if (key) {\n      const context = await parsingContext.getContext(keys);\n\n      if (!parsingContext.jsonLiteralStack[depth] && (await util.predicateToTerm(context, keys[depth]))) {\n        // If this valid predicate is of type @json, mark it so in the stack so that no deeper handling of nodes occurs.\n        if (Util_1.Util.getContextValueType(context, key) === '@json') {\n          parsingContext.jsonLiteralStack[depth + 1] = true;\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async test(parsingContext, util, key, keys, depth) {\n    return keys[depth];\n  }\n\n  async handle(parsingContext, util, key, keys, value, depth, testResult) {\n    const keyOriginal = keys[depth];\n    const context = await parsingContext.getContext(keys);\n    const predicate = await util.predicateToTerm(context, key);\n\n    if (predicate) {\n      const objects = await util.valueToTerm(context, key, value, depth, keys);\n\n      if (objects.length) {\n        for (let object of objects) {\n          const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, await util.unaliasKeywordParent(keys, depth));\n\n          if (value) {\n            // Special case if our term was defined as an @list, but does not occur in an array,\n            // In that case we just emit it as an RDF list with a single element.\n            const listValueContainer = ('@list' in Util_1.Util.getContextValueContainer(context, key));\n\n            if (listValueContainer || value['@list']) {\n              if ((listValueContainer && !Array.isArray(value) && !value['@list'] || value['@list'] && !Array.isArray(value['@list'])) && object !== util.rdfNil) {\n                const listPointer = util.dataFactory.blankNode();\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfRest, util.rdfNil, util.getDefaultGraph()));\n                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfFirst, object, util.getDefaultGraph()));\n                object = listPointer;\n              } // Lists are not allowed in @reverse'd properties\n\n\n              if (reverse && !parsingContext.allowSubjectList) {\n                throw new jsonld_context_parser_1.ErrorCoded(`Found illegal list value in subject position at ${key}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n              }\n            }\n          }\n\n          await EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, object, reverse);\n        }\n      }\n    }\n  }\n\n}\n\nexports.EntryHandlerPredicate = EntryHandlerPredicate;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerPredicate.js"],"names":["Object","defineProperty","exports","value","EntryHandlerPredicate","jsonld_context_parser_1","require","Util_1","handlePredicateObject","parsingContext","util","keys","depth","predicate","object","reverse","depthProperties","getPropertiesDepth","depthOffsetGraph","getDepthOffsetGraph","depthPropertiesGraph","subjects","idStack","subject","atGraph","graphs","graph","validateReverseSubject","emitQuad","dataFactory","quad","getUnidentifiedGraphBufferSafe","push","getGraphContainerValue","getUnidentifiedValueBufferSafe","isPropertyHandler","isStackProcessor","validate","inProperty","key","context","getContext","jsonLiteralStack","predicateToTerm","Util","getContextValueType","test","handle","testResult","keyOriginal","objects","valueToTerm","length","isPropertyReverse","unaliasKeywordParent","listValueContainer","getContextValueContainer","Array","isArray","rdfNil","listPointer","blankNode","rdfRest","getDefaultGraph","rdfFirst","allowSubjectList","ErrorCoded","ERROR_CODES","INVALID_REVERSE_PROPERTY_VALUE"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerPredicate = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst Util_1 = require(\"../Util\");\n/**\n * Interprets keys as predicates.\n * The most common case in JSON-LD processing.\n */\nclass EntryHandlerPredicate {\n    /**\n     * Handle the given predicate-object by either emitting it,\n     * or by placing it in the appropriate stack for later emission when no @graph and/or @id has been defined.\n     * @param {ParsingContext} parsingContext A parsing context.\n     * @param {Util} util A utility instance.\n     * @param {any[]} keys A stack of keys.\n     * @param {number} depth The current depth.\n     * @param {Term} predicate The predicate.\n     * @param {Term} object The object.\n     * @param {boolean} reverse If the property is reversed.\n     * @return {Promise<void>} A promise resolving when handling is done.\n     */\n    static async handlePredicateObject(parsingContext, util, keys, depth, predicate, object, reverse) {\n        const depthProperties = await util.getPropertiesDepth(keys, depth);\n        const depthOffsetGraph = await util.getDepthOffsetGraph(depth, keys);\n        const depthPropertiesGraph = depth - depthOffsetGraph;\n        const subjects = parsingContext.idStack[depthProperties];\n        if (subjects) {\n            // Emit directly if the @id was already defined\n            for (const subject of subjects) {\n                // Check if we're in a @graph context\n                const atGraph = depthOffsetGraph >= 0;\n                if (atGraph) {\n                    const graphs = parsingContext.idStack[depthPropertiesGraph - 1];\n                    if (graphs) {\n                        for (const graph of graphs) {\n                            // Emit our quad if graph @id is known\n                            if (reverse) {\n                                util.validateReverseSubject(object);\n                                parsingContext.emitQuad(depth, util.dataFactory.quad(object, predicate, subject, graph));\n                            }\n                            else {\n                                parsingContext.emitQuad(depth, util.dataFactory.quad(subject, predicate, object, graph));\n                            }\n                        }\n                    }\n                    else {\n                        // Buffer our triple if graph @id is not known yet.\n                        if (reverse) {\n                            util.validateReverseSubject(object);\n                            parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1).push({ subject: object, predicate, object: subject });\n                        }\n                        else {\n                            parsingContext.getUnidentifiedGraphBufferSafe(depthPropertiesGraph - 1)\n                                .push({ subject, predicate, object });\n                        }\n                    }\n                }\n                else {\n                    // Emit if no @graph was applicable\n                    const graph = await util.getGraphContainerValue(keys, depthProperties);\n                    if (reverse) {\n                        util.validateReverseSubject(object);\n                        parsingContext.emitQuad(depth, util.dataFactory.quad(object, predicate, subject, graph));\n                    }\n                    else {\n                        parsingContext.emitQuad(depth, util.dataFactory.quad(subject, predicate, object, graph));\n                    }\n                }\n            }\n        }\n        else {\n            // Buffer until our @id becomes known, or we go up the stack\n            if (reverse) {\n                util.validateReverseSubject(object);\n            }\n            parsingContext.getUnidentifiedValueBufferSafe(depthProperties).push({ predicate, object, reverse });\n        }\n    }\n    isPropertyHandler() {\n        return true;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        const key = keys[depth];\n        if (key) {\n            const context = await parsingContext.getContext(keys);\n            if (!parsingContext.jsonLiteralStack[depth] && await util.predicateToTerm(context, keys[depth])) {\n                // If this valid predicate is of type @json, mark it so in the stack so that no deeper handling of nodes occurs.\n                if (Util_1.Util.getContextValueType(context, key) === '@json') {\n                    parsingContext.jsonLiteralStack[depth + 1] = true;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        return keys[depth];\n    }\n    async handle(parsingContext, util, key, keys, value, depth, testResult) {\n        const keyOriginal = keys[depth];\n        const context = await parsingContext.getContext(keys);\n        const predicate = await util.predicateToTerm(context, key);\n        if (predicate) {\n            const objects = await util.valueToTerm(context, key, value, depth, keys);\n            if (objects.length) {\n                for (let object of objects) {\n                    const reverse = Util_1.Util.isPropertyReverse(context, keyOriginal, await util.unaliasKeywordParent(keys, depth));\n                    if (value) {\n                        // Special case if our term was defined as an @list, but does not occur in an array,\n                        // In that case we just emit it as an RDF list with a single element.\n                        const listValueContainer = '@list' in Util_1.Util.getContextValueContainer(context, key);\n                        if (listValueContainer || value['@list']) {\n                            if (((listValueContainer && !Array.isArray(value) && !value['@list'])\n                                || (value['@list'] && !Array.isArray(value['@list'])))\n                                && object !== util.rdfNil) {\n                                const listPointer = util.dataFactory.blankNode();\n                                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfRest, util.rdfNil, util.getDefaultGraph()));\n                                parsingContext.emitQuad(depth, util.dataFactory.quad(listPointer, util.rdfFirst, object, util.getDefaultGraph()));\n                                object = listPointer;\n                            }\n                            // Lists are not allowed in @reverse'd properties\n                            if (reverse && !parsingContext.allowSubjectList) {\n                                throw new jsonld_context_parser_1.ErrorCoded(`Found illegal list value in subject position at ${key}`, jsonld_context_parser_1.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE);\n                            }\n                        }\n                    }\n                    await EntryHandlerPredicate.handlePredicateObject(parsingContext, util, keys, depth, predicate, object, reverse);\n                }\n            }\n        }\n    }\n}\nexports.EntryHandlerPredicate = EntryHandlerPredicate;\n//# sourceMappingURL=EntryHandlerPredicate.js.map"]},"metadata":{},"sourceType":"script"}