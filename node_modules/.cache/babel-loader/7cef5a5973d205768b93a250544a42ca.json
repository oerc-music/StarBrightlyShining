{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport React from 'react';\nimport withWebId from './withWebId';\nimport ExpressionEvaluator from '../ExpressionEvaluator';\nimport { pick, getDisplayName } from '../util';\n/**\n * Higher-order component that evaluates LDflex expressions in properties\n * and passes their results to the wrapped component.\n */\n\nexport default function evaluateExpressions(valueProps, listProps, Component) {\n  // Shift the optional listProps parameter when not specified\n  if (!Component) [Component, listProps] = [listProps, []];\n  valueProps = valueProps ? [...valueProps] : [];\n  listProps = listProps ? [...listProps] : []; // Create the initial state for all Component instances\n\n  const initialState = {\n    pending: true\n  };\n\n  for (const name of valueProps) initialState[name] = undefined;\n\n  for (const name of listProps) initialState[name] = []; // Create a higher-order component that wraps the given Component\n\n\n  class EvaluateExpressions extends React.Component {\n    constructor(...args) {\n      super(...args);\n\n      _defineProperty(this, \"state\", initialState);\n    }\n\n    componentDidMount() {\n      this.evaluator = new ExpressionEvaluator();\n\n      this.update = state => this.setState(state);\n\n      this.evaluate(valueProps, listProps);\n    }\n\n    componentDidUpdate(prevProps) {\n      // A property needs to be re-evaluated if it changed\n      // or, if it is a string expression, when the user has changed\n      // (which might influence the expression's evaluation).\n      const newUser = this.props.webId !== prevProps.webId;\n\n      const changed = name => this.props[name] !== prevProps[name] || newUser && typeof this.props[name] === 'string';\n\n      this.evaluate(valueProps.filter(changed), listProps.filter(changed));\n    }\n\n    componentWillUnmount() {\n      this.evaluator.destroy();\n    }\n\n    render() {\n      return /*#__PURE__*/React.createElement(Component, _extends({}, this.props, this.state));\n    }\n\n    evaluate(values, lists) {\n      const {\n        props,\n        evaluator\n      } = this;\n      if (values.length > 0 || lists.length > 0) evaluator.evaluate(pick(props, values), pick(props, lists), this.update);\n    }\n\n  }\n\n  _defineProperty(EvaluateExpressions, \"displayName\", `EvaluateExpressions(${getDisplayName(Component)})`);\n\n  return withWebId(EvaluateExpressions);\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@solid/react/module/components/evaluateExpressions.js"],"names":["_extends","_defineProperty","React","withWebId","ExpressionEvaluator","pick","getDisplayName","evaluateExpressions","valueProps","listProps","Component","initialState","pending","name","undefined","EvaluateExpressions","constructor","args","componentDidMount","evaluator","update","state","setState","evaluate","componentDidUpdate","prevProps","newUser","props","webId","changed","filter","componentWillUnmount","destroy","render","createElement","values","lists","length"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport React from 'react';\nimport withWebId from './withWebId';\nimport ExpressionEvaluator from '../ExpressionEvaluator';\nimport { pick, getDisplayName } from '../util';\n/**\n * Higher-order component that evaluates LDflex expressions in properties\n * and passes their results to the wrapped component.\n */\n\nexport default function evaluateExpressions(valueProps, listProps, Component) {\n  // Shift the optional listProps parameter when not specified\n  if (!Component) [Component, listProps] = [listProps, []];\n  valueProps = valueProps ? [...valueProps] : [];\n  listProps = listProps ? [...listProps] : []; // Create the initial state for all Component instances\n\n  const initialState = {\n    pending: true\n  };\n\n  for (const name of valueProps) initialState[name] = undefined;\n\n  for (const name of listProps) initialState[name] = []; // Create a higher-order component that wraps the given Component\n\n\n  class EvaluateExpressions extends React.Component {\n    constructor(...args) {\n      super(...args);\n\n      _defineProperty(this, \"state\", initialState);\n    }\n\n    componentDidMount() {\n      this.evaluator = new ExpressionEvaluator();\n\n      this.update = state => this.setState(state);\n\n      this.evaluate(valueProps, listProps);\n    }\n\n    componentDidUpdate(prevProps) {\n      // A property needs to be re-evaluated if it changed\n      // or, if it is a string expression, when the user has changed\n      // (which might influence the expression's evaluation).\n      const newUser = this.props.webId !== prevProps.webId;\n\n      const changed = name => this.props[name] !== prevProps[name] || newUser && typeof this.props[name] === 'string';\n\n      this.evaluate(valueProps.filter(changed), listProps.filter(changed));\n    }\n\n    componentWillUnmount() {\n      this.evaluator.destroy();\n    }\n\n    render() {\n      return /*#__PURE__*/React.createElement(Component, _extends({}, this.props, this.state));\n    }\n\n    evaluate(values, lists) {\n      const {\n        props,\n        evaluator\n      } = this;\n      if (values.length > 0 || lists.length > 0) evaluator.evaluate(pick(props, values), pick(props, lists), this.update);\n    }\n\n  }\n\n  _defineProperty(EvaluateExpressions, \"displayName\", `EvaluateExpressions(${getDisplayName(Component)})`);\n\n  return withWebId(EvaluateExpressions);\n}"]},"metadata":{},"sourceType":"module"}