{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SparqlEndpointFetcher = void 0;\n\nrequire(\"cross-fetch/polyfill\");\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst sparqljs_1 = require(\"sparqljs\");\n\nconst sparqljson_parse_1 = require(\"sparqljson-parse\");\n\nconst sparqlxml_parse_1 = require(\"sparqlxml-parse\"); // tslint:disable:no-var-requires\n\n\nconst n3 = require('n3');\n\nconst isStream = require('is-stream');\n\nconst toNodeReadable = require('web-streams-node').toNodeReadable;\n/**\n * A SparqlEndpointFetcher can send queries to SPARQL endpoints,\n * and retrieve and parse the results.\n */\n\n\nclass SparqlEndpointFetcher {\n  constructor(args) {\n    args = args || {};\n    this.method = args.method || 'POST';\n    this.fetchCb = args.fetch;\n    this.sparqlJsonParser = new sparqljson_parse_1.SparqlJsonParser(args);\n    this.sparqlXmlParser = new sparqlxml_parse_1.SparqlXmlParser(args);\n    this.sparqlParsers = {\n      [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON]: {\n        parseBooleanStream: sparqlResponseStream => this.sparqlJsonParser.parseJsonBooleanStream(sparqlResponseStream),\n        parseResultsStream: sparqlResponseStream => this.sparqlJsonParser.parseJsonResultsStream(sparqlResponseStream)\n      },\n      [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML]: {\n        parseBooleanStream: sparqlResponseStream => this.sparqlXmlParser.parseXmlBooleanStream(sparqlResponseStream),\n        parseResultsStream: sparqlResponseStream => this.sparqlXmlParser.parseXmlResultsStream(sparqlResponseStream)\n      }\n    };\n  }\n  /**\n   * Get the query type of the given query.\n   *\n   * This will parse the query and thrown an exception on syntax errors.\n   *\n   * @param {string} query A query.\n   * @return {\"SELECT\" | \"ASK\" | \"CONSTRUCT\" | \"UNKNOWN\"} The query type.\n   */\n\n\n  getQueryType(query) {\n    const parsedQuery = new sparqljs_1.Parser().parse(query);\n    return parsedQuery.type === 'query' ? parsedQuery.queryType === 'DESCRIBE' ? 'CONSTRUCT' : parsedQuery.queryType : \"UNKNOWN\";\n  }\n  /**\n   * Get the query type of the given update query.\n   *\n   * This will parse the update query and thrown an exception on syntax errors.\n   *\n   * @param {string} query An update query.\n   * @return {'UNKNOWN' | UpdateTypes} The included update operations.\n   */\n\n\n  getUpdateTypes(query) {\n    const parsedQuery = new sparqljs_1.Parser().parse(query);\n\n    if (parsedQuery.type === 'update') {\n      const operations = {};\n\n      for (const update of parsedQuery.updates) {\n        if ('type' in update) {\n          operations[update.type] = true;\n        } else {\n          operations[update.updateType] = true;\n        }\n      }\n\n      return operations;\n    } else {\n      return \"UNKNOWN\";\n    }\n\n    ;\n  }\n\n  /**\n   * Send a SELECT query to the given endpoint URL and return the resulting bindings stream.\n   * @see IBindings\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<NodeJS.ReadableStream>} A stream of {@link IBindings}.\n   */\n  async fetchBindings(endpoint, query) {\n    const [contentType, responseStream] = await this.fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_SPARQL);\n    const parser = this.sparqlParsers[contentType];\n\n    if (!parser) {\n      throw new Error('Unknown SPARQL results content type: ' + contentType);\n    }\n\n    return parser.parseResultsStream(responseStream);\n  }\n  /**\n   * Send an ASK query to the given endpoint URL and return a promise resolving to the boolean answer.\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<boolean>} A boolean resolving to the answer.\n   */\n\n\n  async fetchAsk(endpoint, query) {\n    const [contentType, responseStream] = await this.fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_SPARQL);\n    const parser = this.sparqlParsers[contentType];\n\n    if (!parser) {\n      throw new Error('Unknown SPARQL results content type: ' + contentType);\n    }\n\n    return parser.parseBooleanStream(responseStream);\n  }\n  /**\n   * Send a CONSTRUCT/DESCRIBE query to the given endpoint URL and return the resulting triple stream.\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<Stream>} A stream of triples.\n   */\n\n\n  async fetchTriples(endpoint, query) {\n    const rawStream = (await this.fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_TURTLE))[1];\n    return rawStream.pipe(new n3.StreamParser({\n      format: SparqlEndpointFetcher.CONTENTTYPE_TURTLE\n    }));\n  }\n  /**\n   * Send an update query to the given endpoint URL using POST.\n   *\n   * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query        A SPARQL query string.\n   */\n\n\n  async fetchUpdate(endpoint, query) {\n    const abortController = new abort_controller_1.AbortController();\n    const init = {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/sparql-update'\n      },\n      body: query,\n      signal: abortController.signal\n    };\n    await this.handleFetchCall(endpoint, init, {\n      ignoreBody: true\n    });\n    abortController.abort();\n  }\n  /**\n   * Send a query to the given endpoint URL and return the resulting stream.\n   *\n   * This will only accept responses with the application/sparql-results+json content type.\n   *\n   * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query        A SPARQL query string.\n   * @param {string} acceptHeader The HTTP accept to use.\n   * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.\n   */\n\n\n  async fetchRawStream(endpoint, query, acceptHeader) {\n    const url = this.method === 'POST' ? endpoint : endpoint + '?query=' + encodeURIComponent(query); // Initiate request\n\n    const headers = new Headers();\n    let body;\n    headers.append('Accept', acceptHeader);\n\n    if (this.method === 'POST') {\n      headers.append('Content-Type', 'application/x-www-form-urlencoded');\n      body = new URLSearchParams();\n      body.set('query', query);\n      headers.append('Content-Length', body.toString().length.toString());\n    }\n\n    return this.handleFetchCall(url, {\n      headers,\n      method: this.method,\n      body\n    });\n  }\n  /**\n   * Helper function to generalize internal fetch calls.\n   *\n   * @param {string}      url     The URL to call.\n   * @param {RequestInit} init    Options to pass along to the fetch call.\n   * @param {any}         options Other specific fetch options.\n   * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.\n   */\n\n\n  async handleFetchCall(url, init, options = {}) {\n    const httpResponse = await (this.fetchCb || fetch)(url, init);\n    let responseStream; // Handle response body\n\n    if (!options.ignoreBody) {\n      // Wrap WhatWG readable stream into a Node.js readable stream\n      // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n      responseStream = isStream(httpResponse.body) ? httpResponse.body : toNodeReadable(httpResponse.body);\n    } // Determine the content type and emit it to the stream\n\n\n    let contentType = httpResponse.headers.get('Content-Type') || '';\n\n    if (contentType.indexOf(';') > 0) {\n      contentType = contentType.substr(0, contentType.indexOf(';'));\n    } // Emit an error if the server returned an invalid response\n\n\n    if (!httpResponse.ok) {\n      const simpleUrl = /^[^?]*/u.exec(url)[0];\n      throw new Error('Invalid SPARQL endpoint (' + simpleUrl + ') response: ' + httpResponse.statusText);\n    }\n\n    return [contentType, responseStream];\n  }\n\n}\n\nexports.SparqlEndpointFetcher = SparqlEndpointFetcher;\nSparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON = 'application/sparql-results+json';\nSparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML = 'application/sparql-results+xml';\nSparqlEndpointFetcher.CONTENTTYPE_SPARQL = `${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON};q=1.0,${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML};q=0.7`;\nSparqlEndpointFetcher.CONTENTTYPE_TURTLE = 'text/turtle';","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/fetch-sparql-endpoint/lib/SparqlEndpointFetcher.js"],"names":["Object","defineProperty","exports","value","SparqlEndpointFetcher","require","abort_controller_1","sparqljs_1","sparqljson_parse_1","sparqlxml_parse_1","n3","isStream","toNodeReadable","constructor","args","method","fetchCb","fetch","sparqlJsonParser","SparqlJsonParser","sparqlXmlParser","SparqlXmlParser","sparqlParsers","CONTENTTYPE_SPARQL_JSON","parseBooleanStream","sparqlResponseStream","parseJsonBooleanStream","parseResultsStream","parseJsonResultsStream","CONTENTTYPE_SPARQL_XML","parseXmlBooleanStream","parseXmlResultsStream","getQueryType","query","parsedQuery","Parser","parse","type","queryType","getUpdateTypes","operations","update","updates","updateType","fetchBindings","endpoint","contentType","responseStream","fetchRawStream","CONTENTTYPE_SPARQL","parser","Error","fetchAsk","fetchTriples","rawStream","CONTENTTYPE_TURTLE","pipe","StreamParser","format","fetchUpdate","abortController","AbortController","init","headers","body","signal","handleFetchCall","ignoreBody","abort","acceptHeader","url","encodeURIComponent","Headers","append","URLSearchParams","set","toString","length","options","httpResponse","get","indexOf","substr","ok","simpleUrl","exec","statusText"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,qBAAR,GAAgC,KAAK,CAArC;;AACAC,OAAO,CAAC,sBAAD,CAAP;;AACA,MAAMC,kBAAkB,GAAGD,OAAO,CAAC,kBAAD,CAAlC;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,UAAD,CAA1B;;AACA,MAAMG,kBAAkB,GAAGH,OAAO,CAAC,kBAAD,CAAlC;;AACA,MAAMI,iBAAiB,GAAGJ,OAAO,CAAC,iBAAD,CAAjC,C,CACA;;;AACA,MAAMK,EAAE,GAAGL,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMM,QAAQ,GAAGN,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMO,cAAc,GAAGP,OAAO,CAAC,kBAAD,CAAP,CAA4BO,cAAnD;AACA;AACA;AACA;AACA;;;AACA,MAAMR,qBAAN,CAA4B;AACxBS,EAAAA,WAAW,CAACC,IAAD,EAAO;AACdA,IAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACA,SAAKC,MAAL,GAAcD,IAAI,CAACC,MAAL,IAAe,MAA7B;AACA,SAAKC,OAAL,GAAeF,IAAI,CAACG,KAApB;AACA,SAAKC,gBAAL,GAAwB,IAAIV,kBAAkB,CAACW,gBAAvB,CAAwCL,IAAxC,CAAxB;AACA,SAAKM,eAAL,GAAuB,IAAIX,iBAAiB,CAACY,eAAtB,CAAsCP,IAAtC,CAAvB;AACA,SAAKQ,aAAL,GAAqB;AACjB,OAAClB,qBAAqB,CAACmB,uBAAvB,GAAiD;AAC7CC,QAAAA,kBAAkB,EAAGC,oBAAD,IAA0B,KAAKP,gBAAL,CAAsBQ,sBAAtB,CAA6CD,oBAA7C,CADD;AAE7CE,QAAAA,kBAAkB,EAAGF,oBAAD,IAA0B,KAAKP,gBAAL,CAAsBU,sBAAtB,CAA6CH,oBAA7C;AAFD,OADhC;AAKjB,OAACrB,qBAAqB,CAACyB,sBAAvB,GAAgD;AAC5CL,QAAAA,kBAAkB,EAAGC,oBAAD,IAA0B,KAAKL,eAAL,CAAqBU,qBAArB,CAA2CL,oBAA3C,CADF;AAE5CE,QAAAA,kBAAkB,EAAGF,oBAAD,IAA0B,KAAKL,eAAL,CAAqBW,qBAArB,CAA2CN,oBAA3C;AAFF;AAL/B,KAArB;AAUH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIO,EAAAA,YAAY,CAACC,KAAD,EAAQ;AAChB,UAAMC,WAAW,GAAG,IAAI3B,UAAU,CAAC4B,MAAf,GAAwBC,KAAxB,CAA8BH,KAA9B,CAApB;AACA,WAAOC,WAAW,CAACG,IAAZ,KAAqB,OAArB,GACAH,WAAW,CAACI,SAAZ,KAA0B,UAA1B,GAAuC,WAAvC,GAAqDJ,WAAW,CAACI,SADjE,GAC8E,SADrF;AAEH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,cAAc,CAACN,KAAD,EAAQ;AAClB,UAAMC,WAAW,GAAG,IAAI3B,UAAU,CAAC4B,MAAf,GAAwBC,KAAxB,CAA8BH,KAA9B,CAApB;;AACA,QAAIC,WAAW,CAACG,IAAZ,KAAqB,QAAzB,EAAmC;AAC/B,YAAMG,UAAU,GAAG,EAAnB;;AACA,WAAK,MAAMC,MAAX,IAAqBP,WAAW,CAACQ,OAAjC,EAA0C;AACtC,YAAI,UAAUD,MAAd,EAAsB;AAClBD,UAAAA,UAAU,CAACC,MAAM,CAACJ,IAAR,CAAV,GAA0B,IAA1B;AACH,SAFD,MAGK;AACDG,UAAAA,UAAU,CAACC,MAAM,CAACE,UAAR,CAAV,GAAgC,IAAhC;AACH;AACJ;;AACD,aAAOH,UAAP;AACH,KAXD,MAYK;AACD,aAAO,SAAP;AACH;;AACD;AACH;;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACuB,QAAbI,aAAa,CAACC,QAAD,EAAWZ,KAAX,EAAkB;AACjC,UAAM,CAACa,WAAD,EAAcC,cAAd,IAAgC,MAAM,KACvCC,cADuC,CACxBH,QADwB,EACdZ,KADc,EACP7B,qBAAqB,CAAC6C,kBADf,CAA5C;AAEA,UAAMC,MAAM,GAAG,KAAK5B,aAAL,CAAmBwB,WAAnB,CAAf;;AACA,QAAI,CAACI,MAAL,EAAa;AACT,YAAM,IAAIC,KAAJ,CAAU,0CAA0CL,WAApD,CAAN;AACH;;AACD,WAAOI,MAAM,CAACvB,kBAAP,CAA0BoB,cAA1B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACkB,QAARK,QAAQ,CAACP,QAAD,EAAWZ,KAAX,EAAkB;AAC5B,UAAM,CAACa,WAAD,EAAcC,cAAd,IAAgC,MAAM,KACvCC,cADuC,CACxBH,QADwB,EACdZ,KADc,EACP7B,qBAAqB,CAAC6C,kBADf,CAA5C;AAEA,UAAMC,MAAM,GAAG,KAAK5B,aAAL,CAAmBwB,WAAnB,CAAf;;AACA,QAAI,CAACI,MAAL,EAAa;AACT,YAAM,IAAIC,KAAJ,CAAU,0CAA0CL,WAApD,CAAN;AACH;;AACD,WAAOI,MAAM,CAAC1B,kBAAP,CAA0BuB,cAA1B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACsB,QAAZM,YAAY,CAACR,QAAD,EAAWZ,KAAX,EAAkB;AAChC,UAAMqB,SAAS,GAAG,CAAC,MAAM,KAAKN,cAAL,CAAoBH,QAApB,EAA8BZ,KAA9B,EAAqC7B,qBAAqB,CAACmD,kBAA3D,CAAP,EAAuF,CAAvF,CAAlB;AACA,WAAOD,SAAS,CAACE,IAAV,CAAe,IAAI9C,EAAE,CAAC+C,YAAP,CAAoB;AAAEC,MAAAA,MAAM,EAAEtD,qBAAqB,CAACmD;AAAhC,KAApB,CAAf,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACqB,QAAXI,WAAW,CAACd,QAAD,EAAWZ,KAAX,EAAkB;AAC/B,UAAM2B,eAAe,GAAG,IAAItD,kBAAkB,CAACuD,eAAvB,EAAxB;AACA,UAAMC,IAAI,GAAG;AACT/C,MAAAA,MAAM,EAAE,MADC;AAETgD,MAAAA,OAAO,EAAE;AACL,wBAAgB;AADX,OAFA;AAKTC,MAAAA,IAAI,EAAE/B,KALG;AAMTgC,MAAAA,MAAM,EAAEL,eAAe,CAACK;AANf,KAAb;AAQA,UAAM,KAAKC,eAAL,CAAqBrB,QAArB,EAA+BiB,IAA/B,EAAqC;AAAEK,MAAAA,UAAU,EAAE;AAAd,KAArC,CAAN;AACAP,IAAAA,eAAe,CAACQ,KAAhB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACwB,QAAdpB,cAAc,CAACH,QAAD,EAAWZ,KAAX,EAAkBoC,YAAlB,EAAgC;AAChD,UAAMC,GAAG,GAAG,KAAKvD,MAAL,KAAgB,MAAhB,GAAyB8B,QAAzB,GAAoCA,QAAQ,GAAG,SAAX,GAAuB0B,kBAAkB,CAACtC,KAAD,CAAzF,CADgD,CAEhD;;AACA,UAAM8B,OAAO,GAAG,IAAIS,OAAJ,EAAhB;AACA,QAAIR,IAAJ;AACAD,IAAAA,OAAO,CAACU,MAAR,CAAe,QAAf,EAAyBJ,YAAzB;;AACA,QAAI,KAAKtD,MAAL,KAAgB,MAApB,EAA4B;AACxBgD,MAAAA,OAAO,CAACU,MAAR,CAAe,cAAf,EAA+B,mCAA/B;AACAT,MAAAA,IAAI,GAAG,IAAIU,eAAJ,EAAP;AACAV,MAAAA,IAAI,CAACW,GAAL,CAAS,OAAT,EAAkB1C,KAAlB;AACA8B,MAAAA,OAAO,CAACU,MAAR,CAAe,gBAAf,EAAiCT,IAAI,CAACY,QAAL,GAAgBC,MAAhB,CAAuBD,QAAvB,EAAjC;AACH;;AACD,WAAO,KAAKV,eAAL,CAAqBI,GAArB,EAA0B;AAAEP,MAAAA,OAAF;AAAWhD,MAAAA,MAAM,EAAE,KAAKA,MAAxB;AAAgCiD,MAAAA;AAAhC,KAA1B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACyB,QAAfE,eAAe,CAACI,GAAD,EAAMR,IAAN,EAAYgB,OAAO,GAAG,EAAtB,EAA0B;AAC3C,UAAMC,YAAY,GAAG,MAAM,CAAC,KAAK/D,OAAL,IAAgBC,KAAjB,EAAwBqD,GAAxB,EAA6BR,IAA7B,CAA3B;AACA,QAAIf,cAAJ,CAF2C,CAG3C;;AACA,QAAI,CAAC+B,OAAO,CAACX,UAAb,EAAyB;AACrB;AACA;AACApB,MAAAA,cAAc,GAAGpC,QAAQ,CAACoE,YAAY,CAACf,IAAd,CAAR,GACXe,YAAY,CAACf,IADF,GACSpD,cAAc,CAACmE,YAAY,CAACf,IAAd,CADxC;AAEH,KAT0C,CAU3C;;;AACA,QAAIlB,WAAW,GAAGiC,YAAY,CAAChB,OAAb,CAAqBiB,GAArB,CAAyB,cAAzB,KAA4C,EAA9D;;AACA,QAAIlC,WAAW,CAACmC,OAAZ,CAAoB,GAApB,IAA2B,CAA/B,EAAkC;AAC9BnC,MAAAA,WAAW,GAAGA,WAAW,CAACoC,MAAZ,CAAmB,CAAnB,EAAsBpC,WAAW,CAACmC,OAAZ,CAAoB,GAApB,CAAtB,CAAd;AACH,KAd0C,CAe3C;;;AACA,QAAI,CAACF,YAAY,CAACI,EAAlB,EAAsB;AAClB,YAAMC,SAAS,GAAG,UAAUC,IAAV,CAAef,GAAf,EAAoB,CAApB,CAAlB;AACA,YAAM,IAAInB,KAAJ,CAAU,8BAA8BiC,SAA9B,GAA0C,cAA1C,GAA2DL,YAAY,CAACO,UAAlF,CAAN;AACH;;AACD,WAAO,CAACxC,WAAD,EAAcC,cAAd,CAAP;AACH;;AA5KuB;;AA8K5B7C,OAAO,CAACE,qBAAR,GAAgCA,qBAAhC;AACAA,qBAAqB,CAACmB,uBAAtB,GAAgD,iCAAhD;AACAnB,qBAAqB,CAACyB,sBAAtB,GAA+C,gCAA/C;AACAzB,qBAAqB,CAAC6C,kBAAtB,GAA4C,GAAE7C,qBAAqB,CAACmB,uBAAwB,UAASnB,qBAAqB,CAACyB,sBAAuB,QAAlJ;AACAzB,qBAAqB,CAACmD,kBAAtB,GAA2C,aAA3C","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SparqlEndpointFetcher = void 0;\nrequire(\"cross-fetch/polyfill\");\nconst abort_controller_1 = require(\"abort-controller\");\nconst sparqljs_1 = require(\"sparqljs\");\nconst sparqljson_parse_1 = require(\"sparqljson-parse\");\nconst sparqlxml_parse_1 = require(\"sparqlxml-parse\");\n// tslint:disable:no-var-requires\nconst n3 = require('n3');\nconst isStream = require('is-stream');\nconst toNodeReadable = require('web-streams-node').toNodeReadable;\n/**\n * A SparqlEndpointFetcher can send queries to SPARQL endpoints,\n * and retrieve and parse the results.\n */\nclass SparqlEndpointFetcher {\n    constructor(args) {\n        args = args || {};\n        this.method = args.method || 'POST';\n        this.fetchCb = args.fetch;\n        this.sparqlJsonParser = new sparqljson_parse_1.SparqlJsonParser(args);\n        this.sparqlXmlParser = new sparqlxml_parse_1.SparqlXmlParser(args);\n        this.sparqlParsers = {\n            [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON]: {\n                parseBooleanStream: (sparqlResponseStream) => this.sparqlJsonParser.parseJsonBooleanStream(sparqlResponseStream),\n                parseResultsStream: (sparqlResponseStream) => this.sparqlJsonParser.parseJsonResultsStream(sparqlResponseStream),\n            },\n            [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML]: {\n                parseBooleanStream: (sparqlResponseStream) => this.sparqlXmlParser.parseXmlBooleanStream(sparqlResponseStream),\n                parseResultsStream: (sparqlResponseStream) => this.sparqlXmlParser.parseXmlResultsStream(sparqlResponseStream),\n            },\n        };\n    }\n    /**\n     * Get the query type of the given query.\n     *\n     * This will parse the query and thrown an exception on syntax errors.\n     *\n     * @param {string} query A query.\n     * @return {\"SELECT\" | \"ASK\" | \"CONSTRUCT\" | \"UNKNOWN\"} The query type.\n     */\n    getQueryType(query) {\n        const parsedQuery = new sparqljs_1.Parser().parse(query);\n        return parsedQuery.type === 'query'\n            ? (parsedQuery.queryType === 'DESCRIBE' ? 'CONSTRUCT' : parsedQuery.queryType) : \"UNKNOWN\";\n    }\n    /**\n     * Get the query type of the given update query.\n     *\n     * This will parse the update query and thrown an exception on syntax errors.\n     *\n     * @param {string} query An update query.\n     * @return {'UNKNOWN' | UpdateTypes} The included update operations.\n     */\n    getUpdateTypes(query) {\n        const parsedQuery = new sparqljs_1.Parser().parse(query);\n        if (parsedQuery.type === 'update') {\n            const operations = {};\n            for (const update of parsedQuery.updates) {\n                if ('type' in update) {\n                    operations[update.type] = true;\n                }\n                else {\n                    operations[update.updateType] = true;\n                }\n            }\n            return operations;\n        }\n        else {\n            return \"UNKNOWN\";\n        }\n        ;\n    }\n    ;\n    /**\n     * Send a SELECT query to the given endpoint URL and return the resulting bindings stream.\n     * @see IBindings\n     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n     * @param {string} query    A SPARQL query string.\n     * @return {Promise<NodeJS.ReadableStream>} A stream of {@link IBindings}.\n     */\n    async fetchBindings(endpoint, query) {\n        const [contentType, responseStream] = await this\n            .fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_SPARQL);\n        const parser = this.sparqlParsers[contentType];\n        if (!parser) {\n            throw new Error('Unknown SPARQL results content type: ' + contentType);\n        }\n        return parser.parseResultsStream(responseStream);\n    }\n    /**\n     * Send an ASK query to the given endpoint URL and return a promise resolving to the boolean answer.\n     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n     * @param {string} query    A SPARQL query string.\n     * @return {Promise<boolean>} A boolean resolving to the answer.\n     */\n    async fetchAsk(endpoint, query) {\n        const [contentType, responseStream] = await this\n            .fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_SPARQL);\n        const parser = this.sparqlParsers[contentType];\n        if (!parser) {\n            throw new Error('Unknown SPARQL results content type: ' + contentType);\n        }\n        return parser.parseBooleanStream(responseStream);\n    }\n    /**\n     * Send a CONSTRUCT/DESCRIBE query to the given endpoint URL and return the resulting triple stream.\n     * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n     * @param {string} query    A SPARQL query string.\n     * @return {Promise<Stream>} A stream of triples.\n     */\n    async fetchTriples(endpoint, query) {\n        const rawStream = (await this.fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_TURTLE))[1];\n        return rawStream.pipe(new n3.StreamParser({ format: SparqlEndpointFetcher.CONTENTTYPE_TURTLE }));\n    }\n    /**\n     * Send an update query to the given endpoint URL using POST.\n     *\n     * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n     * @param {string} query        A SPARQL query string.\n     */\n    async fetchUpdate(endpoint, query) {\n        const abortController = new abort_controller_1.AbortController();\n        const init = {\n            method: 'POST',\n            headers: {\n                'content-type': 'application/sparql-update',\n            },\n            body: query,\n            signal: abortController.signal,\n        };\n        await this.handleFetchCall(endpoint, init, { ignoreBody: true });\n        abortController.abort();\n    }\n    /**\n     * Send a query to the given endpoint URL and return the resulting stream.\n     *\n     * This will only accept responses with the application/sparql-results+json content type.\n     *\n     * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n     * @param {string} query        A SPARQL query string.\n     * @param {string} acceptHeader The HTTP accept to use.\n     * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.\n     */\n    async fetchRawStream(endpoint, query, acceptHeader) {\n        const url = this.method === 'POST' ? endpoint : endpoint + '?query=' + encodeURIComponent(query);\n        // Initiate request\n        const headers = new Headers();\n        let body;\n        headers.append('Accept', acceptHeader);\n        if (this.method === 'POST') {\n            headers.append('Content-Type', 'application/x-www-form-urlencoded');\n            body = new URLSearchParams();\n            body.set('query', query);\n            headers.append('Content-Length', body.toString().length.toString());\n        }\n        return this.handleFetchCall(url, { headers, method: this.method, body });\n    }\n    /**\n     * Helper function to generalize internal fetch calls.\n     *\n     * @param {string}      url     The URL to call.\n     * @param {RequestInit} init    Options to pass along to the fetch call.\n     * @param {any}         options Other specific fetch options.\n     * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.\n     */\n    async handleFetchCall(url, init, options = {}) {\n        const httpResponse = await (this.fetchCb || fetch)(url, init);\n        let responseStream;\n        // Handle response body\n        if (!options.ignoreBody) {\n            // Wrap WhatWG readable stream into a Node.js readable stream\n            // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n            responseStream = isStream(httpResponse.body)\n                ? httpResponse.body : toNodeReadable(httpResponse.body);\n        }\n        // Determine the content type and emit it to the stream\n        let contentType = httpResponse.headers.get('Content-Type') || '';\n        if (contentType.indexOf(';') > 0) {\n            contentType = contentType.substr(0, contentType.indexOf(';'));\n        }\n        // Emit an error if the server returned an invalid response\n        if (!httpResponse.ok) {\n            const simpleUrl = /^[^?]*/u.exec(url)[0];\n            throw new Error('Invalid SPARQL endpoint (' + simpleUrl + ') response: ' + httpResponse.statusText);\n        }\n        return [contentType, responseStream];\n    }\n}\nexports.SparqlEndpointFetcher = SparqlEndpointFetcher;\nSparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON = 'application/sparql-results+json';\nSparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML = 'application/sparql-results+xml';\nSparqlEndpointFetcher.CONTENTTYPE_SPARQL = `${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON};q=1.0,${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML};q=0.7`;\nSparqlEndpointFetcher.CONTENTTYPE_TURTLE = 'text/turtle';\n//# sourceMappingURL=SparqlEndpointFetcher.js.map"]},"metadata":{},"sourceType":"script"}