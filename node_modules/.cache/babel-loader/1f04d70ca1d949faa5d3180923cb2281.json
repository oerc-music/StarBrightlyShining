{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Util = void 0;\n\nclass Util {\n  /**\n   * Check if the given term is a valid compact IRI.\n   * Otherwise, it may be an IRI.\n   * @param {string} term A term.\n   * @return {boolean} If it is a compact IRI.\n   */\n  static isCompactIri(term) {\n    return term.indexOf(':') > 0 && !(term && term[0] === '#');\n  }\n  /**\n   * Get the prefix from the given term.\n   * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n   * @param {string} term A term that is an URL or a prefixed URL.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @return {string} The prefix or null.\n   */\n\n\n  static getPrefix(term, context) {\n    // Do not consider relative IRIs starting with a hash as compact IRIs\n    if (term && term[0] === '#') {\n      return null;\n    }\n\n    const separatorPos = term.indexOf(':');\n\n    if (separatorPos >= 0) {\n      // Suffix can not begin with two slashes\n      if (term.length > separatorPos + 1 && term.charAt(separatorPos + 1) === '/' && term.charAt(separatorPos + 2) === '/') {\n        return null;\n      }\n\n      const prefix = term.substr(0, separatorPos); // Prefix can not be an underscore (this is a blank node)\n\n      if (prefix === '_') {\n        return null;\n      } // Prefix must match a term in the active context\n\n\n      if (context[prefix]) {\n        return prefix;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * From a given context entry value, get the string value, or the @id field.\n   * @param contextValue A value for a term in a context.\n   * @return {string} The id value, or null.\n   */\n\n\n  static getContextValueId(contextValue) {\n    if (contextValue === null || typeof contextValue === 'string') {\n      return contextValue;\n    }\n\n    const id = contextValue['@id'];\n    return id ? id : null;\n  }\n  /**\n   * Check if the given simple term definition (string-based value of a context term)\n   * should be considered a prefix.\n   * @param value A simple term definition value.\n   * @param options Options that define the way how expansion must be done.\n   */\n\n\n  static isSimpleTermDefinitionPrefix(value, options) {\n    return !Util.isPotentialKeyword(value) && (value[0] === '_' || options.allowPrefixNonGenDelims || Util.isPrefixIriEndingWithGenDelim(value));\n  }\n  /**\n   * Check if the given keyword is of the keyword format \"@\"1*ALPHA.\n   * @param {string} keyword A potential keyword.\n   * @return {boolean} If the given keyword is of the keyword format.\n   */\n\n\n  static isPotentialKeyword(keyword) {\n    return typeof keyword === 'string' && Util.KEYWORD_REGEX.test(keyword);\n  }\n  /**\n   * Check if the given prefix ends with a gen-delim character.\n   * @param {string} prefixIri A prefix IRI.\n   * @return {boolean} If the given prefix IRI is valid.\n   */\n\n\n  static isPrefixIriEndingWithGenDelim(prefixIri) {\n    return Util.ENDS_WITH_GEN_DELIM.test(prefixIri);\n  }\n  /**\n   * Check if the given context value can be a prefix value.\n   * @param value A context value.\n   * @return {boolean} If it can be a prefix value.\n   */\n\n\n  static isPrefixValue(value) {\n    return value && (typeof value === 'string' || value && typeof value === 'object');\n  }\n  /**\n   * Check if the given IRI is valid.\n   * @param {string} iri A potential IRI.\n   * @return {boolean} If the given IRI is valid.\n   */\n\n\n  static isValidIri(iri) {\n    return Util.IRI_REGEX.test(iri);\n  }\n  /**\n   * Check if the given IRI is valid, this includes the possibility of being a relative IRI.\n   * @param {string} iri A potential IRI.\n   * @return {boolean} If the given IRI is valid.\n   */\n\n\n  static isValidIriWeak(iri) {\n    return !!iri && iri[0] !== ':' && Util.IRI_REGEX_WEAK.test(iri);\n  }\n  /**\n   * Check if the given keyword is a defined according to the JSON-LD specification.\n   * @param {string} keyword A potential keyword.\n   * @return {boolean} If the given keyword is valid.\n   */\n\n\n  static isValidKeyword(keyword) {\n    return Util.VALID_KEYWORDS[keyword];\n  }\n  /**\n   * Check if the given term is protected in the context.\n   * @param {IJsonLdContextNormalizedRaw} context A context.\n   * @param {string} key A context term.\n   * @return {boolean} If the given term has an @protected flag.\n   */\n\n\n  static isTermProtected(context, key) {\n    const value = context[key];\n    return !(typeof value === 'string') && value && value['@protected'];\n  }\n  /**\n   * Check if the given context has at least one protected term.\n   * @param context A context.\n   * @return If the context has a protected term.\n   */\n\n\n  static hasProtectedTerms(context) {\n    for (const key of Object.keys(context)) {\n      if (Util.isTermProtected(context, key)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Check if the given key is an internal reserved keyword.\n   * @param key A context key.\n   */\n\n\n  static isReservedInternalKeyword(key) {\n    return key.startsWith('@__');\n  }\n\n}\n\nexports.Util = Util; // Regex for valid IRIs\n\nUtil.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`#]*(#[^#]*)?$/; // Weaker regex for valid IRIs, this includes relative IRIs\n\nUtil.IRI_REGEX_WEAK = /(?::[^:])|\\//; // Regex for keyword form\n\nUtil.KEYWORD_REGEX = /^@[a-z]+$/i; // Regex to see if an IRI ends with a gen-delim character (see RFC 3986)\n\nUtil.ENDS_WITH_GEN_DELIM = /[:/?#\\[\\]@]$/; // Regex for language tags\n\nUtil.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/; // Regex for base directions\n\nUtil.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/; // All known valid JSON-LD keywords\n// @see https://www.w3.org/TR/json-ld11/#keywords\n\nUtil.VALID_KEYWORDS = {\n  '@base': true,\n  '@container': true,\n  '@context': true,\n  '@direction': true,\n  '@graph': true,\n  '@id': true,\n  '@import': true,\n  '@included': true,\n  '@index': true,\n  '@json': true,\n  '@language': true,\n  '@list': true,\n  '@nest': true,\n  '@none': true,\n  '@prefix': true,\n  '@propagate': true,\n  '@protected': true,\n  '@reverse': true,\n  '@set': true,\n  '@type': true,\n  '@value': true,\n  '@version': true,\n  '@vocab': true\n}; // Keys in the contexts that will not be expanded based on the base IRI\n\nUtil.EXPAND_KEYS_BLACKLIST = ['@base', '@vocab', '@language', '@version', '@direction']; // Keys in the contexts that may not be aliased from\n\nUtil.ALIAS_DOMAIN_BLACKLIST = ['@container', '@graph', '@id', '@index', '@list', '@nest', '@none', '@prefix', '@reverse', '@set', '@type', '@value', '@version']; // Keys in the contexts that may not be aliased to\n\nUtil.ALIAS_RANGE_BLACKLIST = ['@context', '@preserve']; // All valid @container values\n\nUtil.CONTAINERS = ['@list', '@set', '@index', '@language', '@graph', '@id', '@type']; // All valid @container values under processing mode 1.0\n\nUtil.CONTAINERS_1_0 = ['@list', '@set', '@index'];","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-context-parser/lib/Util.js"],"names":["Object","defineProperty","exports","value","Util","isCompactIri","term","indexOf","getPrefix","context","separatorPos","length","charAt","prefix","substr","getContextValueId","contextValue","id","isSimpleTermDefinitionPrefix","options","isPotentialKeyword","allowPrefixNonGenDelims","isPrefixIriEndingWithGenDelim","keyword","KEYWORD_REGEX","test","prefixIri","ENDS_WITH_GEN_DELIM","isPrefixValue","isValidIri","iri","IRI_REGEX","isValidIriWeak","IRI_REGEX_WEAK","isValidKeyword","VALID_KEYWORDS","isTermProtected","key","hasProtectedTerms","keys","isReservedInternalKeyword","startsWith","REGEX_LANGUAGE_TAG","REGEX_DIRECTION_TAG","EXPAND_KEYS_BLACKLIST","ALIAS_DOMAIN_BLACKLIST","ALIAS_RANGE_BLACKLIST","CONTAINERS","CONTAINERS_1_0"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nclass Util {\n    /**\n     * Check if the given term is a valid compact IRI.\n     * Otherwise, it may be an IRI.\n     * @param {string} term A term.\n     * @return {boolean} If it is a compact IRI.\n     */\n    static isCompactIri(term) {\n        return term.indexOf(':') > 0 && !(term && term[0] === '#');\n    }\n    /**\n     * Get the prefix from the given term.\n     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {string} The prefix or null.\n     */\n    static getPrefix(term, context) {\n        // Do not consider relative IRIs starting with a hash as compact IRIs\n        if (term && term[0] === '#') {\n            return null;\n        }\n        const separatorPos = term.indexOf(':');\n        if (separatorPos >= 0) {\n            // Suffix can not begin with two slashes\n            if (term.length > separatorPos + 1\n                && term.charAt(separatorPos + 1) === '/'\n                && term.charAt(separatorPos + 2) === '/') {\n                return null;\n            }\n            const prefix = term.substr(0, separatorPos);\n            // Prefix can not be an underscore (this is a blank node)\n            if (prefix === '_') {\n                return null;\n            }\n            // Prefix must match a term in the active context\n            if (context[prefix]) {\n                return prefix;\n            }\n        }\n        return null;\n    }\n    /**\n     * From a given context entry value, get the string value, or the @id field.\n     * @param contextValue A value for a term in a context.\n     * @return {string} The id value, or null.\n     */\n    static getContextValueId(contextValue) {\n        if (contextValue === null || typeof contextValue === 'string') {\n            return contextValue;\n        }\n        const id = contextValue['@id'];\n        return id ? id : null;\n    }\n    /**\n     * Check if the given simple term definition (string-based value of a context term)\n     * should be considered a prefix.\n     * @param value A simple term definition value.\n     * @param options Options that define the way how expansion must be done.\n     */\n    static isSimpleTermDefinitionPrefix(value, options) {\n        return !Util.isPotentialKeyword(value)\n            && (value[0] === '_' || options.allowPrefixNonGenDelims || Util.isPrefixIriEndingWithGenDelim(value));\n    }\n    /**\n     * Check if the given keyword is of the keyword format \"@\"1*ALPHA.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is of the keyword format.\n     */\n    static isPotentialKeyword(keyword) {\n        return typeof keyword === 'string' && Util.KEYWORD_REGEX.test(keyword);\n    }\n    /**\n     * Check if the given prefix ends with a gen-delim character.\n     * @param {string} prefixIri A prefix IRI.\n     * @return {boolean} If the given prefix IRI is valid.\n     */\n    static isPrefixIriEndingWithGenDelim(prefixIri) {\n        return Util.ENDS_WITH_GEN_DELIM.test(prefixIri);\n    }\n    /**\n     * Check if the given context value can be a prefix value.\n     * @param value A context value.\n     * @return {boolean} If it can be a prefix value.\n     */\n    static isPrefixValue(value) {\n        return value && (typeof value === 'string' || (value && typeof value === 'object'));\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return Util.IRI_REGEX.test(iri);\n    }\n    /**\n     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIriWeak(iri) {\n        return !!iri && iri[0] !== ':' && Util.IRI_REGEX_WEAK.test(iri);\n    }\n    /**\n     * Check if the given keyword is a defined according to the JSON-LD specification.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is valid.\n     */\n    static isValidKeyword(keyword) {\n        return Util.VALID_KEYWORDS[keyword];\n    }\n    /**\n     * Check if the given term is protected in the context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {string} key A context term.\n     * @return {boolean} If the given term has an @protected flag.\n     */\n    static isTermProtected(context, key) {\n        const value = context[key];\n        return !(typeof value === 'string') && value && value['@protected'];\n    }\n    /**\n     * Check if the given context has at least one protected term.\n     * @param context A context.\n     * @return If the context has a protected term.\n     */\n    static hasProtectedTerms(context) {\n        for (const key of Object.keys(context)) {\n            if (Util.isTermProtected(context, key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check if the given key is an internal reserved keyword.\n     * @param key A context key.\n     */\n    static isReservedInternalKeyword(key) {\n        return key.startsWith('@__');\n    }\n}\nexports.Util = Util;\n// Regex for valid IRIs\nUtil.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`#]*(#[^#]*)?$/;\n// Weaker regex for valid IRIs, this includes relative IRIs\nUtil.IRI_REGEX_WEAK = /(?::[^:])|\\//;\n// Regex for keyword form\nUtil.KEYWORD_REGEX = /^@[a-z]+$/i;\n// Regex to see if an IRI ends with a gen-delim character (see RFC 3986)\nUtil.ENDS_WITH_GEN_DELIM = /[:/?#\\[\\]@]$/;\n// Regex for language tags\nUtil.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;\n// Regex for base directions\nUtil.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/;\n// All known valid JSON-LD keywords\n// @see https://www.w3.org/TR/json-ld11/#keywords\nUtil.VALID_KEYWORDS = {\n    '@base': true,\n    '@container': true,\n    '@context': true,\n    '@direction': true,\n    '@graph': true,\n    '@id': true,\n    '@import': true,\n    '@included': true,\n    '@index': true,\n    '@json': true,\n    '@language': true,\n    '@list': true,\n    '@nest': true,\n    '@none': true,\n    '@prefix': true,\n    '@propagate': true,\n    '@protected': true,\n    '@reverse': true,\n    '@set': true,\n    '@type': true,\n    '@value': true,\n    '@version': true,\n    '@vocab': true,\n};\n// Keys in the contexts that will not be expanded based on the base IRI\nUtil.EXPAND_KEYS_BLACKLIST = [\n    '@base',\n    '@vocab',\n    '@language',\n    '@version',\n    '@direction',\n];\n// Keys in the contexts that may not be aliased from\nUtil.ALIAS_DOMAIN_BLACKLIST = [\n    '@container',\n    '@graph',\n    '@id',\n    '@index',\n    '@list',\n    '@nest',\n    '@none',\n    '@prefix',\n    '@reverse',\n    '@set',\n    '@type',\n    '@value',\n    '@version',\n];\n// Keys in the contexts that may not be aliased to\nUtil.ALIAS_RANGE_BLACKLIST = [\n    '@context',\n    '@preserve',\n];\n// All valid @container values\nUtil.CONTAINERS = [\n    '@list',\n    '@set',\n    '@index',\n    '@language',\n    '@graph',\n    '@id',\n    '@type',\n];\n// All valid @container values under processing mode 1.0\nUtil.CONTAINERS_1_0 = [\n    '@list',\n    '@set',\n    '@index',\n];\n//# sourceMappingURL=Util.js.map"]},"metadata":{},"sourceType":"script"}