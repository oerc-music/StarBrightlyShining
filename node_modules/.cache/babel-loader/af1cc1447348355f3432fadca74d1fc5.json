{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeHandlerDocument = void 0;\n\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\n\nconst NodeHandlerAdapter_1 = require(\"./NodeHandlerAdapter\");\n/**\n * Converts GraphQL documents to joined operations for all its definitions.\n */\n\n\nclass NodeHandlerDocument extends NodeHandlerAdapter_1.NodeHandlerAdapter {\n  constructor(util, settings) {\n    super('Document', util, settings);\n  }\n\n  handle(document, convertContext) {\n    const operation = this.util.operationFactory.createProject(document.definitions.map(definition => {\n      const subjectOutput = this.getNodeQuadContextDefinitionNode(definition, Object.assign(Object.assign({}, convertContext), {\n        ignoreUnknownVariables: true\n      }));\n      const queryParseContext = Object.assign(Object.assign({}, convertContext), {\n        graph: subjectOutput.graph || convertContext.graph,\n        subject: subjectOutput.subject || this.util.dataFactory.blankNode()\n      });\n      let definitionOperation = this.util.handleNode(definition, queryParseContext);\n\n      if (subjectOutput && subjectOutput.auxiliaryPatterns) {\n        definitionOperation = this.util.joinOperations([definitionOperation, this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns)]);\n      }\n\n      return definitionOperation;\n    }).reduce((prev, current) => {\n      if (!current) {\n        return prev;\n      }\n\n      if (!prev) {\n        return current;\n      }\n\n      return this.util.operationFactory.createUnion(prev, current);\n    }, null), convertContext.terminalVariables); // Convert blank nodes to variables\n\n    return this.translateBlankNodesToVariables(operation);\n  }\n  /**\n   * Get the quad context of a definition node that should be used for the whole definition node.\n   * @param {DefinitionNode} definition A definition node.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {INodeQuadContext | null} The subject and optional auxiliary patterns.\n   */\n\n\n  getNodeQuadContextDefinitionNode(definition, convertContext) {\n    if (definition.kind === 'OperationDefinition') {\n      return this.getNodeQuadContextSelectionSet(definition.selectionSet, definition.name ? definition.name.value : '', convertContext);\n    }\n\n    return null;\n  }\n  /**\n   * Translates blank nodes inside the query to variables.\n   * @param {Project} operation The operation to translate.\n   * @return {Operation} The transformed operation.\n   */\n\n\n  translateBlankNodesToVariables(operation) {\n    const self = this;\n    const blankToVariableMapping = {};\n    const variablesRaw = Array.from(operation.variables).reduce((acc, variable) => {\n      acc[variable.value] = true;\n      return acc;\n    }, {});\n    return sparqlalgebrajs_1.Util.mapOperation(operation, {\n      path: (op, factory) => {\n        return {\n          recurse: false,\n          result: factory.createPath(blankToVariable(op.subject), op.predicate, blankToVariable(op.object), blankToVariable(op.graph))\n        };\n      },\n      pattern: (op, factory) => {\n        return {\n          recurse: false,\n          result: factory.createPattern(blankToVariable(op.subject), blankToVariable(op.predicate), blankToVariable(op.object), blankToVariable(op.graph))\n        };\n      }\n    });\n\n    function blankToVariable(term) {\n      if (term.termType === 'BlankNode') {\n        let variable = blankToVariableMapping[term.value];\n\n        if (!variable) {\n          variable = sparqlalgebrajs_1.Util.createUniqueVariable(term.value, variablesRaw, self.util.dataFactory);\n          variablesRaw[variable.value] = true;\n          blankToVariableMapping[term.value] = variable;\n        }\n\n        return variable;\n      }\n\n      return term;\n    }\n  }\n\n}\n\nexports.NodeHandlerDocument = NodeHandlerDocument;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/graphql-to-sparql/lib/handler/NodeHandlerDocument.js"],"names":["Object","defineProperty","exports","value","NodeHandlerDocument","sparqlalgebrajs_1","require","NodeHandlerAdapter_1","NodeHandlerAdapter","constructor","util","settings","handle","document","convertContext","operation","operationFactory","createProject","definitions","map","definition","subjectOutput","getNodeQuadContextDefinitionNode","assign","ignoreUnknownVariables","queryParseContext","graph","subject","dataFactory","blankNode","definitionOperation","handleNode","auxiliaryPatterns","joinOperations","createBgp","reduce","prev","current","createUnion","terminalVariables","translateBlankNodesToVariables","kind","getNodeQuadContextSelectionSet","selectionSet","name","self","blankToVariableMapping","variablesRaw","Array","from","variables","acc","variable","Util","mapOperation","path","op","factory","recurse","result","createPath","blankToVariable","predicate","object","pattern","createPattern","term","termType","createUniqueVariable"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NodeHandlerDocument = void 0;\nconst sparqlalgebrajs_1 = require(\"sparqlalgebrajs\");\nconst NodeHandlerAdapter_1 = require(\"./NodeHandlerAdapter\");\n/**\n * Converts GraphQL documents to joined operations for all its definitions.\n */\nclass NodeHandlerDocument extends NodeHandlerAdapter_1.NodeHandlerAdapter {\n    constructor(util, settings) {\n        super('Document', util, settings);\n    }\n    handle(document, convertContext) {\n        const operation = this.util.operationFactory.createProject(document.definitions\n            .map((definition) => {\n            const subjectOutput = this.getNodeQuadContextDefinitionNode(definition, Object.assign(Object.assign({}, convertContext), { ignoreUnknownVariables: true }));\n            const queryParseContext = Object.assign(Object.assign({}, convertContext), { graph: subjectOutput.graph || convertContext.graph, subject: subjectOutput.subject || this.util.dataFactory.blankNode() });\n            let definitionOperation = this.util.handleNode(definition, queryParseContext);\n            if (subjectOutput && subjectOutput.auxiliaryPatterns) {\n                definitionOperation = this.util.joinOperations([\n                    definitionOperation,\n                    this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns),\n                ]);\n            }\n            return definitionOperation;\n        })\n            .reduce((prev, current) => {\n            if (!current) {\n                return prev;\n            }\n            if (!prev) {\n                return current;\n            }\n            return this.util.operationFactory.createUnion(prev, current);\n        }, null), convertContext.terminalVariables);\n        // Convert blank nodes to variables\n        return this.translateBlankNodesToVariables(operation);\n    }\n    /**\n     * Get the quad context of a definition node that should be used for the whole definition node.\n     * @param {DefinitionNode} definition A definition node.\n     * @param {IConvertContext} convertContext A convert context.\n     * @return {INodeQuadContext | null} The subject and optional auxiliary patterns.\n     */\n    getNodeQuadContextDefinitionNode(definition, convertContext) {\n        if (definition.kind === 'OperationDefinition') {\n            return this.getNodeQuadContextSelectionSet(definition.selectionSet, definition.name ? definition.name.value : '', convertContext);\n        }\n        return null;\n    }\n    /**\n     * Translates blank nodes inside the query to variables.\n     * @param {Project} operation The operation to translate.\n     * @return {Operation} The transformed operation.\n     */\n    translateBlankNodesToVariables(operation) {\n        const self = this;\n        const blankToVariableMapping = {};\n        const variablesRaw = Array.from(operation.variables)\n            .reduce((acc, variable) => {\n            acc[variable.value] = true;\n            return acc;\n        }, {});\n        return sparqlalgebrajs_1.Util.mapOperation(operation, {\n            path: (op, factory) => {\n                return {\n                    recurse: false,\n                    result: factory.createPath(blankToVariable(op.subject), op.predicate, blankToVariable(op.object), blankToVariable(op.graph)),\n                };\n            },\n            pattern: (op, factory) => {\n                return {\n                    recurse: false,\n                    result: factory.createPattern(blankToVariable(op.subject), blankToVariable(op.predicate), blankToVariable(op.object), blankToVariable(op.graph)),\n                };\n            },\n        });\n        function blankToVariable(term) {\n            if (term.termType === 'BlankNode') {\n                let variable = blankToVariableMapping[term.value];\n                if (!variable) {\n                    variable = sparqlalgebrajs_1.Util.createUniqueVariable(term.value, variablesRaw, self.util.dataFactory);\n                    variablesRaw[variable.value] = true;\n                    blankToVariableMapping[term.value] = variable;\n                }\n                return variable;\n            }\n            return term;\n        }\n    }\n}\nexports.NodeHandlerDocument = NodeHandlerDocument;\n//# sourceMappingURL=NodeHandlerDocument.js.map"]},"metadata":{},"sourceType":"script"}