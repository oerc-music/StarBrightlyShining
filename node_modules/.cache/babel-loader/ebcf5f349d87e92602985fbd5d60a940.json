{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\n\nfunction resolve(relativeIRI, baseIRI) {\n  baseIRI = baseIRI || '';\n  const baseFragmentPos = baseIRI.indexOf('#'); // Ignore any fragments in the base IRI\n\n  if (baseFragmentPos > 0) {\n    baseIRI = baseIRI.substr(0, baseFragmentPos);\n  } // Convert empty value directly to base IRI\n\n\n  if (!relativeIRI.length) {\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    if (baseIRI.indexOf(':') < 0) {\n      throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n\n    return baseIRI;\n  } // If the value starts with a query character, concat directly (but strip the existing query)\n\n\n  if (relativeIRI.startsWith('?')) {\n    const baseQueryPos = baseIRI.indexOf('?');\n\n    if (baseQueryPos > 0) {\n      baseIRI = baseIRI.substr(0, baseQueryPos);\n    }\n\n    return baseIRI + relativeIRI;\n  } // If the value starts with a fragment character, concat directly\n\n\n  if (relativeIRI.startsWith('#')) {\n    return baseIRI + relativeIRI;\n  } // Ignore baseIRI if it is empty\n\n\n  if (!baseIRI.length) {\n    const relativeColonPos = relativeIRI.indexOf(':');\n\n    if (relativeColonPos < 0) {\n      throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n    }\n\n    return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n  } // Ignore baseIRI if the value is absolute\n\n\n  const valueColonPos = relativeIRI.indexOf(':');\n\n  if (valueColonPos >= 0) {\n    return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n  } // At this point, the baseIRI MUST be absolute, otherwise we error\n\n\n  const baseColonPos = baseIRI.indexOf(':');\n\n  if (baseColonPos < 0) {\n    throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n  }\n\n  const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1); // Inherit the baseIRI scheme if the value starts with '//'\n\n  if (relativeIRI.indexOf('//') === 0) {\n    return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n  } // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n\n\n  let baseSlashAfterColonPos;\n\n  if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n    // If there is no additional '/' after the '//'.\n    baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n\n    if (baseSlashAfterColonPos < 0) {\n      // If something other than a '/' follows the '://', append the value after a '/',\n      // otherwise, prefix the value with only the baseIRI scheme.\n      if (baseIRI.length > baseColonPos + 3) {\n        return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n      } else {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n      }\n    }\n  } else {\n    // If there is not even a single '/' after the ':'\n    baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n\n    if (baseSlashAfterColonPos < 0) {\n      // If we don't have a '/' after the ':',\n      // prefix the value with only the baseIRI scheme.\n      return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n  } // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n\n\n  if (relativeIRI.indexOf('/') === 0) {\n    return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n  }\n\n  let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n  const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/'); // Ignore everything after the last '/' in the baseIRI path\n\n  if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n    baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1); // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n    // This change is only allowed if there is something else following the path\n\n    if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n      relativeIRI = relativeIRI.substr(1);\n    }\n  } // Prefix the value with the baseIRI path where\n\n\n  relativeIRI = baseIRIPath + relativeIRI; // Remove dot segment from the IRI\n\n  relativeIRI = removeDotSegments(relativeIRI); // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n\n  return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\n\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\n\nfunction removeDotSegments(path) {\n  // Prepare a buffer with segments between each '/.\n  // Each segment represents an array of characters.\n  const segmentBuffers = [];\n  let i = 0;\n\n  while (i < path.length) {\n    // Remove '/.' or '/..'\n    switch (path[i]) {\n      case '/':\n        if (path[i + 1] === '.') {\n          if (path[i + 2] === '.') {\n            // Start a new segment if we find an invalid character after the '.'\n            if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n              segmentBuffers.push([]);\n              i++;\n              break;\n            } // Go to parent directory,\n            // so we remove a parent segment\n\n\n            segmentBuffers.pop(); // Ensure that we end with a slash if there is a trailing '/..'\n\n            if (!path[i + 3]) {\n              segmentBuffers.push([]);\n            }\n\n            i += 3;\n          } else {\n            // Start a new segment if we find an invalid character after the '.'\n            if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n              segmentBuffers.push([]);\n              i++;\n              break;\n            } // Ensure that we end with a slash if there is a trailing '/.'\n\n\n            if (!path[i + 2]) {\n              segmentBuffers.push([]);\n            } // Go to the current directory,\n            // so we do nothing\n\n\n            i += 2;\n          }\n        } else {\n          // Start a new segment\n          segmentBuffers.push([]);\n          i++;\n        }\n\n        break;\n\n      case '#':\n      case '?':\n        // Query and fragment string should be appended unchanged\n        if (!segmentBuffers.length) {\n          segmentBuffers.push([]);\n        }\n\n        segmentBuffers[segmentBuffers.length - 1].push(path.substr(i)); // Break the while loop\n\n        i = path.length;\n        break;\n\n      default:\n        // Not a special character, just append it to our buffer\n        if (!segmentBuffers.length) {\n          segmentBuffers.push([]);\n        }\n\n        segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n        i++;\n        break;\n    }\n  }\n\n  return '/' + segmentBuffers.map(buffer => buffer.join('')).join('/');\n}\n\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\n\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n  // Determine where we should start looking for the first '/' that indicates the start of the path\n  let searchOffset = colonPosition + 1;\n\n  if (colonPosition >= 0) {\n    if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n      searchOffset = colonPosition + 3;\n    }\n  } else {\n    if (iri[0] === '/' && iri[1] === '/') {\n      searchOffset = 2;\n    }\n  } // Determine the path\n\n\n  const pathSeparator = iri.indexOf('/', searchOffset);\n\n  if (pathSeparator < 0) {\n    return iri;\n  }\n\n  const base = iri.substr(0, pathSeparator);\n  const path = iri.substr(pathSeparator); // Remove dot segments from the path\n\n  return base + removeDotSegments(path);\n}\n\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\n\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n  return !character || character === '#' || character === '?' || character === '/';\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/relative-to-absolute-iri/lib/Resolve.js"],"names":["Object","defineProperty","exports","value","resolve","relativeIRI","baseIRI","baseFragmentPos","indexOf","substr","length","Error","startsWith","baseQueryPos","relativeColonPos","removeDotSegmentsOfPath","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","removeDotSegments","baseIRIPath","baseIRILastSlashPos","lastIndexOf","path","segmentBuffers","i","isCharacterAllowedAfterRelativePathSegment","push","pop","map","buffer","join","iri","colonPosition","searchOffset","pathSeparator","base","character"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        // At this point, the baseIRI MUST be absolute, otherwise we error\n        if (baseIRI.indexOf(':') < 0) {\n            throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n        }\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        const relativeColonPos = relativeIRI.indexOf(':');\n        if (relativeColonPos < 0) {\n            throw new Error(`Found invalid relative IRI '${relativeIRI}' for a missing baseIRI`);\n        }\n        return removeDotSegmentsOfPath(relativeIRI, relativeColonPos);\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map"]},"metadata":{},"sourceType":"script"}