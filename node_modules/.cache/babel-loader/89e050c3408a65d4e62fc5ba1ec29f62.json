{"ast":null,"code":"\"use strict\";\n/* eslint-disable unicorn/filename-case */\n\n/* ! @license MIT ©2013-2016 Ruben Verborgh, Ghent University - imec */\n\n/* Single-function HTTP(S) request module for browsers */\n\n/* Translated from https://github.com/LinkedDataFragments/Client.js/blob/master/lib/browser/Request.js */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst stream_1 = require(\"stream\");\n\nconst parseLink = require(\"parse-link-header\"); // Headers we cannot send (see https://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method)\n\n\nconst UNSAFE_REQUEST_HEADERS = {\n  'accept-encoding': true,\n  'user-agent': true,\n  referer: true\n};\n\nclass Requester {\n  constructor() {\n    this.negotiatedResources = {};\n  } // Creates an HTTP request with the given settings\n\n\n  createRequest(settings) {\n    // PERFORMANCE HACK:\n    // Reduce OPTIONS preflight requests by removing the Accept-Datetime header\n    // on requests for resources that are presumed to have been time-negotiated\n    if (this.negotiatedResources[this.removeQuery(settings.url)]) {\n      settings.headers.delete('accept-datetime');\n    } // Create the actual XMLHttpRequest\n\n\n    const request = new XMLHttpRequest();\n    const reqHeaders = settings.headers;\n    request.open(settings.method, settings.url, true);\n    request.timeout = settings.timeout;\n    request.withCredentials = settings.withCredentials;\n    reqHeaders.forEach((value, key) => {\n      if (!(key in UNSAFE_REQUEST_HEADERS) && value) {\n        request.setRequestHeader(key, value);\n      }\n    }); // Create a proxy for the XMLHttpRequest\n\n    const requestProxy = new events_1.EventEmitter();\n\n    requestProxy.abort = () => {\n      request.abort();\n    }; // Handle the arrival of a response\n\n\n    request.onload = () => {\n      var _a, _b; // Convert the response into an iterator\n\n\n      const response = new stream_1.Readable();\n      response.push(request.responseText || '');\n      response.push(null);\n      response.statusCode = request.status;\n      response.responseUrl = request.responseURL; // Parse the response headers\n\n      const resHeaders = this.convertRequestHeadersToFetchHeaders(response.headers);\n      response.headers = resHeaders;\n      const rawHeaders = request.getAllResponseHeaders() || '';\n      const headerMatcher = /^([^\\n\\r:]+):[\\t ]*([^\\n\\r]*)$/gmu;\n      let match = headerMatcher.exec(rawHeaders);\n\n      while (match) {\n        resHeaders.set(match[1].toLowerCase(), match[2]);\n        match = headerMatcher.exec(rawHeaders);\n      } // Emit the response\n\n\n      requestProxy.emit('response', response); // If the resource was time-negotiated, store its queryless URI\n      // to enable the PERFORMANCE HACK explained above\n\n      if (reqHeaders.has('accept-datetime') && resHeaders.has('memento-datetime')) {\n        const resource = this.removeQuery((_a = resHeaders.get('content-location')) !== null && _a !== void 0 ? _a : settings.url);\n\n        if (!this.negotiatedResources[resource]) {\n          // Ensure the resource is not a timegate\n          const links = (_b = resHeaders.get('link') && parseLink(resHeaders.get('link'))) !== null && _b !== void 0 ? _b : undefined;\n          const timegate = this.removeQuery(links && links.timegate && links.timegate.url);\n\n          if (resource !== timegate) {\n            this.negotiatedResources[resource] = true;\n          }\n        }\n      }\n    }; // Report errors and timeouts\n\n\n    request.onerror = () => {\n      requestProxy.emit('error', new Error(`Error requesting ${settings.url}`));\n    };\n\n    request.ontimeout = () => {\n      requestProxy.emit('error', new Error(`Timeout requesting ${settings.url}`));\n    }; // Execute the request\n\n\n    if (settings.body) {\n      if (settings.body instanceof URLSearchParams) {\n        request.send(settings.body.toString());\n      } else {\n        settings.body.blob().then(blob => request.send(blob)).catch(error => requestProxy.emit('error', error));\n      }\n    } else {\n      request.send();\n    }\n\n    return requestProxy;\n  } // Wrap headers into an header object type\n\n\n  convertRequestHeadersToFetchHeaders(headers) {\n    const responseHeaders = new Headers();\n\n    for (const key in headers) {\n      responseHeaders.append(key, headers[key]);\n    }\n\n    return responseHeaders;\n  } // Removes the query string from a URL\n\n\n  removeQuery(url) {\n    return url ? url.replace(/\\?.*$/u, '') : '';\n  }\n\n}\n\nexports.default = Requester;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-http-native/lib/Requester-browser.js"],"names":["Object","defineProperty","exports","value","events_1","require","stream_1","parseLink","UNSAFE_REQUEST_HEADERS","referer","Requester","constructor","negotiatedResources","createRequest","settings","removeQuery","url","headers","delete","request","XMLHttpRequest","reqHeaders","open","method","timeout","withCredentials","forEach","key","setRequestHeader","requestProxy","EventEmitter","abort","onload","_a","_b","response","Readable","push","responseText","statusCode","status","responseUrl","responseURL","resHeaders","convertRequestHeadersToFetchHeaders","rawHeaders","getAllResponseHeaders","headerMatcher","match","exec","set","toLowerCase","emit","has","resource","get","links","undefined","timegate","onerror","Error","ontimeout","body","URLSearchParams","send","toString","blob","then","catch","error","responseHeaders","Headers","append","replace","default"],"mappings":"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","sourcesContent":["\"use strict\";\n/* eslint-disable unicorn/filename-case */\n/* ! @license MIT ©2013-2016 Ruben Verborgh, Ghent University - imec */\n/* Single-function HTTP(S) request module for browsers */\n/* Translated from https://github.com/LinkedDataFragments/Client.js/blob/master/lib/browser/Request.js */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst stream_1 = require(\"stream\");\nconst parseLink = require(\"parse-link-header\");\n// Headers we cannot send (see https://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method)\nconst UNSAFE_REQUEST_HEADERS = { 'accept-encoding': true, 'user-agent': true, referer: true };\nclass Requester {\n    constructor() {\n        this.negotiatedResources = {};\n    }\n    // Creates an HTTP request with the given settings\n    createRequest(settings) {\n        // PERFORMANCE HACK:\n        // Reduce OPTIONS preflight requests by removing the Accept-Datetime header\n        // on requests for resources that are presumed to have been time-negotiated\n        if (this.negotiatedResources[this.removeQuery(settings.url)]) {\n            settings.headers.delete('accept-datetime');\n        }\n        // Create the actual XMLHttpRequest\n        const request = new XMLHttpRequest();\n        const reqHeaders = settings.headers;\n        request.open(settings.method, settings.url, true);\n        request.timeout = settings.timeout;\n        request.withCredentials = settings.withCredentials;\n        reqHeaders.forEach((value, key) => {\n            if (!(key in UNSAFE_REQUEST_HEADERS) && value) {\n                request.setRequestHeader(key, value);\n            }\n        });\n        // Create a proxy for the XMLHttpRequest\n        const requestProxy = new events_1.EventEmitter();\n        requestProxy.abort = () => {\n            request.abort();\n        };\n        // Handle the arrival of a response\n        request.onload = () => {\n            var _a, _b;\n            // Convert the response into an iterator\n            const response = new stream_1.Readable();\n            response.push(request.responseText || '');\n            response.push(null);\n            response.statusCode = request.status;\n            response.responseUrl = request.responseURL;\n            // Parse the response headers\n            const resHeaders = this.convertRequestHeadersToFetchHeaders(response.headers);\n            response.headers = resHeaders;\n            const rawHeaders = request.getAllResponseHeaders() || '';\n            const headerMatcher = /^([^\\n\\r:]+):[\\t ]*([^\\n\\r]*)$/gmu;\n            let match = headerMatcher.exec(rawHeaders);\n            while (match) {\n                resHeaders.set(match[1].toLowerCase(), match[2]);\n                match = headerMatcher.exec(rawHeaders);\n            }\n            // Emit the response\n            requestProxy.emit('response', response);\n            // If the resource was time-negotiated, store its queryless URI\n            // to enable the PERFORMANCE HACK explained above\n            if (reqHeaders.has('accept-datetime') && resHeaders.has('memento-datetime')) {\n                const resource = this.removeQuery((_a = resHeaders.get('content-location')) !== null && _a !== void 0 ? _a : settings.url);\n                if (!this.negotiatedResources[resource]) {\n                    // Ensure the resource is not a timegate\n                    const links = (_b = (resHeaders.get('link') && parseLink(resHeaders.get('link')))) !== null && _b !== void 0 ? _b : undefined;\n                    const timegate = this.removeQuery(links && links.timegate && links.timegate.url);\n                    if (resource !== timegate) {\n                        this.negotiatedResources[resource] = true;\n                    }\n                }\n            }\n        };\n        // Report errors and timeouts\n        request.onerror = () => {\n            requestProxy.emit('error', new Error(`Error requesting ${settings.url}`));\n        };\n        request.ontimeout = () => {\n            requestProxy.emit('error', new Error(`Timeout requesting ${settings.url}`));\n        };\n        // Execute the request\n        if (settings.body) {\n            if (settings.body instanceof URLSearchParams) {\n                request.send(settings.body.toString());\n            }\n            else {\n                settings.body.blob()\n                    .then((blob) => request.send(blob))\n                    .catch((error) => requestProxy.emit('error', error));\n            }\n        }\n        else {\n            request.send();\n        }\n        return requestProxy;\n    }\n    // Wrap headers into an header object type\n    convertRequestHeadersToFetchHeaders(headers) {\n        const responseHeaders = new Headers();\n        for (const key in headers) {\n            responseHeaders.append(key, headers[key]);\n        }\n        return responseHeaders;\n    }\n    // Removes the query string from a URL\n    removeQuery(url) {\n        return url ? url.replace(/\\?.*$/u, '') : '';\n    }\n}\nexports.default = Requester;\n//# sourceMappingURL=Requester-browser.js.map"]},"metadata":{},"sourceType":"script"}