{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ActorQueryOperationBgpEmpty = void 0;\n\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst rdf_terms_1 = require(\"rdf-terms\");\n/**\n * A comunica Query Operation Actor for empty BGPs.\n */\n\n\nclass ActorQueryOperationBgpEmpty extends bus_query_operation_1.ActorQueryOperationTyped {\n  constructor(args) {\n    super(args, 'bgp');\n  }\n  /**\n   * Get all variables in the given patterns.\n   * No duplicates are returned.\n   * @param {Algebra.Pattern} patterns Quad patterns.\n   * @return {string[]} The variables in this pattern, with '?' prefix.\n   */\n\n\n  static getVariables(patterns) {\n    return rdf_terms_1.uniqTerms(patterns.map(pattern => rdf_terms_1.getTerms(pattern).filter(term => term.termType === 'Variable')).reduce((acc, val) => [...acc, ...val], [])).map(x => rdf_string_1.termToString(x));\n  }\n\n  async testOperation(pattern, context) {\n    if (pattern.patterns.length > 0) {\n      throw new Error(`Actor ${this.name} can only operate on empty BGPs.`);\n    }\n\n    return true;\n  }\n\n  async runOperation(pattern, context) {\n    return {\n      bindingsStream: new asynciterator_1.SingletonIterator(bus_query_operation_1.Bindings({})),\n      metadata: () => Promise.resolve({\n        totalItems: 1\n      }),\n      type: 'bindings',\n      variables: ActorQueryOperationBgpEmpty.getVariables(pattern.patterns),\n      canContainUndefs: false\n    };\n  }\n\n}\n\nexports.ActorQueryOperationBgpEmpty = ActorQueryOperationBgpEmpty;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-bgp-empty/lib/ActorQueryOperationBgpEmpty.js"],"names":["Object","defineProperty","exports","value","ActorQueryOperationBgpEmpty","bus_query_operation_1","require","asynciterator_1","rdf_string_1","rdf_terms_1","ActorQueryOperationTyped","constructor","args","getVariables","patterns","uniqTerms","map","pattern","getTerms","filter","term","termType","reduce","acc","val","x","termToString","testOperation","context","length","Error","name","runOperation","bindingsStream","SingletonIterator","Bindings","metadata","Promise","resolve","totalItems","type","variables","canContainUndefs"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,2BAAR,GAAsC,KAAK,CAA3C;;AACA,MAAMC,qBAAqB,GAAGC,OAAO,CAAC,+BAAD,CAArC;;AACA,MAAMC,eAAe,GAAGD,OAAO,CAAC,eAAD,CAA/B;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,YAAD,CAA5B;;AACA,MAAMG,WAAW,GAAGH,OAAO,CAAC,WAAD,CAA3B;AACA;AACA;AACA;;;AACA,MAAMF,2BAAN,SAA0CC,qBAAqB,CAACK,wBAAhE,CAAyF;AACrFC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACd,UAAMA,IAAN,EAAY,KAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACuB,SAAZC,YAAY,CAACC,QAAD,EAAW;AAC1B,WAAOL,WAAW,CAACM,SAAZ,CAAsBD,QAAQ,CAChCE,GADwB,CACpBC,OAAO,IAAIR,WAAW,CAACS,QAAZ,CAAqBD,OAArB,EACfE,MADe,CACRC,IAAI,IAAIA,IAAI,CAACC,QAAL,KAAkB,UADlB,CADS,EAGxBC,MAHwB,CAGjB,CAACC,GAAD,EAAMC,GAAN,KAAc,CAAC,GAAGD,GAAJ,EAAS,GAAGC,GAAZ,CAHG,EAGe,EAHf,CAAtB,EAIFR,GAJE,CAIES,CAAC,IAAIjB,YAAY,CAACkB,YAAb,CAA0BD,CAA1B,CAJP,CAAP;AAKH;;AACkB,QAAbE,aAAa,CAACV,OAAD,EAAUW,OAAV,EAAmB;AAClC,QAAIX,OAAO,CAACH,QAAR,CAAiBe,MAAjB,GAA0B,CAA9B,EAAiC;AAC7B,YAAM,IAAIC,KAAJ,CAAW,SAAQ,KAAKC,IAAK,kCAA7B,CAAN;AACH;;AACD,WAAO,IAAP;AACH;;AACiB,QAAZC,YAAY,CAACf,OAAD,EAAUW,OAAV,EAAmB;AACjC,WAAO;AACHK,MAAAA,cAAc,EAAE,IAAI1B,eAAe,CAAC2B,iBAApB,CAAsC7B,qBAAqB,CAAC8B,QAAtB,CAA+B,EAA/B,CAAtC,CADb;AAEHC,MAAAA,QAAQ,EAAE,MAAMC,OAAO,CAACC,OAAR,CAAgB;AAAEC,QAAAA,UAAU,EAAE;AAAd,OAAhB,CAFb;AAGHC,MAAAA,IAAI,EAAE,UAHH;AAIHC,MAAAA,SAAS,EAAErC,2BAA2B,CAACS,YAA5B,CAAyCI,OAAO,CAACH,QAAjD,CAJR;AAKH4B,MAAAA,gBAAgB,EAAE;AALf,KAAP;AAOH;;AA/BoF;;AAiCzFxC,OAAO,CAACE,2BAAR,GAAsCA,2BAAtC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ActorQueryOperationBgpEmpty = void 0;\nconst bus_query_operation_1 = require(\"@comunica/bus-query-operation\");\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst rdf_terms_1 = require(\"rdf-terms\");\n/**\n * A comunica Query Operation Actor for empty BGPs.\n */\nclass ActorQueryOperationBgpEmpty extends bus_query_operation_1.ActorQueryOperationTyped {\n    constructor(args) {\n        super(args, 'bgp');\n    }\n    /**\n     * Get all variables in the given patterns.\n     * No duplicates are returned.\n     * @param {Algebra.Pattern} patterns Quad patterns.\n     * @return {string[]} The variables in this pattern, with '?' prefix.\n     */\n    static getVariables(patterns) {\n        return rdf_terms_1.uniqTerms(patterns\n            .map(pattern => rdf_terms_1.getTerms(pattern)\n            .filter(term => term.termType === 'Variable'))\n            .reduce((acc, val) => [...acc, ...val], []))\n            .map(x => rdf_string_1.termToString(x));\n    }\n    async testOperation(pattern, context) {\n        if (pattern.patterns.length > 0) {\n            throw new Error(`Actor ${this.name} can only operate on empty BGPs.`);\n        }\n        return true;\n    }\n    async runOperation(pattern, context) {\n        return {\n            bindingsStream: new asynciterator_1.SingletonIterator(bus_query_operation_1.Bindings({})),\n            metadata: () => Promise.resolve({ totalItems: 1 }),\n            type: 'bindings',\n            variables: ActorQueryOperationBgpEmpty.getVariables(pattern.patterns),\n            canContainUndefs: false,\n        };\n    }\n}\nexports.ActorQueryOperationBgpEmpty = ActorQueryOperationBgpEmpty;\n//# sourceMappingURL=ActorQueryOperationBgpEmpty.js.map"]},"metadata":{},"sourceType":"script"}