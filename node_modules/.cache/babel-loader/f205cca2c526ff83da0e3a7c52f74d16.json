{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EntryHandlerContainer = void 0;\n\nconst ContainerHandlerIdentifier_1 = require(\"../containerhandler/ContainerHandlerIdentifier\");\n\nconst ContainerHandlerIndex_1 = require(\"../containerhandler/ContainerHandlerIndex\");\n\nconst ContainerHandlerLanguage_1 = require(\"../containerhandler/ContainerHandlerLanguage\");\n\nconst ContainerHandlerType_1 = require(\"../containerhandler/ContainerHandlerType\");\n\nconst Util_1 = require(\"../Util\");\n/**\n * Handles values that are part of a container type (like @index),\n * as specified by {@link IContainerHandler}.\n */\n\n\nclass EntryHandlerContainer {\n  /**\n   * Check fit the given container is a simple @graph container.\n   * Concretely, it will check if no @index or @id is active as well.\n   * @param containers A container hash.\n   */\n  static isSimpleGraphContainer(containers) {\n    return '@graph' in containers && ('@set' in containers && Object.keys(containers).length === 2 || Object.keys(containers).length === 1);\n  }\n  /**\n   * Check fit the given container is a complex @graph container.\n   * Concretely, it will check if @index or @id is active as well next to @graph.\n   * @param containers A container hash.\n   */\n\n\n  static isComplexGraphContainer(containers) {\n    return '@graph' in containers && ('@set' in containers && Object.keys(containers).length > 2 || !('@set' in containers) && Object.keys(containers).length > 1);\n  }\n  /**\n   * Create an graph container index that can be used for identifying a graph term inside the graphContainerTermStack.\n   * @param containers The applicable containers.\n   * @param depth The container depth.\n   * @param keys The array of keys.\n   * @return The graph index.\n   */\n\n\n  static getContainerGraphIndex(containers, depth, keys) {\n    let isSimpleGraphContainer = EntryHandlerContainer.isSimpleGraphContainer(containers);\n    let index = '';\n\n    for (let i = depth; i < keys.length; i++) {\n      if (!isSimpleGraphContainer || typeof keys[i] === 'number') {\n        index += ':' + keys[i];\n      } // Only allow a second 'real' key if in a non-simple graph container.\n\n\n      if (!isSimpleGraphContainer && typeof keys[i] !== 'number') {\n        isSimpleGraphContainer = true;\n      }\n    }\n\n    return index;\n  }\n  /**\n   * Return the applicable container type at the given depth.\n   *\n   * This will ignore any arrays in the key chain.\n   *\n   * @param {ParsingContext} parsingContext A parsing context.\n   * @param {any[]} keys The array of keys.\n   * @param {number} depth The current depth.\n   * @return {Promise<{ containers: {[typeName: string]: boolean}, depth: number, fallback: boolean }>}\n   *          All applicable containers for the given depth,\n   *          the `depth` of the container root (can change when arrays are in the key chain),\n   *          and the `fallback` flag that indicates if the default container type was returned\n   *            (i.e., no dedicated container type is defined).\n   */\n\n\n  static async getContainerHandler(parsingContext, keys, depth) {\n    const fallback = {\n      containers: {\n        '@set': true\n      },\n      depth,\n      fallback: true\n    }; // A flag that is enabled when @graph container should be tested in next iteration\n\n    let checkGraphContainer = false; // Iterate from deeper to higher\n\n    const context = await parsingContext.getContext(keys, 2);\n\n    for (let i = depth - 1; i >= 0; i--) {\n      if (typeof keys[i] !== 'number') {\n        // Skip array keys\n        // @graph containers without any other types are one level less deep, and require special handling\n        const containersSelf = Util_1.Util.getContextValue(context, '@container', keys[i], false);\n\n        if (containersSelf && EntryHandlerContainer.isSimpleGraphContainer(containersSelf)) {\n          return {\n            containers: containersSelf,\n            depth: i + 1,\n            fallback: false\n          };\n        }\n\n        const containersParent = Util_1.Util.getContextValue(context, '@container', keys[i - 1], false);\n\n        if (!containersParent) {\n          // If we have the fallback container value\n          if (checkGraphContainer) {\n            // Return false if we were already expecting a @graph-@id of @graph-@index container\n            return fallback;\n          } // Check parent-parent, we may be in a @graph-@id of @graph-@index container, which have two levels\n\n\n          checkGraphContainer = true;\n        } else {\n          // We had an invalid container next iteration, so we now have to check if we were in an @graph container\n          const graphContainer = ('@graph' in containersParent); // We're in a regular container\n\n          for (const containerHandleName in EntryHandlerContainer.CONTAINER_HANDLERS) {\n            if (containersParent[containerHandleName]) {\n              if (graphContainer) {\n                // Only accept graph containers if their combined handlers can handle them.\n                if (EntryHandlerContainer.CONTAINER_HANDLERS[containerHandleName].canCombineWithGraph()) {\n                  return {\n                    containers: containersParent,\n                    depth: i,\n                    fallback: false\n                  };\n                } else {\n                  return fallback;\n                }\n              } else {\n                // Only accept if we were not expecting a @graph-@id of @graph-@index container\n                if (checkGraphContainer) {\n                  return fallback;\n                } else {\n                  return {\n                    containers: containersParent,\n                    depth: i,\n                    fallback: false\n                  };\n                }\n              }\n            }\n          } // Fail if no valid container handlers were found\n\n\n          return fallback;\n        }\n      }\n    }\n\n    return fallback;\n  }\n  /**\n   * Check if we are handling a value at the given depth\n   * that is part of something that should be handled as a container,\n   * AND if this container should be buffered, so that it can be handled by a dedicated container handler.\n   *\n   * For instance, any container with @graph will NOT be buffered.\n   *\n   * This will ignore any arrays in the key chain.\n   *\n   * @param {ParsingContext} parsingContext A parsing context.\n   * @param {any[]} keys The array of keys.\n   * @param {number} depth The current depth.\n   * @return {Promise<boolean>} If we are in the scope of a container handler.\n   */\n\n\n  static async isBufferableContainerHandler(parsingContext, keys, depth) {\n    const handler = await EntryHandlerContainer.getContainerHandler(parsingContext, keys, depth);\n    return !handler.fallback && !('@graph' in handler.containers);\n  }\n\n  isPropertyHandler() {\n    return false;\n  }\n\n  isStackProcessor() {\n    return true;\n  }\n\n  async validate(parsingContext, util, keys, depth, inProperty) {\n    return !!(await this.test(parsingContext, util, null, keys, depth));\n  }\n\n  async test(parsingContext, util, key, keys, depth) {\n    const containers = Util_1.Util.getContextValueContainer(await parsingContext.getContext(keys, 2), keys[depth - 1]);\n\n    for (const containerName in EntryHandlerContainer.CONTAINER_HANDLERS) {\n      if (containers[containerName]) {\n        return {\n          containers,\n          handler: EntryHandlerContainer.CONTAINER_HANDLERS[containerName]\n        };\n      }\n    }\n\n    return null;\n  }\n\n  async handle(parsingContext, util, key, keys, value, depth, testResult) {\n    return testResult.handler.handle(testResult.containers, parsingContext, util, keys, value, depth);\n  }\n\n}\n\nexports.EntryHandlerContainer = EntryHandlerContainer;\nEntryHandlerContainer.CONTAINER_HANDLERS = {\n  '@id': new ContainerHandlerIdentifier_1.ContainerHandlerIdentifier(),\n  '@index': new ContainerHandlerIndex_1.ContainerHandlerIndex(),\n  '@language': new ContainerHandlerLanguage_1.ContainerHandlerLanguage(),\n  '@type': new ContainerHandlerType_1.ContainerHandlerType()\n};","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-parser/lib/entryhandler/EntryHandlerContainer.js"],"names":["Object","defineProperty","exports","value","EntryHandlerContainer","ContainerHandlerIdentifier_1","require","ContainerHandlerIndex_1","ContainerHandlerLanguage_1","ContainerHandlerType_1","Util_1","isSimpleGraphContainer","containers","keys","length","isComplexGraphContainer","getContainerGraphIndex","depth","index","i","getContainerHandler","parsingContext","fallback","checkGraphContainer","context","getContext","containersSelf","Util","getContextValue","containersParent","graphContainer","containerHandleName","CONTAINER_HANDLERS","canCombineWithGraph","isBufferableContainerHandler","handler","isPropertyHandler","isStackProcessor","validate","util","inProperty","test","key","getContextValueContainer","containerName","handle","testResult","ContainerHandlerIdentifier","ContainerHandlerIndex","ContainerHandlerLanguage","ContainerHandlerType"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EntryHandlerContainer = void 0;\nconst ContainerHandlerIdentifier_1 = require(\"../containerhandler/ContainerHandlerIdentifier\");\nconst ContainerHandlerIndex_1 = require(\"../containerhandler/ContainerHandlerIndex\");\nconst ContainerHandlerLanguage_1 = require(\"../containerhandler/ContainerHandlerLanguage\");\nconst ContainerHandlerType_1 = require(\"../containerhandler/ContainerHandlerType\");\nconst Util_1 = require(\"../Util\");\n/**\n * Handles values that are part of a container type (like @index),\n * as specified by {@link IContainerHandler}.\n */\nclass EntryHandlerContainer {\n    /**\n     * Check fit the given container is a simple @graph container.\n     * Concretely, it will check if no @index or @id is active as well.\n     * @param containers A container hash.\n     */\n    static isSimpleGraphContainer(containers) {\n        return '@graph' in containers\n            && (('@set' in containers && Object.keys(containers).length === 2) || Object.keys(containers).length === 1);\n    }\n    /**\n     * Check fit the given container is a complex @graph container.\n     * Concretely, it will check if @index or @id is active as well next to @graph.\n     * @param containers A container hash.\n     */\n    static isComplexGraphContainer(containers) {\n        return '@graph' in containers\n            && (('@set' in containers && Object.keys(containers).length > 2)\n                || (!('@set' in containers) && Object.keys(containers).length > 1));\n    }\n    /**\n     * Create an graph container index that can be used for identifying a graph term inside the graphContainerTermStack.\n     * @param containers The applicable containers.\n     * @param depth The container depth.\n     * @param keys The array of keys.\n     * @return The graph index.\n     */\n    static getContainerGraphIndex(containers, depth, keys) {\n        let isSimpleGraphContainer = EntryHandlerContainer.isSimpleGraphContainer(containers);\n        let index = '';\n        for (let i = depth; i < keys.length; i++) {\n            if (!isSimpleGraphContainer || typeof keys[i] === 'number') {\n                index += ':' + keys[i];\n            }\n            // Only allow a second 'real' key if in a non-simple graph container.\n            if (!isSimpleGraphContainer && typeof keys[i] !== 'number') {\n                isSimpleGraphContainer = true;\n            }\n        }\n        return index;\n    }\n    /**\n     * Return the applicable container type at the given depth.\n     *\n     * This will ignore any arrays in the key chain.\n     *\n     * @param {ParsingContext} parsingContext A parsing context.\n     * @param {any[]} keys The array of keys.\n     * @param {number} depth The current depth.\n     * @return {Promise<{ containers: {[typeName: string]: boolean}, depth: number, fallback: boolean }>}\n     *          All applicable containers for the given depth,\n     *          the `depth` of the container root (can change when arrays are in the key chain),\n     *          and the `fallback` flag that indicates if the default container type was returned\n     *            (i.e., no dedicated container type is defined).\n     */\n    static async getContainerHandler(parsingContext, keys, depth) {\n        const fallback = {\n            containers: { '@set': true },\n            depth,\n            fallback: true,\n        };\n        // A flag that is enabled when @graph container should be tested in next iteration\n        let checkGraphContainer = false;\n        // Iterate from deeper to higher\n        const context = await parsingContext.getContext(keys, 2);\n        for (let i = depth - 1; i >= 0; i--) {\n            if (typeof keys[i] !== 'number') { // Skip array keys\n                // @graph containers without any other types are one level less deep, and require special handling\n                const containersSelf = Util_1.Util.getContextValue(context, '@container', keys[i], false);\n                if (containersSelf && EntryHandlerContainer.isSimpleGraphContainer(containersSelf)) {\n                    return {\n                        containers: containersSelf,\n                        depth: i + 1,\n                        fallback: false,\n                    };\n                }\n                const containersParent = Util_1.Util.getContextValue(context, '@container', keys[i - 1], false);\n                if (!containersParent) { // If we have the fallback container value\n                    if (checkGraphContainer) {\n                        // Return false if we were already expecting a @graph-@id of @graph-@index container\n                        return fallback;\n                    }\n                    // Check parent-parent, we may be in a @graph-@id of @graph-@index container, which have two levels\n                    checkGraphContainer = true;\n                }\n                else {\n                    // We had an invalid container next iteration, so we now have to check if we were in an @graph container\n                    const graphContainer = '@graph' in containersParent;\n                    // We're in a regular container\n                    for (const containerHandleName in EntryHandlerContainer.CONTAINER_HANDLERS) {\n                        if (containersParent[containerHandleName]) {\n                            if (graphContainer) {\n                                // Only accept graph containers if their combined handlers can handle them.\n                                if (EntryHandlerContainer.CONTAINER_HANDLERS[containerHandleName].canCombineWithGraph()) {\n                                    return {\n                                        containers: containersParent,\n                                        depth: i,\n                                        fallback: false,\n                                    };\n                                }\n                                else {\n                                    return fallback;\n                                }\n                            }\n                            else {\n                                // Only accept if we were not expecting a @graph-@id of @graph-@index container\n                                if (checkGraphContainer) {\n                                    return fallback;\n                                }\n                                else {\n                                    return {\n                                        containers: containersParent,\n                                        depth: i,\n                                        fallback: false,\n                                    };\n                                }\n                            }\n                        }\n                    }\n                    // Fail if no valid container handlers were found\n                    return fallback;\n                }\n            }\n        }\n        return fallback;\n    }\n    /**\n     * Check if we are handling a value at the given depth\n     * that is part of something that should be handled as a container,\n     * AND if this container should be buffered, so that it can be handled by a dedicated container handler.\n     *\n     * For instance, any container with @graph will NOT be buffered.\n     *\n     * This will ignore any arrays in the key chain.\n     *\n     * @param {ParsingContext} parsingContext A parsing context.\n     * @param {any[]} keys The array of keys.\n     * @param {number} depth The current depth.\n     * @return {Promise<boolean>} If we are in the scope of a container handler.\n     */\n    static async isBufferableContainerHandler(parsingContext, keys, depth) {\n        const handler = await EntryHandlerContainer.getContainerHandler(parsingContext, keys, depth);\n        return !handler.fallback && !('@graph' in handler.containers);\n    }\n    isPropertyHandler() {\n        return false;\n    }\n    isStackProcessor() {\n        return true;\n    }\n    async validate(parsingContext, util, keys, depth, inProperty) {\n        return !!await this.test(parsingContext, util, null, keys, depth);\n    }\n    async test(parsingContext, util, key, keys, depth) {\n        const containers = Util_1.Util.getContextValueContainer(await parsingContext.getContext(keys, 2), keys[depth - 1]);\n        for (const containerName in EntryHandlerContainer.CONTAINER_HANDLERS) {\n            if (containers[containerName]) {\n                return {\n                    containers,\n                    handler: EntryHandlerContainer.CONTAINER_HANDLERS[containerName],\n                };\n            }\n        }\n        return null;\n    }\n    async handle(parsingContext, util, key, keys, value, depth, testResult) {\n        return testResult.handler.handle(testResult.containers, parsingContext, util, keys, value, depth);\n    }\n}\nexports.EntryHandlerContainer = EntryHandlerContainer;\nEntryHandlerContainer.CONTAINER_HANDLERS = {\n    '@id': new ContainerHandlerIdentifier_1.ContainerHandlerIdentifier(),\n    '@index': new ContainerHandlerIndex_1.ContainerHandlerIndex(),\n    '@language': new ContainerHandlerLanguage_1.ContainerHandlerLanguage(),\n    '@type': new ContainerHandlerType_1.ContainerHandlerType(),\n};\n//# sourceMappingURL=EntryHandlerContainer.js.map"]},"metadata":{},"sourceType":"script"}