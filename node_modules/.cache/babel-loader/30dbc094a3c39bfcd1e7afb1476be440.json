{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst Algebra = require(\"./algebra\");\n\nconst factory_1 = require(\"./factory\");\n\nconst util_1 = require(\"./util\");\n\nconst equal = require(\"fast-deep-equal\");\n\nconst rdf_string_1 = require(\"rdf-string\");\n\nconst Parser = require('sparqljs').Parser;\n\nconst types = Algebra.types;\nlet variables = new Set();\nlet varCount = 0;\nlet useQuads = false;\nlet factory;\n/**\n * Translates the given SPARQL query to SPARQL Algebra.\n * @param sparql - Either a SPARQL string or an object generated by sparql.js\n * @param options - Optional options object. Current options:\n *                    * dataFactory: The Datafactory used to generate terms. Default @rdfjs/data-model.\n *                    * quads: Boolean indicating whether triples should be converted to Quads (consumes GRAPH statements). Default false.\n *                    * prefixes: Pre-defined prefixes for the given query. Default empty.\n *                    * baseIRI: Base IRI that should be used for the query. Default undefined (throws error if required).\n * @returns {Operation}\n */\n\nfunction translate(sparql, options) {\n  options = options || {};\n  factory = new factory_1.default(options.dataFactory);\n\n  if (isString(sparql)) {\n    let parser = new Parser(options); // resets the identifier counter used for blank nodes\n    // provides nicer and more consistent output if there are multiple calls\n\n    parser._resetBlanks();\n\n    sparql = parser.parse(sparql);\n  }\n\n  return translateQuery(sparql, options.quads, options.blankToVariable);\n}\n\nexports.default = translate;\n\nfunction translateQuery(sparql, quads, blankToVariable) {\n  // this set is filled in during the inScopeVariables call\n  variables = new Set();\n  varCount = 0;\n  useQuads = quads; // Assume this is an empty query\n\n  if (!sparql.type) return factory.createProject(factory.createBgp([]), []);\n  if (sparql.type !== 'query' && sparql.type !== 'update') throw new Error('Translate only works on complete query or update objects.');\n  let vars = new Set(Object.keys(inScopeVariables(sparql)).map(factory.createTerm.bind(factory)));\n  let res;\n\n  if (sparql.type === 'query') {\n    // group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE\n    let group = {\n      type: 'group',\n      patterns: sparql.where || []\n    };\n    res = translateGroupGraphPattern(group);\n    res = translateAggregates(sparql, res, vars);\n  } else if (sparql.type === 'update') {\n    res = translateUpdate(sparql);\n  }\n\n  if (blankToVariable) {\n    res = translateBlankNodesToVariables(res, vars);\n  }\n\n  return res;\n}\n\nfunction isString(str) {\n  return typeof str === 'string';\n}\n\nfunction isObject(o) {\n  return o !== null && typeof o === 'object';\n}\n\nfunction isVariable(term) {\n  return term && term.termType === \"Variable\";\n} // 18.2.1\n\n\nfunction inScopeVariables(thingy) {\n  let inScope = {};\n\n  if (isVariable(thingy)) {\n    inScope[rdf_string_1.termToString(thingy)] = true;\n    variables.add(thingy); // keep track of all variables so we don't generate duplicates\n  } else if (isObject(thingy)) {\n    if (thingy.type === 'bind') {\n      inScopeVariables(thingy.expression); // to fill `variables`\n\n      Object.assign(inScope, inScopeVariables(thingy.variable));\n    } else if (thingy.queryType === 'SELECT') {\n      let all = inScopeVariables(thingy.where); // always executing this makes sure `variables` gets filled correctly\n\n      for (let v of thingy.variables) {\n        if (util_1.default.isWildcard(v)) Object.assign(inScope, all);else if (v.variable) // aggregates\n          Object.assign(inScope, inScopeVariables(v.variable));else Object.assign(inScope, inScopeVariables(v));\n      } // TODO: I'm not 100% sure if you always add these or only when '*' was selected\n\n\n      if (thingy.group) for (let v of thingy.group) Object.assign(inScope, inScopeVariables(v));\n    } else for (let key of Object.keys(thingy)) Object.assign(inScope, inScopeVariables(thingy[key]));\n  }\n\n  return inScope;\n}\n\nfunction translateGroupGraphPattern(thingy) {\n  // 18.2.2.1\n  // already done by sparql parser\n  // 18.2.2.2\n  let filters = [];\n  let nonfilters = [];\n  if (thingy.patterns) for (let pattern of thingy.patterns) (pattern.type === 'filter' ? filters : nonfilters).push(pattern); // 18.2.2.3\n  // 18.2.2.4\n  // 18.2.2.5\n\n  if (thingy.type === 'bgp') return translateBgp(thingy); // 18.2.2.6\n\n  let result;\n  if (thingy.type === 'union') result = nonfilters.map(p => {\n    // sparqljs doesn't always indicate the children are groups\n    if (p.type !== 'group') p = {\n      type: 'group',\n      patterns: [p]\n    };\n    return translateGroupGraphPattern(p);\n  }).reduce((acc, item) => factory.createUnion(acc, item));else if (thingy.type === 'graph') // need to handle this separately since the filters need to be in the graph\n    return translateGraph(thingy);else if (thingy.type === 'group') result = nonfilters.reduce(accumulateGroupGraphPattern, factory.createBgp([])); // custom values operation\n  else if (thingy.type === 'values') result = translateInlineData(thingy);else if (thingy.type === 'query') result = translateQuery(thingy, useQuads, false);else throw new Error('Unexpected type: ' + thingy.type);\n\n  if (filters.length > 0) {\n    let expressions = filters.map(filter => translateExpression(filter.expression));\n    if (expressions.length > 0) result = factory.createFilter(result, expressions.reduce((acc, exp) => factory.createOperatorExpression('&&', [acc, exp])));\n  }\n\n  return result;\n}\n\nfunction translateExpression(exp) {\n  if (util_1.default.isTerm(exp) || exp.termType === 'Quad') return factory.createTermExpression(exp);\n  if (util_1.default.isWildcard(exp)) return factory.createWildcardExpression();\n  if (exp.aggregation) return factory.createAggregateExpression(exp.aggregation, translateExpression(exp.expression), exp.distinct, exp.separator);\n  if (exp.function) return factory.createNamedExpression(exp.function, exp.args.map(translateExpression));\n\n  if (exp.operator) {\n    if (exp.operator === 'exists' || exp.operator === 'notexists') return factory.createExistenceExpression(exp.operator === 'notexists', translateGroupGraphPattern(exp.args[0]));\n    if (exp.operator === 'in' || exp.operator === 'notin') exp.args = [exp.args[0]].concat(exp.args[1]); // sparql.js uses 2 arguments with the second one being a list\n\n    return factory.createOperatorExpression(exp.operator, exp.args.map(translateExpression));\n  }\n\n  throw new Error('Unknown expression: ' + JSON.stringify(exp));\n}\n\nfunction translateBgp(thingy) {\n  let patterns = [];\n  let joins = [];\n\n  for (let t of thingy.triples) {\n    if (t.predicate.type === 'path') {\n      // translatePath returns a mix of Quads and Paths\n      let path = translatePath(t);\n\n      for (let p of path) {\n        if (p.type === types.PATH) {\n          if (patterns.length > 0) joins.push(factory.createBgp(patterns));\n          patterns = [];\n          joins.push(p);\n        } else patterns.push(p);\n      }\n    } else patterns.push(translateQuad(t));\n  }\n\n  if (patterns.length > 0) joins.push(factory.createBgp(patterns));\n  if (joins.length === 1) return joins[0];\n  return joins.reduce((acc, item) => factory.createJoin(acc, item));\n}\n\nfunction translatePath(triple) {\n  let sub = triple.subject;\n  let pred = translatePathPredicate(triple.predicate);\n  let obj = triple.object;\n  return simplifyPath(sub, pred, obj);\n}\n\nfunction translatePathPredicate(predicate) {\n  if (util_1.default.isTerm(predicate) && predicate.termType === \"NamedNode\") return factory.createLink(predicate);\n  if (predicate.pathType === '^') return factory.createInv(translatePathPredicate(predicate.items[0]));\n\n  if (predicate.pathType === '!') {\n    // negation is either over a single predicate or a list of disjuncted properties\n    let normals = [];\n    let inverted = [];\n    let items;\n    if (predicate.items[0].type === 'path' && predicate.items[0].pathType === '|') items = predicate.items[0].items; // the | element\n    else items = predicate.items;\n\n    for (let item of items) {\n      if (util_1.default.isTerm(item)) normals.push(item);else if (item.pathType === '^') inverted.push(item.items[0]);else throw new Error('Unexpected item: ' + JSON.stringify(item));\n    } // NPS elements do not have the LINK function\n\n\n    let normalElement = factory.createNps(normals);\n    let invertedElement = factory.createInv(factory.createNps(inverted));\n    if (inverted.length === 0) return normalElement;\n    if (normals.length === 0) return invertedElement;\n    return factory.createAlt(normalElement, invertedElement);\n  }\n\n  if (predicate.pathType === '/') return predicate.items.map(translatePathPredicate).reduce((acc, p) => factory.createSeq(acc, p));\n  if (predicate.pathType === '|') return predicate.items.map(translatePathPredicate).reduce((acc, p) => factory.createAlt(acc, p));\n  if (predicate.pathType === '*') return factory.createZeroOrMorePath(translatePathPredicate(predicate.items[0]));\n  if (predicate.pathType === '+') return factory.createOneOrMorePath(translatePathPredicate(predicate.items[0]));\n  if (predicate.pathType === '?') return factory.createZeroOrOnePath(translatePathPredicate(predicate.items[0]));\n  throw new Error('Unable to translate path expression ' + JSON.stringify(predicate));\n}\n\nfunction simplifyPath(subject, predicate, object) {\n  if (predicate.type === types.LINK) return [factory.createPattern(subject, predicate.iri, object)];\n  if (predicate.type === types.INV) return simplifyPath(object, predicate.path, subject);\n\n  if (predicate.type === types.SEQ) {\n    let v = generateFreshVar();\n    let left = simplifyPath(subject, predicate.left, v);\n    let right = simplifyPath(v, predicate.right, object);\n    return left.concat(right);\n  }\n\n  return [factory.createPath(subject, predicate, object)];\n}\n\nfunction generateFreshVar() {\n  let v = '?var' + varCount++;\n  if (variables.has(v)) return generateFreshVar();\n  variables.add(v);\n  return factory.createTerm(v);\n}\n\nfunction translateQuad(quad) {\n  return factory.createPattern(quad.subject, quad.predicate, quad.object, quad.graph);\n}\n\nfunction translateGraph(graph) {\n  graph.type = 'group';\n  let result = translateGroupGraphPattern(graph);\n  if (useQuads) result = recurseGraph(result, graph.name);else result = factory.createGraph(result, graph.name);\n  return result;\n}\n\nlet typeVals = Object.keys(types).map(key => types[key]);\n\nfunction recurseGraph(thingy, graph, replacement) {\n  if (thingy.type === types.GRAPH) {\n    if (replacement) {\n      // At this point we would lose track of the replacement which would result in incorrect results\n      // This would indicate the library is not being used as intended though\n      throw new Error('Recursing through nested GRAPH statements with a replacement is impossible.');\n    }\n\n    const graph = thingy; // In case there were nested GRAPH statements that were not recursed yet for some reason\n\n    thingy = recurseGraph(graph.input, graph.name);\n  } else if (thingy.type === types.BGP) thingy.patterns = thingy.patterns.map(quad => {\n    if (replacement) {\n      if (quad.subject.equals(graph)) quad.subject = replacement;\n      if (quad.predicate.equals(graph)) quad.predicate = replacement;\n      if (quad.object.equals(graph)) quad.object = replacement;\n    }\n\n    if (quad.graph.termType === 'DefaultGraph') quad.graph = graph;\n    return quad;\n  });else if (thingy.type === types.PATH) {\n    const p = thingy;\n\n    if (replacement) {\n      if (p.subject.equals(graph)) p.subject = replacement;\n      if (p.object.equals(graph)) p.object = replacement;\n    }\n\n    if (thingy.graph.termType === 'DefaultGraph') thingy.graph = graph;\n  } // need to replace variables in subqueries should the graph also be a variable of the same name\n  // unless the subquery projects that variable\n  else if (thingy.type === types.PROJECT && !replacement) {\n    const proj = thingy;\n    if (!proj.variables.some(v => v.equals(graph))) replacement = generateFreshVar();\n    proj.input = recurseGraph(proj.input, graph, replacement);\n  } // this can happen if the query extends an expression to the name of the graph\n  // since the extend happens here there should be no further occurrences of this name\n  // if there are it's the same situation as above\n  else if (thingy.type === types.EXTEND && !replacement) {\n    const ext = thingy;\n    if (ext.variable.equals(graph)) replacement = generateFreshVar();\n    ext.input = recurseGraph(ext.input, graph, replacement);\n  } else {\n    for (let key of Object.keys(thingy)) {\n      if (Array.isArray(thingy[key])) thingy[key] = thingy[key].map(x => recurseGraph(x, graph, replacement));else if (typeVals.indexOf(thingy[key].type) >= 0) // can't do instanceof on an interface\n        thingy[key] = recurseGraph(thingy[key], graph, replacement);else if (replacement && isVariable(thingy[key]) && thingy[key].equals(graph)) thingy[key] = replacement;\n    }\n  }\n\n  return thingy;\n}\n\nfunction accumulateGroupGraphPattern(G, E) {\n  if (E.type === 'optional') {\n    // optional input needs to be interpreted as a group\n    let A = translateGroupGraphPattern({\n      type: 'group',\n      patterns: E.patterns\n    });\n\n    if (A.type === types.FILTER) {\n      let filter = A;\n      G = factory.createLeftJoin(G, filter.input, filter.expression);\n    } else G = factory.createLeftJoin(G, A);\n  } else if (E.type === 'minus') {\n    // minus input needs to be interpreted as a group\n    let A = translateGroupGraphPattern({\n      type: 'group',\n      patterns: E.patterns\n    });\n    G = factory.createMinus(G, A);\n  } else if (E.type === 'bind') G = factory.createExtend(G, E.variable, translateExpression(E.expression));else if (E.type === 'service') {\n    // transform to group so childnodes get parsed correctly\n    E.type = 'group';\n    let A = factory.createService(translateGroupGraphPattern(E), E.name, E.silent);\n    G = simplifiedJoin(G, A);\n  } else {\n    let A = translateGroupGraphPattern(E);\n    G = simplifiedJoin(G, A);\n  }\n\n  return G;\n}\n\nfunction simplifiedJoin(G, A) {\n  // Note: this is more simplification than requested in 18.2.2.8, but no reason not to do it.\n  if (G.type === types.BGP && A.type === types.BGP) G = factory.createBgp([].concat(G.patterns, A.patterns)); // 18.2.2.8 (simplification)\n  else if (G.type === types.BGP && G.patterns.length === 0) G = A;else if (A.type === types.BGP && A.patterns.length === 0) {} // do nothing\n  else G = factory.createJoin(G, A);\n  return G;\n}\n\nfunction translateInlineData(values) {\n  let variables = (values.values.length === 0 ? [] : Object.keys(values.values[0])).map(factory.createTerm.bind(factory));\n  let bindings = values.values.map(binding => {\n    let keys = Object.keys(binding);\n    keys = keys.filter(k => binding[k] !== undefined);\n    let map = {};\n\n    for (let key of keys) map[key] = binding[key];\n\n    return map;\n  });\n  return factory.createValues(variables, bindings);\n} // --------------------------------------- AGGREGATES\n\n\nfunction translateAggregates(query, res, variables) {\n  // 18.2.4.1\n  let E = [];\n  let A = {};\n  query.variables = mapAggregates(query.variables, A);\n  query.having = mapAggregates(query.having, A);\n  query.order = mapAggregates(query.order, A); // if there are any aggregates or if we have a groupBy (both result in a GROUP)\n\n  if (query.group || Object.keys(A).length > 0) {\n    let aggregates = Object.keys(A).map(v => translateBoundAggregate(A[v], factory.createTerm(v)));\n    let vars = [];\n\n    if (query.group) {\n      for (let e of query.group) {\n        if (e.expression.type) {\n          const v = e.variable ? e.variable : generateFreshVar();\n          res = factory.createExtend(res, v, translateExpression(e.expression));\n          vars.push(v);\n        } else vars.push(e.expression); // this will always be a var, otherwise sparql would be invalid\n\n      }\n    }\n\n    res = factory.createGroup(res, vars, aggregates);\n  } // 18.2.4.2\n\n\n  if (query.having) for (let filter of query.having) res = factory.createFilter(res, translateExpression(filter)); // 18.2.4.3\n\n  if (query.values) res = factory.createJoin(res, translateInlineData(query)); // 18.2.4.4\n\n  let PV = new Set();\n\n  if (query.queryType === 'SELECT' || query.queryType === 'DESCRIBE') {\n    if (query.variables.some(e => e && util_1.default.isWildcard(e))) PV = variables;else {\n      for (let v of query.variables) {\n        // can have non-variables with DESCRIBE\n        if (isVariable(v) || !v.variable) PV.add(v);else if (v.variable) // ... AS ?x\n          {\n            PV.add(v.variable);\n            E.push(v);\n          }\n      }\n    }\n  } // TODO: Jena simplifies by having a list of extends\n\n\n  for (let v of E) res = factory.createExtend(res, v.variable, translateExpression(v.expression)); // 18.2.5\n  // not using toList and toMultiset\n  // 18.2.5.1\n\n\n  if (query.order) res = factory.createOrderBy(res, query.order.map(exp => {\n    let result = translateExpression(exp.expression);\n    if (exp.descending) result = factory.createOperatorExpression(types.DESC, [result]); // TODO: should this really be an expression?\n\n    return result;\n  })); // 18.2.5.2\n  // construct does not need a project (select, ask and describe do)\n\n  if (query.queryType === 'SELECT') res = factory.createProject(res, Array.from(PV)); // 18.2.5.3\n\n  if (query.distinct) res = factory.createDistinct(res); // 18.2.5.4\n\n  if (query.reduced) res = factory.createReduced(res); // NEW: support for ask/construct/describe queries\n\n  if (query.queryType === 'CONSTRUCT') res = factory.createConstruct(res, query.template.map(translateQuad));else if (query.queryType === 'ASK') res = factory.createAsk(res);else if (query.queryType === 'DESCRIBE') res = factory.createDescribe(res, Array.from(PV)); // Slicing needs to happen after construct/describe\n  // 18.2.5.5\n\n  if (query.offset || query.limit) res = factory.createSlice(res, query.offset, query.limit);\n  if (query.from) res = factory.createFrom(res, query.from.default, query.from.named);\n  return res;\n} // rewrites some of the input sparql object to make use of aggregate variables\n\n\nfunction mapAggregates(thingy, aggregates) {\n  if (!thingy) return thingy;\n\n  if (thingy.type === 'aggregate') {\n    let found = false;\n    let v;\n\n    for (let key of Object.keys(aggregates)) {\n      if (equal(aggregates[key], thingy)) {\n        v = factory.createTerm(key);\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      v = generateFreshVar();\n      aggregates[rdf_string_1.termToString(v)] = thingy;\n    }\n\n    return v;\n  } // non-aggregate expression\n\n\n  if (thingy.expression) thingy.expression = mapAggregates(thingy.expression, aggregates);else if (thingy.args) mapAggregates(thingy.args, aggregates);else if (Array.isArray(thingy)) thingy.forEach((subthingy, idx) => thingy[idx] = mapAggregates(subthingy, aggregates));\n  return thingy;\n}\n\nfunction translateBoundAggregate(thingy, v) {\n  if (thingy.type !== 'aggregate' || !thingy.aggregation) throw new Error('Unexpected input: ' + JSON.stringify(thingy));\n  let A = translateExpression(thingy);\n  A.variable = v;\n  return A;\n}\n\nfunction translateUpdate(thingy) {\n  if (thingy.updates.length === 1) return translateSingleUpdate(thingy.updates[0]);\n  return factory.createCompositeUpdate(thingy.updates.map(translateSingleUpdate));\n}\n\nfunction translateSingleUpdate(thingy) {\n  if (thingy.updateType === 'insertdelete' || thingy.updateType === 'deletewhere' || thingy.updateType === 'delete' || thingy.updateType === 'insert') return translateInsertDelete(thingy);\n  if (thingy.type === 'load') return translateUpdateGraphLoad(thingy);\n  if (thingy.type === 'clear' || thingy.type === 'create' || thingy.type === 'drop') return translateUpdateGraph(thingy);\n  if (thingy.type === 'add' || thingy.type === 'copy' || thingy.type === 'move') return translateUpdateGraphShortcut(thingy);\n  throw new Error(`Unknown update type ${thingy.updateType}`);\n}\n\nfunction translateInsertDelete(thingy) {\n  if (!useQuads) throw new Error('INSERT/DELETE operations are only supported with quads option enabled');\n  let deleteTriples = [];\n  let insertTriples = [];\n  let where;\n  if (thingy.delete) deleteTriples = util_1.default.flatten(thingy.delete.map(input => translateUpdateTriplesBlock(input, thingy.graph)));\n  if (thingy.insert) insertTriples = util_1.default.flatten(thingy.insert.map(input => translateUpdateTriplesBlock(input, thingy.graph)));\n\n  if (thingy.where && thingy.where.length > 0) {\n    where = translateGroupGraphPattern({\n      type: 'group',\n      patterns: thingy.where\n    });\n    if (thingy.using) where = factory.createFrom(where, thingy.using.default, thingy.using.named);else if (thingy.graph) // This is equivalent\n      where = recurseGraph(where, thingy.graph);\n  } else if (thingy.updateType === 'deletewhere' && deleteTriples.length > 0) {\n    where = factory.createBgp(deleteTriples);\n  }\n\n  return factory.createDeleteInsert(deleteTriples.length > 0 ? deleteTriples : undefined, insertTriples.length > 0 ? insertTriples : undefined, where);\n} // UPDATE parsing will always return quads and have no GRAPH elements\n\n\nfunction translateUpdateTriplesBlock(thingy, graph) {\n  let currentGraph = graph;\n  if (thingy.type === 'graph') currentGraph = thingy.name;\n  let currentTriples = thingy.triples;\n  if (currentGraph) currentTriples = currentTriples.map(triple => Object.assign(triple, {\n    graph: currentGraph\n  }));\n  return currentTriples.map(translateQuad);\n}\n\nfunction translateUpdateGraph(thingy) {\n  let source;\n  if (thingy.graph.all) source = 'ALL';else if (thingy.graph.default) source = 'DEFAULT';else if (thingy.graph.named) source = 'NAMED';else source = thingy.graph.name;\n\n  switch (thingy.type) {\n    case 'clear':\n      return factory.createClear(source, thingy.silent);\n\n    case 'create':\n      return factory.createCreate(source, thingy.silent);\n\n    case 'drop':\n      return factory.createDrop(source, thingy.silent);\n  }\n}\n\nfunction translateUpdateGraphLoad(thingy) {\n  return factory.createLoad(thingy.source, thingy.destination, thingy.silent);\n}\n\nfunction translateUpdateGraphShortcut(thingy) {\n  const source = thingy.source.default ? 'DEFAULT' : thingy.source.name;\n  const destination = thingy.destination.default ? 'DEFAULT' : thingy.destination.name;\n\n  switch (thingy.type) {\n    case 'copy':\n      return factory.createCopy(source, destination, thingy.silent);\n\n    case 'move':\n      return factory.createMove(source, destination, thingy.silent);\n\n    case 'add':\n      return factory.createAdd(source, destination, thingy.silent);\n  }\n}\n\nfunction translateBlankNodesToVariables(res, variables) {\n  const blankToVariableMapping = {};\n  const variablesRaw = Array.from(variables).reduce((acc, variable) => {\n    acc[variable.value] = true;\n    return acc;\n  }, {});\n  return util_1.default.mapOperation(res, {\n    'deleteinsert': op => {\n      // Only relevant for INSERT operations as others should never contain blank nodes\n      return {\n        result: op,\n        recurse: false\n      };\n    },\n    'path': (op, factory) => {\n      return {\n        result: factory.createPath(blankToVariable(op.subject), op.predicate, blankToVariable(op.object), blankToVariable(op.graph)),\n        recurse: false\n      };\n    },\n    'pattern': (op, factory) => {\n      return {\n        result: factory.createPattern(blankToVariable(op.subject), blankToVariable(op.predicate), blankToVariable(op.object), blankToVariable(op.graph)),\n        recurse: false\n      };\n    },\n    'construct': op => {\n      // Blank nodes in CONSTRUCT templates must be maintained\n      return {\n        result: factory.createConstruct(translateBlankNodesToVariables(op.input, variables), op.template),\n        recurse: false\n      };\n    }\n  });\n\n  function blankToVariable(term) {\n    if (term.termType === 'BlankNode') {\n      let variable = blankToVariableMapping[term.value];\n\n      if (!variable) {\n        variable = util_1.default.createUniqueVariable(term.value, variablesRaw, factory.dataFactory);\n        variablesRaw[variable.value] = true;\n        blankToVariableMapping[term.value] = variable;\n      }\n\n      return variable;\n    }\n\n    return term;\n  }\n}","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/sparqlalgebrajs/lib/sparqlAlgebra.js"],"names":["Object","defineProperty","exports","value","Algebra","require","factory_1","util_1","equal","rdf_string_1","Parser","types","variables","Set","varCount","useQuads","factory","translate","sparql","options","default","dataFactory","isString","parser","_resetBlanks","parse","translateQuery","quads","blankToVariable","type","createProject","createBgp","Error","vars","keys","inScopeVariables","map","createTerm","bind","res","group","patterns","where","translateGroupGraphPattern","translateAggregates","translateUpdate","translateBlankNodesToVariables","str","isObject","o","isVariable","term","termType","thingy","inScope","termToString","add","expression","assign","variable","queryType","all","v","isWildcard","key","filters","nonfilters","pattern","push","translateBgp","result","p","reduce","acc","item","createUnion","translateGraph","accumulateGroupGraphPattern","translateInlineData","length","expressions","filter","translateExpression","createFilter","exp","createOperatorExpression","isTerm","createTermExpression","createWildcardExpression","aggregation","createAggregateExpression","distinct","separator","function","createNamedExpression","args","operator","createExistenceExpression","concat","JSON","stringify","joins","t","triples","predicate","path","translatePath","PATH","translateQuad","createJoin","triple","sub","subject","pred","translatePathPredicate","obj","object","simplifyPath","createLink","pathType","createInv","items","normals","inverted","normalElement","createNps","invertedElement","createAlt","createSeq","createZeroOrMorePath","createOneOrMorePath","createZeroOrOnePath","LINK","createPattern","iri","INV","SEQ","generateFreshVar","left","right","createPath","has","quad","graph","recurseGraph","name","createGraph","typeVals","replacement","GRAPH","input","BGP","equals","PROJECT","proj","some","EXTEND","ext","Array","isArray","x","indexOf","G","E","A","FILTER","createLeftJoin","createMinus","createExtend","createService","silent","simplifiedJoin","values","bindings","binding","k","undefined","createValues","query","mapAggregates","having","order","aggregates","translateBoundAggregate","e","createGroup","PV","createOrderBy","descending","DESC","from","createDistinct","reduced","createReduced","createConstruct","template","createAsk","createDescribe","offset","limit","createSlice","createFrom","named","found","forEach","subthingy","idx","updates","translateSingleUpdate","createCompositeUpdate","updateType","translateInsertDelete","translateUpdateGraphLoad","translateUpdateGraph","translateUpdateGraphShortcut","deleteTriples","insertTriples","delete","flatten","translateUpdateTriplesBlock","insert","using","createDeleteInsert","currentGraph","currentTriples","source","createClear","createCreate","createDrop","createLoad","destination","createCopy","createMove","createAdd","blankToVariableMapping","variablesRaw","mapOperation","op","recurse","createUniqueVariable"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Algebra = require(\"./algebra\");\nconst factory_1 = require(\"./factory\");\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst rdf_string_1 = require(\"rdf-string\");\nconst Parser = require('sparqljs').Parser;\nconst types = Algebra.types;\nlet variables = new Set();\nlet varCount = 0;\nlet useQuads = false;\nlet factory;\n/**\n * Translates the given SPARQL query to SPARQL Algebra.\n * @param sparql - Either a SPARQL string or an object generated by sparql.js\n * @param options - Optional options object. Current options:\n *                    * dataFactory: The Datafactory used to generate terms. Default @rdfjs/data-model.\n *                    * quads: Boolean indicating whether triples should be converted to Quads (consumes GRAPH statements). Default false.\n *                    * prefixes: Pre-defined prefixes for the given query. Default empty.\n *                    * baseIRI: Base IRI that should be used for the query. Default undefined (throws error if required).\n * @returns {Operation}\n */\nfunction translate(sparql, options) {\n    options = options || {};\n    factory = new factory_1.default(options.dataFactory);\n    if (isString(sparql)) {\n        let parser = new Parser(options);\n        // resets the identifier counter used for blank nodes\n        // provides nicer and more consistent output if there are multiple calls\n        parser._resetBlanks();\n        sparql = parser.parse(sparql);\n    }\n    return translateQuery(sparql, options.quads, options.blankToVariable);\n}\nexports.default = translate;\nfunction translateQuery(sparql, quads, blankToVariable) {\n    // this set is filled in during the inScopeVariables call\n    variables = new Set();\n    varCount = 0;\n    useQuads = quads;\n    // Assume this is an empty query\n    if (!sparql.type)\n        return factory.createProject(factory.createBgp([]), []);\n    if (sparql.type !== 'query' && sparql.type !== 'update')\n        throw new Error('Translate only works on complete query or update objects.');\n    let vars = new Set(Object.keys(inScopeVariables(sparql)).map(factory.createTerm.bind(factory)));\n    let res;\n    if (sparql.type === 'query') {\n        // group and where are identical, having only 1 makes parsing easier, can be undefined in DESCRIBE\n        let group = { type: 'group', patterns: sparql.where || [] };\n        res = translateGroupGraphPattern(group);\n        res = translateAggregates(sparql, res, vars);\n    }\n    else if (sparql.type === 'update') {\n        res = translateUpdate(sparql);\n    }\n    if (blankToVariable) {\n        res = translateBlankNodesToVariables(res, vars);\n    }\n    return res;\n}\nfunction isString(str) {\n    return typeof str === 'string';\n}\nfunction isObject(o) {\n    return o !== null && typeof o === 'object';\n}\nfunction isVariable(term) {\n    return term && term.termType === \"Variable\";\n}\n// 18.2.1\nfunction inScopeVariables(thingy) {\n    let inScope = {};\n    if (isVariable(thingy)) {\n        inScope[rdf_string_1.termToString(thingy)] = true;\n        variables.add(thingy); // keep track of all variables so we don't generate duplicates\n    }\n    else if (isObject(thingy)) {\n        if (thingy.type === 'bind') {\n            inScopeVariables(thingy.expression); // to fill `variables`\n            Object.assign(inScope, inScopeVariables(thingy.variable));\n        }\n        else if (thingy.queryType === 'SELECT') {\n            let all = inScopeVariables(thingy.where); // always executing this makes sure `variables` gets filled correctly\n            for (let v of thingy.variables) {\n                if (util_1.default.isWildcard(v))\n                    Object.assign(inScope, all);\n                else if (v.variable) // aggregates\n                    Object.assign(inScope, inScopeVariables(v.variable));\n                else\n                    Object.assign(inScope, inScopeVariables(v));\n            }\n            // TODO: I'm not 100% sure if you always add these or only when '*' was selected\n            if (thingy.group)\n                for (let v of thingy.group)\n                    Object.assign(inScope, inScopeVariables(v));\n        }\n        else\n            for (let key of Object.keys(thingy))\n                Object.assign(inScope, inScopeVariables(thingy[key]));\n    }\n    return inScope;\n}\nfunction translateGroupGraphPattern(thingy) {\n    // 18.2.2.1\n    // already done by sparql parser\n    // 18.2.2.2\n    let filters = [];\n    let nonfilters = [];\n    if (thingy.patterns)\n        for (let pattern of thingy.patterns)\n            (pattern.type === 'filter' ? filters : nonfilters).push(pattern);\n    // 18.2.2.3\n    // 18.2.2.4\n    // 18.2.2.5\n    if (thingy.type === 'bgp')\n        return translateBgp(thingy);\n    // 18.2.2.6\n    let result;\n    if (thingy.type === 'union')\n        result = nonfilters.map((p) => {\n            // sparqljs doesn't always indicate the children are groups\n            if (p.type !== 'group')\n                p = { type: 'group', patterns: [p] };\n            return translateGroupGraphPattern(p);\n        }).reduce((acc, item) => factory.createUnion(acc, item));\n    else if (thingy.type === 'graph')\n        // need to handle this separately since the filters need to be in the graph\n        return translateGraph(thingy);\n    else if (thingy.type === 'group')\n        result = nonfilters.reduce(accumulateGroupGraphPattern, factory.createBgp([]));\n    // custom values operation\n    else if (thingy.type === 'values')\n        result = translateInlineData(thingy);\n    else if (thingy.type === 'query')\n        result = translateQuery(thingy, useQuads, false);\n    else\n        throw new Error('Unexpected type: ' + thingy.type);\n    if (filters.length > 0) {\n        let expressions = filters.map(filter => translateExpression(filter.expression));\n        if (expressions.length > 0)\n            result = factory.createFilter(result, expressions.reduce((acc, exp) => factory.createOperatorExpression('&&', [acc, exp])));\n    }\n    return result;\n}\nfunction translateExpression(exp) {\n    if (util_1.default.isTerm(exp) || exp.termType === 'Quad')\n        return factory.createTermExpression(exp);\n    if (util_1.default.isWildcard(exp))\n        return factory.createWildcardExpression();\n    if (exp.aggregation)\n        return factory.createAggregateExpression(exp.aggregation, translateExpression(exp.expression), exp.distinct, exp.separator);\n    if (exp.function)\n        return factory.createNamedExpression(exp.function, exp.args.map(translateExpression));\n    if (exp.operator) {\n        if (exp.operator === 'exists' || exp.operator === 'notexists')\n            return factory.createExistenceExpression(exp.operator === 'notexists', translateGroupGraphPattern(exp.args[0]));\n        if (exp.operator === 'in' || exp.operator === 'notin')\n            exp.args = [exp.args[0]].concat(exp.args[1]); // sparql.js uses 2 arguments with the second one being a list\n        return factory.createOperatorExpression(exp.operator, exp.args.map(translateExpression));\n    }\n    throw new Error('Unknown expression: ' + JSON.stringify(exp));\n}\nfunction translateBgp(thingy) {\n    let patterns = [];\n    let joins = [];\n    for (let t of thingy.triples) {\n        if (t.predicate.type === 'path') {\n            // translatePath returns a mix of Quads and Paths\n            let path = translatePath(t);\n            for (let p of path) {\n                if (p.type === types.PATH) {\n                    if (patterns.length > 0)\n                        joins.push(factory.createBgp(patterns));\n                    patterns = [];\n                    joins.push(p);\n                }\n                else\n                    patterns.push(p);\n            }\n        }\n        else\n            patterns.push(translateQuad(t));\n    }\n    if (patterns.length > 0)\n        joins.push(factory.createBgp(patterns));\n    if (joins.length === 1)\n        return joins[0];\n    return joins.reduce((acc, item) => factory.createJoin(acc, item));\n}\nfunction translatePath(triple) {\n    let sub = triple.subject;\n    let pred = translatePathPredicate(triple.predicate);\n    let obj = triple.object;\n    return simplifyPath(sub, pred, obj);\n}\nfunction translatePathPredicate(predicate) {\n    if (util_1.default.isTerm(predicate) && predicate.termType === \"NamedNode\")\n        return factory.createLink(predicate);\n    if (predicate.pathType === '^')\n        return factory.createInv(translatePathPredicate(predicate.items[0]));\n    if (predicate.pathType === '!') {\n        // negation is either over a single predicate or a list of disjuncted properties\n        let normals = [];\n        let inverted = [];\n        let items;\n        if (predicate.items[0].type === 'path' && predicate.items[0].pathType === '|')\n            items = predicate.items[0].items; // the | element\n        else\n            items = predicate.items;\n        for (let item of items) {\n            if (util_1.default.isTerm(item))\n                normals.push(item);\n            else if (item.pathType === '^')\n                inverted.push(item.items[0]);\n            else\n                throw new Error('Unexpected item: ' + JSON.stringify(item));\n        }\n        // NPS elements do not have the LINK function\n        let normalElement = factory.createNps(normals);\n        let invertedElement = factory.createInv(factory.createNps(inverted));\n        if (inverted.length === 0)\n            return normalElement;\n        if (normals.length === 0)\n            return invertedElement;\n        return factory.createAlt(normalElement, invertedElement);\n    }\n    if (predicate.pathType === '/')\n        return predicate.items.map(translatePathPredicate).reduce((acc, p) => factory.createSeq(acc, p));\n    if (predicate.pathType === '|')\n        return predicate.items.map(translatePathPredicate).reduce((acc, p) => factory.createAlt(acc, p));\n    if (predicate.pathType === '*')\n        return factory.createZeroOrMorePath(translatePathPredicate(predicate.items[0]));\n    if (predicate.pathType === '+')\n        return factory.createOneOrMorePath(translatePathPredicate(predicate.items[0]));\n    if (predicate.pathType === '?')\n        return factory.createZeroOrOnePath(translatePathPredicate(predicate.items[0]));\n    throw new Error('Unable to translate path expression ' + JSON.stringify(predicate));\n}\nfunction simplifyPath(subject, predicate, object) {\n    if (predicate.type === types.LINK)\n        return [factory.createPattern(subject, predicate.iri, object)];\n    if (predicate.type === types.INV)\n        return simplifyPath(object, predicate.path, subject);\n    if (predicate.type === types.SEQ) {\n        let v = generateFreshVar();\n        let left = simplifyPath(subject, predicate.left, v);\n        let right = simplifyPath(v, predicate.right, object);\n        return left.concat(right);\n    }\n    return [factory.createPath(subject, predicate, object)];\n}\nfunction generateFreshVar() {\n    let v = '?var' + varCount++;\n    if (variables.has(v))\n        return generateFreshVar();\n    variables.add(v);\n    return factory.createTerm(v);\n}\nfunction translateQuad(quad) {\n    return factory.createPattern(quad.subject, quad.predicate, quad.object, quad.graph);\n}\nfunction translateGraph(graph) {\n    graph.type = 'group';\n    let result = translateGroupGraphPattern(graph);\n    if (useQuads)\n        result = recurseGraph(result, graph.name);\n    else\n        result = factory.createGraph(result, graph.name);\n    return result;\n}\nlet typeVals = Object.keys(types).map(key => types[key]);\nfunction recurseGraph(thingy, graph, replacement) {\n    if (thingy.type === types.GRAPH) {\n        if (replacement) {\n            // At this point we would lose track of the replacement which would result in incorrect results\n            // This would indicate the library is not being used as intended though\n            throw new Error('Recursing through nested GRAPH statements with a replacement is impossible.');\n        }\n        const graph = thingy;\n        // In case there were nested GRAPH statements that were not recursed yet for some reason\n        thingy = recurseGraph(graph.input, graph.name);\n    }\n    else if (thingy.type === types.BGP)\n        thingy.patterns = thingy.patterns.map(quad => {\n            if (replacement) {\n                if (quad.subject.equals(graph))\n                    quad.subject = replacement;\n                if (quad.predicate.equals(graph))\n                    quad.predicate = replacement;\n                if (quad.object.equals(graph))\n                    quad.object = replacement;\n            }\n            if (quad.graph.termType === 'DefaultGraph')\n                quad.graph = graph;\n            return quad;\n        });\n    else if (thingy.type === types.PATH) {\n        const p = thingy;\n        if (replacement) {\n            if (p.subject.equals(graph))\n                p.subject = replacement;\n            if (p.object.equals(graph))\n                p.object = replacement;\n        }\n        if (thingy.graph.termType === 'DefaultGraph')\n            thingy.graph = graph;\n    }\n    // need to replace variables in subqueries should the graph also be a variable of the same name\n    // unless the subquery projects that variable\n    else if (thingy.type === types.PROJECT && !replacement) {\n        const proj = thingy;\n        if (!proj.variables.some(v => v.equals(graph)))\n            replacement = generateFreshVar();\n        proj.input = recurseGraph(proj.input, graph, replacement);\n    }\n    // this can happen if the query extends an expression to the name of the graph\n    // since the extend happens here there should be no further occurrences of this name\n    // if there are it's the same situation as above\n    else if (thingy.type === types.EXTEND && !replacement) {\n        const ext = thingy;\n        if (ext.variable.equals(graph))\n            replacement = generateFreshVar();\n        ext.input = recurseGraph(ext.input, graph, replacement);\n    }\n    else {\n        for (let key of Object.keys(thingy)) {\n            if (Array.isArray(thingy[key]))\n                thingy[key] = thingy[key].map((x) => recurseGraph(x, graph, replacement));\n            else if (typeVals.indexOf(thingy[key].type) >= 0) // can't do instanceof on an interface\n                thingy[key] = recurseGraph(thingy[key], graph, replacement);\n            else if (replacement && isVariable(thingy[key]) && thingy[key].equals(graph))\n                thingy[key] = replacement;\n        }\n    }\n    return thingy;\n}\nfunction accumulateGroupGraphPattern(G, E) {\n    if (E.type === 'optional') {\n        // optional input needs to be interpreted as a group\n        let A = translateGroupGraphPattern({ type: 'group', patterns: E.patterns });\n        if (A.type === types.FILTER) {\n            let filter = A;\n            G = factory.createLeftJoin(G, filter.input, filter.expression);\n        }\n        else\n            G = factory.createLeftJoin(G, A);\n    }\n    else if (E.type === 'minus') {\n        // minus input needs to be interpreted as a group\n        let A = translateGroupGraphPattern({ type: 'group', patterns: E.patterns });\n        G = factory.createMinus(G, A);\n    }\n    else if (E.type === 'bind')\n        G = factory.createExtend(G, E.variable, translateExpression(E.expression));\n    else if (E.type === 'service') {\n        // transform to group so childnodes get parsed correctly\n        E.type = 'group';\n        let A = factory.createService(translateGroupGraphPattern(E), E.name, E.silent);\n        G = simplifiedJoin(G, A);\n    }\n    else {\n        let A = translateGroupGraphPattern(E);\n        G = simplifiedJoin(G, A);\n    }\n    return G;\n}\nfunction simplifiedJoin(G, A) {\n    // Note: this is more simplification than requested in 18.2.2.8, but no reason not to do it.\n    if (G.type === types.BGP && A.type === types.BGP)\n        G = factory.createBgp([].concat(G.patterns, A.patterns));\n    // 18.2.2.8 (simplification)\n    else if (G.type === types.BGP && G.patterns.length === 0)\n        G = A;\n    else if (A.type === types.BGP && A.patterns.length === 0) { } // do nothing\n    else\n        G = factory.createJoin(G, A);\n    return G;\n}\nfunction translateInlineData(values) {\n    let variables = (values.values.length === 0 ? [] : Object.keys(values.values[0])).map(factory.createTerm.bind(factory));\n    let bindings = values.values.map((binding) => {\n        let keys = Object.keys(binding);\n        keys = keys.filter(k => binding[k] !== undefined);\n        let map = {};\n        for (let key of keys)\n            map[key] = binding[key];\n        return map;\n    });\n    return factory.createValues(variables, bindings);\n}\n// --------------------------------------- AGGREGATES\nfunction translateAggregates(query, res, variables) {\n    // 18.2.4.1\n    let E = [];\n    let A = {};\n    query.variables = mapAggregates(query.variables, A);\n    query.having = mapAggregates(query.having, A);\n    query.order = mapAggregates(query.order, A);\n    // if there are any aggregates or if we have a groupBy (both result in a GROUP)\n    if (query.group || Object.keys(A).length > 0) {\n        let aggregates = Object.keys(A).map(v => translateBoundAggregate(A[v], factory.createTerm(v)));\n        let vars = [];\n        if (query.group) {\n            for (let e of query.group) {\n                if (e.expression.type) {\n                    const v = e.variable ? e.variable : generateFreshVar();\n                    res = factory.createExtend(res, v, translateExpression(e.expression));\n                    vars.push(v);\n                }\n                else\n                    vars.push(e.expression); // this will always be a var, otherwise sparql would be invalid\n            }\n        }\n        res = factory.createGroup(res, vars, aggregates);\n    }\n    // 18.2.4.2\n    if (query.having)\n        for (let filter of query.having)\n            res = factory.createFilter(res, translateExpression(filter));\n    // 18.2.4.3\n    if (query.values)\n        res = factory.createJoin(res, translateInlineData(query));\n    // 18.2.4.4\n    let PV = new Set();\n    if (query.queryType === 'SELECT' || query.queryType === 'DESCRIBE') {\n        if (query.variables.some((e) => e && util_1.default.isWildcard(e)))\n            PV = variables;\n        else {\n            for (let v of query.variables) {\n                // can have non-variables with DESCRIBE\n                if (isVariable(v) || !v.variable)\n                    PV.add(v);\n                else if (v.variable) // ... AS ?x\n                 {\n                    PV.add(v.variable);\n                    E.push(v);\n                }\n            }\n        }\n    }\n    // TODO: Jena simplifies by having a list of extends\n    for (let v of E)\n        res = factory.createExtend(res, v.variable, translateExpression(v.expression));\n    // 18.2.5\n    // not using toList and toMultiset\n    // 18.2.5.1\n    if (query.order)\n        res = factory.createOrderBy(res, query.order.map((exp) => {\n            let result = translateExpression(exp.expression);\n            if (exp.descending)\n                result = factory.createOperatorExpression(types.DESC, [result]); // TODO: should this really be an expression?\n            return result;\n        }));\n    // 18.2.5.2\n    // construct does not need a project (select, ask and describe do)\n    if (query.queryType === 'SELECT')\n        res = factory.createProject(res, Array.from(PV));\n    // 18.2.5.3\n    if (query.distinct)\n        res = factory.createDistinct(res);\n    // 18.2.5.4\n    if (query.reduced)\n        res = factory.createReduced(res);\n    // NEW: support for ask/construct/describe queries\n    if (query.queryType === 'CONSTRUCT')\n        res = factory.createConstruct(res, query.template.map(translateQuad));\n    else if (query.queryType === 'ASK')\n        res = factory.createAsk(res);\n    else if (query.queryType === 'DESCRIBE')\n        res = factory.createDescribe(res, Array.from(PV));\n    // Slicing needs to happen after construct/describe\n    // 18.2.5.5\n    if (query.offset || query.limit)\n        res = factory.createSlice(res, query.offset, query.limit);\n    if (query.from)\n        res = factory.createFrom(res, query.from.default, query.from.named);\n    return res;\n}\n// rewrites some of the input sparql object to make use of aggregate variables\nfunction mapAggregates(thingy, aggregates) {\n    if (!thingy)\n        return thingy;\n    if (thingy.type === 'aggregate') {\n        let found = false;\n        let v;\n        for (let key of Object.keys(aggregates)) {\n            if (equal(aggregates[key], thingy)) {\n                v = factory.createTerm(key);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            v = generateFreshVar();\n            aggregates[rdf_string_1.termToString(v)] = thingy;\n        }\n        return v;\n    }\n    // non-aggregate expression\n    if (thingy.expression)\n        thingy.expression = mapAggregates(thingy.expression, aggregates);\n    else if (thingy.args)\n        mapAggregates(thingy.args, aggregates);\n    else if (Array.isArray(thingy))\n        thingy.forEach((subthingy, idx) => thingy[idx] = mapAggregates(subthingy, aggregates));\n    return thingy;\n}\nfunction translateBoundAggregate(thingy, v) {\n    if (thingy.type !== 'aggregate' || !thingy.aggregation)\n        throw new Error('Unexpected input: ' + JSON.stringify(thingy));\n    let A = translateExpression(thingy);\n    A.variable = v;\n    return A;\n}\nfunction translateUpdate(thingy) {\n    if (thingy.updates.length === 1)\n        return translateSingleUpdate(thingy.updates[0]);\n    return factory.createCompositeUpdate(thingy.updates.map(translateSingleUpdate));\n}\nfunction translateSingleUpdate(thingy) {\n    if (thingy.updateType === 'insertdelete' || thingy.updateType === 'deletewhere' || thingy.updateType === 'delete' || thingy.updateType === 'insert')\n        return translateInsertDelete(thingy);\n    if (thingy.type === 'load')\n        return translateUpdateGraphLoad(thingy);\n    if (thingy.type === 'clear' || thingy.type === 'create' || thingy.type === 'drop')\n        return translateUpdateGraph(thingy);\n    if (thingy.type === 'add' || thingy.type === 'copy' || thingy.type === 'move')\n        return translateUpdateGraphShortcut(thingy);\n    throw new Error(`Unknown update type ${thingy.updateType}`);\n}\nfunction translateInsertDelete(thingy) {\n    if (!useQuads)\n        throw new Error('INSERT/DELETE operations are only supported with quads option enabled');\n    let deleteTriples = [];\n    let insertTriples = [];\n    let where;\n    if (thingy.delete)\n        deleteTriples = util_1.default.flatten(thingy.delete.map(input => translateUpdateTriplesBlock(input, thingy.graph)));\n    if (thingy.insert)\n        insertTriples = util_1.default.flatten(thingy.insert.map(input => translateUpdateTriplesBlock(input, thingy.graph)));\n    if (thingy.where && thingy.where.length > 0) {\n        where = translateGroupGraphPattern({ type: 'group', patterns: thingy.where });\n        if (thingy.using)\n            where = factory.createFrom(where, thingy.using.default, thingy.using.named);\n        else if (thingy.graph)\n            // This is equivalent\n            where = recurseGraph(where, thingy.graph);\n    }\n    else if (thingy.updateType === 'deletewhere' && deleteTriples.length > 0) {\n        where = factory.createBgp(deleteTriples);\n    }\n    return factory.createDeleteInsert(deleteTriples.length > 0 ? deleteTriples : undefined, insertTriples.length > 0 ? insertTriples : undefined, where);\n}\n// UPDATE parsing will always return quads and have no GRAPH elements\nfunction translateUpdateTriplesBlock(thingy, graph) {\n    let currentGraph = graph;\n    if (thingy.type === 'graph')\n        currentGraph = thingy.name;\n    let currentTriples = thingy.triples;\n    if (currentGraph)\n        currentTriples = currentTriples.map(triple => Object.assign(triple, { graph: currentGraph }));\n    return currentTriples.map(translateQuad);\n}\nfunction translateUpdateGraph(thingy) {\n    let source;\n    if (thingy.graph.all)\n        source = 'ALL';\n    else if (thingy.graph.default)\n        source = 'DEFAULT';\n    else if (thingy.graph.named)\n        source = 'NAMED';\n    else\n        source = thingy.graph.name;\n    switch (thingy.type) {\n        case 'clear': return factory.createClear(source, thingy.silent);\n        case 'create': return factory.createCreate(source, thingy.silent);\n        case 'drop': return factory.createDrop(source, thingy.silent);\n    }\n}\nfunction translateUpdateGraphLoad(thingy) {\n    return factory.createLoad(thingy.source, thingy.destination, thingy.silent);\n}\nfunction translateUpdateGraphShortcut(thingy) {\n    const source = thingy.source.default ? 'DEFAULT' : thingy.source.name;\n    const destination = thingy.destination.default ? 'DEFAULT' : thingy.destination.name;\n    switch (thingy.type) {\n        case 'copy': return factory.createCopy(source, destination, thingy.silent);\n        case 'move': return factory.createMove(source, destination, thingy.silent);\n        case 'add': return factory.createAdd(source, destination, thingy.silent);\n    }\n}\nfunction translateBlankNodesToVariables(res, variables) {\n    const blankToVariableMapping = {};\n    const variablesRaw = Array.from(variables).reduce((acc, variable) => {\n        acc[variable.value] = true;\n        return acc;\n    }, {});\n    return util_1.default.mapOperation(res, {\n        'deleteinsert': (op) => {\n            // Only relevant for INSERT operations as others should never contain blank nodes\n            return { result: op, recurse: false };\n        },\n        'path': (op, factory) => {\n            return {\n                result: factory.createPath(blankToVariable(op.subject), op.predicate, blankToVariable(op.object), blankToVariable(op.graph)),\n                recurse: false,\n            };\n        },\n        'pattern': (op, factory) => {\n            return {\n                result: factory.createPattern(blankToVariable(op.subject), blankToVariable(op.predicate), blankToVariable(op.object), blankToVariable(op.graph)),\n                recurse: false,\n            };\n        },\n        'construct': (op) => {\n            // Blank nodes in CONSTRUCT templates must be maintained\n            return {\n                result: factory.createConstruct(translateBlankNodesToVariables(op.input, variables), op.template),\n                recurse: false,\n            };\n        },\n    });\n    function blankToVariable(term) {\n        if (term.termType === 'BlankNode') {\n            let variable = blankToVariableMapping[term.value];\n            if (!variable) {\n                variable = util_1.default.createUniqueVariable(term.value, variablesRaw, factory.dataFactory);\n                variablesRaw[variable.value] = true;\n                blankToVariableMapping[term.value] = variable;\n            }\n            return variable;\n        }\n        return term;\n    }\n}\n//# sourceMappingURL=sparqlAlgebra.js.map"]},"metadata":{},"sourceType":"script"}