{"ast":null,"code":"let AsyncIterator = require('asynciterator').AsyncIterator; // https://en.wikipedia.org/wiki/Symmetric_Hash_Join\n\n\nclass SymmetricHashJoin extends AsyncIterator {\n  constructor(left, right, funHash, funJoin) {\n    super();\n    this.left = left;\n    this.right = right;\n    this.funHash = funHash;\n    this.funJoin = funJoin;\n    this.usedLeft = false;\n    this.leftMap = new Map();\n    this.rightMap = new Map();\n    this.on('end', () => this._cleanup());\n    this.match = null;\n    this.matches = [];\n    this.matchIdx = 0;\n\n    if (this.left.readable || this.right.readable) {\n      this.readable = true;\n    }\n\n    this.left.on('readable', () => this.readable = true);\n    this.right.on('readable', () => this.readable = true); // this needs to be here since it's possible the left/right streams only get ended after there are no more results left\n\n    this.left.on('end', () => {\n      if (!this.hasResults()) this._end();\n    });\n    this.right.on('end', () => {\n      if (!this.hasResults()) this._end();\n    });\n  }\n\n  hasResults() {\n    // The \"!!this.match\" condition was added as a workaround to race\n    // conditions and/or duplicate \"end\" events that may lead to premature\n    // cleanups of the \"this.matches\" array.\n    // See https://github.com/joachimvh/asyncjoin/issues/7\n    return !this.left.ended || !this.right.ended || !!this.matches && this.matchIdx < this.matches.length;\n  }\n\n  _cleanup() {\n    // motivate garbage collector to remove these\n    this.leftMap = null;\n    this.rightMap = null;\n    this.matches = null;\n  }\n\n  close() {\n    super.close();\n    this.left.close();\n    this.right.close();\n  }\n\n  read() {\n    if (this.ended) return null;\n\n    while (this.matchIdx < this.matches.length) {\n      let item = this.matches[this.matchIdx++];\n      let result = this.usedLeft ? this.funJoin(this.match, item) : this.funJoin(item, this.match);\n      if (result !== null) return result;\n    }\n\n    if (!this.hasResults()) this._end();\n    let item = null; // try both streams if the first one has no value\n\n    for (let i = 0; i < 2; ++i) {\n      item = this.usedLeft ? this.right.read() : this.left.read();\n      this.usedLeft = !this.usedLeft; // try other stream next time\n      // found a result, no need to check the other stream this run\n\n      if (item !== null) break;\n    }\n\n    if (item === null) {\n      this.readable = false;\n      return null;\n    }\n\n    let hash = this.funHash(item);\n    let map = this.usedLeft ? this.leftMap : this.rightMap;\n    if (!map.has(hash)) map.set(hash, []);\n    let arr = map.get(hash);\n    arr.push(item);\n    this.match = item;\n    this.matches = (this.usedLeft ? this.rightMap : this.leftMap).get(hash) || [];\n    this.matchIdx = 0; // array is filled again so recursive call can have results\n\n    return this.read();\n  }\n\n}\n\nmodule.exports = SymmetricHashJoin;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/asyncjoin/join/SymmetricHashJoin.js"],"names":["AsyncIterator","require","SymmetricHashJoin","constructor","left","right","funHash","funJoin","usedLeft","leftMap","Map","rightMap","on","_cleanup","match","matches","matchIdx","readable","hasResults","_end","ended","length","close","read","item","result","i","hash","map","has","set","arr","get","push","module","exports"],"mappings":"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","sourcesContent":["\nlet AsyncIterator = require('asynciterator').AsyncIterator;\n\n// https://en.wikipedia.org/wiki/Symmetric_Hash_Join\nclass SymmetricHashJoin extends AsyncIterator\n{\n    constructor (left, right, funHash, funJoin)\n    {\n        super();\n        \n        this.left  = left;\n        this.right = right;\n        \n        this.funHash = funHash;\n        this.funJoin = funJoin;\n    \n        this.usedLeft = false;\n        this.leftMap  = new Map();\n        this.rightMap = new Map();\n        \n        this.on('end', () => this._cleanup() );\n        \n        this.match    = null;\n        this.matches  = [];\n        this.matchIdx = 0;\n\n        if (this.left.readable || this.right.readable)\n        {\n            this.readable = true;\n        }\n        \n        this.left.on('readable', () => this.readable = true);\n        this.right.on('readable', () => this.readable = true);\n        \n        // this needs to be here since it's possible the left/right streams only get ended after there are no more results left\n        this.left.on ('end', () => { if (!this.hasResults()) this._end(); });\n        this.right.on('end', () => { if (!this.hasResults()) this._end(); });\n    }\n    \n    hasResults()\n    {\n        // The \"!!this.match\" condition was added as a workaround to race\n        // conditions and/or duplicate \"end\" events that may lead to premature\n        // cleanups of the \"this.matches\" array.\n        // See https://github.com/joachimvh/asyncjoin/issues/7\n        return !this.left.ended  || !this.right.ended || (!!this.matches && this.matchIdx < this.matches.length);\n    }\n    \n    _cleanup ()\n    {\n        // motivate garbage collector to remove these\n        this.leftMap = null;\n        this.rightMap = null;\n        this.matches = null;\n    }\n    \n    close ()\n    {\n        super.close();\n        this.left.close();\n        this.right.close();\n    }\n    \n    read ()\n    {\n        if (this.ended)\n            return null;\n        \n        while (this.matchIdx < this.matches.length)\n        {\n            let item = this.matches[this.matchIdx++];\n            let result = this.usedLeft ? this.funJoin(this.match, item) : this.funJoin(item, this.match);\n            if (result !== null)\n                return result;\n        }\n        \n        if (!this.hasResults())\n            this._end();\n        \n        let item = null;\n        // try both streams if the first one has no value\n        for (let i = 0; i < 2; ++i)\n        {\n            item = this.usedLeft ? this.right.read() : this.left.read();\n            this.usedLeft = !this.usedLeft; // try other stream next time\n            \n            // found a result, no need to check the other stream this run\n            if (item !== null)\n                break;\n        }\n        \n        if (item === null)\n        {\n            this.readable = false;\n            return null;\n        }\n        \n        let hash = this.funHash(item);\n        let map = this.usedLeft ? this.leftMap : this.rightMap;\n        if (!map.has(hash))\n            map.set(hash, []);\n        let arr = map.get(hash);\n        arr.push(item);\n    \n        this.match = item;\n        this.matches = (this.usedLeft ? this.rightMap : this.leftMap).get(hash) || [];\n        this.matchIdx = 0;\n        \n        // array is filled again so recursive call can have results\n        return this.read();\n    }\n}\n\nmodule.exports = SymmetricHashJoin;"]},"metadata":{},"sourceType":"script"}