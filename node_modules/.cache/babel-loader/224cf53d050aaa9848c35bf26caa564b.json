{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeHandlerDefinitionOperation = void 0;\n\nconst NodeHandlerDefinitionAdapter_1 = require(\"./NodeHandlerDefinitionAdapter\");\n/**\n * Converts GraphQL definitions to joined operations for all its selections.\n */\n\n\nclass NodeHandlerDefinitionOperation extends NodeHandlerDefinitionAdapter_1.NodeHandlerDefinitionAdapter {\n  constructor(util, settings) {\n    super('OperationDefinition', util, settings);\n  }\n\n  handle(operationDefinition, convertContext) {\n    if (operationDefinition.operation !== 'query') {\n      throw new Error('Unsupported definition operation: ' + operationDefinition.operation);\n    } // We ignore the query name, as SPARQL doesn't support naming queries.\n    // Variables\n\n\n    if (operationDefinition.variableDefinitions) {\n      for (const variableDefinition of operationDefinition.variableDefinitions) {\n        const name = variableDefinition.variable.name.value; // Put the default value in the context if it hasn't been defined yet.\n\n        if (variableDefinition.defaultValue) {\n          if (!convertContext.variablesDict[name]) {\n            convertContext.variablesDict[name] = variableDefinition.defaultValue;\n          }\n        } // Handle type\n\n\n        let typeNode = variableDefinition.type;\n        const mandatory = typeNode.kind === 'NonNullType';\n\n        if (mandatory) {\n          typeNode = typeNode.type;\n        }\n\n        const list = typeNode.kind === 'ListType';\n\n        if (list) {\n          typeNode = typeNode.type;\n        }\n\n        const type = typeNode.name.value;\n        convertContext.variablesMetaDict[name] = {\n          mandatory,\n          list,\n          type\n        };\n      }\n    } // Directives\n\n\n    const directiveOutputs = this.getDirectiveOutputs(operationDefinition.directives, operationDefinition.name ? operationDefinition.name.value : '', convertContext);\n\n    if (!directiveOutputs) {\n      return this.util.operationFactory.createBgp([]);\n    } // Handle the operation\n\n\n    const operation = this.util.joinOperations(operationDefinition.selectionSet.selections.map(selectionNode => this.util.handleNode(selectionNode, convertContext))); // Override operation if needed\n\n    return this.handleDirectiveOutputs(directiveOutputs, operation);\n  }\n\n}\n\nexports.NodeHandlerDefinitionOperation = NodeHandlerDefinitionOperation;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/graphql-to-sparql/lib/handler/NodeHandlerDefinitionOperation.js"],"names":["Object","defineProperty","exports","value","NodeHandlerDefinitionOperation","NodeHandlerDefinitionAdapter_1","require","NodeHandlerDefinitionAdapter","constructor","util","settings","handle","operationDefinition","convertContext","operation","Error","variableDefinitions","variableDefinition","name","variable","defaultValue","variablesDict","typeNode","type","mandatory","kind","list","variablesMetaDict","directiveOutputs","getDirectiveOutputs","directives","operationFactory","createBgp","joinOperations","selectionSet","selections","map","selectionNode","handleNode","handleDirectiveOutputs"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,8BAAR,GAAyC,KAAK,CAA9C;;AACA,MAAMC,8BAA8B,GAAGC,OAAO,CAAC,gCAAD,CAA9C;AACA;AACA;AACA;;;AACA,MAAMF,8BAAN,SAA6CC,8BAA8B,CAACE,4BAA5E,CAAyG;AACrGC,EAAAA,WAAW,CAACC,IAAD,EAAOC,QAAP,EAAiB;AACxB,UAAM,qBAAN,EAA6BD,IAA7B,EAAmCC,QAAnC;AACH;;AACDC,EAAAA,MAAM,CAACC,mBAAD,EAAsBC,cAAtB,EAAsC;AACxC,QAAID,mBAAmB,CAACE,SAApB,KAAkC,OAAtC,EAA+C;AAC3C,YAAM,IAAIC,KAAJ,CAAU,uCAAuCH,mBAAmB,CAACE,SAArE,CAAN;AACH,KAHuC,CAIxC;AACA;;;AACA,QAAIF,mBAAmB,CAACI,mBAAxB,EAA6C;AACzC,WAAK,MAAMC,kBAAX,IAAiCL,mBAAmB,CAACI,mBAArD,EAA0E;AACtE,cAAME,IAAI,GAAGD,kBAAkB,CAACE,QAAnB,CAA4BD,IAA5B,CAAiCf,KAA9C,CADsE,CAEtE;;AACA,YAAIc,kBAAkB,CAACG,YAAvB,EAAqC;AACjC,cAAI,CAACP,cAAc,CAACQ,aAAf,CAA6BH,IAA7B,CAAL,EAAyC;AACrCL,YAAAA,cAAc,CAACQ,aAAf,CAA6BH,IAA7B,IAAqCD,kBAAkB,CAACG,YAAxD;AACH;AACJ,SAPqE,CAQtE;;;AACA,YAAIE,QAAQ,GAAGL,kBAAkB,CAACM,IAAlC;AACA,cAAMC,SAAS,GAAGF,QAAQ,CAACG,IAAT,KAAkB,aAApC;;AACA,YAAID,SAAJ,EAAe;AACXF,UAAAA,QAAQ,GAAGA,QAAQ,CAACC,IAApB;AACH;;AACD,cAAMG,IAAI,GAAGJ,QAAQ,CAACG,IAAT,KAAkB,UAA/B;;AACA,YAAIC,IAAJ,EAAU;AACNJ,UAAAA,QAAQ,GAAGA,QAAQ,CAACC,IAApB;AACH;;AACD,cAAMA,IAAI,GAAGD,QAAQ,CAACJ,IAAT,CAAcf,KAA3B;AACAU,QAAAA,cAAc,CAACc,iBAAf,CAAiCT,IAAjC,IAAyC;AAAEM,UAAAA,SAAF;AAAaE,UAAAA,IAAb;AAAmBH,UAAAA;AAAnB,SAAzC;AACH;AACJ,KA5BuC,CA6BxC;;;AACA,UAAMK,gBAAgB,GAAG,KAAKC,mBAAL,CAAyBjB,mBAAmB,CAACkB,UAA7C,EAAyDlB,mBAAmB,CAACM,IAApB,GAA2BN,mBAAmB,CAACM,IAApB,CAAyBf,KAApD,GAA4D,EAArH,EAAyHU,cAAzH,CAAzB;;AACA,QAAI,CAACe,gBAAL,EAAuB;AACnB,aAAO,KAAKnB,IAAL,CAAUsB,gBAAV,CAA2BC,SAA3B,CAAqC,EAArC,CAAP;AACH,KAjCuC,CAkCxC;;;AACA,UAAMlB,SAAS,GAAG,KAAKL,IAAL,CAAUwB,cAAV,CAAyBrB,mBAAmB,CAACsB,YAApB,CAAiCC,UAAjC,CACtCC,GADsC,CACjCC,aAAD,IAAmB,KAAK5B,IAAL,CAAU6B,UAAV,CAAqBD,aAArB,EAAoCxB,cAApC,CADe,CAAzB,CAAlB,CAnCwC,CAqCxC;;AACA,WAAO,KAAK0B,sBAAL,CAA4BX,gBAA5B,EAA8Cd,SAA9C,CAAP;AACH;;AA3CoG;;AA6CzGZ,OAAO,CAACE,8BAAR,GAAyCA,8BAAzC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NodeHandlerDefinitionOperation = void 0;\nconst NodeHandlerDefinitionAdapter_1 = require(\"./NodeHandlerDefinitionAdapter\");\n/**\n * Converts GraphQL definitions to joined operations for all its selections.\n */\nclass NodeHandlerDefinitionOperation extends NodeHandlerDefinitionAdapter_1.NodeHandlerDefinitionAdapter {\n    constructor(util, settings) {\n        super('OperationDefinition', util, settings);\n    }\n    handle(operationDefinition, convertContext) {\n        if (operationDefinition.operation !== 'query') {\n            throw new Error('Unsupported definition operation: ' + operationDefinition.operation);\n        }\n        // We ignore the query name, as SPARQL doesn't support naming queries.\n        // Variables\n        if (operationDefinition.variableDefinitions) {\n            for (const variableDefinition of operationDefinition.variableDefinitions) {\n                const name = variableDefinition.variable.name.value;\n                // Put the default value in the context if it hasn't been defined yet.\n                if (variableDefinition.defaultValue) {\n                    if (!convertContext.variablesDict[name]) {\n                        convertContext.variablesDict[name] = variableDefinition.defaultValue;\n                    }\n                }\n                // Handle type\n                let typeNode = variableDefinition.type;\n                const mandatory = typeNode.kind === 'NonNullType';\n                if (mandatory) {\n                    typeNode = typeNode.type;\n                }\n                const list = typeNode.kind === 'ListType';\n                if (list) {\n                    typeNode = typeNode.type;\n                }\n                const type = typeNode.name.value;\n                convertContext.variablesMetaDict[name] = { mandatory, list, type };\n            }\n        }\n        // Directives\n        const directiveOutputs = this.getDirectiveOutputs(operationDefinition.directives, operationDefinition.name ? operationDefinition.name.value : '', convertContext);\n        if (!directiveOutputs) {\n            return this.util.operationFactory.createBgp([]);\n        }\n        // Handle the operation\n        const operation = this.util.joinOperations(operationDefinition.selectionSet.selections\n            .map((selectionNode) => this.util.handleNode(selectionNode, convertContext)));\n        // Override operation if needed\n        return this.handleDirectiveOutputs(directiveOutputs, operation);\n    }\n}\nexports.NodeHandlerDefinitionOperation = NodeHandlerDefinitionOperation;\n//# sourceMappingURL=NodeHandlerDefinitionOperation.js.map"]},"metadata":{},"sourceType":"script"}