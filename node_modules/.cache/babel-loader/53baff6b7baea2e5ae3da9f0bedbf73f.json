{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MicrodataRdfParser = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst htmlparser2_1 = require(\"htmlparser2\");\n\nconst ItemPropertyHandlerContent_1 = require(\"./propertyhandler/ItemPropertyHandlerContent\");\n\nconst ItemPropertyHandlerNumber_1 = require(\"./propertyhandler/ItemPropertyHandlerNumber\");\n\nconst ItemPropertyHandlerTime_1 = require(\"./propertyhandler/ItemPropertyHandlerTime\");\n\nconst ItemPropertyHandlerUrl_1 = require(\"./propertyhandler/ItemPropertyHandlerUrl\");\n\nconst Util_1 = require(\"./Util\");\n\nconst VOCAB_REGISTRY_DEFAULT = require(\"./vocab-registry-default.json\");\n/**\n * A stream transformer that parses Microdata (text) streams to an {@link RDF.Stream}.\n */\n\n\nclass MicrodataRdfParser extends stream_1.Transform {\n  constructor(options) {\n    super({\n      readableObjectMode: true\n    }); // Stacks, where the key is the current depth.\n\n    this.itemScopeStack = [];\n    this.textBufferStack = []; // Variables for managing itemrefs.\n\n    this.isEmittingReferences = false;\n    this.pendingItemRefsDomain = {};\n    this.pendingItemRefsRangeFinalized = {}; // eslint-disable-next-line lines-between-class-members\n\n    this.pendingItemRefsRangeCollecting = {};\n    options = options || {};\n    this.options = options;\n    this.util = new Util_1.Util(options.dataFactory, options.baseIRI);\n    this.defaultGraph = options.defaultGraph || this.util.dataFactory.defaultGraph();\n    this.htmlParseListener = options.htmlParseListener;\n    this.vocabRegistry = options.vocabRegistry || VOCAB_REGISTRY_DEFAULT;\n    this.parser = this.initializeParser(!!options.xmlMode);\n  }\n  /**\n   * Parses the given text stream into a quad stream.\n   * @param {NodeJS.EventEmitter} stream A text stream.\n   * @return {RDF.Stream} A quad stream.\n   */\n\n\n  import(stream) {\n    const output = new stream_1.PassThrough({\n      readableObjectMode: true\n    });\n    stream.on('error', error => parsed.emit('error', error));\n    stream.on('data', data => output.push(data));\n    stream.on('end', () => output.push(null));\n    const parsed = output.pipe(new MicrodataRdfParser(this.options));\n    return parsed;\n  }\n\n  _transform(chunk, encoding, callback) {\n    this.parser.write(chunk);\n    callback();\n  }\n\n  _flush(callback) {\n    this.parser.end();\n    callback();\n  }\n  /**\n   * Get the current item scope for the current depth.\n   * This will skip all undefined item scopes.\n   * @param parent If we should start looking one level higher in the stack.\n   */\n\n\n  getItemScope(parent) {\n    let parentTagI = this.itemScopeStack.length - (parent ? 2 : 1);\n\n    while (parentTagI > 0 && !this.itemScopeStack[parentTagI]) {\n      parentTagI--;\n    }\n\n    return this.itemScopeStack[parentTagI];\n  }\n  /**\n   * Get the current stack depth.\n   */\n\n\n  getDepth() {\n    return this.itemScopeStack.length;\n  }\n\n  onTagOpen(name, attributes) {\n    if (!this.isEmittingReferences) {\n      // If the tag has an 'id', start collecting the whole stack in the item reference buffer\n      if ('id' in attributes) {\n        const id = attributes.id;\n        this.pendingItemRefsRangeCollecting[id] = {\n          events: [],\n          counter: 0,\n          ids: []\n        };\n      } // Store this event in all collecting item reference buffers\n\n\n      for (const buffer of Object.values(this.pendingItemRefsRangeCollecting)) {\n        buffer.counter++;\n        buffer.events.push({\n          type: 'open',\n          name,\n          attributes\n        });\n      }\n    } // Ensure the text buffer stack is in line with the stack depth\n    // eslint-disable-next-line unicorn/no-useless-undefined\n\n\n    this.textBufferStack.push(undefined); // Processing steps based on https://w3c.github.io/microdata-rdf/#rdf-conversion-algorithm\n    // 1. Determine the current item scope\n\n    let itemScope;\n\n    if ('itemscope' in attributes) {\n      // Create a new item scope\n      let subject;\n\n      if (this.emittingReferencesItemScopeIdGenerator) {\n        subject = this.emittingReferencesItemScopeIdGenerator();\n      } else {\n        subject = 'itemid' in attributes && this.util.createSubject(attributes.itemid) || this.util.dataFactory.blankNode(); // Store the genererated id in all collecting item reference buffers\n\n        for (const buffer of Object.values(this.pendingItemRefsRangeCollecting)) {\n          buffer.ids.push(subject);\n        }\n      }\n\n      itemScope = {\n        subject\n      }; // If the id was reused from a reference, block any new triples to be generated from it\n\n      if (this.isEmittingReferences) {\n        itemScope.blockEmission = true;\n      } // Inherit vocab from parent item scope\n\n\n      const parentItemScope = this.getItemScope();\n\n      if (parentItemScope && parentItemScope.vocab) {\n        itemScope.vocab = parentItemScope.vocab;\n      } // 2. Push any changes to the item scope to the stack\n\n\n      this.itemScopeStack.push(itemScope);\n    } else {\n      // Determine the parent item scope\n      itemScope = this.getItemScope(); // 2. Push any changes to the item scope to the stack\n      // eslint-disable-next-line unicorn/no-useless-undefined\n\n      this.itemScopeStack.push(undefined);\n    } // If we have a valid item scope, process the current node\n\n\n    if (itemScope) {\n      // 3. Handle item types\n      if ('itemtype' in attributes) {\n        for (const type of this.util.createVocabIris(attributes.itemtype, itemScope, false)) {\n          // 4. Vocab identifier is the first valid item\n          if (!itemScope.vocab) {\n            // 5. Modify vocab based on registry\n            itemScope.vocab = this.util.deriveVocab(type.value, this.vocabRegistry);\n          } // Emit item type\n\n\n          if (!itemScope.blockEmission) {\n            this.emitTriple(itemScope.subject, this.util.dataFactory.namedNode(`${Util_1.Util.RDF}type`), type);\n          }\n        }\n      } // Save language in item scope\n\n\n      if ('lang' in attributes) {\n        itemScope.language = attributes.lang;\n      }\n\n      if ('xml:lang' in attributes) {\n        itemScope.language = attributes['xml:lang'];\n      } // Handle itemrefs (only if we also had an itemscope)\n\n\n      if ('itemscope' in attributes) {\n        // If we have an itemref, store it in our domain buffer.\n        if (!this.isEmittingReferences && 'itemref' in attributes) {\n          for (const reference of attributes.itemref.split(/\\s+/u)) {\n            if (!(reference in this.pendingItemRefsDomain)) {\n              this.pendingItemRefsDomain[reference] = [];\n            }\n\n            this.pendingItemRefsDomain[reference].push(itemScope);\n            this.tryToEmitReferences(reference, itemScope);\n          }\n        }\n      }\n    } // 6. Handle item properties\n\n\n    if ('itemprop' in attributes) {\n      this.handleItemProperties(attributes.itemprop, false, itemScope, name, attributes);\n    } // Handle reverse item properties\n    // https://w3c.github.io/microdata-rdf/#reverse-itemprop\n\n\n    if ('itemprop-reverse' in attributes) {\n      this.handleItemProperties(attributes['itemprop-reverse'], true, itemScope, name, attributes);\n    }\n  }\n\n  onText(data) {\n    // Store this event in all collecting item reference buffers\n    if (!this.isEmittingReferences) {\n      for (const buffer of Object.values(this.pendingItemRefsRangeCollecting)) {\n        buffer.events.push({\n          type: 'text',\n          data\n        });\n      }\n    } // Save the text inside all item scopes that need to collect text\n\n\n    for (const textBuffer of this.textBufferStack) {\n      if (textBuffer) {\n        textBuffer.push(data);\n      }\n    }\n  }\n\n  onTagClose() {\n    // Store this event in all collecting item reference buffers\n    if (!this.isEmittingReferences) {\n      for (const [reference, buffer] of Object.entries(this.pendingItemRefsRangeCollecting)) {\n        buffer.counter--;\n        buffer.events.push({\n          type: 'close'\n        }); // Once the counter becomes zero, the tag is fully buffered, so we finalize it.\n\n        if (buffer.counter === 0) {\n          this.pendingItemRefsRangeFinalized[reference] = buffer;\n          delete this.pendingItemRefsRangeCollecting[reference]; // Try to emit this reference with buffered domain items\n\n          this.tryToEmitReferences(reference);\n        }\n      }\n    } // Emit all triples that were determined in the active tag\n\n\n    const itemScope = this.getItemScope(true);\n\n    if (itemScope) {\n      const depth = this.getDepth();\n\n      if (itemScope.predicates && depth in itemScope.predicates) {\n        for (const [predicateKey, predicates] of Object.entries(itemScope.predicates[depth])) {\n          // First check if we have a child item scope, otherwise get the text content\n          // Safely cast textBufferStack, as it is always defined when itemScope.predicates is defined.\n          const object = this.util.createLiteral(this.textBufferStack[depth].join(''), itemScope);\n          this.emitPredicateTriples(itemScope, predicates, object, predicateKey === 'reverse');\n          delete itemScope.predicates[depth][predicateKey];\n        }\n      }\n    } // Remove the active tag from the stack\n\n\n    this.itemScopeStack.pop();\n    this.textBufferStack.pop();\n  }\n\n  onEnd() {// Nothing important should happen here.\n  }\n  /**\n   * Initialize a new HtmlParser.\n   * @param xmlMode If the parser should be setup in strict mode.\n   */\n\n\n  initializeParser(xmlMode) {\n    return new htmlparser2_1.Parser({\n      onclosetag: () => {\n        try {\n          this.onTagClose();\n\n          if (this.htmlParseListener) {\n            this.htmlParseListener.onTagClose();\n          }\n        } catch (error) {\n          this.emit('error', error);\n        }\n      },\n      onend: () => {\n        try {\n          this.onEnd();\n\n          if (this.htmlParseListener) {\n            this.htmlParseListener.onEnd();\n          }\n        } catch (error) {\n          this.emit('error', error);\n        }\n      },\n      onopentag: (name, attributes) => {\n        try {\n          this.onTagOpen(name, attributes);\n\n          if (this.htmlParseListener) {\n            this.htmlParseListener.onTagOpen(name, attributes);\n          }\n        } catch (error) {\n          this.emit('error', error);\n        }\n      },\n      ontext: data => {\n        try {\n          this.onText(data);\n\n          if (this.htmlParseListener) {\n            this.htmlParseListener.onText(data);\n          }\n        } catch (error) {\n          this.emit('error', error);\n        }\n      }\n    }, {\n      decodeEntities: true,\n      recognizeSelfClosing: true,\n      xmlMode\n    });\n  }\n  /**\n   * Handle the given item properties.\n   * @param itempropValue The value of itemprop or itemprop-reverse.\n   * @param reverse If the item properties are reversed (itemprop-reverse).\n   * @param itemScope The current item scope.\n   * @param tagName The current tag name.\n   * @param tagAttributes The current tag attributes.\n   */\n\n\n  handleItemProperties(itempropValue, reverse, itemScope, tagName, tagAttributes) {\n    const parentItemScope = this.getItemScope(true);\n\n    if (parentItemScope) {\n      // Set predicates in the scope, and handle them on tag close.\n      const depth = this.getDepth();\n      const predicates = this.util.createVocabIris(itempropValue, parentItemScope, true);\n\n      if (!parentItemScope.predicates) {\n        parentItemScope.predicates = {};\n      }\n\n      if (!parentItemScope.predicates[depth]) {\n        parentItemScope.predicates[depth] = {};\n      }\n\n      const predicatesKey = reverse ? 'reverse' : 'forward';\n      parentItemScope.predicates[depth][predicatesKey] = predicates; // Append rdf:type predicate if vocabulary expansion applies\n\n      for (const vocabularyExpansionType of this.util.getVocabularyExpansionType(itempropValue, parentItemScope, this.vocabRegistry)) {\n        predicates.push(vocabularyExpansionType);\n      } // Check if a property handler that applies, forcefully use that as predicate value.\n      // But DON'T call handlers in this prop is a direct (nested) itemscope.\n\n\n      if (itemScope && 'itemscope' in tagAttributes) {\n        this.emitPredicateTriples(parentItemScope, predicates, itemScope.subject, reverse); // Finalize the predicates, so text values do not apply to them.\n\n        delete parentItemScope.predicates[depth][predicatesKey];\n      } else {\n        for (const handler of MicrodataRdfParser.ITEM_PROPERTY_HANDLERS) {\n          if (handler.canHandle(tagName, tagAttributes)) {\n            const object = handler.getObject(tagAttributes, this.util, parentItemScope);\n            this.emitPredicateTriples(parentItemScope, predicates, object, reverse); // Finalize the predicates, so text values do not apply to them.\n\n            delete parentItemScope.predicates[depth][predicatesKey];\n          }\n        }\n      } // If no valid handler was found, indicate that we should collect text at this depth.\n\n\n      if (parentItemScope.predicates[depth][predicatesKey]) {\n        this.textBufferStack[depth] = [];\n      }\n    }\n  }\n  /**\n   * Emit the given object for the given predicates.\n   * @param itemScope The current item scope.\n   * @param predicates An array of predicates.\n   * @param object An object.\n   * @param reverse If the triples should be reversed.\n   */\n\n\n  emitPredicateTriples(itemScope, predicates, object, reverse) {\n    if (!itemScope.blockEmission) {\n      for (const predicate of predicates) {\n        if (reverse) {\n          // Literals can not exist in subject position, so they must be ignored.\n          if (object.termType !== 'Literal') {\n            this.emitTriple(object, predicate, itemScope.subject);\n          }\n        } else {\n          this.emitTriple(itemScope.subject, predicate, object);\n        }\n      }\n    }\n  }\n  /**\n   * Emit the given triple to the stream.\n   * @param {Quad_Subject} subject A subject term.\n   * @param {Quad_Predicate} predicate A predicate term.\n   * @param {Quad_Object} object An object term.\n   */\n\n\n  emitTriple(subject, predicate, object) {\n    this.push(this.util.dataFactory.quad(subject, predicate, object, this.defaultGraph));\n  }\n  /**\n   * Attempt to emit all pending itemrefs for the given reference.\n   * @param reference An item reference id.\n   * @param itemScopeDomain An optional item scope. If defined, only refs from this scope will be emitted.\n   */\n\n\n  tryToEmitReferences(reference, itemScopeDomain) {\n    const range = this.pendingItemRefsRangeFinalized[reference];\n\n    if (range) {\n      // Determine the item scope domains to emit\n      let applicableItemScopes;\n\n      if (itemScopeDomain) {\n        applicableItemScopes = [itemScopeDomain]; // Remove the item from the pending array\n        // Element is guaranteed to exist in buffer\n\n        const itemScopeDomainIndex = this.pendingItemRefsDomain[reference].indexOf(itemScopeDomain);\n        this.pendingItemRefsDomain[reference].splice(itemScopeDomainIndex, 1);\n      } else {\n        applicableItemScopes = this.pendingItemRefsDomain[reference]; // Remove all items from the pending array\n\n        delete this.pendingItemRefsDomain[reference];\n      }\n\n      if (applicableItemScopes) {\n        // Save the stack state\n        const itemScopeStackOld = this.itemScopeStack;\n        const textBufferStackOld = this.textBufferStack;\n        this.isEmittingReferences = true; // For all applicable item scopes, emit the buffered events.\n\n        for (const itemScope of applicableItemScopes) {\n          this.itemScopeStack = [itemScope];\n          this.textBufferStack = [undefined];\n          const pendingIds = range.ids.slice();\n\n          this.emittingReferencesItemScopeIdGenerator = () => pendingIds.shift();\n\n          for (const event of range.events) {\n            switch (event.type) {\n              case 'open':\n                this.onTagOpen(event.name, event.attributes);\n                break;\n\n              case 'text':\n                this.onText(event.data);\n                break;\n\n              case 'close':\n                this.onTagClose();\n                break;\n            }\n          }\n        } // Restore the stack state\n\n\n        this.emittingReferencesItemScopeIdGenerator = undefined;\n        this.itemScopeStack = itemScopeStackOld;\n        this.textBufferStack = textBufferStackOld;\n        this.isEmittingReferences = false;\n      }\n    }\n  }\n\n}\n\nexports.MicrodataRdfParser = MicrodataRdfParser;\nMicrodataRdfParser.ITEM_PROPERTY_HANDLERS = [new ItemPropertyHandlerContent_1.ItemPropertyHandlerContent(), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('a', 'href'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('area', 'href'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('audio', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('embed', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('iframe', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('img', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('link', 'href'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('object', 'data'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('source', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('track', 'src'), new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('video', 'src'), new ItemPropertyHandlerNumber_1.ItemPropertyHandlerNumber('data', 'value'), new ItemPropertyHandlerNumber_1.ItemPropertyHandlerNumber('meter', 'value'), new ItemPropertyHandlerTime_1.ItemPropertyHandlerTime()];","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/microdata-rdf-streaming-parser/lib/MicrodataRdfParser.js"],"names":["Object","defineProperty","exports","value","MicrodataRdfParser","stream_1","require","htmlparser2_1","ItemPropertyHandlerContent_1","ItemPropertyHandlerNumber_1","ItemPropertyHandlerTime_1","ItemPropertyHandlerUrl_1","Util_1","VOCAB_REGISTRY_DEFAULT","Transform","constructor","options","readableObjectMode","itemScopeStack","textBufferStack","isEmittingReferences","pendingItemRefsDomain","pendingItemRefsRangeFinalized","pendingItemRefsRangeCollecting","util","Util","dataFactory","baseIRI","defaultGraph","htmlParseListener","vocabRegistry","parser","initializeParser","xmlMode","import","stream","output","PassThrough","on","error","parsed","emit","data","push","pipe","_transform","chunk","encoding","callback","write","_flush","end","getItemScope","parent","parentTagI","length","getDepth","onTagOpen","name","attributes","id","events","counter","ids","buffer","values","type","undefined","itemScope","subject","emittingReferencesItemScopeIdGenerator","createSubject","itemid","blankNode","blockEmission","parentItemScope","vocab","createVocabIris","itemtype","deriveVocab","emitTriple","namedNode","RDF","language","lang","reference","itemref","split","tryToEmitReferences","handleItemProperties","itemprop","onText","textBuffer","onTagClose","entries","depth","predicates","predicateKey","object","createLiteral","join","emitPredicateTriples","pop","onEnd","Parser","onclosetag","onend","onopentag","ontext","decodeEntities","recognizeSelfClosing","itempropValue","reverse","tagName","tagAttributes","predicatesKey","vocabularyExpansionType","getVocabularyExpansionType","handler","ITEM_PROPERTY_HANDLERS","canHandle","getObject","predicate","termType","quad","itemScopeDomain","range","applicableItemScopes","itemScopeDomainIndex","indexOf","splice","itemScopeStackOld","textBufferStackOld","pendingIds","slice","shift","event","ItemPropertyHandlerContent","ItemPropertyHandlerUrl","ItemPropertyHandlerNumber","ItemPropertyHandlerTime"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MicrodataRdfParser = void 0;\nconst stream_1 = require(\"stream\");\nconst htmlparser2_1 = require(\"htmlparser2\");\nconst ItemPropertyHandlerContent_1 = require(\"./propertyhandler/ItemPropertyHandlerContent\");\nconst ItemPropertyHandlerNumber_1 = require(\"./propertyhandler/ItemPropertyHandlerNumber\");\nconst ItemPropertyHandlerTime_1 = require(\"./propertyhandler/ItemPropertyHandlerTime\");\nconst ItemPropertyHandlerUrl_1 = require(\"./propertyhandler/ItemPropertyHandlerUrl\");\nconst Util_1 = require(\"./Util\");\nconst VOCAB_REGISTRY_DEFAULT = require(\"./vocab-registry-default.json\");\n/**\n * A stream transformer that parses Microdata (text) streams to an {@link RDF.Stream}.\n */\nclass MicrodataRdfParser extends stream_1.Transform {\n    constructor(options) {\n        super({ readableObjectMode: true });\n        // Stacks, where the key is the current depth.\n        this.itemScopeStack = [];\n        this.textBufferStack = [];\n        // Variables for managing itemrefs.\n        this.isEmittingReferences = false;\n        this.pendingItemRefsDomain = {};\n        this.pendingItemRefsRangeFinalized = {};\n        // eslint-disable-next-line lines-between-class-members\n        this.pendingItemRefsRangeCollecting = {};\n        options = options || {};\n        this.options = options;\n        this.util = new Util_1.Util(options.dataFactory, options.baseIRI);\n        this.defaultGraph = options.defaultGraph || this.util.dataFactory.defaultGraph();\n        this.htmlParseListener = options.htmlParseListener;\n        this.vocabRegistry = options.vocabRegistry || VOCAB_REGISTRY_DEFAULT;\n        this.parser = this.initializeParser(!!options.xmlMode);\n    }\n    /**\n     * Parses the given text stream into a quad stream.\n     * @param {NodeJS.EventEmitter} stream A text stream.\n     * @return {RDF.Stream} A quad stream.\n     */\n    import(stream) {\n        const output = new stream_1.PassThrough({ readableObjectMode: true });\n        stream.on('error', (error) => parsed.emit('error', error));\n        stream.on('data', (data) => output.push(data));\n        stream.on('end', () => output.push(null));\n        const parsed = output.pipe(new MicrodataRdfParser(this.options));\n        return parsed;\n    }\n    _transform(chunk, encoding, callback) {\n        this.parser.write(chunk);\n        callback();\n    }\n    _flush(callback) {\n        this.parser.end();\n        callback();\n    }\n    /**\n     * Get the current item scope for the current depth.\n     * This will skip all undefined item scopes.\n     * @param parent If we should start looking one level higher in the stack.\n     */\n    getItemScope(parent) {\n        let parentTagI = this.itemScopeStack.length - (parent ? 2 : 1);\n        while (parentTagI > 0 && !this.itemScopeStack[parentTagI]) {\n            parentTagI--;\n        }\n        return this.itemScopeStack[parentTagI];\n    }\n    /**\n     * Get the current stack depth.\n     */\n    getDepth() {\n        return this.itemScopeStack.length;\n    }\n    onTagOpen(name, attributes) {\n        if (!this.isEmittingReferences) {\n            // If the tag has an 'id', start collecting the whole stack in the item reference buffer\n            if ('id' in attributes) {\n                const id = attributes.id;\n                this.pendingItemRefsRangeCollecting[id] = {\n                    events: [],\n                    counter: 0,\n                    ids: [],\n                };\n            }\n            // Store this event in all collecting item reference buffers\n            for (const buffer of Object.values(this.pendingItemRefsRangeCollecting)) {\n                buffer.counter++;\n                buffer.events.push({ type: 'open', name, attributes });\n            }\n        }\n        // Ensure the text buffer stack is in line with the stack depth\n        // eslint-disable-next-line unicorn/no-useless-undefined\n        this.textBufferStack.push(undefined);\n        // Processing steps based on https://w3c.github.io/microdata-rdf/#rdf-conversion-algorithm\n        // 1. Determine the current item scope\n        let itemScope;\n        if ('itemscope' in attributes) {\n            // Create a new item scope\n            let subject;\n            if (this.emittingReferencesItemScopeIdGenerator) {\n                subject = this.emittingReferencesItemScopeIdGenerator();\n            }\n            else {\n                subject = 'itemid' in attributes && this.util.createSubject(attributes.itemid) ||\n                    this.util.dataFactory.blankNode();\n                // Store the genererated id in all collecting item reference buffers\n                for (const buffer of Object.values(this.pendingItemRefsRangeCollecting)) {\n                    buffer.ids.push(subject);\n                }\n            }\n            itemScope = { subject };\n            // If the id was reused from a reference, block any new triples to be generated from it\n            if (this.isEmittingReferences) {\n                itemScope.blockEmission = true;\n            }\n            // Inherit vocab from parent item scope\n            const parentItemScope = this.getItemScope();\n            if (parentItemScope && parentItemScope.vocab) {\n                itemScope.vocab = parentItemScope.vocab;\n            }\n            // 2. Push any changes to the item scope to the stack\n            this.itemScopeStack.push(itemScope);\n        }\n        else {\n            // Determine the parent item scope\n            itemScope = this.getItemScope();\n            // 2. Push any changes to the item scope to the stack\n            // eslint-disable-next-line unicorn/no-useless-undefined\n            this.itemScopeStack.push(undefined);\n        }\n        // If we have a valid item scope, process the current node\n        if (itemScope) {\n            // 3. Handle item types\n            if ('itemtype' in attributes) {\n                for (const type of this.util.createVocabIris(attributes.itemtype, itemScope, false)) {\n                    // 4. Vocab identifier is the first valid item\n                    if (!itemScope.vocab) {\n                        // 5. Modify vocab based on registry\n                        itemScope.vocab = this.util.deriveVocab(type.value, this.vocabRegistry);\n                    }\n                    // Emit item type\n                    if (!itemScope.blockEmission) {\n                        this.emitTriple(itemScope.subject, this.util.dataFactory.namedNode(`${Util_1.Util.RDF}type`), type);\n                    }\n                }\n            }\n            // Save language in item scope\n            if ('lang' in attributes) {\n                itemScope.language = attributes.lang;\n            }\n            if ('xml:lang' in attributes) {\n                itemScope.language = attributes['xml:lang'];\n            }\n            // Handle itemrefs (only if we also had an itemscope)\n            if ('itemscope' in attributes) {\n                // If we have an itemref, store it in our domain buffer.\n                if (!this.isEmittingReferences && 'itemref' in attributes) {\n                    for (const reference of attributes.itemref.split(/\\s+/u)) {\n                        if (!(reference in this.pendingItemRefsDomain)) {\n                            this.pendingItemRefsDomain[reference] = [];\n                        }\n                        this.pendingItemRefsDomain[reference].push(itemScope);\n                        this.tryToEmitReferences(reference, itemScope);\n                    }\n                }\n            }\n        }\n        // 6. Handle item properties\n        if ('itemprop' in attributes) {\n            this.handleItemProperties(attributes.itemprop, false, itemScope, name, attributes);\n        }\n        // Handle reverse item properties\n        // https://w3c.github.io/microdata-rdf/#reverse-itemprop\n        if ('itemprop-reverse' in attributes) {\n            this.handleItemProperties(attributes['itemprop-reverse'], true, itemScope, name, attributes);\n        }\n    }\n    onText(data) {\n        // Store this event in all collecting item reference buffers\n        if (!this.isEmittingReferences) {\n            for (const buffer of Object.values(this.pendingItemRefsRangeCollecting)) {\n                buffer.events.push({ type: 'text', data });\n            }\n        }\n        // Save the text inside all item scopes that need to collect text\n        for (const textBuffer of this.textBufferStack) {\n            if (textBuffer) {\n                textBuffer.push(data);\n            }\n        }\n    }\n    onTagClose() {\n        // Store this event in all collecting item reference buffers\n        if (!this.isEmittingReferences) {\n            for (const [reference, buffer] of Object.entries(this.pendingItemRefsRangeCollecting)) {\n                buffer.counter--;\n                buffer.events.push({ type: 'close' });\n                // Once the counter becomes zero, the tag is fully buffered, so we finalize it.\n                if (buffer.counter === 0) {\n                    this.pendingItemRefsRangeFinalized[reference] = buffer;\n                    delete this.pendingItemRefsRangeCollecting[reference];\n                    // Try to emit this reference with buffered domain items\n                    this.tryToEmitReferences(reference);\n                }\n            }\n        }\n        // Emit all triples that were determined in the active tag\n        const itemScope = this.getItemScope(true);\n        if (itemScope) {\n            const depth = this.getDepth();\n            if (itemScope.predicates && depth in itemScope.predicates) {\n                for (const [predicateKey, predicates] of Object.entries(itemScope.predicates[depth])) {\n                    // First check if we have a child item scope, otherwise get the text content\n                    // Safely cast textBufferStack, as it is always defined when itemScope.predicates is defined.\n                    const object = this.util.createLiteral(this.textBufferStack[depth].join(''), itemScope);\n                    this.emitPredicateTriples(itemScope, predicates, object, predicateKey === 'reverse');\n                    delete itemScope.predicates[depth][predicateKey];\n                }\n            }\n        }\n        // Remove the active tag from the stack\n        this.itemScopeStack.pop();\n        this.textBufferStack.pop();\n    }\n    onEnd() {\n        // Nothing important should happen here.\n    }\n    /**\n     * Initialize a new HtmlParser.\n     * @param xmlMode If the parser should be setup in strict mode.\n     */\n    initializeParser(xmlMode) {\n        return new htmlparser2_1.Parser({\n            onclosetag: () => {\n                try {\n                    this.onTagClose();\n                    if (this.htmlParseListener) {\n                        this.htmlParseListener.onTagClose();\n                    }\n                }\n                catch (error) {\n                    this.emit('error', error);\n                }\n            },\n            onend: () => {\n                try {\n                    this.onEnd();\n                    if (this.htmlParseListener) {\n                        this.htmlParseListener.onEnd();\n                    }\n                }\n                catch (error) {\n                    this.emit('error', error);\n                }\n            },\n            onopentag: (name, attributes) => {\n                try {\n                    this.onTagOpen(name, attributes);\n                    if (this.htmlParseListener) {\n                        this.htmlParseListener.onTagOpen(name, attributes);\n                    }\n                }\n                catch (error) {\n                    this.emit('error', error);\n                }\n            },\n            ontext: (data) => {\n                try {\n                    this.onText(data);\n                    if (this.htmlParseListener) {\n                        this.htmlParseListener.onText(data);\n                    }\n                }\n                catch (error) {\n                    this.emit('error', error);\n                }\n            },\n        }, {\n            decodeEntities: true,\n            recognizeSelfClosing: true,\n            xmlMode,\n        });\n    }\n    /**\n     * Handle the given item properties.\n     * @param itempropValue The value of itemprop or itemprop-reverse.\n     * @param reverse If the item properties are reversed (itemprop-reverse).\n     * @param itemScope The current item scope.\n     * @param tagName The current tag name.\n     * @param tagAttributes The current tag attributes.\n     */\n    handleItemProperties(itempropValue, reverse, itemScope, tagName, tagAttributes) {\n        const parentItemScope = this.getItemScope(true);\n        if (parentItemScope) {\n            // Set predicates in the scope, and handle them on tag close.\n            const depth = this.getDepth();\n            const predicates = this.util.createVocabIris(itempropValue, parentItemScope, true);\n            if (!parentItemScope.predicates) {\n                parentItemScope.predicates = {};\n            }\n            if (!parentItemScope.predicates[depth]) {\n                parentItemScope.predicates[depth] = {};\n            }\n            const predicatesKey = reverse ? 'reverse' : 'forward';\n            parentItemScope.predicates[depth][predicatesKey] = predicates;\n            // Append rdf:type predicate if vocabulary expansion applies\n            for (const vocabularyExpansionType of this.util.getVocabularyExpansionType(itempropValue, parentItemScope, this.vocabRegistry)) {\n                predicates.push(vocabularyExpansionType);\n            }\n            // Check if a property handler that applies, forcefully use that as predicate value.\n            // But DON'T call handlers in this prop is a direct (nested) itemscope.\n            if (itemScope && 'itemscope' in tagAttributes) {\n                this.emitPredicateTriples(parentItemScope, predicates, itemScope.subject, reverse);\n                // Finalize the predicates, so text values do not apply to them.\n                delete parentItemScope.predicates[depth][predicatesKey];\n            }\n            else {\n                for (const handler of MicrodataRdfParser.ITEM_PROPERTY_HANDLERS) {\n                    if (handler.canHandle(tagName, tagAttributes)) {\n                        const object = handler.getObject(tagAttributes, this.util, parentItemScope);\n                        this.emitPredicateTriples(parentItemScope, predicates, object, reverse);\n                        // Finalize the predicates, so text values do not apply to them.\n                        delete parentItemScope.predicates[depth][predicatesKey];\n                    }\n                }\n            }\n            // If no valid handler was found, indicate that we should collect text at this depth.\n            if (parentItemScope.predicates[depth][predicatesKey]) {\n                this.textBufferStack[depth] = [];\n            }\n        }\n    }\n    /**\n     * Emit the given object for the given predicates.\n     * @param itemScope The current item scope.\n     * @param predicates An array of predicates.\n     * @param object An object.\n     * @param reverse If the triples should be reversed.\n     */\n    emitPredicateTriples(itemScope, predicates, object, reverse) {\n        if (!itemScope.blockEmission) {\n            for (const predicate of predicates) {\n                if (reverse) {\n                    // Literals can not exist in subject position, so they must be ignored.\n                    if (object.termType !== 'Literal') {\n                        this.emitTriple(object, predicate, itemScope.subject);\n                    }\n                }\n                else {\n                    this.emitTriple(itemScope.subject, predicate, object);\n                }\n            }\n        }\n    }\n    /**\n     * Emit the given triple to the stream.\n     * @param {Quad_Subject} subject A subject term.\n     * @param {Quad_Predicate} predicate A predicate term.\n     * @param {Quad_Object} object An object term.\n     */\n    emitTriple(subject, predicate, object) {\n        this.push(this.util.dataFactory.quad(subject, predicate, object, this.defaultGraph));\n    }\n    /**\n     * Attempt to emit all pending itemrefs for the given reference.\n     * @param reference An item reference id.\n     * @param itemScopeDomain An optional item scope. If defined, only refs from this scope will be emitted.\n     */\n    tryToEmitReferences(reference, itemScopeDomain) {\n        const range = this.pendingItemRefsRangeFinalized[reference];\n        if (range) {\n            // Determine the item scope domains to emit\n            let applicableItemScopes;\n            if (itemScopeDomain) {\n                applicableItemScopes = [itemScopeDomain];\n                // Remove the item from the pending array\n                // Element is guaranteed to exist in buffer\n                const itemScopeDomainIndex = this.pendingItemRefsDomain[reference].indexOf(itemScopeDomain);\n                this.pendingItemRefsDomain[reference].splice(itemScopeDomainIndex, 1);\n            }\n            else {\n                applicableItemScopes = this.pendingItemRefsDomain[reference];\n                // Remove all items from the pending array\n                delete this.pendingItemRefsDomain[reference];\n            }\n            if (applicableItemScopes) {\n                // Save the stack state\n                const itemScopeStackOld = this.itemScopeStack;\n                const textBufferStackOld = this.textBufferStack;\n                this.isEmittingReferences = true;\n                // For all applicable item scopes, emit the buffered events.\n                for (const itemScope of applicableItemScopes) {\n                    this.itemScopeStack = [itemScope];\n                    this.textBufferStack = [undefined];\n                    const pendingIds = range.ids.slice();\n                    this.emittingReferencesItemScopeIdGenerator = () => pendingIds.shift();\n                    for (const event of range.events) {\n                        switch (event.type) {\n                            case 'open':\n                                this.onTagOpen(event.name, event.attributes);\n                                break;\n                            case 'text':\n                                this.onText(event.data);\n                                break;\n                            case 'close':\n                                this.onTagClose();\n                                break;\n                        }\n                    }\n                }\n                // Restore the stack state\n                this.emittingReferencesItemScopeIdGenerator = undefined;\n                this.itemScopeStack = itemScopeStackOld;\n                this.textBufferStack = textBufferStackOld;\n                this.isEmittingReferences = false;\n            }\n        }\n    }\n}\nexports.MicrodataRdfParser = MicrodataRdfParser;\nMicrodataRdfParser.ITEM_PROPERTY_HANDLERS = [\n    new ItemPropertyHandlerContent_1.ItemPropertyHandlerContent(),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('a', 'href'),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('area', 'href'),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('audio', 'src'),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('embed', 'src'),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('iframe', 'src'),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('img', 'src'),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('link', 'href'),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('object', 'data'),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('source', 'src'),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('track', 'src'),\n    new ItemPropertyHandlerUrl_1.ItemPropertyHandlerUrl('video', 'src'),\n    new ItemPropertyHandlerNumber_1.ItemPropertyHandlerNumber('data', 'value'),\n    new ItemPropertyHandlerNumber_1.ItemPropertyHandlerNumber('meter', 'value'),\n    new ItemPropertyHandlerTime_1.ItemPropertyHandlerTime(),\n];\n//# sourceMappingURL=MicrodataRdfParser.js.map"]},"metadata":{},"sourceType":"script"}