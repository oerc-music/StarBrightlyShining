{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonLdSerializer = void 0;\n\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\n\nconst stream_1 = require(\"stream\");\n\nconst SeparatorType_1 = require(\"./SeparatorType\");\n\nconst Util_1 = require(\"./Util\");\n/**\n * A stream transformer that transforms an {@link RDF.Stream} into a JSON-LD (text) stream.\n */\n\n\nclass JsonLdSerializer extends stream_1.Transform {\n  constructor(options = {}) {\n    super({\n      objectMode: true\n    });\n    this.indentation = 0;\n    this.options = options; // Parse the context\n\n    if (this.options.baseIRI && !this.options.context) {\n      this.options.context = {\n        '@base': this.options.baseIRI\n      };\n    }\n\n    if (this.options.context) {\n      this.originalContext = this.options.context;\n      this.context = new jsonld_context_parser_1.ContextParser().parse(this.options.context, {\n        baseIRI: this.options.baseIRI\n      });\n    } else {\n      this.context = Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized({}));\n    }\n  }\n  /**\n   * Parses the given text stream into a quad stream.\n   * @param {NodeJS.EventEmitter} stream A text stream.\n   * @return {NodeJS.EventEmitter} A quad stream.\n   */\n\n\n  import(stream) {\n    const output = new stream_1.PassThrough({\n      objectMode: true\n    });\n    stream.on('error', error => parsed.emit('error', error));\n    stream.on('data', data => output.push(data));\n    stream.on('end', () => output.push(null));\n    const parsed = output.pipe(new JsonLdSerializer(this.options));\n    return parsed;\n  }\n  /**\n   * Transforms a quad into the text stream.\n   * @param {Quad} quad An RDF quad.\n   * @param {string} encoding An (ignored) encoding.\n   * @param {module:stream.internal.TransformCallback} callback Callback that is invoked when the transformation is done\n   * @private\n   */\n\n\n  _transform(quad, encoding, callback) {\n    this.context.then(context => {\n      this.transformQuad(quad, context);\n      callback();\n    }).catch(callback);\n  }\n  /**\n   * Construct a list in an RDF.Term object that can be used\n   * inside a quad's object to write into the serializer\n   * as a list using the @list keyword.\n   * @param {RDF.Quad_Object[]} values A list of values, can be empty.\n   * @return {RDF.Quad_Object} A term that should be used in the object position of the quad that is written to the serializer.\n   */\n\n\n  async list(values) {\n    const context = await this.context;\n    return {\n      '@list': values.map(value => Util_1.Util.termToValue(value, context, this.options))\n    };\n  }\n  /**\n   * Claled when the incoming stream is closed.\n   * @param {module:stream.internal.TransformCallback} callback Callback that is invoked when the flushing is done.\n   * @private\n   */\n\n\n  _flush(callback) {\n    // If the stream was empty, ensure that we push the opening array\n    if (!this.opened) {\n      this.pushDocumentStart();\n    }\n\n    if (this.lastPredicate) {\n      this.endPredicate();\n    }\n\n    if (this.lastSubject) {\n      this.endSubject();\n    }\n\n    if (this.lastGraph && this.lastGraph.termType !== 'DefaultGraph') {\n      this.endGraph();\n    }\n\n    this.endDocument();\n    return callback(null, null);\n  }\n  /**\n   * Transforms a quad into the text stream.\n   * @param {Quad} quad An RDF quad.\n   * @param {JsonLdContextNormalized} context A context for compacting.\n   */\n\n\n  transformQuad(quad, context) {\n    // Open the array before the first quad\n    if (!this.opened) {\n      this.pushDocumentStart();\n    } // Check if the subject equals the last named graph\n    // In that case, we can reuse the already-existing @id node\n\n\n    const lastGraphMatchesSubject = this.lastGraph && this.lastGraph.termType !== 'DefaultGraph' && this.lastGraph.equals(quad.subject); // Write graph\n\n    if (!lastGraphMatchesSubject && (!this.lastGraph || !quad.graph.equals(this.lastGraph))) {\n      // Check if the named graph equals the last subject\n      // In that case, we can reuse the already-existing @id node\n      let lastSubjectMatchesGraph = quad.graph.termType !== 'DefaultGraph' && this.lastSubject && this.lastSubject.equals(quad.graph);\n\n      if (this.lastGraph) {\n        if (this.lastGraph.termType !== 'DefaultGraph') {\n          // The last graph was named\n          this.endPredicate();\n          this.endSubject();\n          this.endGraph(true);\n          lastSubjectMatchesGraph = false; // Special-case to avoid deeper nesting\n        } else {\n          // The last graph was default\n          if (!lastSubjectMatchesGraph) {\n            this.endPredicate();\n            this.endSubject(true);\n          } else {\n            this.endPredicate(true);\n            this.lastSubject = null;\n          }\n        }\n      } // Push the graph\n\n\n      if (quad.graph.termType !== 'DefaultGraph') {\n        if (!lastSubjectMatchesGraph) {\n          this.pushId(quad.graph, context);\n        }\n\n        this.pushSeparator(this.options.space ? SeparatorType_1.SeparatorType.GRAPH_FIELD_NONCOMPACT : SeparatorType_1.SeparatorType.GRAPH_FIELD_COMPACT);\n        this.indentation++;\n      }\n\n      this.lastGraph = quad.graph;\n    } // Write subject\n\n\n    if (!this.lastSubject || !quad.subject.equals(this.lastSubject)) {\n      if (lastGraphMatchesSubject) {\n        this.endPredicate();\n        this.endSubject();\n        this.indentation--;\n        this.pushSeparator(SeparatorType_1.SeparatorType.ARRAY_END_COMMA);\n        this.lastGraph = quad.graph;\n      } else {\n        if (this.lastSubject) {\n          this.endPredicate();\n          this.endSubject(true);\n        } // Open a new node for the new subject\n\n\n        this.pushId(quad.subject, context);\n      }\n\n      this.lastSubject = quad.subject;\n    } // Write predicate\n\n\n    if (!this.lastPredicate || !quad.predicate.equals(this.lastPredicate)) {\n      if (this.lastPredicate) {\n        this.endPredicate(true);\n      } // Open a new array for the new predicate\n\n\n      this.pushPredicate(quad.predicate, context);\n    } // Write the object value\n\n\n    this.pushObject(quad.object, context);\n  }\n\n  pushDocumentStart() {\n    this.opened = true;\n\n    if (this.originalContext && !this.options.excludeContext) {\n      this.pushSeparator(SeparatorType_1.SeparatorType.OBJECT_START);\n      this.indentation++;\n      this.pushSeparator(SeparatorType_1.SeparatorType.CONTEXT_FIELD);\n      this.pushIndented(JSON.stringify(this.originalContext, null, this.options.space) + ',');\n      this.pushSeparator(this.options.space ? SeparatorType_1.SeparatorType.GRAPH_FIELD_NONCOMPACT : SeparatorType_1.SeparatorType.GRAPH_FIELD_COMPACT);\n      this.indentation++;\n    } else {\n      this.pushSeparator(SeparatorType_1.SeparatorType.ARRAY_START);\n      this.indentation++;\n    }\n  }\n  /**\n   * Push the given term as an @id field.\n   * @param {Term} term An RDF term.\n   * @param {JsonLdContextNormalized} context The context.\n   */\n\n\n  pushId(term, context) {\n    const subjectValue = term.termType === 'BlankNode' ? '_:' + term.value : context.compactIri(term.value, false);\n    this.pushSeparator(SeparatorType_1.SeparatorType.OBJECT_START);\n    this.indentation++;\n    this.pushIndented(this.options.space ? `\"@id\": \"${subjectValue}\",` : `\"@id\":\"${subjectValue}\",`);\n  }\n  /**\n   * Push the given predicate field.\n   * @param {Term} predicate An RDF term.\n   * @param {JsonLdContextNormalized} context The context.\n   */\n\n\n  pushPredicate(predicate, context) {\n    let property = predicate.value; // Convert rdf:type into @type if not disabled.\n\n    if (!this.options.useRdfType && property === Util_1.Util.RDF_TYPE) {\n      property = '@type';\n      this.objectOptions = Object.assign(Object.assign({}, this.options), {\n        compactIds: true,\n        vocab: true\n      });\n    } // Open array for following objects\n\n\n    const compactedProperty = context.compactIri(property, true);\n    this.pushIndented(this.options.space ? `\"${compactedProperty}\": [` : `\"${compactedProperty}\":[`);\n    this.indentation++;\n    this.lastPredicate = predicate;\n  }\n  /**\n   * Push the given object value.\n   * @param {Term} object An RDF term.\n   * @param {JsonLdContextNormalized} context The context.\n   */\n\n\n  pushObject(object, context) {\n    // Add a comma if we already had an object for this predicate\n    if (!this.hadObjectForPredicate) {\n      this.hadObjectForPredicate = true;\n    } else {\n      this.pushSeparator(SeparatorType_1.SeparatorType.COMMA);\n    } // Convert the object into a value and push it\n\n\n    let value;\n\n    try {\n      if (object['@list']) {\n        value = object;\n      } else {\n        value = Util_1.Util.termToValue(object, context, this.objectOptions || this.options);\n      }\n    } catch (e) {\n      return this.emit('error', e);\n    }\n\n    this.pushIndented(JSON.stringify(value, null, this.options.space));\n  }\n\n  endDocument() {\n    this.opened = false;\n\n    if (this.originalContext && !this.options.excludeContext) {\n      this.indentation--;\n      this.pushSeparator(SeparatorType_1.SeparatorType.ARRAY_END);\n      this.indentation--;\n      this.pushSeparator(SeparatorType_1.SeparatorType.OBJECT_END);\n    } else {\n      this.indentation--;\n      this.pushSeparator(SeparatorType_1.SeparatorType.ARRAY_END);\n    }\n  }\n  /**\n   * Push the end of a predicate and reset the buffers.\n   * @param {boolean} comma If a comma should be appended.\n   */\n\n\n  endPredicate(comma) {\n    // Close the predicate array\n    this.indentation--;\n    this.pushSeparator(comma ? SeparatorType_1.SeparatorType.ARRAY_END_COMMA : SeparatorType_1.SeparatorType.ARRAY_END); // Reset object buffer\n\n    this.hadObjectForPredicate = false;\n    this.objectOptions = null; // Reset predicate buffer\n\n    this.lastPredicate = null;\n  }\n  /**\n   * Push the end of a subject and reset the buffers.\n   * @param {boolean} comma If a comma should be appended.\n   */\n\n\n  endSubject(comma) {\n    // Close the last subject's node;\n    this.indentation--;\n    this.pushSeparator(comma ? SeparatorType_1.SeparatorType.OBJECT_END_COMMA : SeparatorType_1.SeparatorType.OBJECT_END); // Reset subject buffer\n\n    this.lastSubject = null;\n  }\n  /**\n   * Push the end of a graph and reset the buffers.\n   * @param {boolean} comma If a comma should be appended.\n   */\n\n\n  endGraph(comma) {\n    // Close the graph array\n    this.indentation--;\n    this.pushSeparator(SeparatorType_1.SeparatorType.ARRAY_END); // Close the graph id node\n\n    this.indentation--;\n    this.pushSeparator(comma ? SeparatorType_1.SeparatorType.OBJECT_END_COMMA : SeparatorType_1.SeparatorType.OBJECT_END); // Reset graph buffer\n\n    this.lastGraph = null;\n  }\n  /**\n   * Puh the given separator.\n   * @param {SeparatorType} type A type of separator.\n   */\n\n\n  pushSeparator(type) {\n    this.pushIndented(type.label);\n  }\n  /**\n   * An indentation-aware variant of {@link #push}.\n   * All strings that are pushed here will be prefixed by {@link #indentation} amount of spaces.\n   * @param {string} data A string.\n   */\n\n\n  pushIndented(data) {\n    const prefix = this.getIndentPrefix();\n    const lines = data.split('\\n').map(line => prefix + line).join('\\n');\n    this.push(lines);\n\n    if (this.options.space) {\n      this.push('\\n');\n    }\n  }\n  /**\n   * @return {string} Get the current indentation prefix based on {@link #indentation}.\n   */\n\n\n  getIndentPrefix() {\n    return this.options.space ? this.options.space.repeat(this.indentation) : '';\n  }\n\n}\n\nexports.JsonLdSerializer = JsonLdSerializer;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/jsonld-streaming-serializer/lib/JsonLdSerializer.js"],"names":["Object","defineProperty","exports","value","JsonLdSerializer","jsonld_context_parser_1","require","stream_1","SeparatorType_1","Util_1","Transform","constructor","options","objectMode","indentation","baseIRI","context","originalContext","ContextParser","parse","Promise","resolve","JsonLdContextNormalized","import","stream","output","PassThrough","on","error","parsed","emit","data","push","pipe","_transform","quad","encoding","callback","then","transformQuad","catch","list","values","map","Util","termToValue","_flush","opened","pushDocumentStart","lastPredicate","endPredicate","lastSubject","endSubject","lastGraph","termType","endGraph","endDocument","lastGraphMatchesSubject","equals","subject","graph","lastSubjectMatchesGraph","pushId","pushSeparator","space","SeparatorType","GRAPH_FIELD_NONCOMPACT","GRAPH_FIELD_COMPACT","ARRAY_END_COMMA","predicate","pushPredicate","pushObject","object","excludeContext","OBJECT_START","CONTEXT_FIELD","pushIndented","JSON","stringify","ARRAY_START","term","subjectValue","compactIri","property","useRdfType","RDF_TYPE","objectOptions","assign","compactIds","vocab","compactedProperty","hadObjectForPredicate","COMMA","e","ARRAY_END","OBJECT_END","comma","OBJECT_END_COMMA","type","label","prefix","getIndentPrefix","lines","split","line","join","repeat"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,gBAAR,GAA2B,KAAK,CAAhC;;AACA,MAAMC,uBAAuB,GAAGC,OAAO,CAAC,uBAAD,CAAvC;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAME,eAAe,GAAGF,OAAO,CAAC,iBAAD,CAA/B;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB;AACA;AACA;AACA;;;AACA,MAAMF,gBAAN,SAA+BG,QAAQ,CAACG,SAAxC,CAAkD;AAC9CC,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AACtB,UAAM;AAAEC,MAAAA,UAAU,EAAE;AAAd,KAAN;AACA,SAAKC,WAAL,GAAmB,CAAnB;AACA,SAAKF,OAAL,GAAeA,OAAf,CAHsB,CAItB;;AACA,QAAI,KAAKA,OAAL,CAAaG,OAAb,IAAwB,CAAC,KAAKH,OAAL,CAAaI,OAA1C,EAAmD;AAC/C,WAAKJ,OAAL,CAAaI,OAAb,GAAuB;AAAE,iBAAS,KAAKJ,OAAL,CAAaG;AAAxB,OAAvB;AACH;;AACD,QAAI,KAAKH,OAAL,CAAaI,OAAjB,EAA0B;AACtB,WAAKC,eAAL,GAAuB,KAAKL,OAAL,CAAaI,OAApC;AACA,WAAKA,OAAL,GAAe,IAAIX,uBAAuB,CAACa,aAA5B,GAA4CC,KAA5C,CAAkD,KAAKP,OAAL,CAAaI,OAA/D,EAAwE;AAAED,QAAAA,OAAO,EAAE,KAAKH,OAAL,CAAaG;AAAxB,OAAxE,CAAf;AACH,KAHD,MAIK;AACD,WAAKC,OAAL,GAAeI,OAAO,CAACC,OAAR,CAAgB,IAAIhB,uBAAuB,CAACiB,uBAA5B,CAAoD,EAApD,CAAhB,CAAf;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,MAAM,CAACC,MAAD,EAAS;AACX,UAAMC,MAAM,GAAG,IAAIlB,QAAQ,CAACmB,WAAb,CAAyB;AAAEb,MAAAA,UAAU,EAAE;AAAd,KAAzB,CAAf;AACAW,IAAAA,MAAM,CAACG,EAAP,CAAU,OAAV,EAAoBC,KAAD,IAAWC,MAAM,CAACC,IAAP,CAAY,OAAZ,EAAqBF,KAArB,CAA9B;AACAJ,IAAAA,MAAM,CAACG,EAAP,CAAU,MAAV,EAAmBI,IAAD,IAAUN,MAAM,CAACO,IAAP,CAAYD,IAAZ,CAA5B;AACAP,IAAAA,MAAM,CAACG,EAAP,CAAU,KAAV,EAAiB,MAAMF,MAAM,CAACO,IAAP,CAAY,IAAZ,CAAvB;AACA,UAAMH,MAAM,GAAGJ,MAAM,CAACQ,IAAP,CAAY,IAAI7B,gBAAJ,CAAqB,KAAKQ,OAA1B,CAAZ,CAAf;AACA,WAAOiB,MAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIK,EAAAA,UAAU,CAACC,IAAD,EAAOC,QAAP,EAAiBC,QAAjB,EAA2B;AACjC,SAAKrB,OAAL,CAAasB,IAAb,CAAmBtB,OAAD,IAAa;AAC3B,WAAKuB,aAAL,CAAmBJ,IAAnB,EAAyBnB,OAAzB;AACAqB,MAAAA,QAAQ;AACX,KAHD,EAGGG,KAHH,CAGSH,QAHT;AAIH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACc,QAAJI,IAAI,CAACC,MAAD,EAAS;AACf,UAAM1B,OAAO,GAAG,MAAM,KAAKA,OAA3B;AACA,WAAO;AACH,eAAS0B,MAAM,CAACC,GAAP,CAAYxC,KAAD,IAAWM,MAAM,CAACmC,IAAP,CAAYC,WAAZ,CAAwB1C,KAAxB,EAA+Ba,OAA/B,EAAwC,KAAKJ,OAA7C,CAAtB;AADN,KAAP;AAGH;AACD;AACJ;AACA;AACA;AACA;;;AACIkC,EAAAA,MAAM,CAACT,QAAD,EAAW;AACb;AACA,QAAI,CAAC,KAAKU,MAAV,EAAkB;AACd,WAAKC,iBAAL;AACH;;AACD,QAAI,KAAKC,aAAT,EAAwB;AACpB,WAAKC,YAAL;AACH;;AACD,QAAI,KAAKC,WAAT,EAAsB;AAClB,WAAKC,UAAL;AACH;;AACD,QAAI,KAAKC,SAAL,IAAkB,KAAKA,SAAL,CAAeC,QAAf,KAA4B,cAAlD,EAAkE;AAC9D,WAAKC,QAAL;AACH;;AACD,SAAKC,WAAL;AACA,WAAOnB,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAf;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIE,EAAAA,aAAa,CAACJ,IAAD,EAAOnB,OAAP,EAAgB;AACzB;AACA,QAAI,CAAC,KAAK+B,MAAV,EAAkB;AACd,WAAKC,iBAAL;AACH,KAJwB,CAKzB;AACA;;;AACA,UAAMS,uBAAuB,GAAG,KAAKJ,SAAL,IAAkB,KAAKA,SAAL,CAAeC,QAAf,KAA4B,cAA9C,IACzB,KAAKD,SAAL,CAAeK,MAAf,CAAsBvB,IAAI,CAACwB,OAA3B,CADP,CAPyB,CASzB;;AACA,QAAI,CAACF,uBAAD,KAA6B,CAAC,KAAKJ,SAAN,IAAmB,CAAClB,IAAI,CAACyB,KAAL,CAAWF,MAAX,CAAkB,KAAKL,SAAvB,CAAjD,CAAJ,EAAyF;AACrF;AACA;AACA,UAAIQ,uBAAuB,GAAG1B,IAAI,CAACyB,KAAL,CAAWN,QAAX,KAAwB,cAAxB,IACvB,KAAKH,WADkB,IACH,KAAKA,WAAL,CAAiBO,MAAjB,CAAwBvB,IAAI,CAACyB,KAA7B,CAD3B;;AAEA,UAAI,KAAKP,SAAT,EAAoB;AAChB,YAAI,KAAKA,SAAL,CAAeC,QAAf,KAA4B,cAAhC,EAAgD;AAC5C;AACA,eAAKJ,YAAL;AACA,eAAKE,UAAL;AACA,eAAKG,QAAL,CAAc,IAAd;AACAM,UAAAA,uBAAuB,GAAG,KAA1B,CAL4C,CAKX;AACpC,SAND,MAOK;AACD;AACA,cAAI,CAACA,uBAAL,EAA8B;AAC1B,iBAAKX,YAAL;AACA,iBAAKE,UAAL,CAAgB,IAAhB;AACH,WAHD,MAIK;AACD,iBAAKF,YAAL,CAAkB,IAAlB;AACA,iBAAKC,WAAL,GAAmB,IAAnB;AACH;AACJ;AACJ,OAxBoF,CAyBrF;;;AACA,UAAIhB,IAAI,CAACyB,KAAL,CAAWN,QAAX,KAAwB,cAA5B,EAA4C;AACxC,YAAI,CAACO,uBAAL,EAA8B;AAC1B,eAAKC,MAAL,CAAY3B,IAAI,CAACyB,KAAjB,EAAwB5C,OAAxB;AACH;;AACD,aAAK+C,aAAL,CAAmB,KAAKnD,OAAL,CAAaoD,KAAb,GACbxD,eAAe,CAACyD,aAAhB,CAA8BC,sBADjB,GAC0C1D,eAAe,CAACyD,aAAhB,CAA8BE,mBAD3F;AAEA,aAAKrD,WAAL;AACH;;AACD,WAAKuC,SAAL,GAAiBlB,IAAI,CAACyB,KAAtB;AACH,KA7CwB,CA8CzB;;;AACA,QAAI,CAAC,KAAKT,WAAN,IAAqB,CAAChB,IAAI,CAACwB,OAAL,CAAaD,MAAb,CAAoB,KAAKP,WAAzB,CAA1B,EAAiE;AAC7D,UAAIM,uBAAJ,EAA6B;AACzB,aAAKP,YAAL;AACA,aAAKE,UAAL;AACA,aAAKtC,WAAL;AACA,aAAKiD,aAAL,CAAmBvD,eAAe,CAACyD,aAAhB,CAA8BG,eAAjD;AACA,aAAKf,SAAL,GAAiBlB,IAAI,CAACyB,KAAtB;AACH,OAND,MAOK;AACD,YAAI,KAAKT,WAAT,EAAsB;AAClB,eAAKD,YAAL;AACA,eAAKE,UAAL,CAAgB,IAAhB;AACH,SAJA,CAKD;;;AACA,aAAKU,MAAL,CAAY3B,IAAI,CAACwB,OAAjB,EAA0B3C,OAA1B;AACH;;AACD,WAAKmC,WAAL,GAAmBhB,IAAI,CAACwB,OAAxB;AACH,KAhEwB,CAiEzB;;;AACA,QAAI,CAAC,KAAKV,aAAN,IAAuB,CAACd,IAAI,CAACkC,SAAL,CAAeX,MAAf,CAAsB,KAAKT,aAA3B,CAA5B,EAAuE;AACnE,UAAI,KAAKA,aAAT,EAAwB;AACpB,aAAKC,YAAL,CAAkB,IAAlB;AACH,OAHkE,CAInE;;;AACA,WAAKoB,aAAL,CAAmBnC,IAAI,CAACkC,SAAxB,EAAmCrD,OAAnC;AACH,KAxEwB,CAyEzB;;;AACA,SAAKuD,UAAL,CAAgBpC,IAAI,CAACqC,MAArB,EAA6BxD,OAA7B;AACH;;AACDgC,EAAAA,iBAAiB,GAAG;AAChB,SAAKD,MAAL,GAAc,IAAd;;AACA,QAAI,KAAK9B,eAAL,IAAwB,CAAC,KAAKL,OAAL,CAAa6D,cAA1C,EAA0D;AACtD,WAAKV,aAAL,CAAmBvD,eAAe,CAACyD,aAAhB,CAA8BS,YAAjD;AACA,WAAK5D,WAAL;AACA,WAAKiD,aAAL,CAAmBvD,eAAe,CAACyD,aAAhB,CAA8BU,aAAjD;AACA,WAAKC,YAAL,CAAkBC,IAAI,CAACC,SAAL,CAAe,KAAK7D,eAApB,EAAqC,IAArC,EAA2C,KAAKL,OAAL,CAAaoD,KAAxD,IAAiE,GAAnF;AACA,WAAKD,aAAL,CAAmB,KAAKnD,OAAL,CAAaoD,KAAb,GACbxD,eAAe,CAACyD,aAAhB,CAA8BC,sBADjB,GAC0C1D,eAAe,CAACyD,aAAhB,CAA8BE,mBAD3F;AAEA,WAAKrD,WAAL;AACH,KARD,MASK;AACD,WAAKiD,aAAL,CAAmBvD,eAAe,CAACyD,aAAhB,CAA8Bc,WAAjD;AACA,WAAKjE,WAAL;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACIgD,EAAAA,MAAM,CAACkB,IAAD,EAAOhE,OAAP,EAAgB;AAClB,UAAMiE,YAAY,GAAGD,IAAI,CAAC1B,QAAL,KAAkB,WAAlB,GACf,OAAO0B,IAAI,CAAC7E,KADG,GACKa,OAAO,CAACkE,UAAR,CAAmBF,IAAI,CAAC7E,KAAxB,EAA+B,KAA/B,CAD1B;AAEA,SAAK4D,aAAL,CAAmBvD,eAAe,CAACyD,aAAhB,CAA8BS,YAAjD;AACA,SAAK5D,WAAL;AACA,SAAK8D,YAAL,CAAkB,KAAKhE,OAAL,CAAaoD,KAAb,GAAsB,WAAUiB,YAAa,IAA7C,GAAoD,UAASA,YAAa,IAA5F;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIX,EAAAA,aAAa,CAACD,SAAD,EAAYrD,OAAZ,EAAqB;AAC9B,QAAImE,QAAQ,GAAGd,SAAS,CAAClE,KAAzB,CAD8B,CAE9B;;AACA,QAAI,CAAC,KAAKS,OAAL,CAAawE,UAAd,IAA4BD,QAAQ,KAAK1E,MAAM,CAACmC,IAAP,CAAYyC,QAAzD,EAAmE;AAC/DF,MAAAA,QAAQ,GAAG,OAAX;AACA,WAAKG,aAAL,GAAqBtF,MAAM,CAACuF,MAAP,CAAcvF,MAAM,CAACuF,MAAP,CAAc,EAAd,EAAkB,KAAK3E,OAAvB,CAAd,EAA+C;AAAE4E,QAAAA,UAAU,EAAE,IAAd;AAAoBC,QAAAA,KAAK,EAAE;AAA3B,OAA/C,CAArB;AACH,KAN6B,CAO9B;;;AACA,UAAMC,iBAAiB,GAAG1E,OAAO,CAACkE,UAAR,CAAmBC,QAAnB,EAA6B,IAA7B,CAA1B;AACA,SAAKP,YAAL,CAAkB,KAAKhE,OAAL,CAAaoD,KAAb,GAAsB,IAAG0B,iBAAkB,MAA3C,GAAoD,IAAGA,iBAAkB,KAA3F;AACA,SAAK5E,WAAL;AACA,SAAKmC,aAAL,GAAqBoB,SAArB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIE,EAAAA,UAAU,CAACC,MAAD,EAASxD,OAAT,EAAkB;AACxB;AACA,QAAI,CAAC,KAAK2E,qBAAV,EAAiC;AAC7B,WAAKA,qBAAL,GAA6B,IAA7B;AACH,KAFD,MAGK;AACD,WAAK5B,aAAL,CAAmBvD,eAAe,CAACyD,aAAhB,CAA8B2B,KAAjD;AACH,KAPuB,CAQxB;;;AACA,QAAIzF,KAAJ;;AACA,QAAI;AACA,UAAIqE,MAAM,CAAC,OAAD,CAAV,EAAqB;AACjBrE,QAAAA,KAAK,GAAGqE,MAAR;AACH,OAFD,MAGK;AACDrE,QAAAA,KAAK,GAAGM,MAAM,CAACmC,IAAP,CAAYC,WAAZ,CAAwB2B,MAAxB,EAAgCxD,OAAhC,EAAyC,KAAKsE,aAAL,IAAsB,KAAK1E,OAApE,CAAR;AACH;AACJ,KAPD,CAQA,OAAOiF,CAAP,EAAU;AACN,aAAO,KAAK/D,IAAL,CAAU,OAAV,EAAmB+D,CAAnB,CAAP;AACH;;AACD,SAAKjB,YAAL,CAAkBC,IAAI,CAACC,SAAL,CAAe3E,KAAf,EAAsB,IAAtB,EAA4B,KAAKS,OAAL,CAAaoD,KAAzC,CAAlB;AACH;;AACDR,EAAAA,WAAW,GAAG;AACV,SAAKT,MAAL,GAAc,KAAd;;AACA,QAAI,KAAK9B,eAAL,IAAwB,CAAC,KAAKL,OAAL,CAAa6D,cAA1C,EAA0D;AACtD,WAAK3D,WAAL;AACA,WAAKiD,aAAL,CAAmBvD,eAAe,CAACyD,aAAhB,CAA8B6B,SAAjD;AACA,WAAKhF,WAAL;AACA,WAAKiD,aAAL,CAAmBvD,eAAe,CAACyD,aAAhB,CAA8B8B,UAAjD;AACH,KALD,MAMK;AACD,WAAKjF,WAAL;AACA,WAAKiD,aAAL,CAAmBvD,eAAe,CAACyD,aAAhB,CAA8B6B,SAAjD;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACI5C,EAAAA,YAAY,CAAC8C,KAAD,EAAQ;AAChB;AACA,SAAKlF,WAAL;AACA,SAAKiD,aAAL,CAAmBiC,KAAK,GAAGxF,eAAe,CAACyD,aAAhB,CAA8BG,eAAjC,GAAmD5D,eAAe,CAACyD,aAAhB,CAA8B6B,SAAzG,EAHgB,CAIhB;;AACA,SAAKH,qBAAL,GAA6B,KAA7B;AACA,SAAKL,aAAL,GAAqB,IAArB,CANgB,CAOhB;;AACA,SAAKrC,aAAL,GAAqB,IAArB;AACH;AACD;AACJ;AACA;AACA;;;AACIG,EAAAA,UAAU,CAAC4C,KAAD,EAAQ;AACd;AACA,SAAKlF,WAAL;AACA,SAAKiD,aAAL,CAAmBiC,KAAK,GAAGxF,eAAe,CAACyD,aAAhB,CAA8BgC,gBAAjC,GAAoDzF,eAAe,CAACyD,aAAhB,CAA8B8B,UAA1G,EAHc,CAId;;AACA,SAAK5C,WAAL,GAAmB,IAAnB;AACH;AACD;AACJ;AACA;AACA;;;AACII,EAAAA,QAAQ,CAACyC,KAAD,EAAQ;AACZ;AACA,SAAKlF,WAAL;AACA,SAAKiD,aAAL,CAAmBvD,eAAe,CAACyD,aAAhB,CAA8B6B,SAAjD,EAHY,CAIZ;;AACA,SAAKhF,WAAL;AACA,SAAKiD,aAAL,CAAmBiC,KAAK,GAAGxF,eAAe,CAACyD,aAAhB,CAA8BgC,gBAAjC,GAAoDzF,eAAe,CAACyD,aAAhB,CAA8B8B,UAA1G,EANY,CAOZ;;AACA,SAAK1C,SAAL,GAAiB,IAAjB;AACH;AACD;AACJ;AACA;AACA;;;AACIU,EAAAA,aAAa,CAACmC,IAAD,EAAO;AAChB,SAAKtB,YAAL,CAAkBsB,IAAI,CAACC,KAAvB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIvB,EAAAA,YAAY,CAAC7C,IAAD,EAAO;AACf,UAAMqE,MAAM,GAAG,KAAKC,eAAL,EAAf;AACA,UAAMC,KAAK,GAAGvE,IAAI,CAACwE,KAAL,CAAW,IAAX,EAAiB5D,GAAjB,CAAsB6D,IAAD,IAAUJ,MAAM,GAAGI,IAAxC,EAA8CC,IAA9C,CAAmD,IAAnD,CAAd;AACA,SAAKzE,IAAL,CAAUsE,KAAV;;AACA,QAAI,KAAK1F,OAAL,CAAaoD,KAAjB,EAAwB;AACpB,WAAKhC,IAAL,CAAU,IAAV;AACH;AACJ;AACD;AACJ;AACA;;;AACIqE,EAAAA,eAAe,GAAG;AACd,WAAO,KAAKzF,OAAL,CAAaoD,KAAb,GAAqB,KAAKpD,OAAL,CAAaoD,KAAb,CAAmB0C,MAAnB,CAA0B,KAAK5F,WAA/B,CAArB,GAAmE,EAA1E;AACH;;AAtT6C;;AAwTlDZ,OAAO,CAACE,gBAAR,GAA2BA,gBAA3B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonLdSerializer = void 0;\nconst jsonld_context_parser_1 = require(\"jsonld-context-parser\");\nconst stream_1 = require(\"stream\");\nconst SeparatorType_1 = require(\"./SeparatorType\");\nconst Util_1 = require(\"./Util\");\n/**\n * A stream transformer that transforms an {@link RDF.Stream} into a JSON-LD (text) stream.\n */\nclass JsonLdSerializer extends stream_1.Transform {\n    constructor(options = {}) {\n        super({ objectMode: true });\n        this.indentation = 0;\n        this.options = options;\n        // Parse the context\n        if (this.options.baseIRI && !this.options.context) {\n            this.options.context = { '@base': this.options.baseIRI };\n        }\n        if (this.options.context) {\n            this.originalContext = this.options.context;\n            this.context = new jsonld_context_parser_1.ContextParser().parse(this.options.context, { baseIRI: this.options.baseIRI });\n        }\n        else {\n            this.context = Promise.resolve(new jsonld_context_parser_1.JsonLdContextNormalized({}));\n        }\n    }\n    /**\n     * Parses the given text stream into a quad stream.\n     * @param {NodeJS.EventEmitter} stream A text stream.\n     * @return {NodeJS.EventEmitter} A quad stream.\n     */\n    import(stream) {\n        const output = new stream_1.PassThrough({ objectMode: true });\n        stream.on('error', (error) => parsed.emit('error', error));\n        stream.on('data', (data) => output.push(data));\n        stream.on('end', () => output.push(null));\n        const parsed = output.pipe(new JsonLdSerializer(this.options));\n        return parsed;\n    }\n    /**\n     * Transforms a quad into the text stream.\n     * @param {Quad} quad An RDF quad.\n     * @param {string} encoding An (ignored) encoding.\n     * @param {module:stream.internal.TransformCallback} callback Callback that is invoked when the transformation is done\n     * @private\n     */\n    _transform(quad, encoding, callback) {\n        this.context.then((context) => {\n            this.transformQuad(quad, context);\n            callback();\n        }).catch(callback);\n    }\n    /**\n     * Construct a list in an RDF.Term object that can be used\n     * inside a quad's object to write into the serializer\n     * as a list using the @list keyword.\n     * @param {RDF.Quad_Object[]} values A list of values, can be empty.\n     * @return {RDF.Quad_Object} A term that should be used in the object position of the quad that is written to the serializer.\n     */\n    async list(values) {\n        const context = await this.context;\n        return {\n            '@list': values.map((value) => Util_1.Util.termToValue(value, context, this.options)),\n        };\n    }\n    /**\n     * Claled when the incoming stream is closed.\n     * @param {module:stream.internal.TransformCallback} callback Callback that is invoked when the flushing is done.\n     * @private\n     */\n    _flush(callback) {\n        // If the stream was empty, ensure that we push the opening array\n        if (!this.opened) {\n            this.pushDocumentStart();\n        }\n        if (this.lastPredicate) {\n            this.endPredicate();\n        }\n        if (this.lastSubject) {\n            this.endSubject();\n        }\n        if (this.lastGraph && this.lastGraph.termType !== 'DefaultGraph') {\n            this.endGraph();\n        }\n        this.endDocument();\n        return callback(null, null);\n    }\n    /**\n     * Transforms a quad into the text stream.\n     * @param {Quad} quad An RDF quad.\n     * @param {JsonLdContextNormalized} context A context for compacting.\n     */\n    transformQuad(quad, context) {\n        // Open the array before the first quad\n        if (!this.opened) {\n            this.pushDocumentStart();\n        }\n        // Check if the subject equals the last named graph\n        // In that case, we can reuse the already-existing @id node\n        const lastGraphMatchesSubject = this.lastGraph && this.lastGraph.termType !== 'DefaultGraph'\n            && this.lastGraph.equals(quad.subject);\n        // Write graph\n        if (!lastGraphMatchesSubject && (!this.lastGraph || !quad.graph.equals(this.lastGraph))) {\n            // Check if the named graph equals the last subject\n            // In that case, we can reuse the already-existing @id node\n            let lastSubjectMatchesGraph = quad.graph.termType !== 'DefaultGraph'\n                && this.lastSubject && this.lastSubject.equals(quad.graph);\n            if (this.lastGraph) {\n                if (this.lastGraph.termType !== 'DefaultGraph') {\n                    // The last graph was named\n                    this.endPredicate();\n                    this.endSubject();\n                    this.endGraph(true);\n                    lastSubjectMatchesGraph = false; // Special-case to avoid deeper nesting\n                }\n                else {\n                    // The last graph was default\n                    if (!lastSubjectMatchesGraph) {\n                        this.endPredicate();\n                        this.endSubject(true);\n                    }\n                    else {\n                        this.endPredicate(true);\n                        this.lastSubject = null;\n                    }\n                }\n            }\n            // Push the graph\n            if (quad.graph.termType !== 'DefaultGraph') {\n                if (!lastSubjectMatchesGraph) {\n                    this.pushId(quad.graph, context);\n                }\n                this.pushSeparator(this.options.space\n                    ? SeparatorType_1.SeparatorType.GRAPH_FIELD_NONCOMPACT : SeparatorType_1.SeparatorType.GRAPH_FIELD_COMPACT);\n                this.indentation++;\n            }\n            this.lastGraph = quad.graph;\n        }\n        // Write subject\n        if (!this.lastSubject || !quad.subject.equals(this.lastSubject)) {\n            if (lastGraphMatchesSubject) {\n                this.endPredicate();\n                this.endSubject();\n                this.indentation--;\n                this.pushSeparator(SeparatorType_1.SeparatorType.ARRAY_END_COMMA);\n                this.lastGraph = quad.graph;\n            }\n            else {\n                if (this.lastSubject) {\n                    this.endPredicate();\n                    this.endSubject(true);\n                }\n                // Open a new node for the new subject\n                this.pushId(quad.subject, context);\n            }\n            this.lastSubject = quad.subject;\n        }\n        // Write predicate\n        if (!this.lastPredicate || !quad.predicate.equals(this.lastPredicate)) {\n            if (this.lastPredicate) {\n                this.endPredicate(true);\n            }\n            // Open a new array for the new predicate\n            this.pushPredicate(quad.predicate, context);\n        }\n        // Write the object value\n        this.pushObject(quad.object, context);\n    }\n    pushDocumentStart() {\n        this.opened = true;\n        if (this.originalContext && !this.options.excludeContext) {\n            this.pushSeparator(SeparatorType_1.SeparatorType.OBJECT_START);\n            this.indentation++;\n            this.pushSeparator(SeparatorType_1.SeparatorType.CONTEXT_FIELD);\n            this.pushIndented(JSON.stringify(this.originalContext, null, this.options.space) + ',');\n            this.pushSeparator(this.options.space\n                ? SeparatorType_1.SeparatorType.GRAPH_FIELD_NONCOMPACT : SeparatorType_1.SeparatorType.GRAPH_FIELD_COMPACT);\n            this.indentation++;\n        }\n        else {\n            this.pushSeparator(SeparatorType_1.SeparatorType.ARRAY_START);\n            this.indentation++;\n        }\n    }\n    /**\n     * Push the given term as an @id field.\n     * @param {Term} term An RDF term.\n     * @param {JsonLdContextNormalized} context The context.\n     */\n    pushId(term, context) {\n        const subjectValue = term.termType === 'BlankNode'\n            ? '_:' + term.value : context.compactIri(term.value, false);\n        this.pushSeparator(SeparatorType_1.SeparatorType.OBJECT_START);\n        this.indentation++;\n        this.pushIndented(this.options.space ? `\"@id\": \"${subjectValue}\",` : `\"@id\":\"${subjectValue}\",`);\n    }\n    /**\n     * Push the given predicate field.\n     * @param {Term} predicate An RDF term.\n     * @param {JsonLdContextNormalized} context The context.\n     */\n    pushPredicate(predicate, context) {\n        let property = predicate.value;\n        // Convert rdf:type into @type if not disabled.\n        if (!this.options.useRdfType && property === Util_1.Util.RDF_TYPE) {\n            property = '@type';\n            this.objectOptions = Object.assign(Object.assign({}, this.options), { compactIds: true, vocab: true });\n        }\n        // Open array for following objects\n        const compactedProperty = context.compactIri(property, true);\n        this.pushIndented(this.options.space ? `\"${compactedProperty}\": [` : `\"${compactedProperty}\":[`);\n        this.indentation++;\n        this.lastPredicate = predicate;\n    }\n    /**\n     * Push the given object value.\n     * @param {Term} object An RDF term.\n     * @param {JsonLdContextNormalized} context The context.\n     */\n    pushObject(object, context) {\n        // Add a comma if we already had an object for this predicate\n        if (!this.hadObjectForPredicate) {\n            this.hadObjectForPredicate = true;\n        }\n        else {\n            this.pushSeparator(SeparatorType_1.SeparatorType.COMMA);\n        }\n        // Convert the object into a value and push it\n        let value;\n        try {\n            if (object['@list']) {\n                value = object;\n            }\n            else {\n                value = Util_1.Util.termToValue(object, context, this.objectOptions || this.options);\n            }\n        }\n        catch (e) {\n            return this.emit('error', e);\n        }\n        this.pushIndented(JSON.stringify(value, null, this.options.space));\n    }\n    endDocument() {\n        this.opened = false;\n        if (this.originalContext && !this.options.excludeContext) {\n            this.indentation--;\n            this.pushSeparator(SeparatorType_1.SeparatorType.ARRAY_END);\n            this.indentation--;\n            this.pushSeparator(SeparatorType_1.SeparatorType.OBJECT_END);\n        }\n        else {\n            this.indentation--;\n            this.pushSeparator(SeparatorType_1.SeparatorType.ARRAY_END);\n        }\n    }\n    /**\n     * Push the end of a predicate and reset the buffers.\n     * @param {boolean} comma If a comma should be appended.\n     */\n    endPredicate(comma) {\n        // Close the predicate array\n        this.indentation--;\n        this.pushSeparator(comma ? SeparatorType_1.SeparatorType.ARRAY_END_COMMA : SeparatorType_1.SeparatorType.ARRAY_END);\n        // Reset object buffer\n        this.hadObjectForPredicate = false;\n        this.objectOptions = null;\n        // Reset predicate buffer\n        this.lastPredicate = null;\n    }\n    /**\n     * Push the end of a subject and reset the buffers.\n     * @param {boolean} comma If a comma should be appended.\n     */\n    endSubject(comma) {\n        // Close the last subject's node;\n        this.indentation--;\n        this.pushSeparator(comma ? SeparatorType_1.SeparatorType.OBJECT_END_COMMA : SeparatorType_1.SeparatorType.OBJECT_END);\n        // Reset subject buffer\n        this.lastSubject = null;\n    }\n    /**\n     * Push the end of a graph and reset the buffers.\n     * @param {boolean} comma If a comma should be appended.\n     */\n    endGraph(comma) {\n        // Close the graph array\n        this.indentation--;\n        this.pushSeparator(SeparatorType_1.SeparatorType.ARRAY_END);\n        // Close the graph id node\n        this.indentation--;\n        this.pushSeparator(comma ? SeparatorType_1.SeparatorType.OBJECT_END_COMMA : SeparatorType_1.SeparatorType.OBJECT_END);\n        // Reset graph buffer\n        this.lastGraph = null;\n    }\n    /**\n     * Puh the given separator.\n     * @param {SeparatorType} type A type of separator.\n     */\n    pushSeparator(type) {\n        this.pushIndented(type.label);\n    }\n    /**\n     * An indentation-aware variant of {@link #push}.\n     * All strings that are pushed here will be prefixed by {@link #indentation} amount of spaces.\n     * @param {string} data A string.\n     */\n    pushIndented(data) {\n        const prefix = this.getIndentPrefix();\n        const lines = data.split('\\n').map((line) => prefix + line).join('\\n');\n        this.push(lines);\n        if (this.options.space) {\n            this.push('\\n');\n        }\n    }\n    /**\n     * @return {string} Get the current indentation prefix based on {@link #indentation}.\n     */\n    getIndentPrefix() {\n        return this.options.space ? this.options.space.repeat(this.indentation) : '';\n    }\n}\nexports.JsonLdSerializer = JsonLdSerializer;\n//# sourceMappingURL=JsonLdSerializer.js.map"]},"metadata":{},"sourceType":"script"}