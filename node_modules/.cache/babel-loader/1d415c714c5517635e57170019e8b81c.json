{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BindingsToQuadsIterator = void 0;\n\nconst asynciterator_1 = require(\"asynciterator\");\n\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\n\nconst rdf_terms_1 = require(\"rdf-terms\");\n\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * Transforms a bindings stream into a quad stream given a quad template.\n *\n * This conforms to the SPARQL 1.1 spec on constructing triples:\n * https://www.w3.org/TR/sparql11-query/#rConstructTriples\n */\n\nclass BindingsToQuadsIterator extends asynciterator_1.MultiTransformIterator {\n  constructor(template, bindingsStream, localizeBlankNodes = true) {\n    super(bindingsStream, {\n      autoStart: false\n    });\n    this.template = template;\n    this.localizeBlankNodes = localizeBlankNodes;\n    this.blankNodeCounter = 0;\n  }\n  /**\n   * Bind the given term.\n   * If the term is a variable and the variable is bound in the bindings object,\n   * return the bindings value.\n   * If the term is a variable and the variable is not bound in the bindings object,\n   * a falsy value is returned..\n   * Otherwise, the term itself is returned.\n   * @param {Bindings}  bindings A bindings object.\n   * @param {RDF.Term}  term     An RDF term.\n   * @return {RDF.Term}          If the given term is not a variable, the term itself is returned.\n   *                             If the given term is a variable, then the bound term is returned,\n   *                             or a falsy value if it did not exist in the bindings.\n   */\n\n\n  static bindTerm(bindings, term) {\n    if (term.termType === 'Variable') {\n      return bindings.get(`?${term.value}`);\n    }\n\n    return term;\n  }\n  /**\n   * Bind the given quad pattern.\n   * If one of the terms was a variable AND is not bound in the bindings,\n   * a falsy value will be returned.\n   * @param {Bindings} bindings A bindings object.\n   * @param {RDF.Quad} pattern  An RDF quad.\n   * @return {RDF.Quad}         A bound RDF quad or undefined.\n   */\n\n\n  static bindQuad(bindings, pattern) {\n    try {\n      return rdf_terms_1.mapTerms(pattern, term => {\n        const boundTerm = BindingsToQuadsIterator.bindTerm(bindings, term);\n\n        if (!boundTerm) {\n          throw new Error('Unbound term');\n        }\n\n        return boundTerm;\n      });\n    } catch (_a) {// Do nothing\n    }\n  }\n  /**\n   * Convert a blank node to a unique blank node in the given context.\n   * If the given term is not a blank node, the term itself will be returned.\n   * @param             blankNodeCounter A counter value for the blank node.\n   * @param {RDF.Term}  term             The term that should be localized.\n   * @return {RDF.Term}                  A term.\n   */\n\n\n  static localizeBlankNode(blankNodeCounter, term) {\n    if (term.termType === 'BlankNode') {\n      return DF.blankNode(`${term.value}${blankNodeCounter}`);\n    }\n\n    return term;\n  }\n  /**\n   * Convert the given quad to a quad that only contains unique blank nodes.\n   * @param            blankNodeCounter A counter value for the blank node.\n   * @param {RDF.BaseQuad} pattern          The pattern that should be localized.\n   * @return {RDF.BaseQuad}                 A quad.\n   */\n\n\n  static localizeQuad(blankNodeCounter, pattern) {\n    return rdf_terms_1.mapTerms(pattern, term => BindingsToQuadsIterator.localizeBlankNode(blankNodeCounter, term));\n  }\n  /**\n   * Convert the given template to a list of quads based on the given bindings.\n   * @param {Bindings}    bindings           A bindings object.\n   * @param {RDF.Quad[]}  template           A list of quad patterns.\n   * @param               blankNodeCounter   A counter value for the blank node.\n   * @return {RDF.Quad[]}                    A list of quads.\n   */\n\n\n  bindTemplate(bindings, template, blankNodeCounter) {\n    let quads = template // Bind variables to bound terms\n    .map(x => BindingsToQuadsIterator.bindQuad.bind(null, bindings)(x)) // Remove quads that contained unbound terms, i.e., variables.\n    .filter(Boolean);\n\n    if (this.localizeBlankNodes) {\n      // Make sure the multiple instantiations of the template contain different blank nodes, as required by SPARQL 1.1.\n      quads = quads.map(BindingsToQuadsIterator.localizeQuad.bind(null, blankNodeCounter));\n    }\n\n    return quads;\n  }\n\n  _createTransformer(bindings) {\n    return new asynciterator_1.ArrayIterator(this.bindTemplate(bindings, this.template, this.blankNodeCounter++));\n  }\n\n}\n\nexports.BindingsToQuadsIterator = BindingsToQuadsIterator;","map":{"version":3,"sources":["/Users/mark/localRepos/StarBrightlyShining/node_modules/@comunica/actor-query-operation-construct/lib/BindingsToQuadsIterator.js"],"names":["Object","defineProperty","exports","value","BindingsToQuadsIterator","asynciterator_1","require","rdf_data_factory_1","rdf_terms_1","DF","DataFactory","MultiTransformIterator","constructor","template","bindingsStream","localizeBlankNodes","autoStart","blankNodeCounter","bindTerm","bindings","term","termType","get","bindQuad","pattern","mapTerms","boundTerm","Error","_a","localizeBlankNode","blankNode","localizeQuad","bindTemplate","quads","map","x","bind","filter","Boolean","_createTransformer","ArrayIterator"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BindingsToQuadsIterator = void 0;\nconst asynciterator_1 = require(\"asynciterator\");\nconst rdf_data_factory_1 = require(\"rdf-data-factory\");\nconst rdf_terms_1 = require(\"rdf-terms\");\nconst DF = new rdf_data_factory_1.DataFactory();\n/**\n * Transforms a bindings stream into a quad stream given a quad template.\n *\n * This conforms to the SPARQL 1.1 spec on constructing triples:\n * https://www.w3.org/TR/sparql11-query/#rConstructTriples\n */\nclass BindingsToQuadsIterator extends asynciterator_1.MultiTransformIterator {\n    constructor(template, bindingsStream, localizeBlankNodes = true) {\n        super(bindingsStream, { autoStart: false });\n        this.template = template;\n        this.localizeBlankNodes = localizeBlankNodes;\n        this.blankNodeCounter = 0;\n    }\n    /**\n     * Bind the given term.\n     * If the term is a variable and the variable is bound in the bindings object,\n     * return the bindings value.\n     * If the term is a variable and the variable is not bound in the bindings object,\n     * a falsy value is returned..\n     * Otherwise, the term itself is returned.\n     * @param {Bindings}  bindings A bindings object.\n     * @param {RDF.Term}  term     An RDF term.\n     * @return {RDF.Term}          If the given term is not a variable, the term itself is returned.\n     *                             If the given term is a variable, then the bound term is returned,\n     *                             or a falsy value if it did not exist in the bindings.\n     */\n    static bindTerm(bindings, term) {\n        if (term.termType === 'Variable') {\n            return bindings.get(`?${term.value}`);\n        }\n        return term;\n    }\n    /**\n     * Bind the given quad pattern.\n     * If one of the terms was a variable AND is not bound in the bindings,\n     * a falsy value will be returned.\n     * @param {Bindings} bindings A bindings object.\n     * @param {RDF.Quad} pattern  An RDF quad.\n     * @return {RDF.Quad}         A bound RDF quad or undefined.\n     */\n    static bindQuad(bindings, pattern) {\n        try {\n            return rdf_terms_1.mapTerms(pattern, term => {\n                const boundTerm = BindingsToQuadsIterator.bindTerm(bindings, term);\n                if (!boundTerm) {\n                    throw new Error('Unbound term');\n                }\n                return boundTerm;\n            });\n        }\n        catch (_a) {\n            // Do nothing\n        }\n    }\n    /**\n     * Convert a blank node to a unique blank node in the given context.\n     * If the given term is not a blank node, the term itself will be returned.\n     * @param             blankNodeCounter A counter value for the blank node.\n     * @param {RDF.Term}  term             The term that should be localized.\n     * @return {RDF.Term}                  A term.\n     */\n    static localizeBlankNode(blankNodeCounter, term) {\n        if (term.termType === 'BlankNode') {\n            return DF.blankNode(`${term.value}${blankNodeCounter}`);\n        }\n        return term;\n    }\n    /**\n     * Convert the given quad to a quad that only contains unique blank nodes.\n     * @param            blankNodeCounter A counter value for the blank node.\n     * @param {RDF.BaseQuad} pattern          The pattern that should be localized.\n     * @return {RDF.BaseQuad}                 A quad.\n     */\n    static localizeQuad(blankNodeCounter, pattern) {\n        return rdf_terms_1.mapTerms(pattern, term => BindingsToQuadsIterator.localizeBlankNode(blankNodeCounter, term));\n    }\n    /**\n     * Convert the given template to a list of quads based on the given bindings.\n     * @param {Bindings}    bindings           A bindings object.\n     * @param {RDF.Quad[]}  template           A list of quad patterns.\n     * @param               blankNodeCounter   A counter value for the blank node.\n     * @return {RDF.Quad[]}                    A list of quads.\n     */\n    bindTemplate(bindings, template, blankNodeCounter) {\n        let quads = template\n            // Bind variables to bound terms\n            .map(x => BindingsToQuadsIterator.bindQuad.bind(null, bindings)(x))\n            // Remove quads that contained unbound terms, i.e., variables.\n            .filter(Boolean);\n        if (this.localizeBlankNodes) {\n            // Make sure the multiple instantiations of the template contain different blank nodes, as required by SPARQL 1.1.\n            quads = quads.map(BindingsToQuadsIterator.localizeQuad.bind(null, blankNodeCounter));\n        }\n        return quads;\n    }\n    _createTransformer(bindings) {\n        return new asynciterator_1.ArrayIterator(this.bindTemplate(bindings, this.template, this.blankNodeCounter++));\n    }\n}\nexports.BindingsToQuadsIterator = BindingsToQuadsIterator;\n//# sourceMappingURL=BindingsToQuadsIterator.js.map"]},"metadata":{},"sourceType":"script"}